aspect AspectErrorCheck
{
  public void AspectDecl.checkModifiers() {
    if(isNestedType() && !isStatic())
      error("inner aspects must be static");
    else
      super.checkModifiers();
  }
  
  syn boolean TypeDecl.isAspectDecl() = false;
  eq AspectDecl.isAspectDecl() = true;

  public void AspectDecl.typeCheck() {
    if(hasSuperclass() && superclass().isAspectDecl() && !superclass().isAbstract())
      error("aspects may only extend abstract aspects");
    else
      super.typeCheck();
  }

  public void ClassDecl.typeCheck() {
    if(!isAspectDecl() && hasSuperclass() && superclass().isAspectDecl())
      error("classes may not extend aspects");
    else
      super.typeCheck();
  }

  // aspects cannot be instantiated using new
  refine TypeCheck public void ClassInstanceExpr.typeCheck()
  {
    if (type().isAspectDecl())
      error("Cannot instantiate " + type().typeName() +
            " with 'new' because it is an aspect.");
    TypeCheck.ClassInstanceExpr.typeCheck();
  }

  // aspect constructors must take no arguments
  refine TypeCheck public void ConstructorDecl.typeCheck()
  {
    if (hostType().isAspectDecl() && getNumParameter() > 0)
      error(hostType().typeName() + " is an aspect, so its " +
            "constructor must have no parameters.");
    TypeCheck.ConstructorDecl.typeCheck();
  }
}

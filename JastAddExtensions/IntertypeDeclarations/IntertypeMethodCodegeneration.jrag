aspect IntertypeMethodCodegeneration {
  
  // generate code for each inter-type method that is visible in this type
  public void TypeDecl.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(m instanceof IntertypeMethodDecl) {
        IntertypeMethodDecl methodDecl = (IntertypeMethodDecl)m;
        // do not generate code in the declaring aspect
        // TODO: should maybe not be included in localMethodsIterator()
        if(methodDecl.hostAspect() != this)
          methodDecl.createIntertypeMethod(this);
      }
    }
  }

  // Each IntertypeMethodDecl generates two methods
  //   IntroducedMethodDecl m1 in the aspect, holding the method body
  //   MethodDecl m2 in the introduced type, that delegates the call to m1 
  // the delegation methods are needed to give the desired semantics for instance methods
  // the IntroducedMethodDecl node type is used to specialize name analysis
  public void IntertypeMethodDecl.createIntertypeMethod(TypeDecl introducedType) {
    if(introducedType.isInterfaceDecl() || isAbstract()) {
      // create abstract signature
      introducedType.addMemberMethod(
        new MethodDecl(
          (Modifiers)getModifiers().fullCopy(),
          type().createQualifiedAccess(),
          name(),
          copyParameterList(getParameterList()),
          new List(),
          new List(),
          new Opt()
        )
      );
    }
    else {
      MethodDecl aspectMethod = createAspectMethod();
      MethodDecl delegateMethod = createDelegateMethod(aspectMethod);
      introducedType.addMemberMethod(delegateMethod);
    }
  }

  syn lazy MethodDecl IntertypeMethodDecl.createAspectMethod() {
    if(!isFinal) throw new Error("IntertypeMethodDecl must be final when aspectMethod is created");
    // make aspect method static
    List modifierList = (List)getModifiers().getModifierList().fullCopy();
    if(!isStatic())
      modifierList.add(new Modifier("static"));
    
    // add that for instance methods
    List parameterList = new List();
    if(!isStatic())
    	parameterList.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(getParameter(i).qualifiedCopy());
      
    MethodDecl aspectMethod = new IntroducedMethodDecl(
      new Modifiers(modifierList),
      type().createQualifiedAccess(),
      "impl$body$" + name(),
      parameterList,
      new List(),
      new List(),
      (Opt)getBlockOpt().fullCopy(),
      introducedType(),
      this
    );
    aspectMethod = hostAspect().addMemberMethod(aspectMethod);
    return aspectMethod;
  }

  public ParameterDeclaration ParameterDeclaration.qualifiedCopy() {
    return new ParameterDeclaration(type().createQualifiedAccess(), name());
  }


  syn boolean MethodAccess.needsSuperDispatchDelegate() {
    if(!hasPrevExpr() || !prevExpr().isSuperAccess())
      return false;
    BodyDecl bodyDecl = enclosingBodyDecl();
    if(!(bodyDecl instanceof IntroducedMethodDecl))
      return false;
    IntroducedMethodDecl m = (IntroducedMethodDecl)bodyDecl;
    return m.introducedType() != bodyDecl.hostType();
  }

  public void MethodAccess.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    if(needsSuperDispatchDelegate()) {
      System.out.println("May need super dispatch delegate");
      SimpleSet maxSpecific = SimpleSet.emptySet;
      for(Iterator iter = hostType().memberMethods(name()).iterator(); iter.hasNext(); ) {
        MethodDecl decl = (MethodDecl)iter.next();
        if(applicable(decl) && accessible(decl)) {
          if(maxSpecific.isEmpty())
            maxSpecific = maxSpecific.add(decl);
          else {
            if(decl.moreSpecificThan((MethodDecl)maxSpecific.iterator().next()))
              maxSpecific = SimpleSet.emptySet.add(decl);
            else if(!((MethodDecl)maxSpecific.iterator().next()).moreSpecificThan(decl))
              maxSpecific = maxSpecific.add(decl);
          }
        }
      }
      if(maxSpecific.size() == 1) {
        MethodDecl m = (MethodDecl)maxSpecific.iterator().next();
        m.createSuperDispatchDelegate(hostType());
      }
    }
  }

  refine Transformations public void MethodAccess.transformation() {
    if(needsSuperDispatchDelegate()) {
      System.out.println("May need super dispatch delegate");
      SimpleSet maxSpecific = SimpleSet.emptySet;
      for(Iterator iter = hostType().memberMethods(name()).iterator(); iter.hasNext(); ) {
        MethodDecl decl = (MethodDecl)iter.next();
        if(applicable(decl) && accessible(decl)) {
          if(maxSpecific.isEmpty())
            maxSpecific = maxSpecific.add(decl);
          else {
            if(decl.moreSpecificThan((MethodDecl)maxSpecific.iterator().next()))
              maxSpecific = SimpleSet.emptySet.add(decl);
            else if(!((MethodDecl)maxSpecific.iterator().next()).moreSpecificThan(decl))
              maxSpecific = maxSpecific.add(decl);
          }
        }
      }
      if(maxSpecific.size() == 1) {
        MethodDecl m = (MethodDecl)maxSpecific.iterator().next();
        m.createSuperDispatchDelegate(hostType());
      }
    }
    Transformations.MethodAccess.transformation();
  }

 

  /*
  TODO: fixme
  refine CreateBCode public void MethodAccess.createBCode(CodeGeneration gen) {
    if(needsSuperDispatchDelegate()) {
      SimpleSet maxSpecific = SimpleSet.emptySet;
      for(Iterator iter = hostType().memberMethods(name()).iterator(); iter.hasNext(); ) {
        MethodDecl decl = (MethodDecl)iter.next();
        if(applicable(decl) && accessible(decl)) {
          if(maxSpecific.isEmpty())
            maxSpecific = maxSpecific.add(decl);
          else {
            if(decl.moreSpecificThan((MethodDecl)maxSpecific.iterator().next()))
              maxSpecific = SimpleSet.emptySet.add(decl);
            else if(!((MethodDecl)maxSpecific.iterator().next()).moreSpecificThan(decl))
              maxSpecific = maxSpecific.add(decl);
          }
        }
      }
      if(maxSpecific.size() == 1) {
        MethodDecl m = (MethodDecl)maxSpecific.iterator().next();
        m = m.createSuperDispatchDelegate(hostType());
        // invoke m virtually
        gen.emitLoadReference(0);
        for (int i = 0; i < getNumArg(); ++i) {
          getArg(i).createBCode(gen);
          getArg(i).type().emitCastTo(gen, m.getParameter(i).type()); // MethodInvocationConversion
        }
        m.emitInvokeMethod(gen, m.hostType());
      }
      else
        throw new Error("Used super." + name() + " in introduced method, hostType:" + hostType().typeName() + ", decl().hostType: " + decl().hostType().typeName());
    }
    else
      CreateBCode.MethodAccess.createBCode(gen);
  }*/

  protected static List ASTNode.copyParameterList(List l) {
    List list = new List();
    for(int i = 0; i < l.getNumChild(); i++) {
      ParameterDeclaration p = (ParameterDeclaration)l.getChild(i);
      list.add(new ParameterDeclaration(p.type().createQualifiedAccess(), p.name()));
    }
    return list;
  }
    
  syn lazy MethodDecl MethodDecl.createSuperDispatchDelegate(TypeDecl qualifierType) {
    String name = "superDispatch$" + qualifierType.fullName().replace('.', '$').replace('@', '_') + "$" + name();
    List statements = new List();
    List args = new List();
    for(int i = 0; i < getNumParameter(); i++)
      args.add(getParameter(i).createAccess());
    Expr e = new SuperAccess("super").qualifiesAccess(this.createBoundAccess(args));
    if(type().isVoid())
      statements.add(new ExprStmt(e));
    else
      statements.add(new ReturnStmt(e));
    MethodDecl m = new MethodDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      type().createQualifiedAccess(),
      name,
      copyParameterList(getParameterList()),
      new List(),
      (List)getExceptionList().fullCopy(),
      new Opt(new Block(statements))
    );
    return qualifierType.addMemberMethod(m);
  }

  public Access ParameterDeclaration.createAccess() {
    return new VarAccess(name());
  }

  // decl().signature() -> method to call using invoke super
  // hostType() -> type to hold the new method
  // a new method called dispatchSuper$signature
  
  public MethodDecl IntertypeMethodDecl.createDelegateMethod(MethodDecl aspectMethod) {
    // make arguments from this and method parameters
    List args = new List();
    if(!isStatic())
      args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    
    // delegate by calling the aspect method
    List statements = new List();
    if(type().isVoid())
    	statements.add(new ExprStmt(aspectMethod.createBoundAccess(args)));
    else
    	statements.add(new ReturnStmt(aspectMethod.createBoundAccess(args)));
      
    return new MethodDecl(
      (Modifiers)getModifiers().fullCopy(),
      type().createQualifiedAccess(),
      name(),
      copyParameterList(getParameterList()),
      new List(),
      new List(),
      new Opt(new Block(statements))
    );
  }
  
  // Do not generate bytecode for this node type even though it is a subtype of MethodDecl
  // the IntertypeMethodDecl is a placeholder used during error checking, but code
  // need only be emitted for the two generated methods
  eq IntertypeMethodDecl.generate() = false; 
  
  // change name binding to search for methods in introducedType in IntroducedMethodDecl body
  syn TypeDecl IntroducedMethodDecl.introducedType() = getIntroducedType();
  eq IntroducedMethodDecl.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return getITDBodyDecl().lookupMethod(name);
  }
  inh Collection BodyDecl.lookupMethod(String name);
  
  eq IntroducedMethodDecl.getBlock().lookupVariable(String name) {
    SimpleSet set = parameterDeclaration(name);
    if(!set.isEmpty()) return set;
    set = introducedType().memberFields(name);
    if(!set.isEmpty()) return set;
    return getITDBodyDecl().lookupVariable(name);
  }

  eq IntroducedMethodDecl.getTypeAccess().lookupType(String name) {
    SimpleSet set = introducedType().memberTypes(name);
    if(!set.isEmpty())
      return set;
    return getITDBodyDecl().lookupType(name);
  }
  eq IntroducedMethodDecl.getBlock().lookupType(String name) {
    SimpleSet set = introducedType().memberTypes(name);
    if(!set.isEmpty())
      return set;
    return getITDBodyDecl().lookupType(name);
  }
  inh SimpleSet BodyDecl.lookupType(String name);

  eq IntroducedMethodDecl.getBlock().hostType() = introducedType();
  eq IntroducedMethodDecl.getParameter(int index).hostType() = introducedType();

  // TODO: make this use the modifier prior to transformation instead of hardcoded false
  eq IntroducedMethodDecl.getBlock().inStaticContext() = false;
}

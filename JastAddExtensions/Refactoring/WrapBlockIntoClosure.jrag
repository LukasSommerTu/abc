/** The "Wrap Block Into Closure" refactoring turns a block

      <pre>
      { b_1, ..., b_n }
      </pre>

    into a closure application statement

      <pre>
      (Î» () throws e_1, ..., e_m { b_1, ..., b_n }) ();
      </pre>

    which is optionally itself wrapped into a block, if the original block does not
    itself occur inside a larger block.

    Exceptions e_1, ..., e_m are all uncaught exceptions thrown in the block.
    The refactoring ensures that control flow stays intact. In particular, if the
    block contains any break, continue, or return statements with target outside
    the block, the refactoring will be rejected.

    A possible future optimisation would be to allow the case where all control
    paths of the block end in a return statement, and then wrap the generated
    application into a return statement.
 */

aspect WrapBlockIntoClosure {

	public ClosureInvocation Block.wrapIntoClosure() throws RefactoringException {
		return new WrapBlockIntoClosureRefactoring(this).execute();
	}

	class WrapBlockIntoClosureRefactoring {
		private Block block;
		private AdjustmentTable table;

		public WrapBlockIntoClosureRefactoring(Block block) {
			this.block = block;
			this.table = new AdjustmentTable();
		}

		public ClosureInvocation execute() throws RefactoringException {
			block.lockAllCFlow(table);
			// create a closure without parameters returning void and throwing all
			// uncaught checked exceptions of block
			List<Access> exns = block.computeExceptionsToDeclare(table);
			ClosureInvocation cl = 
				new ClosureInvocation(
						new List(),                      // parameters
						new PrimitiveTypeAccess("void"), // return type
						exns,                            // thrown exceptions
						null,                            // body (to be filled in shortly)
						new List<Expr>());               // arguments
			block.replaceWith(new ExprStmt(cl));
			cl.setBlock(block);
			block.programRoot().flushCaches();
			fixReturnType(cl);
			table.adjust();
			return cl;
		}

		private void fixReturnType(ClosureInvocation cl) throws RefactoringException {
			// if there are no return statements, we're done
			if(cl.returns().isEmpty())
				return;
			// if there is _a_ return statement, _all_ paths should return
			if(!cl.finals().isEmpty())
				throw new RefactoringException("some control paths return values, others don't");
			// create return statement
			cl.setReturnType(cl.returnType().getLockedAccess(table));
			ReturnStmt ret = new ReturnStmt();
			cl.getParent().replaceWith(ret);
			ret.setResult(cl);
			// ret might be a `return void' statement that needs fixing
			table.addReturnVoid(ret);
			block.programRoot().flushCaches();
		}
	}

	inh TypeDecl ClosureInvocation.returnType();

	// return a list of locked type accesses to all exceptions in a subtree that should be declared
	public List<Access> ASTNode.computeExceptionsToDeclare(AdjustmentTable table) {
		List<Access> res = new List<Access>();
		for(TypeDecl exn : uncaughtExceptions())
			if(exn.shouldDeclareAsThrown())
				res.add(exn.getLockedAccess(table));
		return res;
	}
	
	// this is what the JLS calls a checked exception; the definitions in JastAddJ confuse me...
	inh lazy TypeDecl TypeDecl.typeThrowable();
	syn boolean TypeDecl.shouldDeclareAsThrown()
		= instanceOf(typeThrowable()) &&
		  !instanceOf(typeRuntimeException()) &&
		  !instanceOf(typeError());

	inh TypeDecl ReturnStmt.typeVoid();
	syn TypeDecl ReturnStmt.type() = hasResult() ? getResult().type() : typeVoid();

	private java.util.Set<ReturnStmt> AdjustmentTable.returnStmts = new java.util.HashSet<ReturnStmt>();
	public void AdjustmentTable.addReturnVoid(ReturnStmt ret) {
		returnStmts.add(ret);
	}

	// replace return void statements by expr stmt + return
	refine ControlFlow public void AdjustmentTable.adjust() throws RefactoringException {
		refined();
		for(ReturnStmt ret : returnStmts) {
			if(ret.hasResult() && ret.type().isVoid()) {
				if(ret.following().equals(ret.targetStmt(ret))) {
					// we don't need a return at all
					ret.replaceWith(new ExprStmt(ret.getResult()));
				} else {
					boolean inBlock = ret.getParent().getParent() instanceof Block;
					if(inBlock) {
						// if we're in a block, simply plug in a return statement
						Block block = (Block)ret.getParent().getParent();
						int idx = block.getIndexOfStmt(ret);
						block.setStmt(new ExprStmt(ret.getResult()), idx);
						block.insertStmt(idx+1, new ReturnStmt());
					} else {
						// otherwise, make a block with a return statement in it
						ret.replaceWith(
								new Block(
										new List().add(
												new ExprStmt(ret.getResult())
										).add(
												new ReturnStmt()
										)
								)
						);
					}
				}
			}
		}
	}

}
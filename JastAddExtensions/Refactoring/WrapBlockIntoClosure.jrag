/** The "Wrap Block Into Closure" refactoring turns a block

      <pre>
      { b_1, ..., b_n }
      </pre>

    into a closure application statement

      <pre>
      (() : T throws e_1, ..., e_m => { b_1, ..., b_n }) ();
      </pre>

    Exceptions e_1, ..., e_m are all uncaught exceptions thrown in the block.
    The refactoring ensures that control flow stays intact. In particular, if the
    block contains any break, continue, or return statements with target outside
    the block, the refactoring will be rejected.

    Return type T will normally be void, except if the whole block cannot complete
    normally, in which case it will be the return type of the enclosing method
    and the application statement is wrapped into a return statement.
 */

aspect WrapBlockIntoClosure {

	public ClosureInvocation Block.wrapIntoClosure() throws RefactoringException {
		AdjustmentTable table = new AdjustmentTable(programRoot());
		lockAllCFlow(table);
		
		// create a closure without parameters returning and throwing all
		// uncaught checked exceptions of block
		// if the block cannot complete normally, we need to set the return type
		List<Access> exns = computeExceptionsToDeclare(table);
		Access rettype = canCompleteNormally() ? new PrimitiveTypeAccess("void")
			                                   : returnType().getLockedAccess(table);
		ClosureInvocation cl = 
			new ClosureInvocation(
					new List(),         // parameters
					rettype, 	        // return type
					exns,               // thrown exceptions
					null,               // body (to be filled in shortly)
					new List<Expr>());  // arguments
		if(canCompleteNormally()) {
			replaceWith(new ExprStmt(cl));
		} else {
			ReturnStmt ret = new ReturnStmt(cl);
			table.addReturnVoid(ret);
			replaceWith(ret);
		}
		cl.setBlock(this);
		programRoot().flushCaches();
		
		table.adjust();
		return cl;
	}
	
	// return a list of locked type accesses to all exceptions in a subtree that should be declared
	public List<Access> ASTNode.computeExceptionsToDeclare(AdjustmentTable table) {
		List<Access> res = new List<Access>();
		for(TypeDecl exn : uncaughtExceptions())
			if(exn.shouldDeclareAsThrown())
				res.add(exn.getLockedAccess(table));
		return res;
	}
	
	// this is what the JLS calls a checked exception; the definitions in JastAddJ confuse me...
	inh lazy TypeDecl TypeDecl.typeThrowable();
	syn boolean TypeDecl.shouldDeclareAsThrown()
		= instanceOf(typeThrowable()) &&
		  !instanceOf(typeRuntimeException()) &&
		  !instanceOf(typeError());

	inh TypeDecl Block.returnType();
	inh TypeDecl ClosureInvocation.returnType();
	inh TypeDecl ReturnStmt.typeVoid();
	syn TypeDecl ReturnStmt.type() = hasResult() ? getResult().type() : typeVoid();

}
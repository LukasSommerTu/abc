aspect SymbolicTypeAccess {
	
	/*
	 * For a description of the general idea behind symbolic accesses, see
	 * SymbolicAccess.jrag and SymbolicVarAccess.jrag. The case for types
	 * is a bit simpler than for fields, since the source and bend must always
	 * be equal. Similar to variables, we set both of them to [null] for
	 * accesses to local or anonymous classes. Additionally, we have the case
	 * of top level types, which also have neither source nor bend, but whose
	 * target type contains information about the package they live in.
	 */
	
	class SymbolicTypeAccess extends SymbolicAccess {
		public SymbolicTypeAccess(TypeDecl source, TypeDecl bend,
								  boolean needsQualifier, TypeDecl target) {
			super(source, bend, needsQualifier, target);
		}
		
		public SymbolicTypeAccess(TypeDecl outer, boolean needsQualifier,
								  TypeDecl target) {
			this(outer, outer, needsQualifier, target);
		}
		
		public SymbolicTypeAccess(boolean needsQualifier, TypeDecl target) {
			this(target.isNestedType() ? target.enclosingType() : null, 
					needsQualifier, target);
		}
		
		public SymbolicTypeAccess(TypeDecl target) {
			this(false, target);
		}
		
		public boolean isTopLevelTypeAccess() {
			TypeDecl target = (TypeDecl)this.target;
			return target.isTopLevelType();
		}
		
		public boolean isLocalTypeAccess() {
			return (source == null || bend == null) && !isTopLevelTypeAccess();
		}
		
		private SymbolicTypeAccess addQualifier(boolean flag) {
			if(flag) 
				if(isLocalTypeAccess())
					return null;
				else
					needsQualifier = true;
			return this;
		}
		
		public SymbolicTypeAccess moveDownTo(TypeDecl td) {
			TypeDecl target = (TypeDecl)this.target;
			return addQualifier(!td.localMemberTypes(target.name()).isEmpty());
		}
		
		public SymbolicTypeAccess moveInto(Block blk, int index) {
			TypeDecl target = (TypeDecl)this.target;
			return addQualifier(blk.localLookupType(target.name(), index) != null);
		}
		
		public SymbolicTypeAccess moveInto(ClassInstanceExpr cie) {
			TypeDecl target = (TypeDecl)this.target;
			return addQualifier(false);
		}
		
		public SymbolicTypeAccess moveInto(TypeDecl td) {
			TypeDecl target = (TypeDecl)this.target;
			return addQualifier(!td.memberTypes(target.name()).isEmpty());
		}
		
		public Access computeAccess(NamingContext ctxt, boolean ambiguous) {
			TypeDecl target = (TypeDecl)this.target;
			if(isLocalTypeAccess()) {
				if(ctxt.isShadowed(target, ambiguous))
					return null;
				else
					return new TypeAccess(target.name());
			} else if(isTopLevelTypeAccess()) {
				String pkg = target.packageName();
				if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
					if(ctxt.isShadowed(new PackageAccess(pkg), ambiguous))
						return null;
					return new TypeAccess(pkg, target.name());
				} else {
					return new TypeAccess(target.name());
				}
			} else {
				if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
					if(ambiguous && !source.memberFields(target.name()).isEmpty())
						return null;
					Access source_acc = ctxt.accessType(source, ambiguous);
					if(source_acc == null) return null;
					return source_acc.qualifiesAccess(new TypeAccess(target.name()));
				} else {
					return new TypeAccess(target.name());
				}
			}
		}
		
		public Access computeQualifiedAccess(NamingContext ctxt, boolean ambiguous,
										     Expr qualifier) {
			TypeDecl target = (TypeDecl)this.target;
			if(isLocalTypeAccess()) {
				return null;
			} else if(isTopLevelTypeAccess()) {
				String pkg = target.packageName();
				if(qualifier instanceof PackageAccess) {
					PackageAccess pkgacc = (PackageAccess)qualifier;
					if(pkgacc.packageName().equals(pkg) &&
							!ctxt.isShadowed(pkgacc, ambiguous))
						return qualifier.qualifiesAccess(new TypeAccess(target.name()));
				}
				return null;
			} else {
				if(qualifier.isTypeAccess()) {
					TypeDecl td = qualifier.type();
					// TODO: check that td is something we want to qualify with
					//       (i.e., td == source, or maybe an ancestor class)
					if(ambiguous && !source.memberFields(target.name()).isEmpty())
						return null;
					return qualifier.qualifiesAccess(new TypeAccess(target.name()));
				}
			}
			return null;
		}
	}
	
}
aspect SymbolicTypeAccess {
	
	/*
	 * For a description of the general idea behind symbolic accesses, see
	 * SymbolicAccess.jrag and SymbolicVarAccess.jrag. The case for types
	 * is a bit simpler than for fields, since the source and bend must always
	 * be equal. Similar to variables, we set both of them to [null] for
	 * accesses to local or anonymous classes. Additionally, we have the case
	 * of top level types, which also have neither source nor bend, but whose
	 * target type contains information about the package they live in.
	 */
	
	abstract class SymbolicTypeAccess extends SymbolicAccess {
		public SymbolicTypeAccess(TypeDecl outer, boolean needsQualifier,
								  TypeDecl target) {
			super(outer, outer, needsQualifier, target);
		}
	}
	
	class SymbolicTopLevelTypeAccess extends SymbolicTypeAccess {
		public SymbolicTopLevelTypeAccess(boolean needsQualifier, TypeDecl target) {
			super(null, needsQualifier, target);
		}
	}
	
	class SymbolicMemberTypeAccess extends SymbolicTypeAccess {
		public SymbolicMemberTypeAccess(boolean needsQualifier, TypeDecl target) {
			super(target.enclosingType(), needsQualifier, target);
		}
	}
	
	class SymbolicLocalTypeAccess extends SymbolicTypeAccess {
		public SymbolicLocalTypeAccess(TypeDecl target) {
			super(null, false, target);
		}
	}
	
	protected SymbolicTypeAccess SymbolicTypeAccess.addQualifier(boolean flag) {
		if(flag)
			needsQualifier = true;
		return this;
	}
	
	protected SymbolicTypeAccess SymbolicLocalTypeAccess.addQualifier(boolean flag) {
		if(flag)
			return null;
		return this;
	}
	
	public SymbolicTypeAccess SymbolicTypeAccess.moveDownTo(TypeDecl td) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!td.localMemberTypes(target.name()).isEmpty());
	}
		
	public SymbolicTypeAccess SymbolicTypeAccess.moveInto(Block blk, int index) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(blk.localLookupType(target.name(), index) != null);
	}
		
	public SymbolicTypeAccess SymbolicTypeAccess.moveInto(ClassInstanceExpr cie) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(false);
	}
		
	public SymbolicTypeAccess SymbolicTypeAccess.moveInto(TypeDecl td) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!td.memberTypes(target.name()).isEmpty());
	}
		
	public abstract Access SymbolicTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous);
	
	public Access SymbolicLocalTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous) {
		TypeDecl target = (TypeDecl)this.target;
		if(ctxt.isShadowed(target, ambiguous))
			return null;
		else
			return new TypeAccess(target.name());
	}
	
	public Access SymbolicTopLevelTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous) {
		TypeDecl target = (TypeDecl)this.target;
		String pkg = target.packageName();
		if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
			if(ctxt.isShadowed(new PackageAccess(pkg), ambiguous))
				return null;
			return new TypeAccess(pkg, target.name());
		} else {
			return new TypeAccess(target.name());
		}
	}

	public Access SymbolicMemberTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous) {
		TypeDecl target = (TypeDecl)this.target;
		if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
			if(ambiguous && !source.memberFields(target.name()).isEmpty())
				return null;
			Access source_acc = ctxt.accessType(source, ambiguous);
			if(source_acc == null) return null;
			return source_acc.qualifiesAccess(new TypeAccess(target.name()));
		} else {
			return new TypeAccess(target.name());
		}
	}
	
	public abstract Access SymbolicTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier);
	
	public Access SymbolicLocalTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		return null;
	}

	public Access SymbolicTopLevelTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		TypeDecl target = (TypeDecl)this.target;
		String pkg = target.packageName();
		if(qualifier instanceof PackageAccess) {
			PackageAccess pkgacc = (PackageAccess)qualifier;
			if(pkgacc.packageName().equals(pkg) &&
					!ctxt.isShadowed(pkgacc, ambiguous))
				return qualifier.qualifiesAccess(new TypeAccess(target.name()));
		}
		return null;
	}
	
	public Access SymbolicMemberTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		TypeDecl target = (TypeDecl)this.target;
		if(qualifier.isTypeAccess()) {
			TypeDecl td = qualifier.type();
			// TODO: check that td is something we want to qualify with
			//       (i.e., td == source, or maybe an ancestor class)
			if(ambiguous && !source.memberFields(target.name()).isEmpty())
				return null;
			return qualifier.qualifiesAccess(new TypeAccess(target.name()));
		}
		return null;
	}
	
	public SymbolicTypeAccess TypeDecl.getSymbolicAccess(boolean needsQualifier) {
		if(isTopLevelType())
			return new SymbolicTopLevelTypeAccess(needsQualifier, this);
		else if(isMemberType())
			return new SymbolicMemberTypeAccess(needsQualifier, this);
		else
			return new SymbolicLocalTypeAccess(this);
	}
	
	public SymbolicTypeAccess TypeDecl.getSymbolicAccess() {
		return getSymbolicAccess(false);
	}
	
}
import java.util.*;

aspect AccessField {

	eq AbstractDot.getRight().accessField(FieldDeclaration fd) {
		return getLeft().qualifiedAccessField(fd);
	}
	
	syn Access Expr.qualifiedAccessField(FieldDeclaration fd) {
		return type().getBodyDecl(0).accessField(fd);
	}

	eq PackageAccess.qualifiedAccessField(FieldDeclaration fd) = null;

	eq TypeAccess.qualifiedAccessField(FieldDeclaration fd) {
		return type().getBodyDecl(0).accessField(fd);
	}
	
	// travels upwards in the class and interface hierarchy looking
	// for a field declaration fd, returning the type declaration where it was
	// found (null if not found)
	syn TypeDecl TypeDecl.findFieldUpwards(FieldDeclaration fd) = null;
	
	eq ClassDecl.findFieldUpwards(FieldDeclaration fd) {
		if(localFieldsMap().containsValue(fd))
			return this;
		boolean shadowed = localFieldsMap().containsKey(fd.getID());
		if(hasSuperclass()) {
			TypeDecl td = superclass().findFieldUpwards(fd);
			if(td == superclass() && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		for(Iterator i = interfacesIterator(); i.hasNext(); ) {
			InterfaceDecl idecl = (InterfaceDecl)i.next();
			TypeDecl td = idecl.findFieldUpwards(fd);
			if(td == idecl && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		return null;
	}

	eq InterfaceDecl.findFieldUpwards(FieldDeclaration fd) {
		if(localFieldsMap().containsValue(fd))
			return this;
		boolean shadowed = localFieldsMap().containsKey(fd.getID());
		for(Iterator i = superinterfacesIterator(); i.hasNext(); ) {
			InterfaceDecl idecl = (InterfaceDecl)i.next();
			TypeDecl td = idecl.findFieldUpwards(fd);
			if(td == idecl && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		return null;
	}
	
	// travels outwards through enclosing types to find a field declaration fd,
	// in every step invoking findFieldUpwards
	// returns a pair (out, up) detailing the types where it was found, or null
	// otherwise
	syn Pair TypeDecl.findField(FieldDeclaration fd) {
		TypeDecl up = findFieldUpwards(fd);
		if(up == null) {
			if(!isNestedType()) return null;
			boolean shadowed = localFieldsMap().containsKey(fd.getID());
			Pair p = enclosingType().findField(fd);
			if((TypeDecl)p.getFst() == enclosingType() && 
					(TypeDecl)p.getSnd() == enclosingType()	&& ! shadowed)
				return new Pair(this, this);
			return p;
		}
		return new Pair(this, up);
	}
	
	inh Access FieldDeclaration.accessField(FieldDeclaration fd);
	inh Access Expr.accessField(FieldDeclaration fd);
	inh Access Block.accessField(FieldDeclaration fd);
	inh Access CatchClause.accessField(FieldDeclaration fd);
	inh Access TypeDecl.accessField(FieldDeclaration fd);
	inh Access BodyDecl.accessField(FieldDeclaration fd);
	inh Access Methodoid.accessField(FieldDeclaration fd);
	inh Access ForStmt.accessField(FieldDeclaration fd);

	eq Program.getChild().accessField(FieldDeclaration fd) = null;

	eq TypeDecl.getBodyDecl(int i).accessField(FieldDeclaration fd) {
		Pair loc = findField(fd);
		TypeDecl out = (TypeDecl)loc.getFst();
		TypeDecl up = (TypeDecl)loc.getSnd();
		// first case: the field is in this class or one of its ancestors
		if(out == this) {
			Access acc = new VarAccess(fd.getID());
			if(up == this)
				return acc;
			else if(isClassDecl() && ((ClassDecl)this).superclass() == up)
				return new SuperAccess("super").qualifiesAccess(acc);
			else {
				Access tacc = getBodyDecl(i).accessType(up, false);
				if(tacc == null) return null;
				return new ParExpr(new CastExpr(tacc, new ThisAccess("this"))).
							qualifiesAccess(acc);
			}
		// second case: the field is in a surrounding class
		} else if(out == up) {
			Access outacc = getBodyDecl(i).accessType(out, false);
			return outacc.qualifiesAccess(new ThisAccess("this")).
							qualifiesAccess(new VarAccess(fd.getID()));
		// third case: the field is in an ancestor of a surrounding class
		} else {
			Access outacc = getBodyDecl(i).accessType(out, false);
			Access upacc = getBodyDecl(i).accessType(up, false);
			if(outacc == null || upacc == null) return null;
			return new ParExpr(new CastExpr(upacc, 
											outacc.qualifiesAccess(new ThisAccess("this")))).
							qualifiesAccess(new VarAccess(fd.getID()));
		}
	}

	// The scope of a parameter of a method is the entire body of the method
	eq Methodoid.getBlock().accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null) return null;
		if(!parameterDeclaration(fd.getID()).isEmpty() && !(acc instanceof AbstractDot))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}

	// The scope of a local variable declaration in a block is the rest of
	// the block in which the declaration appears
	eq Block.getStmt(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		VariableDeclaration v = localVariableDeclaration(fd.getID());
		if(v != null && declaredBeforeUse(v, i))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}
	
	eq ForStmt.getChild(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		for(int j=0;j<getNumInitStmt();++j)
			if(getInitStmt(j).declares(fd.getID()))
				return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}

	eq CatchClause.getChild(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		if(getParameter().declares(fd.getID()))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}
	
	syn boolean Stmt.declares(String id) = false;
	eq VariableDeclaration.declares(String id) = id.equals(getID());
	
	syn boolean ParameterDeclaration.declares(String id) = id.equals(getID());
	
}
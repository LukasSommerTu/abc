import java.util.*;

/*
 * The inherited attribute accessField tries to compute an access to a field. If,
 * for some node n, calling n.accessField(f) yields an access a, then looking up
 * a at node n should yield field f.
 * 
 * For a field named "f", the code will return one of the following
 *   1. a variable access "f" if the field is directly visible
 *   2. a qualified access "this.f", "super.f", or "((A)this).f", if "f" is
 *      visible in this class, its direct superclass, or its ancestor class/interface
 *      "A", respectively
 *   3. a qualified access "A.this.f" or "((B)A.this).f" if "f" is visible in
 *      enclosing class "A", or "A"'s ancestor class "B"
 *   4. null if none of the above works 
 */

aspect AccessField {

	eq AbstractDot.getRight().accessField(FieldDeclaration fd) {
		return getLeft().qualifiedAccessField(fd);
	}
	
	syn Access Expr.qualifiedAccessField(FieldDeclaration fd) {
		return type().getBodyDecl(0).accessField(fd);
	}

	eq PackageAccess.qualifiedAccessField(FieldDeclaration fd) = null;

	eq TypeAccess.qualifiedAccessField(FieldDeclaration fd) {
		return type().getBodyDecl(0).accessField(fd);
	}
	
	// travels upwards in the class and interface hierarchy looking
	// for a field declaration fd, returning the type declaration where it was
	// found (null if not found)
	syn TypeDecl TypeDecl.findFieldUpwards(FieldDeclaration fd) = null;
	
	eq ClassDecl.findFieldUpwards(FieldDeclaration fd) {
		if(localFieldsMap().containsValue(fd))
			return this;
		boolean shadowed = localFieldsMap().containsKey(fd.getID());
		if(hasSuperclass()) {
			TypeDecl td = superclass().findFieldUpwards(fd);
			// avoid unneccessary qualification
			if(td == superclass() && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		for(Iterator i = interfacesIterator(); i.hasNext(); ) {
			InterfaceDecl idecl = (InterfaceDecl)i.next();
			TypeDecl td = idecl.findFieldUpwards(fd);
			if(td == idecl && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		return null;
	}

	eq InterfaceDecl.findFieldUpwards(FieldDeclaration fd) {
		if(localFieldsMap().containsValue(fd))
			return this;
		boolean shadowed = localFieldsMap().containsKey(fd.getID());
		for(Iterator i = superinterfacesIterator(); i.hasNext(); ) {
			InterfaceDecl idecl = (InterfaceDecl)i.next();
			TypeDecl td = idecl.findFieldUpwards(fd);
			if(td == idecl && !shadowed)
				return this;
			else if(td != null)
				return td;
		}
		return null;
	}
	
	// travels outwards through enclosing types to find a field declaration fd,
	// in every step invoking findFieldUpwards
	// returns a pair (out, up) detailing the types where it was found, or null
	// otherwise
	syn Pair TypeDecl.findField(FieldDeclaration fd) {
		TypeDecl up = findFieldUpwards(fd);
		if(up == null) {
			if(!isNestedType()) return null;
			boolean shadowed = localFieldsMap().containsKey(fd.getID());
			Pair p = enclosingType().findField(fd);
			if((TypeDecl)p.getFst() == enclosingType() && 
					(TypeDecl)p.getSnd() == enclosingType()	&& ! shadowed)
				return new Pair(this, this);
			return p;
		}
		return new Pair(this, up);
	}
	
	inh Access FieldDeclaration.accessField(FieldDeclaration fd);
	inh Access Expr.accessField(FieldDeclaration fd);
	inh Access Block.accessField(FieldDeclaration fd);
	inh Access CatchClause.accessField(FieldDeclaration fd);
	inh Access TypeDecl.accessField(FieldDeclaration fd);
	inh Access BodyDecl.accessField(FieldDeclaration fd);
	inh Access Methodoid.accessField(FieldDeclaration fd);
	inh Access ForStmt.accessField(FieldDeclaration fd);

	eq Program.getChild().accessField(FieldDeclaration fd) = null;

	eq TypeDecl.getBodyDecl(int i).accessField(FieldDeclaration fd) {
		Pair loc = findField(fd);
		TypeDecl out = (TypeDecl)loc.getFst();
		TypeDecl up = (TypeDecl)loc.getSnd();
		// first case: the field is in this class or one of its ancestors
		if(out == this) {
			Access acc = new VarAccess(fd.getID());
			if(up == this)
				return acc;
			else if(isClassDecl() && ((ClassDecl)this).superclass() == up)
				return new SuperAccess("super").qualifiesAccess(acc);
			else {
				Access tacc = getBodyDecl(i).accessType(up, false);
				if(tacc == null) return null;
				return new ParExpr(new CastExpr(tacc, new ThisAccess("this"))).
							qualifiesAccess(acc);
			}
		// second case: the field is in a surrounding class
		} else if(out == up) {
			Access outacc = getBodyDecl(i).accessType(out, false);
			return outacc.qualifiesAccess(new ThisAccess("this")).
							qualifiesAccess(new VarAccess(fd.getID()));
		// third case: the field is in an ancestor of a surrounding class
		} else {
			Access outacc = getBodyDecl(i).accessType(out, false);
			Access upacc = getBodyDecl(i).accessType(up, false);
			if(outacc == null || upacc == null) return null;
			return new ParExpr(new CastExpr(upacc, 
											outacc.qualifiesAccess(new ThisAccess("this")))).
							qualifiesAccess(new VarAccess(fd.getID()));
		}
	}

	// The scope of a parameter of a method includes the entire body of the method
	eq Methodoid.getBlock().accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null) return null;
		if(!parameterDeclaration(fd.getID()).isEmpty() && !(acc instanceof AbstractDot))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}

	// The scope of a local variable declaration in a block includes the rest of
	// the block in which the declaration appears.
	eq Block.getStmt(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		VariableDeclaration v = localVariableDeclaration(fd.getID());
		if(v != null && declaredBeforeUse(v, i))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}
	
	// The scope of variables declared in the init statements of a for loop includes
	// the entire loop.
	eq ForStmt.getChild(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		for(int j=0;j<getNumInitStmt();++j)
			if(getInitStmt(j).declares(fd.getID()))
				return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}

	// The scope of the parameter of a catch clause includes the entire clause.
	eq CatchClause.getChild(int i).accessField(FieldDeclaration fd) {
		Access acc = accessField(fd);
		if(acc == null || acc instanceof AbstractDot) return acc;
		if(getParameter().declares(fd.getID()))
			return new ThisAccess("this").qualifiesAccess(acc);
		return acc;
	}
	
	syn boolean Stmt.declares(String id) = false;
	eq VariableDeclaration.declares(String id) = id.equals(getID());
	
	syn boolean ParameterDeclaration.declares(String id) = id.equals(getID());
	
}
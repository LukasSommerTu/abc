aspect PushDownMethod {
	public void MethodDecl.pushDown(boolean leaveAbstract) {
		if(!fromSource())
			throw new RefactoringException("cannot push library method");
		if(isAbstract())
			pushDownAbstract(leaveAbstract);
		else if(isPrivate() || isStatic())
			pushDownMono(leaveAbstract);
		else
			pushDownVirtual(leaveAbstract);
	}
	
	public void MethodDecl.pushDownAbstract(boolean leaveAbstract) {
		for(TypeDecl child : hostType().childTypes()) {
			MethodDecl md = child.memberMethod(this);
			if(md == null)
				// child type already contains a method with this signature
				continue;
			child.makeAbstract();
			MethodDecl md2 = md.lockedCopyWithEmptyBody();
			if(hostType().isInterfaceDecl() && !child.isInterfaceDecl())
				md2.getModifiers().addModifiers("public", "abstract");
			programRoot().lockMethodNames(md.name());
			child.addBodyDecl(md2);
			programRoot().flushCaches();
			programRoot().eliminateLockedNames();
		}
		removeUnused(leaveAbstract);		
	}
	
	public void MethodDecl.pushDownMono(boolean leaveAbstract) {
		MethodDecl md = this;
		md.unfoldSynchronized();
		for(TypeDecl child : hostType().childTypes()) {
			if(!child.localMethodsSignature(md.signature()).isEmpty() || md.isStatic() && child.isInnerClass())
				throw new RefactoringException("cannot insert method here");
			md.lockAllNames();
			MethodDecl md2 = md;
			md = (MethodDecl)md.fullCopy();
			md2.replaceWith(md);
			md.programRoot().lockMethodNames(md.name());
			child.addBodyDecl(md2);
			md2.foldSynchronized();
			md.programRoot().flushCaches();
			md.programRoot().eliminateLockedNames();
		}
		md.removeUnused(leaveAbstract);
	}
	
	public void MethodDecl.pushDownVirtual(boolean leaveAbstract) {
		ASTNode parent = getParent();
		int idx = parent.getIndexOfChild(this);
		MethodDecl md = this;
		for(TypeDecl child : hostType().childTypes()) {
			MethodAccess ma = child.triviallyOverrideInheritedMethod(md);
			MethodDecl md2 = (MethodDecl)ma.enclosingBodyDecl();
			ma.inline();
			md = (MethodDecl)parent.getChild(idx);
			child.eliminate(WITH_STMT, FRESH_VARIABLES);
			md2.foldSynchronized();
		}
		md.removeUnused(leaveAbstract);
	}
	
	public void MethodDecl.doPushDown(boolean leaveAbstract) {
		Program root = programRoot();
		pushDown(leaveAbstract);
		root.eliminate(RETURN_VOID, LOCKED_NAMES, LOCKED_DATAFLOW);
	}
	
	public MethodAccess TypeDecl.triviallyOverrideInheritedMethod(MethodDecl md) {
		throw new RefactoringException("cannot override in this kind of type");
	}
	
	public MethodAccess ClassDecl.triviallyOverrideInheritedMethod(MethodDecl md) {
		if(md.isAbstract() || md.isFinal())
			throw new RefactoringException("cannot override this method");
		md = memberMethod(md);
		if(md == null)
			throw new RefactoringException("method with same signature exists in subclass");
		MethodDecl new_md = md.lockedCopyWithEmptyBody();
		List<Expr> args = new List<Expr>();
		for(ParameterDeclaration pd : new_md.getParameters())
			args.add(new VarAccess(pd.name()));
		MethodAccess lockedAccess = new MethodAccess(md, args);
		ReturnStmt ret = new ReturnStmt(new AbstractDot(new SuperAccess("super"), lockedAccess));
		new_md.setBlock(new Block(new List<Stmt>().add(ret)));
		addBodyDecl(new_md);
		programRoot().flushCaches();
		return lockedAccess; 
	}
	
	public MethodDecl MethodDecl.lockedCopyWithEmptyBody() {
		Modifiers mods = (Modifiers)getModifiers().fullCopy();
		Access rettype = type().createLockedAccess();
		String name = name();
		List<ParameterDeclaration> parms = new List<ParameterDeclaration>();
		for(ParameterDeclaration pd : getParameters())
			parms.add(pd.lockedCopy());
		List<Access> exns = new List<Access>();
		for(Access exn : getExceptions())
			exns.add(exn.type().createLockedAccess());
		return new MethodDecl(mods, rettype, name, parms, exns, new Opt<Block>());
	}
	
	public MethodDecl GenericMethodDecl.lockedCopyWithEmptyBody() {
		Modifiers mods = (Modifiers)getModifiers().fullCopy();
		Access rettype = type().createLockedAccess();
		String name = name();
		List<ParameterDeclaration> parms = new List<ParameterDeclaration>();
		for(ParameterDeclaration pd : getParameters())
			parms.add(pd.lockedCopy());
		List<Access> exns = new List<Access>();
		for(Access exn : getExceptions())
			exns.add(exn.type().createLockedAccess());
		List<TypeVariable> typeparms = (List<TypeVariable>)getTypeParameters();
		return new GenericMethodDecl(mods, rettype, name, parms, exns, new Opt<Block>(), typeparms);		
	}
	
	public MethodDecl AnnotationMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl BridgeMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl IntertypeMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl IntroducedMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl RawMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	
	public SimpleSet TypeDecl.memberMethods(MethodDecl md) {
		SimpleSet res = SimpleSet.emptySet;
		for(Iterator iter=memberMethods(md.name()).iterator(); iter.hasNext();) {
			MethodDecl md2 = (MethodDecl)iter.next();
			if(md.sourceMethodDecl() == md2.sourceMethodDecl())
				res = res.add(md2);
		}
		return res;
	}
	
	public MethodDecl TypeDecl.memberMethod(MethodDecl md) {
		SimpleSet res = memberMethods(md);
		if(res.size() > 1)
			throw new Error("inherited multiple methods with the same source declaration");
		return res.isEmpty() ? null : (MethodDecl)res.iterator().next();
	}
}
aspect PushDownMethod {	
	/**
	 * The Push Down Method Refactoring.
	 * 
	 * Preconditions:
	 *  - if method to be pushed overrides at least one other method and all its 
	 *    ancestors are abstract, the host type must be abstract as well
	 *  - host type cannot have more than one child type
	 *  - that child type cannot already contain a method with the same signature
	 *  - no virtual call to the method can statically resolve to one of its
	 *    ancestors
	 *  
	 * The preconditions ensure that it is enough to adjust all accesses to
	 * the method being pushed and all accesses within that method.
	 * 
	 * If pushing from an interface to a class, we need to make the pushed
	 * method public and abstract.
	 */
	public MethodDecl MethodDecl.pushDown() {
		if(!fromSource())
			throw new RefactoringException("cannot push library methods");
		if(isRootMethod())
			hostType().makeAbstract();
		Collection<TypeDecl> children = hostType().childTypes();
		if(children.size() != 1)
			throw new RefactoringException("can only push down to exactly one subclass");
		TypeDecl child = children.iterator().next();
		if(isStatic() && child.isInnerClass() || !child.localMethodsSignature(signature()).isEmpty())
			throw new RefactoringException("method cannot be pushed");
		if(hostType().isInterfaceDecl() && !child.isInterfaceDecl())
			getModifiers().addModifiers("public", "abstract");
		unfoldSynchronized();
		for(MethodAccess ma : this.polyUses())
			if(ma.isPolyCall() && overrides().contains(ma.decl()))
				throw new RefactoringException("call target could change");
		programRoot().lockMethodNames(name());
		lockAllNames();
		hostType().removeBodyDecl(this);
		child.addBodyDecl(this);
		programRoot().flushCaches();
		foldSynchronized();
		return this;
	}
	
	// check whether this method has ancestors, but all of them are abstract
    private boolean MethodDecl.isRootMethod() {
    	if(overrides().isEmpty())
    		return false;
    	for(MethodDecl anc : overrides())
    		if(!anc.isAbstract())
    			return false;
    	return true;
	}
	
    public void MethodDecl.doPushDown() {
    	pushDown();
    	programRoot().eliminate(LOCKED_NAMES);
    }
}
aspect PushDownMethod {
	public void MethodDecl.pushDown(boolean leaveAbstract) {
		if(!fromSource())
			throw new RefactoringException("cannot push library method");
		if(isPrivate() || isStatic())
			pushDownMono(leaveAbstract);
		else
			pushDownVirtual(leaveAbstract);
	}
	
	public void MethodDecl.pushDownMono(boolean leaveAbstract) {
		MethodDecl md = this;
		md.unfoldSynchronized();
		for(TypeDecl child : hostType().childTypes()) {
			if(!child.localMethodsSignature(md.signature()).isEmpty() || md.isStatic() && child.isInnerClass())
				throw new RefactoringException("cannot insert method here");
			md.lockAllNames();
			MethodDecl md2 = md;
			md = (MethodDecl)md.fullCopy();
			md2.replaceWith(md);
			md.programRoot().lockMethodNames(md.name());
			child.addBodyDecl(md2);
			md2.foldSynchronized();
			md.programRoot().flushCaches();
			md.programRoot().eliminateLockedNames();
		}
		md.removeUnused(leaveAbstract);
	}
	
	public void MethodDecl.pushDownVirtual(boolean leaveAbstract) {
		ASTNode parent = getParent();
		int idx = parent.getIndexOfChild(this);
		MethodDecl md = this;
		for(TypeDecl child : hostType().childTypes()) {
			MethodAccess ma = child.triviallyOverrideInheritedMethod(md);
			if(ma != null) {
				MethodDecl pushed_down = (MethodDecl)ma.hostBodyDecl();
				ma.inline();
				pushed_down.foldSynchronized();
			}
			md = (MethodDecl)parent.getChild(idx);
			child.eliminate(WITH_STMT, FRESH_VARIABLES);
		}
		md.removeUnused(leaveAbstract);
	}
	
	public void MethodDecl.doPushDown(boolean leaveAbstract) {
		Program root = programRoot();
		pushDown(leaveAbstract);
		root.eliminate(RETURN_VOID, LOCKED_NAMES, LOCKED_DATAFLOW);
	}
	
	public MethodAccess TypeDecl.triviallyOverrideInheritedMethod(MethodDecl md) {
		throw new RefactoringException("cannot override in this kind of type");
	}
	
	public MethodAccess ClassDecl.triviallyOverrideInheritedMethod(MethodDecl md) {
		md = memberMethod(md);
		if(md == null)
			return null;
		MethodDecl new_md = md.lockedCopyWithEmptyBody();
		if(md.hostType().isInterfaceDecl())
			new_md.getModifiers().addModifiers("public", "abstract");
		md.getModifiers().removeModifier("final");
		MethodAccess lockedAccess = null;
		if(md.isAbstract()) {
			makeAbstract();
		} else {
			List<Expr> args = new List<Expr>();
			for(ParameterDeclaration pd : new_md.getParameters())
				args.add(new VarAccess(pd.name()));
			lockedAccess = new MethodAccess(md, args);
			ReturnStmt ret = new ReturnStmt(new AbstractDot(new SuperAccess("super"), lockedAccess));
			new_md.setBlock(new Block(new List<Stmt>().add(ret)));
		}
		addBodyDecl(new_md);
		programRoot().flushCaches();
		return lockedAccess; 
	}
	
	public MethodAccess InterfaceDecl.triviallyOverrideInheritedMethod(MethodDecl md) {
		assert md.isAbstract();
		md = memberMethod(md);
		if(md == null)
			return null;
		MethodDecl new_md = md.lockedCopyWithEmptyBody();
		new_md.getModifiers().removeModifiers("public", "abstract");
		addBodyDecl(new_md);
		programRoot().flushCaches();
		return null;
	}
	
	public MethodDecl MethodDecl.lockedCopyWithEmptyBody() {
		Modifiers mods = (Modifiers)getModifiers().fullCopy();
		Access rettype = type().createLockedAccess();
		String name = name();
		List<ParameterDeclaration> parms = new List<ParameterDeclaration>();
		for(ParameterDeclaration pd : getParameters())
			parms.add(pd.lockedCopy());
		List<Access> exns = new List<Access>();
		for(Access exn : getExceptions())
			exns.add(exn.type().createLockedAccess());
		return new MethodDecl(mods, rettype, name, parms, exns, new Opt<Block>());
	}
	
	public MethodDecl GenericMethodDecl.lockedCopyWithEmptyBody() {
		Modifiers mods = (Modifiers)getModifiers().fullCopy();
		Access rettype = type().createLockedAccess();
		String name = name();
		List<ParameterDeclaration> parms = new List<ParameterDeclaration>();
		for(ParameterDeclaration pd : getParameters())
			parms.add(pd.lockedCopy());
		List<Access> exns = new List<Access>();
		for(Access exn : getExceptions())
			exns.add(exn.type().createLockedAccess());
		Map<TypeVariable, TypeVariable> tvdict = new HashMap<TypeVariable, TypeVariable>();
		getTypeParameters().lockAllNames();
		List<TypeVariable> typeparms = getTypeParameters();
		setTypeParameterList((List<TypeVariable>)typeparms.fullCopy());
		for(int i=0;i<getNumTypeParameter();++i)
			tvdict.put(typeparms.getChild(i), getTypeParameter(i));
		translateTypeVars(tvdict);
		return new GenericMethodDecl(mods, rettype, name, parms, exns, new Opt<Block>(), typeparms);
	}
	
	public MethodDecl AnnotationMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl BridgeMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	public MethodDecl RawMethodDecl.lockedCopyWithEmptyBody() { throw new UnsupportedOperationException(); }
	
	public SimpleSet TypeDecl.memberMethods(MethodDecl md) {
		SimpleSet res = SimpleSet.emptySet;
		for(Iterator iter=memberMethods(md.name()).iterator(); iter.hasNext();) {
			MethodDecl md2 = (MethodDecl)iter.next();
			if(md.sourceMethodDecl() == md2.sourceMethodDecl())
				res = res.add(md2);
		}
		return res;
	}
	
	public MethodDecl TypeDecl.memberMethod(MethodDecl md) {
		SimpleSet res = memberMethods(md);
		if(res.size() > 1)
			throw new Error("inherited multiple methods with the same source declaration");
		return res.isEmpty() ? null : (MethodDecl)res.iterator().next();
	}
}
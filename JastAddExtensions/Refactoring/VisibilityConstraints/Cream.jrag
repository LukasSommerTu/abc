import jp.ac.kobe_u.cs.cream.Network;
import jp.ac.kobe_u.cs.cream.IntVariable;
import jp.ac.kobe_u.cs.cream.Constraint;
import jp.ac.kobe_u.cs.cream.Equals;
import jp.ac.kobe_u.cs.cream.NotEquals;
import jp.ac.kobe_u.cs.cream.IntComparison;
import jp.ac.kobe_u.cs.cream.DefaultSolver;
import jp.ac.kobe_u.cs.cream.Solution;

aspect Cream {
	syn lazy IntVariable Visible.creamVariable(Network network) = new IntVariable(network, VIS_PRIVATE, VIS_PUBLIC, name());
	
	public Constraint AccessibilityConstraint.generateCreamConstraint(Network network) {
		return op.generateCreamConstraint(left.creamVariable(network), right.creamVariable(network));
	}
	
	public Constraint Operator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new IntComparison(left.getNetwork(), getComparisonOperator(), left, right);
	}
	
	public Constraint EQOperator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new Equals(left.getNetwork(), left, right);
	}
	
	public Constraint NEOperator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new NotEquals(left.getNetwork(), left, right);
	}
	
	protected int Operator.getComparisonOperator() { return -1; }
	protected int LEOperator.getComparisonOperator() { return IntComparison.LE; }
	protected int LTOperator.getComparisonOperator() { return IntComparison.LT; }
	protected int GEOperator.getComparisonOperator() { return IntComparison.GE; }
	protected int GTOperator.getComparisonOperator() { return IntComparison.GT; }
	
	public abstract IntVariable WithAccessModifier.creamVariable(Network network);
	public IntVariable AccessModifierConstant.creamVariable(Network network) {
		return new IntVariable(network, vis);
	}
	
	public IntVariable AccessModifierVariable.creamVariable(Network network) {
		return element.creamVariable(network);
	}
	
	public Network Program.generateNetwork(Collection<AccessibilityConstraint> accessibilityConstraints) {
		Network network = new Network();
		// make sure we have variables for all visible elements that come from source
		for(Visible sourceVis : sourceVisibles())
			sourceVis.creamVariable(network);
		for(AccessibilityConstraint constr : accessibilityConstraints)
			constr.generateCreamConstraint(network);
		return network;
	}
	
	public Map<Visible, Integer> Program.solve(Network network, Collection<AccessibilityConstraint> constraints) {
		DefaultSolver solver = new DefaultSolver(network);
		try {
			for(solver.start(); solver.waitNext(); solver.resume()) {
				return generateAccessibilityMap(network, solver.getSolution(), constraints);
			}
			return null;
		} finally {
			solver.stop();
		}
	}
	
	// result may contain the same solution twice
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions(Network network, Collection<AccessibilityConstraint> constraints) {
		Collection<Map<Visible, Integer>> res = new LinkedList<Map<Visible, Integer>>();
		DefaultSolver solver = new DefaultSolver(network);
		for(solver.start(); solver.waitNext(); solver.resume())
			res.add(generateAccessibilityMap(network, solver.getSolution(), constraints));
		solver.stop();
		return res;
	}
	
	public Map<Visible, Integer> Program.solve(Collection<AccessibilityConstraint> accessibilityConstraints) {
		return solve(generateNetwork(accessibilityConstraints), accessibilityConstraints);
	}
	
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions(Collection<AccessibilityConstraint> accessibilityConstraints) {
		return allPossibleSolutions(generateNetwork(accessibilityConstraints), accessibilityConstraints);
	}
	
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions() {
		return allPossibleSolutions(generateNetwork(accessibilityConstraints()), accessibilityConstraints());
	}
	
	private Map<Visible, Integer> Program.generateAccessibilityMap(Network network, Solution solution, Collection<AccessibilityConstraint> constraints) {
		Map<Visible, Integer> map = new HashMap<Visible, Integer>();
		for(Visible element : sourceVisibles()) {
			IntVariable var = element.creamVariable(network);
			int val = solution.getIntValue(var);
			if(val != element.getVisibility())
				map.put(element, val);
		}
		return map;
	}
	
	// collect all visible elements that are from source
	public Collection<Visible> Program.sourceVisibles() {
		Collection<Visible> visibles = new HashSet<Visible>();
		collectSourceVisibles(visibles);
		return visibles;
	}
	
	public void ASTNode.collectSourceVisibles(Collection<Visible> visibles) {
		for(int i=0;i<getNumChild();++i)
			getChild(i).collectSourceVisibles(visibles);
	}
	
	public void CompilationUnit.collectSourceVisibles(Collection<Visible> visibles) {
		if(!fromSource())
			return;
		super.collectSourceVisibles(visibles);
	}
	
	public void Visible.collectSourceVisibles(Collection<Visible> visibles) {
		visibles.add(this);
		super.collectSourceVisibles(visibles);
	}
}
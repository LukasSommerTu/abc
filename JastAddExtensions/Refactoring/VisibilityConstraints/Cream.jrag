import jp.ac.kobe_u.cs.cream.Network;
import jp.ac.kobe_u.cs.cream.IntVariable;
import jp.ac.kobe_u.cs.cream.Constraint;
import jp.ac.kobe_u.cs.cream.Equals;
import jp.ac.kobe_u.cs.cream.NotEquals;
import jp.ac.kobe_u.cs.cream.IntComparison;
import jp.ac.kobe_u.cs.cream.DefaultSolver;
import jp.ac.kobe_u.cs.cream.Solution;

aspect Cream {
	syn lazy IntVariable Visible.creamVariable(Network network) = new IntVariable(network, VIS_PRIVATE, VIS_PUBLIC, name());
	
	public Constraint AccessibilityConstraint.generateCreamConstraint(Network network) {
		return op.generateCreamConstraint(left.creamVariable(network), right.creamVariable(network));
	}
	
	public Constraint Operator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new IntComparison(left.getNetwork(), getComparisonOperator(), left, right);
	}
	
	public Constraint EQOperator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new Equals(left.getNetwork(), left, right);
	}
	
	public Constraint NEOperator.generateCreamConstraint(IntVariable left, IntVariable right) {
		return new NotEquals(left.getNetwork(), left, right);
	}
	
	protected int Operator.getComparisonOperator() { return -1; }
	protected int LEOperator.getComparisonOperator() { return IntComparison.LE; }
	protected int LTOperator.getComparisonOperator() { return IntComparison.LT; }
	protected int GEOperator.getComparisonOperator() { return IntComparison.GE; }
	protected int GTOperator.getComparisonOperator() { return IntComparison.GT; }
	
	public abstract IntVariable WithAccessModifier.creamVariable(Network network);
	public IntVariable AccessModifierConstant.creamVariable(Network network) {
		return new IntVariable(network, vis);
	}
	
	public IntVariable AccessModifierVariable.creamVariable(Network network) {
		return element.creamVariable(network);
	}
	
	public Network Program.generateNetwork(Collection<AccessibilityConstraint> accessibilityConstraints) {
		Network network = new Network();
		for(AccessibilityConstraint constr : accessibilityConstraints)
			constr.generateCreamConstraint(network);
		return network;
	}
	
	public Map<Visible, Integer> Program.solve(Network network, Collection<AccessibilityConstraint> constraints) {
		DefaultSolver solver = new DefaultSolver(network);
		try {
			for(solver.start(); solver.waitNext(); solver.resume()) {
				return generateAccessibilityMap(network, solver.getSolution(), constraints);
				//printSolution(network, solver.getSolution(), constraints);
			}
			return null;
		} finally {
			solver.stop();
		}
	}
	
	// result may contain the same solution twice
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions(Network network, Collection<AccessibilityConstraint> constraints) {
		Collection<Map<Visible, Integer>> res = new LinkedList<Map<Visible, Integer>>();
		DefaultSolver solver = new DefaultSolver(network);
		for(solver.start(); solver.waitNext(); solver.resume())
			res.add(generateAccessibilityMap(network, solver.getSolution(), constraints));
		solver.stop();
		return res;
	}
	
	public Map<Visible, Integer> Program.solve(Collection<AccessibilityConstraint> accessibilityConstraints) {
		return solve(generateNetwork(accessibilityConstraints), accessibilityConstraints);
	}
	
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions(Collection<AccessibilityConstraint> accessibilityConstraints) {
		return allPossibleSolutions(generateNetwork(accessibilityConstraints), accessibilityConstraints);
	}
	
	public Collection<Map<Visible, Integer>> Program.allPossibleSolutions() {
		return allPossibleSolutions(generateNetwork(accessibilityConstraints()), accessibilityConstraints());
	}
	
	// collect all visibles that constraints were generated for
	static Collection<Visible> ASTNode.getConstrainedVisibles(Collection<AccessibilityConstraint> constraints) {
		HashSet<Visible> visibles = new HashSet<Visible>();
		for(AccessibilityConstraint constr : constraints) {
			constr.getLeft().addVisible(visibles);
			constr.getRight().addVisible(visibles);
		}
		return visibles;
	}
	
	public abstract void WithAccessModifier.addVisible(Collection<Visible> visibles);
	public void AccessModifierConstant.addVisible(Collection<Visible> visibles) { }
	public void AccessModifierVariable.addVisible(Collection<Visible> visibles) { visibles.add(element); }
	
	private Map<Visible, Integer> Program.generateAccessibilityMap(Network network, Solution solution, Collection<AccessibilityConstraint> constraints) {
		Map<Visible, Integer> map = new HashMap<Visible, Integer>();
		for(Visible element : getConstrainedVisibles(constraints)) {
			IntVariable var = element.creamVariable(network);
			int val = solution.getIntValue(var);
			if(val != element.getVisibility())
				map.put(element, val);
		}
		return map;
	}
	
    private void Program.printSolution(Network network, Solution solution, Collection<AccessibilityConstraint> constraints) {
    	System.out.println("Solution:");
		// print changed visibilities
		for(Visible element : getConstrainedVisibles(constraints)) {
			IntVariable var = element.creamVariable(network);
			int val = solution.getIntValue(var);
			if(val != element.getVisibility())
				System.out.println("visibility changed to " + visibilityToString(val) + " for " + element);
		}
	}	
}
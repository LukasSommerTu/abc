aspect ClosureSubstitution {
	
	public ClosureInvocation ClosureInvocation.subst() throws RefactoringException {
		AdjustmentTable table = new AdjustmentTable(programRoot());
		getBlock().lockAllLocalDeclarations(table);
		for(int i=getNumParameter()-1;i>=0;--i) {
			RefactoringException exn = getParameter(i).inline(table);
			if(exn != null)
				throw exn;
		}
		programRoot().flushCaches();
		table.adjust();
		return this;
	}
	
	inh RefactoringException ParameterDeclaration.inline(AdjustmentTable table);
	eq ClosureInvocation.getParameter(int i).inline(AdjustmentTable table) {
		ParameterDeclaration pd = getParameter(i);
		Expr arg = getArg(i);
		try {
			if(pd.isIn()) {
				TypeDecl type = pd.type();
				arg.lockAll(table);
				removeParameter(i);
				removeArg(i);
				VariableDeclaration newdecl = pd.asLockedVariableDeclaration(table);
				newdecl.setInit(arg);
				table.add(newdecl);
				getBlock().insertStmt(0, newdecl);
			} else {
				if(!(arg instanceof VarAccess))
					throw new RefactoringException("cannot inline argument");
				Variable decl = ((VarAccess)arg).decl();
				Collection<VarAccess> uses = pd.uses();
				removeParameter(i);
				removeArg(i);
				for(VarAccess v : uses) {
					v.flushCaches();
					v.lockOn(decl);
					table.add(v);
				}
			}
		} catch(RefactoringException rfe) {
			return rfe;
		}
		return null;
	}
	eq Program.getChild().inline(AdjustmentTable table) {
		return new RefactoringException("Cannot inline non-closure parameters");
	}
	
	// enter all local declarations in this subtree into the table
	public void ASTNode.lockAllLocalDeclarations(AdjustmentTable table) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.lockAllLocalDeclarations(table);
		}
	}
	public void LocalDeclaration.lockAllLocalDeclarations(AdjustmentTable table) {
		table.add(this);
	}
	public void TypeDecl.lockAllLocalDeclarations(AdjustmentTable table) { }
	
	
	// adjusting local declarations
	private java.util.Set<LocalDeclaration> AdjustmentTable.locked_declarations = new HashSet<LocalDeclaration>();
	public void AdjustmentTable.add(LocalDeclaration decl) {
		decl.lock();
		locked_declarations.add(decl);
	}
	
	refine Dataflow public void AdjustmentTable.adjust() throws RefactoringException {
		for(LocalDeclaration decl : locked_declarations)
			decl.unlockSafely();
		refined();
	}
	
	// TODO: this would be a lot nicer if we could refine methods defined on interfaces...
	private boolean VariableDeclaration.locked;
	private boolean ParameterDeclaration.locked;
	public void LocalDeclaration.lock() { locked = true; }
	public void LocalDeclaration.unlock() { locked = false; }
	public void LocalDeclaration.unlockSafely() throws RefactoringException {
		if(nameClash(name()))
			rename(pickFreshName());
		unlock();
	}
	
	// locked variable declarations don't collide with other names (ugly duplication!)
	refine LocalVarNesting public boolean ParameterDeclaration.canIntroduceLocal(String name) {
		if(locked)
			return true;
		return refined(name);
	}
	refine LocalVarNesting public boolean VariableDeclaration.canIntroduceLocal(String name) {
		if(locked)
			return true;
		return refined(name);
	}
	
	public boolean LocalDeclaration.nameClash(String name) {
		BodyDecl bd = hostBodyDecl();
		SimpleSet set = bd.lookupVariable(name);
		if(set.isEmpty())
			return !bd.canIntroduceLocal(name);
		for(Iterator iter=set.iterator();iter.hasNext();)
			if(iter.next() instanceof LocalDeclaration)
				return true;
		return false;
	}
	
	public String LocalDeclaration.pickFreshName() {
		String base = name();
		for(int i=0;;++i)
			if(!nameClash(base+i))
				return base+i;
	}
		
}
aspect InlineAssignment {	
	public void AssignSimpleExpr.inline() throws RefactoringException {
		if(!(getParent() instanceof ExprStmt))
			throw new RefactoringException("cannot inline this assignment");
		Stmt stmt = (Stmt)getParent();
		if(!(getDest() instanceof VarAccess))
			throw new RefactoringException("LHS is not a simple variable");
		VarAccess v = (VarAccess)getDest();
		if(!v.decl().isLocalVariable())
			throw new RefactoringException("can only inline assignment to local variable");
		setSource(getSource().makeConversionExplicit(getDest().type()));
		Expr rhs;
		SmallSet<Access> dsuccs = v.reachedUses();
		BodyDecl bd = hostBodyDecl();
		// check that all the data successors have this as their only data predecessor and are not destinations
		// and replace them by copies of the RHS
		// fail if any of the data successors are not in the same method (e.g., inside an anonymous class)
		for(Access w : dsuccs) {
			getSource().lockAllNames();
			bd.hostType().flushCaches();
			rhs = getSource();
			rhs.lockDataFlow();
			bd.lockSyncDependencies();
			if(w.isDest())
				throw new RefactoringException("cannot inline into destinations");
			if(w.hostBodyDecl() != stmt.hostBodyDecl())
				throw new RefactoringException("cannot inline across method boundaries");
			if(!w.reachingDefinitions().isSingleton())
				throw new RefactoringException("ambiguous dataflow");
			w.replaceWith(rhs.precedence() > w.maxPrecedence() ? new ParExpr(rhs) : rhs);
			compilationUnit().flushCaches();
			rhs.unlockDataFlow();
			bd.unlockSyncDependencies();
			setSource(rhs = (Expr)rhs.fullCopy());
		}
		// delete assignment
		stmt.delete();
	}
	
	public Expr Expr.makeConversionExplicit(TypeDecl destType) {
		if(shouldMakeConversionExplicit(destType))
			return createConversion(destType, this);
		return this;
	}
		
	syn lazy boolean Expr.shouldMakeConversionExplicit(TypeDecl destType) = !type().equals(destType);
	eq AbstractDot.shouldMakeConversionExplicit(TypeDecl destType) = getRight().shouldMakeConversionExplicit(destType);
	eq MethodAccess.shouldMakeConversionExplicit(TypeDecl destType) {
		// we need to handle the case where the result type of a method is inferred from a surrounding assignment conversion
		if(!(this instanceof ParMethodAccess) && decl() instanceof ParMethodDecl) {
			ParMethodDecl pmd = (ParMethodDecl)decl();
			// TODO: this will insert spurious conversions in cases where the result type can be inferred from the arguments
			return pmd.genericMethodDecl().type().isTypeVariable();
		}
		return super.shouldMakeConversionExplicit(destType);
	}
	
	public static Expr ASTNode.createConversion(TypeDecl dest, Expr src) {
		// check whether src can be boxe into dest (we assume there is an assignment conversion)
		if(src.type() instanceof PrimitiveType && !dest.unboxed().isUnknown()) {
			if(!src.type().equals(dest.unboxed()))
				src = createConversion(dest.unboxed(), src);
			return new ClassInstanceExpr(dest.createLockedAccess(), new List<Expr>().add(src));
		} else {
			CastExpr ce = new CastExpr(dest.createLockedAccess(), src);
			if(src.precedence() > src.maxPrecedence())
				ce.setExpr(new ParExpr(src));
			return ce;
		}
	}
}
aspect PushDownMethod {
	
	// collects all children of a type declaration
	coll Collection<TypeDecl> TypeDecl.childTypes() circular [new HashSet<TypeDecl>()] 
	                                                         with add root Program;
	ClassDecl contributes
	this when hasSuperclass()
	to TypeDecl.childTypes() for superclass();
	
	ClassDecl contributes
	this
	to TypeDecl.childTypes() for each interfaces();
	
	InterfaceDecl contributes
	this
	to TypeDecl.childTypes() for each superInterfaces();

	/**
	 * The Push Down Method Refactoring.
	 * 
	 * Preconditions:
	 * 	- method to be pushed does not override another method
	 *  - host type of method to be pushed has exactly one child type
	 *  - that child type does not already contain a method with the same signature
	 *  
	 * The preconditions ensure that it is enough to adjust all accesses to
	 * the method being pushed and all accesses within that method.
	 * 
	 * If pushing from an interface to a class, we need to make the pushed
	 * method public and abstract.
	 */
	public void MethodDecl.pushDown() throws RefactoringException {
		if(!this.overrides().isEmpty())
			throw new RefactoringException("cannot push down overriding method");
		TypeDecl oldhost = hostType();
		Collection<TypeDecl> children = oldhost.childTypes();
		if(children.size() != 1)
			throw new RefactoringException("can only push down to exactly one subclass");
		TypeDecl child = children.iterator().next();
		if(!child.localMethodsSignature(signature()).isEmpty())
			throw new RefactoringException("method with that signature already exists");
		AdjustmentTable table = findEndangeredMethodAccesses(name());
		lockAll(table);
		moveTo(child);
		if(oldhost.isInterfaceDecl() && !child.isInterfaceDecl())
			makePublicAbstract();
		programRoot().flushCaches();
		table.adjust();
	}
	
	// move a method decl to a new type; convenience method that is
	// refined in Undo.jadd
	private void MethodDecl.moveTo(TypeDecl target) {
		hostType().removeBodyDecl(this);
		target.addBodyDecl(this);
	}
	
	// make a method public and abstract; convenience method that is
	// refined in Undo.jadd
    private void MethodDecl.makePublicAbstract() {
    	getModifiers().addModifier(new Modifier("public"));
    	getModifiers().addModifier(new Modifier("abstract"));
	}
	
	// lock everything that can be locked in this AST node and its children
	public void ASTNode.lockAll(AdjustmentTable table) {
        for(int i = 0; i < getNumChildNoTransform(); i++) {
          ASTNode node = getChildNoTransform(i);
          if(node != null) 
        	  node.lockAll(table);
        }
	}
	
	public void LockableAccess.lockAll(AdjustmentTable table) {
		table.add(this);
		super.lockAll(table);
	}
	
	
}
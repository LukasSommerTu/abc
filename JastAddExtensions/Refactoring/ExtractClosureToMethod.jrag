aspect ExtractClosureToMethod {
	public MethodDecl ClosureInvocation.extractToMethod(String visibility, String name) throws RefactoringException {
		return new ExtractClosureToMethodRefactoring(this, visibility, name).execute();
	}

	class ExtractClosureToMethodRefactoring {
		private ClosureInvocation closure;
		private String visibility;
		private String name;
		private BodyDecl bodydecl;
		private TypeDecl typedecl;
		private AdjustmentTable table;

		public ExtractClosureToMethodRefactoring(ClosureInvocation closure, String visibility, String name) {
			this.closure = closure;
			this.visibility = visibility;
			this.name = name;
			this.bodydecl = closure.hostBodyDecl();
			this.typedecl = bodydecl.hostType();
			this.table = new AdjustmentTable(typedecl.programRoot());
		}

		public MethodDecl execute() throws RefactoringException {
			closure.eliminateOutParams();
			List<TypeVariable> tvars = bindTypeVariableUses();
			closure.lockAllAccesses(table);
			MethodDecl md = 
				tvars.getNumChild() == 0 ?
						new MethodDecl(modifiers(),
									   closure.getReturnType(), 
									   name, 
									   closure.getParameters(),  // there are no out or ref parameters anymore! 
									   closure.getExceptions(), 
									   new Opt(closure.getBlock()))
					:
						new GenericMethodDecl(modifiers(),
									   closure.getReturnType(),
									   name,
									   closure.getParameters(),
									   closure.getExceptions(),
									   new Opt(closure.getBlock()),
									   tvars);
			int index = typedecl.getBodyDeclList().getIndexOfChild(closure.hostBodyDecl());
			assert(index!=-1);
			typedecl.addMethod(index+1, md, false, false, false);
			MethodAccess ma = md.getLockedAccess(table, closure.getArgList());
			closure.replaceWith(ma);
			typedecl.programRoot().flushCaches();
			table.adjust();
			return md;
		}

		private Modifiers modifiers() {
			List<Modifier> mods = new List<Modifier>();
			mods.add(new Modifier(visibility));
			if(closure.inStaticContext() || closure.inExplicitConstructorInvocation())
				mods.add(new Modifier("static"));
			return new Modifiers(mods);
		}
		
		// return the list of type variables of the surrounding body declaration; empty list
		// if the body declaration is not a generic callable
		private List<TypeVariable> getTypeVariables() {
			if(bodydecl instanceof GenericMethodDecl)
				return ((GenericMethodDecl)bodydecl).getTypeParameters();
			else if(bodydecl instanceof GenericConstructorDecl)
				return ((GenericConstructorDecl)bodydecl).getTypeParameters();
			return new List<TypeVariable>();
		}
		
		// duplicate the list of type variables, and lock all uses of the old type variables
		// onto the new variables
		// otherwise uses of the type variables in the extracted method will be unable to
		// access their target, resulting in unnecessary rejections
		private List<TypeVariable> bindTypeVariableUses() {
			List<TypeVariable> oldvars = getTypeVariables();
			List<TypeVariable> newvars = new List<TypeVariable>();
			for(TypeVariable tv : oldvars) {
				TypeVariable newvar = (TypeVariable)tv.fullCopy();
				newvars.add(newvar);
				for(TypeAccess acc : tv.uses())
					acc.lockOn(newvar);
			}
			return newvars;
		}
	}
	
	inh boolean ClosureInvocation.inExplicitConstructorInvocation();

	public MethodAccess MethodDecl.getLockedAccess(AdjustmentTable table, List<Expr> args) {
		MethodAccess ma = new MethodAccess(name(), args);
		ma.lockOn(this);
		table.add(ma);
		return ma;
	}
}
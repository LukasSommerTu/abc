aspect ExtractClosureToMethod {
	public void ClosureInvocation.extractToMethod(String visibility, String name) throws RefactoringException {
		new ExtractClosureToMethodRefactoring(this, visibility, name).execute();
	}

	class ExtractClosureToMethodRefactoring {
		private ClosureInvocation closure;
		private String visibility;
		private String name;
		private BodyDecl bodydecl;
		private TypeDecl typedecl;
		private AdjustmentTable table;

		public ExtractClosureToMethodRefactoring(ClosureInvocation closure, String visibility, String name) {
			this.closure = closure;
			this.visibility = visibility;
			this.name = name;
			this.bodydecl = closure.hostBodyDecl();
			this.typedecl = bodydecl.hostType();
			this.table = new AdjustmentTable();
		}

		public void execute() throws RefactoringException {
			closure.eliminateOutParams();
			closure.lockAllAccesses(table);
			MethodDecl md = 
				new MethodDecl(modifiers(),
						closure.getReturnType(), 
						name, 
						closure.getParameters(),  // there are no out or ref parameters anymore! 
						closure.getExceptions(), 
						new Opt(closure.getBlock()));
			int index = typedecl.getBodyDeclList().getIndexOfChild(closure.hostBodyDecl());
			assert(index!=-1);
			typedecl.addMethod(index+1, md, false, false, false);
			MethodAccess ma = md.getLockedAccess(table, closure.getArgList());
			closure.replaceWith(ma);
			typedecl.programRoot().flushCaches();
			table.adjust();
		}

		private Modifiers modifiers() {
			List<Modifier> mods = new List<Modifier>();
			mods.add(new Modifier(visibility));
			if(closure.inStaticContext())
				mods.add(new Modifier("static"));
			return new Modifiers(mods);
		}
	}

	public MethodAccess MethodDecl.getLockedAccess(AdjustmentTable table, List<Expr> args) {
		MethodAccess ma = new MethodAccess(name(), args);
		ma.lockOn(this);
		table.add(ma);
		return ma;
	}
}
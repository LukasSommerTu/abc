// some very simple dataflow analyses

aspect Dataflow {
	
	// liveness analysis
	syn boolean ASTNode.live(LocalDeclaration decl) circular [false];
	
	// standard backward propagation code
	eq ASTNode.live(LocalDeclaration decl) {
		for(ASTNode n : succ())
			if(n.live(decl))
				return true;
		return false;
	}
	
	// the actual meat of the definition
	eq VariableDeclaration.live(LocalDeclaration decl) {
		if(this == decl && hasInit())
			return false;
		return super.live(decl);
	}
	
	eq VarAccess.live(LocalDeclaration decl) {
		if(decl() == decl) {
			if(isSource())
				return true;
			if(isDest())
				return false;
		}
		return super.live(decl);
	}
	
	// this is to catch references to local variables from the enclosing scope
	// made in anonymous and local classes -- not too elegant...
	eq TypeDecl.live(LocalDeclaration decl) {
		for(BodyDecl bd : getBodyDecls())
			if(bd.entry().live(decl))
				return true;
		return super.live(decl);
	}
	
	// p.mayDefBefore(x, q): check whether there is a path from p to q
	// containing a definition of x
	syn boolean ASTNode.mayDefBefore(LocalDeclaration decl, ASTNode target) circular [false];
	
	// propagation
	eq ASTNode.mayDefBefore(LocalDeclaration decl, ASTNode target) {
		if(this == target)
			return false;
		for(ASTNode n : succ())
			if(n.mayDefBefore(decl, target))
				return true;
		return false;
	}
	
	eq VariableDeclaration.mayDefBefore(LocalDeclaration decl, ASTNode target) {
		if(this == decl && hasInit())
			return reachable(target);
		return super.mayDefBefore(decl, target);
	}
	
	eq VarAccess.mayDefBefore(LocalDeclaration decl, ASTNode target) {
		if(decl() == decl && isDest())
			return reachable(target);
		return super.mayDefBefore(decl, target);
	}
	
	// p.reachable(q): check whether there is a path from p to q
	syn boolean ASTNode.reachable(ASTNode target) circular [false];
	
	eq ASTNode.reachable(ASTNode target) {
		if(this == target)
			return true;
		for(ASTNode n : succ())
			if(n.reachable(target))
				return true;
		return false;
	}
	
	// data flow predecessors
	public SmallSet<ASTNode> VarAccess.dataPred() {
		if(!(decl() instanceof LocalDeclaration))
			return null;
		if(!isSource())
			return SmallSet.empty();
		// we don't want the node to be its own data flow predecessor
		SmallSet<ASTNode> result = SmallSet.empty();
		for(ASTNode pred : pred())
			result = result.union(pred.dataPredFor(this));
		return result;
	}

	syn SmallSet<ASTNode> ASTNode.dataPredFor(VarAccess var)
		circular [SmallSet.empty()];
	
	eq ASTNode.dataPredFor(VarAccess var) {
		SmallSet<ASTNode> result = SmallSet.empty();
		for(ASTNode pred : pred())
			result = result.union(pred.dataPredFor(var));
		return result;
	}

	eq VarAccess.dataPredFor(VarAccess var) {
		if(decl() == var.decl())
			if(isDest())
				return singleNode(this);
		return super.dataPredFor(var);
	}
	
	eq VariableDeclaration.dataPredFor(VarAccess var) {
		if(this == var.decl())
			if(hasInit() || getParent() instanceof EnhancedForStmt)
				return singleNode(this);
			else
				return SmallSet.empty();
		return super.dataPredFor(var);
	}

	eq ParameterDeclaration.dataPredFor(VarAccess var) {
		if(this == var.decl())
			return singleNode(this);
		return super.dataPredFor(var);
	}

	// data flow successors
	public SmallSet<VarAccess> VarAccess.dataSucc() {
		if(!(decl() instanceof LocalDeclaration))
			return null;
		if(!isDest())
			return SmallSet.empty();
		LocalDeclaration decl = (LocalDeclaration)decl();
		// we don't want the node to be its own data flow successor, so we have
		// to skip past it to its successors
		SmallSet<VarAccess> result = SmallSet.empty();
		for(ASTNode succ : succ())
			result = result.union(succ.dataSuccFor(decl));
		return result;
	}

	syn SmallSet<VarAccess> ASTNode.dataSuccFor(LocalDeclaration decl) 
			circular [SmallSet.empty()] {
		SmallSet<VarAccess> result = SmallSet.empty();
		for(ASTNode succ : succ())
			result = result.union(succ.dataSuccFor(decl));
		return result;
	}

	eq VarAccess.dataSuccFor(LocalDeclaration decl) {
		if(decl() == decl) {
			SmallSet<VarAccess> gen = SmallSet.empty();
			if(isSource())
				gen = gen.union(this);
			return isDest() ? gen : gen.union(super.dataSuccFor(decl));
		}
		return super.dataSuccFor(decl);
	}

	// v.hasDataPredBefore(n): is there some data predecessor p for v such that
	// n is encountered along the path from v back to p?
	public boolean VarAccess.hasDataPredBefore(ASTNode n) {
		if(!(decl() instanceof LocalDeclaration) || !isSource())
			return false;
		// we don't want the node to be its own data flow predecessor
		for(ASTNode pred : pred())
			if(pred.hasDataPredBefore(this, n))
				return true;
		return false;
	}

	syn boolean ASTNode.hasDataPredBefore(VarAccess var, ASTNode n)
		circular [false] {
		if(this == n)
			return !dataPredFor(var).isEmpty();
		for(ASTNode pred : pred())
			if(pred.hasDataPredBefore(var, n))
				return true;
		return false;
	}

	eq VarAccess.hasDataPredBefore(VarAccess var, ASTNode n) {
		if(this == n)
			return !dataPredFor(var).isEmpty();
		if(decl() == var.decl())
			if(isDest())
				return false;
		return super.hasDataPredBefore(var, n);
	}
	
	eq VariableDeclaration.hasDataPredBefore(VarAccess var, ASTNode n) {
		if(this == n)
			return !dataPredFor(var).isEmpty();
		if(this == var.decl())
			return false;
		return super.hasDataPredBefore(var, n);
	}

	eq ParameterDeclaration.hasDataPredBefore(VarAccess var, ASTNode n) {
		if(this == n)
			return !dataPredFor(var).isEmpty();
		if(this == var.decl())
			return false;
		return super.hasDataPredBefore(var, n);
	}
	
	// p.hasDataSuccAfter(n): is there a path from p to one of its data successors such
	// that n occurs on the path?
	public boolean VarAccess.hasDataSuccAfter(ASTNode n) {
		if(!(decl() instanceof LocalDeclaration) || !isDest())
			return false;
		LocalDeclaration decl = (LocalDeclaration)decl();
		// we don't want the node to be its own data flow successor, so we have
		// to skip past it to its successors
		for(ASTNode succ : succ())
			if(succ.hasDataSuccAfter(decl, n))
				return true;
		return false;
	}

	syn boolean ASTNode.hasDataSuccAfter(LocalDeclaration decl, ASTNode n) 
			circular [false] {
		if(this == n)
			return !dataSuccFor(decl).isEmpty();
		for(ASTNode succ : succ())
			if(succ.hasDataSuccAfter(decl, n))
				return true;
		return false;
	}

	eq VarAccess.hasDataSuccAfter(LocalDeclaration decl, ASTNode n) {
		if(this == n)
			return !dataSuccFor(decl).isEmpty();
		if(decl() == decl && isDest())
			return false;
		return super.hasDataSuccAfter(decl, n);
	}

	// checks if a subtree may reference a variable in any way
	public boolean ASTNode.mayRef(Variable v) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null && child.mayRef(v))
				return true;
		}
		return false;
	}

	public boolean VarAccess.mayRef(Variable v) {
		return decl() == v;
	}
	
	// extend the adjustment table to keep track of dataflow
	private Map<VarAccess, SmallSet<ASTNode>> AdjustmentTable.dpreds;
	private Map<VarAccess, SmallSet<VarAccess>> AdjustmentTable.dsuccs;

	refine ControlFlow public AdjustmentTable.AdjustmentTable() {
		refined();
		dpreds = new HashMap<VarAccess, SmallSet<ASTNode>>();
		dsuccs = new HashMap<VarAccess, SmallSet<VarAccess>>();
	}

	public void AdjustmentTable.addDataflow(VarAccess v) {
		dpreds.put(v, v.dataPred());
		dsuccs.put(v, v.dataSucc());
	}

	refine WrapBlockIntoClosure public void AdjustmentTable.adjust() throws RefactoringException {
		refined();
		for(VarAccess node : dpreds.keySet()) {
			if(!dpreds.get(node).equals(node.dataPred())) {
				SmallSet<ASTNode> oldpred = dpreds.get(node);
				SmallSet<ASTNode> newpred = node.dataPred();
				throw new RefactoringException("Could not preserve dflow into "+node);
			}
			if(!dsuccs.get(node).equals(node.dataSucc())) {
				SmallSet<VarAccess> oldsucc = dsuccs.get(node);
				SmallSet<VarAccess> newsucc = node.dataSucc();
				throw new RefactoringException("Could not preserve dflow out of "+node);
			}
		}
	}

	// lock all DFlow in a subtree (only local var accesses, complain about field accesses and methods)
	public void ASTNode.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		for(int i = 0; i < getNumChildNoTransform(); i++) {
			ASTNode node = getChildNoTransform(i);
			if(node != null) 
				node.lockAllDFlow(table);
		}
	}

	public void VarAccess.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		if(!(decl() instanceof LocalDeclaration))
			throw new RefactoringException("cannot handle dataflow for non-local variables");
		super.lockAllDFlow(table);
		table.addDataflow(this);
	}

	public void MethodAccess.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		throw new RefactoringException("cannot handle dataflow for method calls");
	}

	public void ClassInstanceExpr.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		throw new RefactoringException("cannot handle dataflow for constructors");
	}

	// lock all accesses and all dflow in a subtree
	public ASTNode ASTNode.copyAndLockWithDFlow(AdjustmentTable table) throws RefactoringException {
		ASTNode parent = getParent();
		int idx = parent.getIndexOfChild(this);
		ASTNode copy = copyAndLock(table);
		parent.setChild(copy, idx);
		copy.lockAllDFlow(table);
		parent.setChild(this, idx);
		return copy;
	}
	
}
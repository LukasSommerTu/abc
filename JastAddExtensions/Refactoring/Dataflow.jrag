// some very simple dataflow analyses

aspect Dataflow {
  public SmallSet<ASTNode> VarAccess.reachingDefinitions() {
    if(!(decl() instanceof LocalDeclaration))
      return SmallSet.empty();
    LocalDeclaration decl = (LocalDeclaration)decl();
    if(isSource()) {
      SmallSet<ASTNode> result = SmallSet.empty();
      for(CFGNode pred : pred())
	result = result.union(pred.reachingDefinitions(decl));
      return result;
    } else {
      return SmallSet.empty();
    }
  }

  coll SmallSet<CFGNode> CFGNode.reachedUses() [SmallSet.mutable()] 
    with add root BodyDecl;
  VarAccess contributes this to CFGNode.reachedUses() for each reachingDefinitions();
  /*
  /////////////////////////////////////////////////////////////////
  interface VarDef {
    Variable decl();
  }
  VarAccess implements VarDef;
  VariableDeclaration implements VarDef;

  public Variable VariableDeclaration.decl() { return this; }

  syn java.util.Set<VarDef> CFGNode.allReachingDefinitions() 
    circular [new java.util.HashSet<VarDef>()] {
    java.util.Set<VarDef> result = new java.util.HashSet();
    for(CFGNode pred : pred())
      result.addAll(pred.allReachingDefinitions());
    return result;
  }

  eq VarAccess.allReachingDefinitions() {
    java.util.Set<VarDef> result = super.allReachingDefinitions();
    if(isDest())
      for(Iterator<VarDef> iter = result.iterator(); iter.hasNext();)
	if(iter.next().decl() == this.decl())
	  iter.remove();
    result.add(this);
    return result;
  }

  eq VariableDeclaration.allReachingDefinitions() {
    java.util.Set<VarDef> result = super.allReachingDefinitions();
    if(hasInit())
      for(Iterator<VarDef> iter = result.iterator(); iter.hasNext();)
	if(iter.next().decl() == this)
	  iter.remove();
    result.add(this);
    return result;
    }*/

  //SmallSet<ASTNode> CFGNode.reachingDefinitions(LocalDeclaration v);

  syn SmallSet<ASTNode> ASTNode.reachingDefinitions(LocalDeclaration v) 
    circular [SmallSet.empty()] {
    return SmallSet.empty();
  }

  eq CFGNode.reachingDefinitions(LocalDeclaration v) {
    SmallSet<ASTNode> result = SmallSet.empty();
    for(CFGNode pred : pred())
      result = result.union(pred.reachingDefinitions(v));
    return result;
  }

  eq VarAccess.reachingDefinitions(LocalDeclaration v) {
    if(decl() == v && isDest())
      return SmallSet.singleton((ASTNode)this);
    return super.reachingDefinitions(v);
  }

  eq VariableDeclaration.reachingDefinitions(LocalDeclaration v) {
    if(this == v && hasInit())
      return SmallSet.singleton((ASTNode)this);
    return super.reachingDefinitions(v);
  }

  eq ParameterDeclaration.reachingDefinitions(LocalDeclaration v) {
    if(this == v)
      return SmallSet.singleton((ASTNode)this);
    return super.reachingDefinitions(v);
  }

  public boolean ASTNode.mayRef(Variable v) {
    for(int i=0;i<getNumChild();++i) {
      ASTNode child = getChild(i);
      if(child != null && child.mayRef(v))
	return true;
    }
    return false;
  }

  public boolean VarAccess.mayRef(Variable v) {
    return decl() == v;
  }
}
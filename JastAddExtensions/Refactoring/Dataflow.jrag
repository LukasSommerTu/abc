// some very simple dataflow analyses

aspect Dataflow {

	// data flow predecessors
	public SmallSet<CFGNode> VarAccess.dataPred() {
		if(!(decl() instanceof LocalDeclaration))
			return null;
		if(!isSource())
			return SmallSet.empty();
		// we don't want the node to be its own data flow predecessor
		SmallSet<CFGNode> result = SmallSet.empty();
		for(CFGNode pred : pred())
			result = result.union(pred.dataPredFor(this));
		return result;
	}

	syn SmallSet<CFGNode> CFGNode.dataPredFor(VarAccess var)
		circular [SmallSet.empty()];
	
	// account for variable references in local classes
	// note that since such variables must be final, they can only have been defined in
	// the surrounding method (not, for instance, in an initializer of the local class)
	// for the same reason, we don't need to worry about this kind of thing in the
	// dataSucc() computation below
	eq EntryStmt.dataPredFor(VarAccess var) {
		TypeDecl host = hostType();
		if(host.isAnonymous() || host.isLocalClass())
			return ((CFGNode)host.getParent()).dataPredFor(var);
		return SmallSet.empty();
	}

	eq Stmt.dataPredFor(VarAccess var) {
		SmallSet<CFGNode> result = SmallSet.empty();
		for(CFGNode pred : pred())
			result = result.union(pred.dataPredFor(var));
		return result;
	}

	// just a duplicate of the above; this is unfortunate but necessary
	// we cannot give an equation for CFGNode.dataPredFor, since we
	// then couldn't override it for ParameterDeclaration below
	eq Expr.dataPredFor(VarAccess var) {
		SmallSet<CFGNode> result = SmallSet.empty();
		for(CFGNode pred : pred())
			result = result.union(pred.dataPredFor(var));
		return result;
	}

	eq VarAccess.dataPredFor(VarAccess var) {
		if(decl() == var.decl())
			if(isDest())
				return SmallSet.singleton((CFGNode)this);
		return super.dataPredFor(var);
	}
	
	eq VariableDeclaration.dataPredFor(VarAccess var) {
		if(this == var.decl())
			if(hasInit() || getParent() instanceof EnhancedForStmt)
				return SmallSet.singleton((CFGNode)this);
			else
				return SmallSet.empty();
		return super.dataPredFor(var);
	}

	eq ParameterDeclaration.dataPredFor(VarAccess var) {
		if(this == var.decl())
			return SmallSet.singleton((CFGNode)this);
		// unfortunately, we can't just call super.dataPredFor(decl) here,
		// so we copy again...
		SmallSet<CFGNode> result = SmallSet.empty();
		for(CFGNode pred : pred())
			result = result.union(pred.dataPredFor(var));
		return result;
	}

	// data flow successors
	public SmallSet<VarAccess> VarAccess.dataSucc() {
		if(!(decl() instanceof LocalDeclaration))
			return null;
		if(!isDest())
			return SmallSet.empty();
		LocalDeclaration decl = (LocalDeclaration)decl();
		// we don't want the node to be its own data flow successor, so we have
		// to skip past it to its successors
		SmallSet<VarAccess> result = SmallSet.empty();
		for(CFGNode succ : succ())
			result = result.union(succ.dataSuccFor(decl));
		return result;
	}

	syn SmallSet<VarAccess> CFGNode.dataSuccFor(LocalDeclaration decl) 
			circular [SmallSet.empty()] {
		SmallSet<VarAccess> result = SmallSet.empty();
		for(CFGNode succ : succ())
			result = result.union(succ.dataSuccFor(decl));
		return result;
	}

	eq VarAccess.dataSuccFor(LocalDeclaration decl) {
		if(decl() == decl) {
			SmallSet<VarAccess> gen = SmallSet.empty();
			if(isSource())
				gen = gen.union(this);
			return isDest() ? gen : gen.union(super.dataSuccFor(decl));
		}
		return super.dataSuccFor(decl);
	}

	// checks if a subtree may reference a variable in any way
	public boolean ASTNode.mayRef(Variable v) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null && child.mayRef(v))
				return true;
		}
		return false;
	}

	public boolean VarAccess.mayRef(Variable v) {
		return decl() == v;
	}

	private Map<VarAccess, SmallSet<CFGNode>> AdjustmentTable.dpreds;
	private Map<VarAccess, SmallSet<VarAccess>> AdjustmentTable.dsuccs;

	refine ControlFlow public AdjustmentTable.AdjustmentTable() {
		refined();
		dpreds = new HashMap<VarAccess, SmallSet<CFGNode>>();
		dsuccs = new HashMap<VarAccess, SmallSet<VarAccess>>();
	}

	public void AdjustmentTable.addDataflow(VarAccess v) {
		dpreds.put(v, v.dataPred());
		dsuccs.put(v, v.dataSucc());
	}

	refine WrapBlockIntoClosure public void AdjustmentTable.adjust() throws RefactoringException {
		refined();
		for(VarAccess node : dpreds.keySet()) {
			if(!dpreds.get(node).equals(node.dataPred())) {
				SmallSet<CFGNode> oldpred = dpreds.get(node);
				SmallSet<CFGNode> newpred = node.dataPred();
				throw new RefactoringException("Could not preserve dflow into "+node);
			}
			if(!dsuccs.get(node).equals(node.dataSucc())) {
				SmallSet<VarAccess> oldsucc = dsuccs.get(node);
				SmallSet<VarAccess> newsucc = node.dataSucc();
				throw new RefactoringException("Could not preserve dflow out of "+node);
			}
		}
	}

	// lock all DFlow in a subtree (only local var accesses, complain about field accesses and methods)
	public void ASTNode.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		for(int i = 0; i < getNumChildNoTransform(); i++) {
			ASTNode node = getChildNoTransform(i);
			if(node != null) 
				node.lockAllDFlow(table);
		}
	}

	public void VarAccess.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		if(!(decl() instanceof LocalDeclaration))
			throw new RefactoringException("cannot handle dataflow for non-local variables");
		super.lockAllDFlow(table);
		table.addDataflow(this);
	}

	public void MethodAccess.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		throw new RefactoringException("cannot handle dataflow for method calls");
	}

	public void ClassInstanceExpr.lockAllDFlow(AdjustmentTable table) throws RefactoringException {
		throw new RefactoringException("cannot handle dataflow for constructors");
	}

	// lock all accesses and all dflow in a subtree
	public ASTNode ASTNode.copyAndLockWithDFlow(AdjustmentTable table) throws RefactoringException {
		ASTNode parent = getParent();
		int idx = parent.getIndexOfChild(this);
		ASTNode copy = copyAndLock(table);
		parent.setChild(copy, idx);
		copy.lockAllDFlow(table);
		parent.setChild(this, idx);
		return copy;
	}
	
}
// some very simple dataflow analyses

aspect Dataflow {

  // data flow predecessors
  public SmallSet<CFGNode> VarAccess.dataPred() {
    if(!(decl() instanceof LocalDeclaration))
      return null;
    if(!isSource())
      return SmallSet.empty();
    LocalDeclaration decl = (LocalDeclaration)decl();
    // we don't want the node to be its own data flow predecessor
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode pred : pred())
      result = result.union(pred.dataPredFor(decl));
    return result;
  }

  syn SmallSet<CFGNode> CFGNode.dataPredFor(LocalDeclaration decl)
    circular [SmallSet.empty()];

  eq Stmt.dataPredFor(LocalDeclaration decl) {
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode pred : pred())
      result = result.union(pred.dataPredFor(decl));
    return result;
  }

  // just a duplicate of the above; this is unfortunate but necessary
  // we cannot give an equation for CFGNode.dataPredFor, since we
  // then couldn't override it for ParameterDeclaration below
  eq Expr.dataPredFor(LocalDeclaration decl) {
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode pred : pred())
      result = result.union(pred.dataPredFor(decl));
    return result;
  }

  eq VarAccess.dataPredFor(LocalDeclaration decl) {
    if(decl() == decl)
      if(isDest())
	return SmallSet.singleton((CFGNode)this);
    return super.dataPredFor(decl);
  }

  eq VariableDeclaration.dataPredFor(LocalDeclaration decl) {
    if(this == decl)
      if(hasInit())
	return SmallSet.singleton((CFGNode)this);
      else
	return SmallSet.empty();
    return super.dataPredFor(decl);
  }

  eq ParameterDeclaration.dataPredFor(LocalDeclaration decl) {
    if(this == decl)
      return SmallSet.singleton((CFGNode)this);
    // unfortunately, we can't just call super.dataPredFor(decl) here,
    // so we copy again...
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode pred : pred())
      result = result.union(pred.dataPredFor(decl));
    return result;
  }

  // data flow successors
  public SmallSet<CFGNode> VarAccess.dataSucc() {
    if(!(decl() instanceof LocalDeclaration))
      return null;
    if(!isDest())
      return SmallSet.empty();
    LocalDeclaration decl = (LocalDeclaration)decl();
    // we don't want the node to be its own data flow successor, so we have
    // to skip past it to its successors
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode succ : succ())
      result = result.union(succ.dataSuccFor(decl));
    return result;
  }

  syn SmallSet<CFGNode> CFGNode.dataSuccFor(LocalDeclaration decl) 
    circular [SmallSet.empty()] {
    SmallSet<CFGNode> result = SmallSet.empty();
    for(CFGNode succ : succ())
      result = result.union(succ.dataSuccFor(decl));
    return result;
  }

  eq VarAccess.dataSuccFor(LocalDeclaration decl) {
    if(decl() == decl) {
      SmallSet<CFGNode> gen = SmallSet.empty();
      if(isSource())
	gen = gen.union((CFGNode)this);
      return isDest() ? gen : gen.union(super.dataSuccFor(decl));
    }
    return super.dataSuccFor(decl);
  }

  public boolean ASTNode.mayRef(Variable v) {
    for(int i=0;i<getNumChild();++i) {
      ASTNode child = getChild(i);
      if(child != null && child.mayRef(v))
	return true;
    }
    return false;
  }

  public boolean VarAccess.mayRef(Variable v) {
    return decl() == v;
  }
}
/*
 * some utility methods
 */

aspect ASTUtil {
	
	// some convenience methods to index children by reference instead of numeric index
	public void ASTNode.removeChild(ASTNode child) {
		removeChild(getIndexOfChild(child));
	}

	public void Block.removeStmt(Stmt stmt) {
		getStmtList().removeChild(stmt);
	}

	public void Block.removeStmt(int idx) {
		getStmtList().removeChild(idx);
	}

	public void TypeDecl.removeBodyDecl(BodyDecl bd) {
		getBodyDeclList().removeChild(getBodyDeclList().getIndexOfChild(bd));
	}

	// provide access to the program root
	public Program ASTNode.programRoot() {
		ASTNode p;
		for(p=this; p!=null&&!(p instanceof Program); p=p.getParent());
		if(p == null) return null;
		return (Program)p;
	}
	
	// provide access to the enclosing compilation unit
	public CompilationUnit ASTNode.compilationUnit() {
		ASTNode p;
		for(p=this; p!=null&&!(p instanceof CompilationUnit); p=p.getParent());
		if(p == null) return null;
		return (CompilationUnit)p;
	}
	
	inh SimpleSet ParameterDeclaration.lookupType(String name);
	
	// clear all attribute values in this subtree to force reevaluation of attributes after destructive updates
	public void ASTNode.flushCaches() {
		flushCache();
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).flushCaches();
	}
	
	// no need to flush library compilation units
	public void CompilationUnit.flushCaches() {
		if(fromSource())
			super.flushCaches();
	}
	
    public void FieldDeclaration.makePrivate() throws RefactoringException {
        if(isPrivate())
            return;
        Modifiers m = getModifiers();
        for(int i=0;i<m.getNumModifier();++i) {
            String id = m.getModifier(i).getID();
            if(id.equals("protected") || id.equals("public")) {
                m.setModifier(new Modifier("private"), i);
                return;
            }
        }
        m.addModifier(new Modifier("private"));
    }
    
    protected void ASTNode.replaceWith(ASTNode newnode) throws RefactoringException {
    	ASTNode parent = getParent();
    	parent.setChild(newnode, parent.getIndexOfChild(this));
    }
    
    public void ASTNode.moveChild(int src, int trg) {
    	ASTNode tmp = children[src];
    	children[src] = children[trg];
    	children[src].childIndex = src;
    	children[trg] = tmp;
    	children[trg].childIndex = trg;
    }
    
    public void Block.insertStmt(int idx, Stmt stmt) throws RefactoringException {
    	getStmtList().insertChild(stmt, idx);
    }
    
    public void Block.moveStmt(Stmt stmt, int new_idx) throws RefactoringException {
    	int old_idx = getStmtList().getIndexOfChild(stmt);
    	getStmtList().moveChild(old_idx, new_idx);
    }
    
	public String CompilationUnit.getID() {
	    char pathsep = File.separatorChar;
	    String path = pathName();
	    int i = path.lastIndexOf(pathsep);
		String relname_tail = i == -1 ? path : path.substring(i+1);
	    int j = relname_tail.lastIndexOf(".");
	    return relname_tail.substring(0, j);	 		
	}
		
	public static String ASTNode.capitalize(String str) {
		StringBuffer buf = new StringBuffer(str);
		if(buf.length() > 0)
			buf.setCharAt(0, Character.toUpperCase(buf.charAt(0)));
		return buf.toString();
	}
	
}

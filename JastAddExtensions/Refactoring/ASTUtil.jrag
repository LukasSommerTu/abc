/*
 * some utility methods
 */

aspect ASTUtil {
	
	public static boolean ASTNode.isSingletonOf(SimpleSet s, Object o) {
		return s.size() == 1 && s.iterator().next() == o;
	}
	
	// provide access to the program root
	eq Program.getChild().programRoot() = this;
	inh Program ASTNode.programRoot();
	
	// provide access to the enclosing compilation unit
	eq CompilationUnit.getChild().compilationUnit() = this;
	inh CompilationUnit TypeDecl.compilationUnit();
	
	inh SimpleSet ParameterDeclaration.lookupType(String name);
	
	// clear all attribute values in this subtree to force reevaluation of attributes after destructive updates
	public void ASTNode.clear() {
		flushCache();
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).clear();
	}
	
	public void TypeDecl.removeBodyDecl(BodyDecl bd) {
		getBodyDeclList().removeChild(getBodyDeclList().getIndexOfChild(bd));
	}

    public void FieldDeclaration.makePrivate() {
        if(isPrivate())
            return;
        Modifiers m = getModifiers();
        for(int i=0;i<m.getNumModifier();++i) {
            String id = m.getModifier(i).getID();
            if(id.equals("protected") || id.equals("public")) {
                m.setModifier(new Modifier("private"), i);
                return;
            }
        }
        m.addModifier(new Modifier("private"));
    }
    
    protected void ASTNode.replaceWith(ASTNode newnode) {
    	ASTNode parent = getParent();
    	parent.setChild(newnode, parent.getIndexOfChild(this));
    }
    
    // this method is not very well-behaved if start and end are not valid indices
    protected void ASTNode.replaceRange(ASTNode node, int start, int end) {
        if(children == null) {
        	children = new ASTNode[1];
            children[0] = node;
        } else {
            ASTNode c[] = new ASTNode[children.length - (end-start)];
            System.arraycopy(children, 0, c, 0, start);
            c[start] = node;
            if(end+1 < children.length)
              System.arraycopy(children, end+1, c, start+1, children.length-end-1);
            children = c;
        }
        numChildren -= end-start;
        if(node != null) { node.setParent(this); node.childIndex = start; }
    }
    
    public void ASTNode.moveChild(int src, int trg) {
    	ASTNode tmp = children[src];
    	children[src] = children[trg];
    	children[src].childIndex = src;
    	children[trg] = tmp;
    	children[trg].childIndex = trg;
    }
    
    /*public void List.remove(ASTNode n) {
    	for(int i=0;i<getNumChild();++i)
    		if(getChild(i) == n) {
    			removeChild(i);
    			break;
    		}
    }*/
    
    public void Block.insertStmt(int idx, Stmt stmt) {
    	getStmtList().insertChild(stmt, idx);
    }
    
    public void Block.moveStmt(Stmt stmt, int new_idx) {
    	int old_idx = getStmtList().getIndexOfChild(stmt);
    	getStmtList().moveChild(old_idx, new_idx);
    }
    
    public void Block.pullTogether(int start, int end) {
    	List stmts = new List();
    	for(int i=start;i<=end;++i)
    		stmts.add(getStmt(i));
    	getStmtList().replaceRange(new Block(stmts), start, end);
    }

	public Collection List.toCollection() {
		Collection children = new ArrayList();
		for(int i=0;i<getNumChild();++i)
			children.add(getChild(i));
		return children;
	}
	
	public List.List(Collection c) {
		super();
		addAll(c);
	}
	
	public List List.addAll(Collection c) {
		for(Iterator i=c.iterator();i.hasNext();)
			add((ASTNode)i.next());
		return this;
	}
	
	public int ASTNode.indexIn(ASTNode n) {
		if(getParent() == n)
			return getParent().getIndexOfChild(this);
		if(getParent() == null)
			return -1;
		return getParent().indexIn(n);
	}
	
	public boolean ASTNode.inside(ASTNode n) {
		return indexIn(n) != -1;
	}
	
	public boolean Opt.isEmpty() {
		return getNumChild() == 0;
	}
	
	public String CompilationUnit.getID() {
	    char pathsep = File.separatorChar;
	    String path = pathName();
	    int i = path.lastIndexOf(pathsep);
		String relname_tail = i == -1 ? path : path.substring(i+1);
	    int j = relname_tail.lastIndexOf(".");
	    return relname_tail.substring(0, j);	 		
	}
		
	public static String FieldDeclaration.capitalize(String str) {
		StringBuffer buf = new StringBuffer(str);
		if(buf.length() > 0)
			buf.setCharAt(0, Character.toUpperCase(buf.charAt(0)));
		return buf.toString();
	}
	
	public int ASTNode.height() {
		int ht = -1;
		for(int i=0;i<getNumChild();++i) {
			int childht = getChild(i).height();
			if(childht > ht) ht = childht;
		}
		return ht+1;
	}
	
	class HeightComparator implements Comparator {
		public int compare(Object o1, Object o2) {
			if(!(o1 instanceof ASTNode && o2 instanceof ASTNode))
				throw new IllegalArgumentException("cannot compare non-AST nodes for height");
			int ht1 = ((ASTNode)o1).height();
			int ht2 = ((ASTNode)o2).height();
			if(ht1 < ht2) return -1;
			if(ht1 == ht2) return 0;
			return 1;
		}
		public boolean equals(Object o1, Object o2) {
			return compare(o1,o2)==0;
		}
	}

}
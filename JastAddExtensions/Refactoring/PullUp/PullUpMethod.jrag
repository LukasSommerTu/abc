aspect PullUpMethod {
	public void MethodDecl.pullUp(boolean onlyAbstract) {
		if(!hostType().isClassDecl() || !hostType().fromSource() || !((ClassDecl)hostType()).superclass().fromSource())
			throw new RefactoringException("no fitting super class");
		ClassDecl host = (ClassDecl)hostType();
		ClassDecl sup = host.superclass();
		MethodDecl md = this;
		lockAllNames();
		removeSuper();
		translateTypeVars(host, sup);
		MethodDecl md_copy = (MethodDecl)fullCopyAndDetach();
		md.replaceWith(md_copy);
		programRoot().flushCaches();
		sup.insertUnusedMethod(md);
		if(onlyAbstract)
			md.makeAbstract();
		if(!md.isAbstract() || md_copy.isAbstract()) {
			// reroute uses of old method to new method
			for(MethodAccess ma : md_copy.uses())
				ma.lock(md);
			host.removeBodyDecl(md_copy);
		}
		programRoot().flushCaches();
		// check that everything went OK wrt types
		for(TypeConstraint typeConstraint : this.typeConstraints(Predicate.TRUE))
			if(!typeConstraint.solved())
				throw new RefactoringException("type constraint violated: " + typeConstraint);
	}
	
	public void MethodDecl.doPullUp(boolean onlyAbstract) {
		pullUp(onlyAbstract);
		programRoot().eliminate(LOCKED_NAMES);
	}
	
	public void MethodDecl.doPullUp() {
		doPullUp(false);
	}
	
	public void ASTNode.removeSuper() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).removeSuper();
	}
	
	public void TypeDecl.removeSuper() { }
	
	public void AbstractDot.removeSuper() {
		rotateLeft();
		if(getLeft().isSuperAccess() && !getRight().isMethodAccess())
			replaceWith(getRight());
		else
			super.removeSuper();
	}
}
aspect DataFlow {
	public void ASTNode.lockDataFlow() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).lockDataFlow();
	}
	
	protected SmallSet<Definition> Access.lockedReachingDefs = null;
	protected SmallSet<Access> Access.lockedReachedUses = null;
	protected SmallSet<Access> Access.lockedWriteDeps = null;
	
	public void Access.lockDataFlow() {
		if(lockedReachingDefs == null)
			lockedReachingDefs = reachingDefinitions();
		if(lockedReachedUses == null)
			lockedReachedUses = reachedUses();
		if(lockedWriteDeps == null)
			// we actually don't need to lock write dependences for local variables
			// (since for them we can see every write), but that is not implemented at the moment
			lockedWriteDeps = writeDeps();
		super.lockDataFlow();
	}
	
	// conservative approximation of data flow for method accesses
	MethodDecl implements Location;
	eq MethodAccess.getLocation() = decl();
	
	refine Alias public boolean Variable.mayAlias(Location l) {
		return l instanceof MethodDecl && (this.isClassVariable() || this.isInstanceVariable())
		    || refined(l);
	}
	
	refine Alias eq ArrayAccess.mayReferTo(Location l) = l instanceof MethodDecl || refined(l);
	
	public void ASTNode.unlockDataFlow() { }
	
	public void Access.unlockDataFlow() {
		if(hostBodyDecl() != null)
			hostBodyDecl().flushCollectionCache();
		if(lockedReachingDefs != null) {
			if(!reachingDefinitions().equals(lockedReachingDefs))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachingDefs = null;
		}
		if(lockedReachedUses != null) {
			if(!reachedUses().equals(lockedReachedUses))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachedUses = null;
		}
		if(lockedWriteDeps != null) {
			if(!writeDeps().equals(lockedWriteDeps))
				throw new RefactoringException("couldn't preserve data flow");
			lockedWriteDeps = null;
		}
	}
	
	public static LanguageExtension ASTNode.LOCKED_DATAFLOW = new LanguageExtension("locked data flow") {
		public ASTNode eliminateOn(ASTNode n) {
			n.unlockDataFlow();
			return n;
		}
	};
}
aspect DataFlow {
	public void ASTNode.lockDataFlow() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).lockDataFlow();
	}
	
	protected SmallSet<Definition> Access.lockedReachingDefs = null;
	protected SmallSet<Access> Access.lockedReachedUses = null;
	protected SmallSet<Definition> Access.lockedWriteDeps = null;
	
	public void Access.lockReachingDefsAndUses() {
		if(lockedReachingDefs == null)
			lockedReachingDefs = reachingDefinitions();
		if(lockedReachedUses == null)
			lockedReachedUses = reachedUses();
	}
	
	public void Access.lockWriteDeps() {
		if(lockedWriteDeps == null)
			lockedWriteDeps = writeDeps();
	}
	
	public void ArrayAccess.lockDataFlow() {
		lockReachingDefsAndUses();
		lockWriteDeps();
		super.lockDataFlow();
	}
	
	public void ClassInstanceExpr.lockDataFlow() {
		lockReachingDefsAndUses();
		lockWriteDeps();
		super.lockDataFlow();
	}
	
	public void ConstructorAccess.lockDataFlow() {
		lockReachingDefsAndUses();
		lockWriteDeps();
		super.lockDataFlow();
	}
	
	public void MethodAccess.lockDataFlow() {
		lockReachingDefsAndUses();
		lockWriteDeps();
		super.lockDataFlow();
	}
	
	public void VarAccess.lockDataFlow() {
		lockReachingDefsAndUses();
		if(decl().isField())
			lockWriteDeps();
		super.lockDataFlow();
	}
	
	// conservative approximation of data flow for method accesses
	MethodDecl implements Location;
	eq MethodAccess.getLocation() = decl();
	public boolean MethodDecl.isHeapLocation() { return true; }
	
	refine Alias public boolean Variable.mayAlias(Location l) {
		return l instanceof MethodDecl && (this.isClassVariable() || this.isInstanceVariable())
		    || refined(l);
	}
	
	refine Alias eq ArrayAccess.mayReferTo(Location l) = l instanceof MethodDecl || refined(l);
	
	public void ASTNode.unlockDataFlow() { }
	
	public void Access.unlockDataFlow() {
		if(hostType() != null)
			hostType().flushCollectionCache();
		if(lockedReachingDefs != null) {
			if(!reachingDefinitions().equals(lockedReachingDefs))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachingDefs = null;
		}
		if(lockedReachedUses != null) {
			if(!reachedUses().equals(lockedReachedUses))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachedUses = null;
		}
		if(lockedWriteDeps != null) {
			if(!writeDeps().equals(lockedWriteDeps))
				throw new RefactoringException("couldn't preserve data flow");
			lockedWriteDeps = null;
		}
	}
	
	public static LanguageExtension ASTNode.LOCKED_DATAFLOW = new LanguageExtension("locked data flow") {
		public ASTNode eliminateOn(ASTNode n) {
			n.unlockDataFlow();
			return n;
		}
	};
}
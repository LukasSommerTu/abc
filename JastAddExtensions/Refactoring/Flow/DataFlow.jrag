aspect DataFlow {
	public void ASTNode.lockDataFlow() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).lockDataFlow();
	}
	
	protected SmallSet<Definition> Access.lockedReachingDefs = null;
	protected SmallSet<Access> Access.lockedReachedUses = null;
	protected SmallSet<Access> Access.lockedWriteDeps = null;
	
	public void Access.lockDataFlow() {
		if(lockedReachingDefs == null)
			lockedReachingDefs = reachingDefinitions();
		if(lockedReachedUses == null)
			lockedReachedUses = reachedUses();
		if(lockedWriteDeps == null)
			// we actually don't need to lock write dependences for local variables
			// (since for them we can see every write), but that is not implemented at the moment
			lockedWriteDeps = writeDeps();
	}
	
	public void MethodAccess.lockDataFlow() {
		throw new RefactoringException("cannot preserve data flow for method invocations");
	}
	
	public void ASTNode.unlockDataFlow() { }
	
	public void Access.unlockDataFlow() {
		if(lockedReachingDefs != null) {
			if(!reachingDefinitions().equals(lockedReachingDefs))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachingDefs = null;
		}
		if(lockedReachedUses != null) {
			if(!reachedUses().equals(lockedReachedUses))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachedUses = null;
		}
		if(lockedWriteDeps != null) {
			if(!writeDeps().equals(lockedWriteDeps))
				throw new RefactoringException("couldn't preserve data flow");
			lockedWriteDeps = null;
		}
	}
	
	public static LanguageExtension ASTNode.LOCKED_DATAFLOW = new LanguageExtension("locked data flow") {
		public ASTNode eliminateOn(ASTNode n) {
			n.unlockDataFlow();
			return n;
		}
	};
}
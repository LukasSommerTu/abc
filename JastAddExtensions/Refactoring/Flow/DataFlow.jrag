aspect DataFlow {
	public static LanguageExtension ASTNode.LOCKED_DATAFLOW = new LanguageExtension("locked data flow");
	
	public void ASTNode.lockDataFlow() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).lockDataFlow();
	}
	
	public void ASTNode.unlockDataFlow() {
		for(int i=0;i<getNumChild();++i)
			getChild(i).unlockDataFlow();
	}
	
	protected SmallSet<Definition> Access.lockedReachingDefs = null;
	protected SmallSet<Access> Access.lockedReachedUses = null;
	protected SmallSet<Access> Access.lockedWriteDeps = null;
	
	public void Access.lockDataFlow() {
		if(lockedReachingDefs == null)
			lockedReachingDefs = reachingDefinitions();
		if(lockedReachedUses == null)
			lockedReachedUses = reachedUses();
		if(lockedWriteDeps == null)
			// we actually don't need to lock write dependences for local variables
			// (since for them we can see every write), but that is not implemented at the moment
			lockedWriteDeps = writeDeps();
	}
	
	public void Access.unlockDataFlow() {
		if(lockedReachingDefs != null) {
			if(!reachingDefinitions().equals(lockedReachingDefs))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachingDefs = null;
		}
		if(lockedReachedUses != null) {
			if(!reachedUses().equals(lockedReachedUses))
				throw new RefactoringException("couldn't preserve data flow");
			lockedReachedUses = null;
		}
		if(lockedWriteDeps != null) {
			if(!writeDeps().equals(lockedWriteDeps))
				throw new RefactoringException("couldn't preserve data flow");
			lockedWriteDeps = null;
		}
	}
	public void MethodAccess.unlockDataFlow() {
		throw new RefactoringException("cannot preserve data flow for method invocations");
	}
	
	public boolean Access.hasLockedDataFlow() {
		return lockedReachingDefs != null || lockedReachedUses != null || lockedWriteDeps != null;
	}
	
	rewrite Access {
		when(!hasExtension(LOCKED_DATAFLOW) && hasLockedDataFlow())
		to Access {
			unlockDataFlow();
			return this;
		}
	}
}
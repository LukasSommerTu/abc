aspect DependencyEdges {
	abstract class DependencyEdge {
		protected abstract boolean isStart(ASTNode node);
		protected abstract boolean isTarget(ASTNode start, ASTNode end);
		public abstract SmallSet<CFNode> collect(ASTNode start);
	}
	
	abstract class BackwardEdge extends DependencyEdge {
		public abstract boolean terminates(ASTNode start, ASTNode end);
		public SmallSet<CFNode> collect(ASTNode start) {
			if(!isStart(start))
				return SmallSet.<CFNode>empty();
			return start.collect(this, start);
		}
	}
	
	abstract class IrreflexiveBackwardEdge extends BackwardEdge {
		public SmallSet<CFNode> collect(ASTNode start) {
			if(!isStart(start))
				return SmallSet.<CFNode>empty();
			SmallSet<CFNode> res = SmallSet.<CFNode>empty();
			for(ASTNode p : (SmallSet<ASTNode>)start.pred())
				res = res.union(p.collect(this, start));
			return res;
		}
	}
	
	syn lazy SmallSet<CFNode> ASTNode.collect(BackwardEdge be, ASTNode start) 
		circular [SmallSet.<CFNode> empty()] {
		SmallSet<CFNode> res = be.isTarget(start, this) ? SmallSet.singleton((CFNode)this)
													  : SmallSet.<CFNode>empty();
		if(be.terminates(start, this))
			return res;
		for(ASTNode p : pred())
			res = res.union(p.collect(be, start));
		return res;
	}
	
	abstract class ForwardEdge extends DependencyEdge {
		public abstract boolean terminates(ASTNode start, ASTNode end);
		public SmallSet<CFNode> collect(ASTNode start) {
			if(!isStart(start))
				return SmallSet.<CFNode>empty();
			return start.collect(this, start);
		}
	}
	
	abstract class IrreflexiveForwardEdge extends ForwardEdge {
		public SmallSet<CFNode> collect(ASTNode start) {
			if(!isStart(start))
				return SmallSet.<CFNode>empty();
			SmallSet<CFNode> res = SmallSet.<CFNode>empty();
			for(ASTNode p : (SmallSet<ASTNode>)start.succ())
				res = res.union(p.collect(this, start));
			return res;
		}
	}
	
	syn lazy SmallSet<CFNode> ASTNode.collect(ForwardEdge fe, ASTNode start) 
		circular [SmallSet.<CFNode> empty()] {
		SmallSet<CFNode> res = fe.isTarget(start, this) ? SmallSet.singleton((CFNode)this)
												  	  : SmallSet.<CFNode>empty();
		if(fe.terminates(start, this))
			return res;
		for(ASTNode p : succ())
			res = res.union(p.collect(fe, start));
		return res;
	}

	class PreservationStrategy {
		private DependencyEdge edge;
		
		public PreservationStrategy(DependencyEdge edge) {
			this.edge = edge;
		}
		
		public DependencyEdge getEdge() {
			return edge;
		}
		
		public boolean preserve(ASTNode n) { return true; }
		public boolean reflect(ASTNode n) { return true; }
	}
	
	private IdentityHashMap<DependencyEdge, SmallSet<CFNode>> ASTNode.dependencies = null;
	private IdentityHashMap<DependencyEdge, SmallSet<CFNode>> ASTNode.getDependencies() {
		if(dependencies == null)
			dependencies = new IdentityHashMap<DependencyEdge, SmallSet<CFNode>>();
		return dependencies;
	}
	
	public void ASTNode.lockDependencies(DependencyEdge... edges) {
		for(DependencyEdge e : edges)
			if(e.isStart(this))
				getDependencies().put(e, e.collect(this));
		for(int i=0;i<getNumChild();++i) {
			ASTNode ch = getChild(i);
			if(ch != null)
				ch.lockDependencies(edges);
		}
	}
	
	public void ASTNode.unlockDependencies(PreservationStrategy r) {
		DependencyEdge e = r.getEdge();
		if(e.isStart(this)) {
			SmallSet<CFNode> old_edges = getDependencies().get(e);
			if(old_edges != null) {
				SmallSet<CFNode> new_edges = e.collect(this);
				if(r.preserve(this) && !old_edges.subsetOf(new_edges))
					throw new RefactoringException("couldn't preserve edge: "+e);
				if(r.reflect(this) && !new_edges.subsetOf(old_edges))
					throw new RefactoringException("couldn't reflect edge: "+e);
			}
		}
		for(int i=0;i<getNumChild();++i) {
			ASTNode ch = getChild(i);
			if(ch != null)
				ch.unlockDependencies(r);
		}
	}
	
}
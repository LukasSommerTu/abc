aspect PromoteTempToField {
	inh boolean VariableDeclaration.inStaticContext();
	
	public void VariableDeclaration.promoteToField(int vis) {
		split();
		Modifiers mods = new Modifiers(vis);
		if(inStaticContext())
			mods.addModifier("static");
		FieldDeclaration fd = new FieldDeclaration(mods, type().createLockedAccess(), name(), new Opt<Expr>());
		hostType().insertField(fd, hostBodyDecl());
		for(VarAccess va : uses()) {
			va.lock(fd);
			va.lockDataFlow();
			va.lockSyncDependencies();
		}
		/*hostBodyDecl().entry().lockSyncDependencies();
		hostBodyDecl().exit().lockSyncDependencies();*/
		programRoot().flushCaches();
		removeUnused();
	}
	
	public void VariableDeclaration.doPromoteToField(int vis) {
		BodyDecl bd = this.hostBodyDecl();
		promoteToField(vis);
		bd.programRoot().eliminate(LOCKED_NAMES, LOCKED_DATAFLOW);
		bd.unlockSyncDependencies();
	}
	
	public void VariableDeclaration.doPromoteToField() {
		doPromoteToField(VIS_PRIVATE);
	}
	
	public void TypeDecl.insertField(FieldDeclaration fd) {
		insertField(fd, null);
	}
	
	public void TypeDecl.insertField(FieldDeclaration fd, BodyDecl before) {
		if(!isClassDecl() && !isInterfaceDecl())
			throw new RefactoringException("cannot insert field into this type");
		SimpleSet res = localFields(fd.name());
		if(!res.isEmpty() && !res.isSingleton(fd))
			throw new RefactoringException("field of the same name exists");
		fd.checkEnclosingTypeNames(this);
		programRoot().lockNames(fd.name());
		if(before == null)
			addBodyDecl(fd);
		else
			getBodyDeclList().insertChild(fd, getBodyDeclList().getIndexOfChild(before));
		if(fd.isStatic() && !fd.isConstant() && isInnerClass())
			throw new RefactoringException("cannot insert static field into this type");
	}
}
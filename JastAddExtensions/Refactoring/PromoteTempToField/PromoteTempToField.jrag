aspect PromoteTempToField {
	inh boolean VariableDeclaration.inStaticContext();
	
	public void VariableDeclaration.promoteToField() {
		split();
		Modifiers mods = new Modifiers("private");
		if(inStaticContext())
			mods.addModifier("static");
		FieldDeclaration fd = new FieldDeclaration(mods, type().createLockedAccess(), name(), new Opt<Expr>());
		hostType().insertField(fd);
		for(VarAccess va : uses()) {
			va.lock(fd);
			va.lockDataFlow();
			va.lockSyncDependencies();
		}
		/*hostBodyDecl().entry().lockSyncDependencies();
		hostBodyDecl().exit().lockSyncDependencies();*/
		programRoot().flushCaches();
		removeUnused();
	}
	
	public void VariableDeclaration.doPromoteToField() {
		BodyDecl bd = this.hostBodyDecl();
		promoteToField();
		bd.programRoot().eliminate(LOCKED_NAMES, LOCKED_DATAFLOW);
		bd.unlockSyncDependencies();
	}
	
	public void TypeDecl.insertField(FieldDeclaration fd) {
		insertField(fd, null);
	}
	
	public void TypeDecl.insertField(FieldDeclaration fd, BodyDecl before) {
		if(!isClassDecl() && !isInterfaceDecl())
			throw new RefactoringException("cannot insert field into this type");
		if(fd.getModifiers().isStatic() && (isLocalClass() || isAnonymous()))
			throw new RefactoringException("cannot insert static field into this type");
		SimpleSet res = localFields(fd.name());
		if(!res.isEmpty() && !res.isSingleton(fd))
			throw new RefactoringException("field of the same name exists");
		programRoot().lockNames(fd.name());
		if(before == null)
			addBodyDecl(fd);
		else
			getBodyDeclList().insertChild(fd, getBodyDeclList().getIndexOfChild(before));
	}
}
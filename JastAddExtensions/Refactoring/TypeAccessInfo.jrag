aspect TypeAccessInfo {
	
	/*
	 * For a description of the general idea behind symbolic accesses, see
	 * AccessInfo.jrag and VarAccessInfo.jrag. The case for types
	 * is a bit simpler than for fields, since the source and bend must always
	 * be equal. Similar to variables, we set both of them to [null] for
	 * accesses to local or anonymous classes. Additionally, we have the case
	 * of top level types, which also have neither source nor bend, but whose
	 * target type contains information about the package they live in.
	 */
	
	abstract class TypeAccessInfo extends AccessInfo<TypeDecl> {
		public TypeAccessInfo(TypeDecl outer, boolean needsQualifier,
								  TypeDecl target) {
			super(outer, outer, needsQualifier, target);
		}
	}
	
	class TopLevelTypeAccessInfo extends TypeAccessInfo {
		public TopLevelTypeAccessInfo(boolean needsQualifier, TypeDecl target) {
			super(null, needsQualifier, target);
		}
	}
	
	class MemberTypeAccessInfo extends TypeAccessInfo {
		public MemberTypeAccessInfo(boolean needsQualifier, TypeDecl target) {
			super(target.enclosingType(), needsQualifier, target);
		}
	}
	
	class LocalTypeAccessInfo extends TypeAccessInfo {
		public LocalTypeAccessInfo(TypeDecl target) {
			super(null, false, target);
		}
	}
	
	protected TypeAccessInfo TypeAccessInfo.addQualifier(boolean flag) {
		if(flag)
			needsQualifier = true;
		return this;
	}
	
	protected TypeAccessInfo LocalTypeAccessInfo.addQualifier(boolean flag) {
		if(flag)
			return null;
		return this;
	}
	
	public TypeAccessInfo TypeAccessInfo.moveDownTo(TypeDecl td) {
		return addQualifier(!td.localTypeDecls(target.name()).isEmpty());
	}
		
	public TypeAccessInfo TypeAccessInfo.moveInto(Block blk, int index) {
		return addQualifier(blk.localLookupType(target.name(), index) != null);
	}
		
	public TypeAccessInfo TypeAccessInfo.moveInto(ClassInstanceExpr cie) {
		return addQualifier(false);
	}
		
	public TypeAccessInfo TypeAccessInfo.moveInto(TypeDecl td) {
		return addQualifier(!td.memberTypes(target.name()).isEmpty());
	}
		
	public abstract Access TypeAccessInfo.computeAccess(NamingContext ctxt, boolean ambiguous);
	
	public Access LocalTypeAccessInfo.computeAccess(NamingContext ctxt, boolean ambiguous) {
		if(ctxt.isShadowed(target, ambiguous))
			return null;
		else
			return new TypeAccess(target.name());
	}
	
	public Access TopLevelTypeAccessInfo.computeAccess(NamingContext ctxt, boolean ambiguous) {
		String pkg = target.packageName();
		if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
			if(ctxt.isShadowed(new PackageAccess(pkg), ambiguous))
				return null;
			return new TypeAccess(pkg, target.name());
		} else {
			return new TypeAccess(target.name());
		}
	}

	public Access MemberTypeAccessInfo.computeAccess(NamingContext ctxt, boolean ambiguous) {
		if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
			if(ambiguous && !source.memberFields(target.name()).isEmpty())
				return null;
			Access source_acc = ctxt.accessType(source, ambiguous);
			if(source_acc == null) return null;
			return source_acc.qualifiesAccess(new TypeAccess(target.name()));
		} else {
			return new TypeAccess(target.name());
		}
	}
	
	public abstract Access TypeAccessInfo.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier);
	
	public Access LocalTypeAccessInfo.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		return null;
	}

	public Access TopLevelTypeAccessInfo.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		String pkg = target.packageName();
		if(qualifier instanceof PackageAccess) {
			PackageAccess pkgacc = (PackageAccess)qualifier;
			if(pkgacc.packageName().equals(pkg) &&
					!ctxt.isShadowed(pkgacc, ambiguous))
				return qualifier.qualifiesAccess(new TypeAccess(target.name()));
		}
		return null;
	}
	
	public Access MemberTypeAccessInfo.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		if(qualifier.isTypeAccess()) {
			TypeDecl td = qualifier.type();
			// TODO: check that td is something we want to qualify with
			//       (i.e., td == source, or maybe an ancestor class)
			if(ambiguous && !source.memberFields(target.name()).isEmpty())
				return null;
			return qualifier.qualifiesAccess(new TypeAccess(target.name()));
		}
		return null;
	}
	
	public TypeAccessInfo TypeDecl.getAccessInfo(boolean needsQualifier) {
		if(isTopLevelType())
			return new TopLevelTypeAccessInfo(needsQualifier, this);
		else if(isMemberType())
			return new MemberTypeAccessInfo(needsQualifier, this);
		else
			return new LocalTypeAccessInfo(this);
	}
	
	public TypeAccessInfo TypeDecl.getAccessInfo() {
		return getAccessInfo(false);
	}
	
}
import java.util.*;

/*
 * The inherited attribute accessMethod(m) computes a SymbolicMethodAccess which
 * describes how to access method m from the current location in the AST. This
 * SymbolicMethodAccess can in turn be used to construct an actual access.
 * 
 * The implementation of accessMethod tries to stay close to lookupMethod with
 * basically the same clauses and the same control flow, but with additional calls to
 * methods "moveInto" and "moveDownTo", which transport a symbolic access from a
 * parent type to a child type resp. an enclosing type to a nested type, adding
 * information about required qualifications in the process. For the implementation
 * of these methods see SymbolicMethodAccess.jrag
 */

aspect AccessMethod {
	
	public SimpleSet TypeDecl.localMethods(String name) {
		SimpleSet res = SimpleSet.emptySet;
		for(Iterator i=localMethodsIterator();i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			if(md.name().equals(name))
				res = res.add(md);
		}
		return res;
	}
	
	// cf. attribute lookupMethod(String) in LookupMethod.jrag
	inh SymbolicMethodAccess Expr.accessMethod(MethodDecl md);
	inh lazy SymbolicMethodAccess TypeDecl.accessMethod(MethodDecl md);
	inh SymbolicMethodAccess BodyDecl.accessMethod(MethodDecl md);

	eq MethodAccess.getArg().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ConstructorAccess.getArg().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ArrayAccess.getExpr().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ArrayTypeWithSizeAccess.getExpr().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);

	eq Program.getChild().accessMethod(MethodDecl md) = null;
	eq TypeDecl.getBodyDecl(int i).accessMethod(MethodDecl md) = unqualifiedAccessMethod(md);

	// cf. attribute unqualifiedLookupMethod in LookupMethod.jrag
	syn lazy SymbolicMethodAccess TypeDecl.unqualifiedAccessMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessMemberMethod(md);
		if(acc != null) return acc;
		if(isInnerType() || md.isStatic()) {
			acc = accessMethod(md);
			if(acc != null)
				return acc.moveInto(this);
		}
		return null;
	}

	// in explicit constructor invocation
	eq ConstructorDecl.getConstructorInvocation().accessMethod(MethodDecl md) {
		SymbolicMethodAccess acc = hostType().accessMemberMethod(md);
		if(acc != null && md.isStatic()) return acc;
		if(hostType().isNestedType()) {
			acc = hostType().accessMethod(md);
			if(acc != null)
				return acc.moveInto(hostType());
		}
		return null;
	}
	
	eq AbstractDot.getRight().accessMethod(MethodDecl md) = 
		getLeft().type().accessMemberMethod(md);

	// cf. attribute memberMethods(String)
	syn SymbolicMethodAccess TypeDecl.accessMemberMethod(MethodDecl md) =
		accessLocalMethod(md);
	
	eq ClassDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}
	
	eq InterfaceDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		acc = typeObject().accessMemberMethod(md);
		if(acc != null && md.isPublic())
			return acc.moveDownTo(this);
		return null;
	}
	
	// somewhat similar to attribute localMethodsSignature(String)
	public SymbolicMethodAccess TypeDecl.accessLocalMethod(MethodDecl md) {
		for(int i=0;i<getNumBodyDecl();++i) {
			if(getBodyDecl(i) == md)
				return new SymbolicMethodAccess(this, this, false, md); 
		}
		return null;
	}
	
	public Access Access.access(MethodDecl md, List args) {
		SymbolicMethodAccess acc = accessMethod(md);
		if(acc == null) return null;
		if(isQualified())
			return acc.computeQualifiedAccess(qualifier().type().getMemberNamingContext(),
										      getCompleteQualifier(), args);
		else
			return acc.computeAccess(getNamingContext(), args);
	}
}
import java.util.*;

/*
 * The inherited attribute accessMethod tries to compute an access to a method. If,
 * for some node n, calling n.accessMethod(m) yields an access a, then looking up
 * a at node n should yield method m.
 * 
 * For a method named "m", the code will return one of the following
 *   1. a method access "m" if the method is directly visible
 *   2. a qualified access "super.m()" or "((A)this).m()", if "m" is
 *      visible in the direct superclass, or an ancestor class/interface
 *      "A", respectively; the second form only works for static methods
 *   3. a qualified access "A.this.m" if "m" is visible in
 *      enclosing class "A"
 *   4. null if none of the above works 
 */

aspect AccessMethod {
	
	public SimpleSet TypeDecl.localMethods(String name) {
		SimpleSet res = SimpleSet.emptySet;
		for(Iterator i=localMethodsIterator();i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			if(md.name().equals(name))
				res = res.add(md);
		}
		return res;
	}
	
	class SymbolicMethodAccess {
		protected TypeDecl source;
		protected TypeDecl bend;
		protected boolean needsQualifier;
		protected MethodDecl target;
		
		public SymbolicMethodAccess(TypeDecl source, TypeDecl bend, boolean needsQualifier,
									MethodDecl target) {
			this.source = source;
			this.bend = bend;
			this.needsQualifier = needsQualifier;
			this.target = target;
		}

		public SymbolicMethodAccess moveDownTo(TypeDecl td) {
			bend = td;
			if(!td.localMethods(target.name()).isEmpty())
				needsQualifier = true;
			else if(!needsQualifier)
				source = td;
			return this;
		}
		
		public SymbolicMethodAccess moveInto(TypeDecl td) {
			if(!td.memberMethods(target.name()).isEmpty())
				needsQualifier = true;
			return this;
		}
		
		public Access getAccess(NamingContext ctxt, List args) {
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(ctxt.isStatic()) return null;
				if(source == bend) {
					if(source == ctxt.enclosingType())
						return ma;
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new ThisAccess("this").qualifiesAccess(ma));
					}
				} else if(bend instanceof ClassDecl && 
							source == ((ClassDecl)bend).superclass()) {
					if(bend == ctxt.enclosingType())
						return new SuperAccess("super").qualifiesAccess(ma);
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new SuperAccess("super").qualifiesAccess(ma));
					}
				} else if(target.isStatic()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper == null) return null;
					if(bend == ctxt.enclosingType()) {
						return new ParExpr(new CastExpr(upper, new ThisAccess("this"))).qualifiesAccess(ma);
					} else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return new ParExpr(new CastExpr(upper, outer.qualifiesAccess(new ThisAccess("this")))).
										   qualifiesAccess(ma);
					}
				} else {
					return null;
				}
			} else {
				return ma;
			}
		}
		
		public Access getQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(!target.isStatic())
					return null;
				if(ctxt.isStatic())
					return null;
				if(source == bend && source == ctxt.enclosingType())
					return qualifier.qualifiesAccess(ma);
				else if(!qualifier.isTypeAccess()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper != null && bend == ctxt.enclosingType())
						return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
				}
				return null;
			} else {
				return qualifier.qualifiesAccess(ma);
			}
		}	
		
	}

	inh SymbolicMethodAccess Expr.accessMethod(MethodDecl md);
	inh lazy SymbolicMethodAccess TypeDecl.accessMethod(MethodDecl md);

	eq MethodAccess.getArg().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ConstructorAccess.getArg().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ArrayAccess.getExpr().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);
	eq ArrayTypeWithSizeAccess.getExpr().accessMethod(MethodDecl md) = unqualifiedScope().accessMethod(md);

	eq Program.getChild().accessMethod(MethodDecl md) = null;
	eq TypeDecl.getBodyDecl(int i).accessMethod(MethodDecl md) = unqualifiedAccessMethod(md);

	syn lazy SymbolicMethodAccess TypeDecl.unqualifiedAccessMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessMemberMethod(md);
		if(acc != null) return acc;
		if(isInnerType() || md.isStatic()) {
			acc = accessMethod(md);
			if(acc != null)
				return acc.moveInto(this);
		}
		return null;
	}

	// in explicit constructor invocation
	eq ConstructorDecl.getConstructorInvocation().accessMethod(MethodDecl md) {
		SymbolicMethodAccess acc = hostType().accessMemberMethod(md);
		if(acc != null && md.isStatic()) return acc;
		if(hostType().isNestedType()) {
			acc = hostType().accessMethod(md);
			if(acc != null)
				return acc.moveInto(hostType());
		}
		return null;
	}
	
	eq AbstractDot.getRight().accessMethod(MethodDecl md) = 
		getLeft().type().accessMemberMethod(md);

	syn SymbolicMethodAccess TypeDecl.accessMemberMethod(MethodDecl md) =
		accessLocalMethod(md);
	
	eq ClassDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}
	
	eq InterfaceDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		acc = typeObject().accessMemberMethod(md);
		if(acc != null && md.isPublic())
			return acc.moveDownTo(this);
		return null;
	}
	
	public SymbolicMethodAccess TypeDecl.accessLocalMethod(MethodDecl md) {
		for(int i=0;i<getNumBodyDecl();++i) {
			if(getBodyDecl(i) == md)
				return new SymbolicMethodAccess(this, this, false, md); 
		}
		return null;
	}
	
	public Access Access.getAccessTo(MethodDecl md, List args) {
		SymbolicMethodAccess acc = accessMethod(md);
		if(acc == null) return null;
		if(isQualified())
			return acc.getQualifiedAccess(qualifier().type().getMemberNamingContext(),
										  getCompleteQualifier(), args);
		else
			return acc.getAccess(getNamingContext(), args);
	}
}
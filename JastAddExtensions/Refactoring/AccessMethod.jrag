import java.util.*;

/*
 * The inherited attribute accessMethod tries to compute an access to a method. If,
 * for some node n, calling n.accessMethod(m) yields an access a, then looking up
 * a at node n should yield method m.
 * 
 * For a method named "m", the code will return one of the following
 *   1. a method access "m" if the method is directly visible
 *   2. a qualified access "super.m()" or "((A)this).m()", if "m" is
 *      visible in the direct superclass, or an ancestor class/interface
 *      "A", respectively; the second form only works for static methods
 *   3. a qualified access "A.this.m" if "m" is visible in
 *      enclosing class "A"
 *   4. null if none of the above works 
 */

aspect AccessMethod {

	inh lazy Access TypeDecl.accessMethod(MethodDecl md, List args);
	inh lazy Access BodyDecl.accessMethod(MethodDecl md, List args);
	inh lazy Access Block.accessMethod(MethodDecl md, List args);
	inh lazy Access Access.accessMethod(MethodDecl md, List args);

	eq Program.getChild().accessMethod(MethodDecl md, List args) = null;

	eq TypeDecl.getBodyDecl(int i).accessMethod(MethodDecl md, List args) {
		if(lookupMethod(md.getID()).contains(md)) {
			return new MethodAccess(md.getID(), args);
		} else if(md.hostType().encloses(hostType())) {
			// we need an expression of the form A.this.x
			Access typacc = getBodyDecl(i).accessType(md.hostType(), true);
			if(typacc == null)
				return null;
			return typacc.qualifiesAccess(new ThisAccess("this").qualifiesAccess(
					new MethodAccess(md.getID(), args)));
		} else if(hostType().instanceOf(md.hostType())) {
			// we need to qualify either with `super' or with `(A)this'
			if(hostType() instanceof ClassDecl && 
					((ClassDecl)hostType()).superclass() == md.hostType()) {
				return new SuperAccess("super").qualifiesAccess(
						new MethodAccess(md.getID(), args));
			} else if(md.isStatic()) {
				// non-static overridden methods of the superclass can be accessed,
				// anything further up is off-limits
				Access typacc = getBodyDecl(i).accessType(md.hostType(), true);
				if(typacc == null) return null;
				return new ParExpr(new CastExpr(typacc, new ThisAccess("this"))).
					qualifiesAccess(new MethodAccess(md.getID(), args));
			}
		}
		return null;
	}
	
	eq AbstractDot.getRight().accessMethod(MethodDecl md, List args) {
		return getLeft().qualifiedAccessMethod(md, args);
	}
	
	syn Access Expr.qualifiedAccessMethod(MethodDecl md, List args) {
		return type().getBodyDecl(0).accessMethod(md, args);
	}

	eq PackageAccess.qualifiedAccessMethod(MethodDecl md, List args) = null;

	eq TypeAccess.qualifiedAccessMethod(MethodDecl md, List args) {
		return type().getBodyDecl(0).accessMethod(md, args);
	}
	
}
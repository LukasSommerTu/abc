/*
 * A symbolic access contains information on how to access a program entity
 * from some point in the syntax tree in implicit form.
 * 
 * More precisely, it records a "source" class of which the entity in question
 * is a member, and a "bend" class which is a descendant of source and lexically
 * encloses the point from where the access is made (think of the access 
 * information as describing a river that flows from its source through a bend
 * to the access point).
 * 
 * For example, if the entity e being accessed is in fact declared in the host
 * type C of the AST node n where we want to access it, the symbolic access
 * has both source and bend set to C.
 * 
 * If e is declared in a supertype A of C, then the source is A and the bend
 * is C. If e is declared in a type B that lexically encloses A, then
 * source and bend are both A. If, finally, e is declared in a supertype D of 
 * B, then the source is D and the bend is B.
 * 
 * Finally, there is a flag indicating whether qualification is necessary.
 * How an actual access is generated from a symbolic one depends on the
 * entity being accessed; you will find that code in AccessType.jrag, 
 * AccessVariable.jrag, and AccessMethod.jrag.
 */

aspect AccessInfo {
	
	class AccessInfo<T> {
		 public TypeDecl source;
		 public TypeDecl bend;
		 public boolean needsQualifier;
		 public T target;
		 
		 public AccessInfo(TypeDecl source, TypeDecl bend, 
				 			   boolean needsQualifier, T target) {
			 this.source = source;
			 this.bend = bend;
			 this.needsQualifier = needsQualifier;
			 this.target = target;
		 }
	}
	
}
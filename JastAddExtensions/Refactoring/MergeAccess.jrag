aspect MergeAccess {
	
	public Access TypeAccess.mergeWithAccess(Access f) {
		return this.qualifiesAccess(f);
	}

	// the field access f is either a simple name or qualified with this, super, ((A)this),
	// A.this, or ((A)B.this) for some classes A and B
	public Access Expr.mergeWithAccess(Access f) throws RefactoringException {
		if(f.isVariable() || f instanceof TypeAccess || f instanceof MethodAccess ||
				f instanceof ClassAccess || f instanceof ArrayAccess) {
			return this.qualifiesAccess(f);
		} else if(f instanceof AbstractDot) {
			Expr left = ((AbstractDot)f).getLeft();
			Access right = ((AbstractDot)f).getRight();
			if(right.isMethodAccess() && !((MethodAccess)right).decl().isStatic())
				throw new RefactoringException("cannot access method");
			if(left.isThisAccess())
				return mergeWithAccess(right);
			else if(left.isSuperAccess()) {
				if(type() instanceof ClassDecl) {
					ClassDecl cdcl = (ClassDecl)type();
					if(cdcl.hasSuperclass())
						return new ParExpr(new CastExpr((TypeAccess)cdcl.getSuperClassAccess().fullCopy(), this)).
									mergeWithAccess(right);
				}
				throw new RefactoringException("only classes have `super'");
			} else if(left instanceof ParExpr) {
				Expr e = ((ParExpr)left).getExpr();
				return mergeWithAccess(new Dot(e, right));
			} else if(left instanceof CastExpr) {
				Access tp = ((CastExpr)left).getTypeAccess();
				Expr e = ((CastExpr)left).getExpr();
				if(e instanceof ThisAccess) {
					return new ParExpr(new CastExpr((TypeAccess)tp, this)).
								mergeWithAccess(right);
				}
			}
		} else {
			assert(false);
		}
		throw new RefactoringException("cannot merge accesses");
	}
	
}
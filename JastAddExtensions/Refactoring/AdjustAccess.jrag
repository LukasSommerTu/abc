/*
 * This is the central piece of machinery for the name-based refactorings: An 
 * adjustment table keeps track of a list of accesses and the declarations they point
 * to. After a refactoring is performed, the table's adjust() method is invoked
 * which tries to adjust all accesses in the table so that they still point to the
 * same declarations as before.
 */

aspect AdjustAccess {
	
	/* a lockable access can be locked to a target declaration; it will then
	 * behave like a bound access to that declaration
	 * it can also be unlocked, regaining its normal behaviour, or safely
	 * unlocked, which will try to modify the access such that it points to
	 * the declaration it is locked to; if that fails, a refactoring exception is
	 * thrown */
	interface LockableAccess {
		void lock();
		void unlock();
		void unlockSafely() throws RefactoringException;
	}
	
	VarAccess implements LockableAccess;
	public Variable VarAccess.target;
	public void VarAccess.lock() { target = decl(); }
	public void VarAccess.lockOn(Variable target) { this.target = target; }
	public void VarAccess.unlock() { target = null; flushCache(); }
	refine LookupVariable eq VarAccess.decl() {
		if(target == null)
			return LookupVariable.VarAccess.decl();
		return target;
	}
	public void VarAccess.unlockSafely() throws RefactoringException {
		Variable v = target;
		// check that target is visible and can be accessed
		if(!v.accessibleFrom(this))
			throw new RefactoringException("variable is not accessible");
		unlock();
		if(v == decl())
			return;
		Access acc = access(v);
		if(acc == null)
			throw new RefactoringException("variable cannot be accessed");
		plugIn(acc);
	}
	
	TypeAccess implements LockableAccess;
	public TypeDecl TypeAccess.target;
	public void TypeAccess.lock() { target = decl(); }
	public void TypeAccess.lockOn(TypeDecl target) { this.target = target; }
	public void TypeAccess.unlock() { target = null; flushCache(); }
	// TODO: this should actually refine LookupType.TypeAccess.decl(), but then
	//       we get a conflicting refinement
	refine Generics eq TypeAccess.decl() {
		if(target == null)
			return Generics.TypeAccess.decl();
		return target;
	}
	public void TypeAccess.unlockSafely() throws RefactoringException {
		TypeDecl td = target;
		unlock();
		if(possiblyObscured() || decl() != td) {
			Access acc = access(td, nameType() == NameType.AMBIGUOUS_NAME);
			if(acc == null)
				throw new RefactoringException("type cannot be accessed");
			plugIn(acc);
		}
	}
	protected boolean TypeAccess.possiblyObscured() {
		// this test is somewhat overly paranoid and could be optimised
		// by consulting the nameType()
		if(!lookupVariable(name()).isEmpty())
			return true;
		if(packageName().equals(""))
			return false;
		String fst = pkgNameFirstComponent(packageName());
		if(!lookupVariable(fst).isEmpty() || !lookupType(fst).isEmpty())
			return true;
		return false;
	}
	
	MethodAccess implements LockableAccess;
	public MethodDecl MethodAccess.target;
	public void MethodAccess.lock() { target = decl(); }
	public void MethodAccess.lockOn(MethodDecl target) { this.target = target; }
	public void MethodAccess.unlock() { target = null; flushCache(); }
	refine LookupMethod eq MethodAccess.decl() {
		if(target == null)
			return LookupMethod.MethodAccess.decl();
		return target;
	}
	public void MethodAccess.unlockSafely() throws RefactoringException {
		MethodDecl md = target;
		unlock();
		if(md == decl())
			return;
		Access acc = access(md, (List<Expr>)getArgs().fullCopy());
		if(acc == null)
			throw new RefactoringException("method cannot be accessed");
		plugIn(acc);
	}
	
	PackageAccess implements LockableAccess;
	public void PackageAccess.lock() { }
	public void PackageAccess.unlock() { }
	public void PackageAccess.unlockSafely() throws RefactoringException {
		/* it seems we do not need to check for obscuring here:
		 * a PackageAccess qualifying a TypeAccess is merged into the type access;
		 * hence raw package accesses do not occur in the wild */
	}
	
	public boolean Variable.accessibleFrom(Expr e);
	public boolean FieldDeclaration.accessibleFrom(Expr e) {
		return e.mayAccess(this);
	}
	public boolean VariableDeclaration.accessibleFrom(Expr e) {
		return hostType() == e.hostType() || isFinal();
	}
	public boolean ParameterDeclaration.accessibleFrom(Expr e) {
		return hostType() == e.hostType() || isFinal();
	}
	
	class AdjustmentTable {
		private java.util.List<LockableAccess> adjustments;
	}
	
	public AdjustmentTable.AdjustmentTable() {
		adjustments = new LinkedList<LockableAccess>();
	}
	
	public int AdjustmentTable.size() {
		return adjustments.size();
	}
		
	public void AdjustmentTable.add(LockableAccess acc) {
		adjustments.add(acc);
		acc.lock();
	}
		
	public void AdjustmentTable.adjust() throws RefactoringException {
		try {
			for(LockableAccess acc : adjustments)
				acc.unlockSafely();
		} finally {
			for(LockableAccess acc : adjustments)
				acc.unlock();
		}
	}
	
	// replace the access and its qualifier by an expr
	public void Access.plugIn(Expr expr) throws RefactoringException {
		if(isLeftChildOfDot()) {
			Access right = parentDot().getRight();
			Expr p = nestedScope();
			p.replaceWith(expr.qualifiesAccess(right));
		} else {
			this.unqualifiedScope().replaceWith(expr);
		}
	}

}
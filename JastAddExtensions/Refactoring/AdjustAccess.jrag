aspect AdjustAccess {
	
	class AdjustmentTable {
		private Map adjustments;
		private java.util.Set adjusted;
		
		public AdjustmentTable() {
			adjustments = new HashMap();
			adjusted = new HashSet();
		}
		
		public void add(Access acc, ASTNode target) {
			adjustments.put(acc, target);
		}
		
		public ASTNode getTarget(Access acc) {
			return (ASTNode)adjustments.get(acc);
		}
		
		private boolean isAdjusted(Expr exp) {
			return adjusted.contains(exp);
		}
		
		private void setAdjusted(Expr exp) {
			adjusted.add(exp);
		}
		
		public void adjust() throws RefactoringException {
			for(Iterator i = adjustments.entrySet().iterator(); i.hasNext();) {
				Map.Entry e = (Map.Entry)i.next();
				Access acc = (Access)e.getKey();
				ASTNode val = (ASTNode)e.getValue();
				adjust(acc);
			}
		}
		
		public void adjust(Expr exp) throws RefactoringException {
			if(isAdjusted(exp))
				return;
			exp.adjust(this);
			setAdjusted(exp);
		}
	}
	
	public void Expr.adjust(AdjustmentTable table) throws RefactoringException {
	}
	
	public void AbstractDot.adjust(AdjustmentTable table) throws RefactoringException {
		getRight().adjust(table);
	}
	
	public void ParExpr.adjust(AdjustmentTable table) throws RefactoringException {
		getExpr().adjust(table);
	}
	
	// more needed here...
	
	public void Access.adjust(AdjustmentTable table) throws RefactoringException {
		if(isQualified())
			table.adjust(qualifier());
		ASTNode target = table.getTarget(this);
		if(target == null) return;
		ASTNode oldacc = null;
		Access newacc = null;
        FileRange pos = new FileRange(getStart(), getEnd());
		if(target instanceof VariableDeclaration) {
			if(((VarAccess)this).decl() != target) {
				newacc = this.accessLocalVariable((VariableDeclaration)target);
				if(newacc == null)
					throw new RefactoringException("local variable would become shadowed at "+pos);
				oldacc = this;
			}
		} else if(target instanceof ParameterDeclaration) {
			if(((VarAccess)this).decl() != target) {
				newacc = this.accessParameter((ParameterDeclaration)target);
				if(newacc == null)
					throw new RefactoringException("parameter would become shadowed at "+pos);
				oldacc = this;
			}
		} else if(target instanceof FieldDeclaration) {
			FieldDeclaration fd = (FieldDeclaration)target;
			if(((VarAccess)this).decl() != fd) {
				newacc = this.accessField(fd);
				if(newacc == null)
					throw new RefactoringException("couldn't consistently rename field access at "+pos);
				if(this.isQualified()) {
					newacc = this.qualifier().mergeWithAccess(newacc);
					if(newacc == null)
						throw new RefactoringException("couldn't consistently rename field access at "+pos);
					oldacc = this.getParent();
				} else {
					oldacc = this;
				}
			}
		} else if(target instanceof MethodDecl) {
			MethodDecl md = (MethodDecl)target;
			RefactoringException exc = new RefactoringException("couldn't consistently rename method access at "+pos);
			if(((MethodAccess)this).decl() != md) {
				newacc = this.accessMethod(md, (List)((MethodAccess)this).getArgList().fullCopy());
				if(newacc == null)
					throw exc;
				if(this.isQualified()) {
					if(newacc instanceof AbstractDot && !md.isStatic())
						throw exc;
					newacc = this.qualifier().mergeWithAccess(newacc);
					if(newacc == null)
						throw exc;
					oldacc = this.getParent();
				} else {
					oldacc = this;
				}
			}
		} else if(target instanceof TypeDecl) {
			TypeAccess tacc = (TypeAccess)this;
            if(tacc.decl() != target) {
                boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                newacc = this.accessType((TypeDecl)target, ambiguous);
                if(newacc == null)
                    throw new RefactoringException("couldn't consistently rename type access at "+pos);
                if(this.isQualified()) {
                    newacc = this.qualifier().mergeWithAccess(newacc);
                    if(newacc == null)
                        throw new RefactoringException("couldn't consistently rename field access at "+pos);
                    oldacc = parent;
                } else {
                    oldacc = this;
                }
            } else {
                ASTNode parent = tacc.getParent();
                int idx = parent.getIndexOfChild(tacc);
                ParseName pn = new ParseName(tacc.getID());
                parent.setChild(pn, idx);
                try {
                	Access tmp = (Access)parent.getChild(idx);
                	if(tmp instanceof VarAccess) {
                		parent.setChild(tacc, idx);
                		boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                		newacc = this.accessType((TypeDecl)target, ambiguous);
                		if(newacc == null)
                			throw new RefactoringException("couldn't consistently rename type access at "+pos);
                		if(this.isQualified()) {
                			newacc = this.qualifier().mergeWithAccess(newacc);
                			if(newacc == null)
                				throw new RefactoringException("couldn't consistently rename field access at "+pos);
                			oldacc = parent;
                		} else {
                			oldacc = this;
                		}
                	}
                } finally {
                	parent.setChild(tacc, idx);
                }
            }
		} else if(target instanceof PackageDecl) {
			Access acc = this;
			ASTNode parent = acc; int idx;
			do {
				acc = (Access)parent;
				parent = acc.getParent();
				idx = parent.getIndexOfChild(acc);
			} while(parent instanceof AbstractDot);
			ParseName pn = new ParseName(acc.packageName());
			parent.setChild(pn, idx);
			try {
				if(parent.getChild(idx) instanceof VarAccess)
					throw new RefactoringException("package access at "+pos+" is shadowed");
				// package accesses never have to be merged through mergeWithAccess()
			} finally {
				parent.setChild(acc, idx);
			}
		} else {
			throw new RefactoringException("don't know how to adjust access to "+target.getClass()+" "+target);
		}
		if(oldacc != newacc)
			oldacc.replaceWith(newacc);
	}
	
}
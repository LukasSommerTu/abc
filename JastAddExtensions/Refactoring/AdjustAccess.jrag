/*
 * This is the central piece of machinery for the name-based refactorings: An 
 * adjustment table keeps track of a list of accesses and the declarations they point
 * to. After a refactoring is performed, the table's adjust() method is invoked
 * which tries to adjust all accesses in the table so that they still point to the
 * same declarations as before.
 */

aspect AdjustAccess {
	
	class AdjustmentTable {
		private Map adjustments;
		
		// the "pending" list prescribes the order in which the adjustments should
		// be performed
		private java.util.List pending;
		private java.util.Set adjusted;
		
		public AdjustmentTable() {
			adjustments = new HashMap();
			pending = new ArrayList();
			adjusted = new HashSet();
		}
		
		public void add(Access acc) {
			add(acc, acc.getDecl());
		}
		
		public void add(Access acc, ASTNode target) {
			if(!adjustments.containsKey(acc))
				adjustments.put(acc, target);
			if(acc.getParent() instanceof AbstractDot)
				add((AbstractDot)acc.getParent());
			else
				pending.add(acc);
		}
		
		public ASTNode getTarget(Expr exp) {
			return (ASTNode)adjustments.get(exp);
		}
		
		private boolean isAdjusted(Expr exp) {
			return adjusted.contains(exp);
		}
		
		private void setAdjusted(Expr exp) {
			adjusted.add(exp);
		}
		
		public void adjust() throws RefactoringException {
			for(Iterator i = pending.iterator(); i.hasNext();) {
				Access acc = (Access)i.next();
				adjust(acc);
			}
		}
		
		public void adjust(Expr exp) throws RefactoringException {
			if(isAdjusted(exp))
				return;
			setAdjusted(exp);
			exp.adjust(this);
		}
	}
	
	public void Expr.adjust(AdjustmentTable table) throws RefactoringException {
	}
	
	// first adjust access to the right of the dot, then merge it with the adjusted
	// access to the left
	public void AbstractDot.adjust(AdjustmentTable table) throws RefactoringException {
		table.adjust(getLeft());
		table.adjust(getRight());
		replaceWith(getLeft().mergeWithAccess(getRight()));
	}
	
	public void ParExpr.adjust(AdjustmentTable table) throws RefactoringException {
		getExpr().adjust(table);
	}
	
	public void ClassAccess.adjust(AdjustmentTable table) throws RefactoringException {
	}
	
	public void Access.adjust(AdjustmentTable table) throws RefactoringException {
		ASTNode target = table.getTarget(this);
		if(target == null) return;
		Access newacc;
        FileRange pos = new FileRange(compilationUnit().relativeName(),
        							  getStart(), getEnd());
		if(target instanceof Variable) {
			if(((VarAccess)this).decl() != target) {
				newacc = this.getAccessTo((Variable)target);
				if(newacc == null)
					throw new RefactoringException("variable would become shadowed at "+pos);
				replaceWith(newacc);
			}
		} else if(target instanceof MethodDecl) {
			MethodDecl md = (MethodDecl)target;
			if(((MethodAccess)this).decl() != md) {
				newacc = this.accessMethod(md, (List)((MethodAccess)this).getArgList().fullCopy());
				if(newacc == null)
					throw new RefactoringException("couldn't consistently rename method access at "+pos);
				replaceWith(newacc);
			}
		} else if(target instanceof TypeDecl) {
			TypeAccess tacc = (TypeAccess)this;
            if(tacc.decl() != target) {
                boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                newacc = this.accessType((TypeDecl)target, ambiguous);
                if(newacc == null)
                    throw new RefactoringException("couldn't consistently rename type access at "+pos);
                replaceWith(newacc);
            } else {
                ASTNode parent = tacc.getParent();
                int idx = parent.getIndexOfChild(tacc);
                ParseName pn = new ParseName(tacc.getID());
                parent.setChild(pn, idx);
                try {
                	Access tmp = (Access)parent.getChild(idx);
                	if(tmp instanceof VarAccess) {
                		parent.setChild(tacc, idx);
                		boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                		newacc = this.accessType((TypeDecl)target, ambiguous);
                		if(newacc == null)
                			throw new RefactoringException("couldn't consistently rename type access at "+pos);
               			replaceWith(newacc);
                	}
                } finally {
                	parent.setChild(tacc, idx);
                }
            }
		} else if(target instanceof PackageDecl) {
			Access acc = this;
			ASTNode parent = acc; int idx;
			do {
				acc = (Access)parent;
				parent = acc.getParent();
				idx = parent.getIndexOfChild(acc);
			} while(parent instanceof AbstractDot);
			ParseName pn = new ParseName(acc.packageName());
			parent.setChild(pn, idx);
			try {
				if(parent.getChild(idx) instanceof VarAccess)
					throw new RefactoringException("package access at "+pos+" is shadowed");
				// package accesses never have to be merged through mergeWithAccess()
			} finally {
				parent.setChild(acc, idx);
			}
		} else {
			throw new RefactoringException("don't know how to adjust access to "+target.getClass()+" "+target);
		}
	}
	
}
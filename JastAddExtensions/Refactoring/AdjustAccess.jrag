/*
 * This is the central piece of machinery for the name-based refactorings: An 
 * adjustment table keeps track of a list of accesses and the declarations they point
 * to. After a refactoring is performed, the table's adjust() method is invoked
 * which tries to adjust all accesses in the table so that they still point to the
 * same declarations as before.
 */

aspect AdjustAccess {
	
	class AdjustmentTable {
		private Map adjustments;
		
		// the "pending" list prescribes the order in which the adjustments should
		// be performed
		private java.util.List pending;
		private java.util.Set adjusted;
		
		public AdjustmentTable() {
			adjustments = new HashMap();
			pending = new LinkedList();
			adjusted = new HashSet();
		}
		
		public int size() {
			return adjustments.size();
		}
		
		public void add(Access acc) {
			ASTNode target = acc.getDecl();
			if(target != null)
				add(acc, acc.getDecl());
		}
		
		public void add(Access acc, ASTNode target) {
			if(!adjustments.containsKey(acc))
				adjustments.put(acc, target);
			if(acc.getParent() instanceof AbstractDot)
				add((AbstractDot)acc.getParent());
			else
				pending.add(acc);
		}
		
		public void addFront(Access acc) {
			ASTNode target = acc.getDecl();
			if(target != null)
				addFront(acc, acc.getDecl());
		}
		
		public void addFront(Access acc, ASTNode target) {
			if(!adjustments.containsKey(acc))
				adjustments.put(acc, target);
			if(acc.getParent() instanceof AbstractDot)
				add((AbstractDot)acc.getParent());
			else
				pending.add(0, acc);
		}
		
		public ASTNode getTarget(Expr exp) {
			return (ASTNode)adjustments.get(exp);
		}
		
		private boolean isAdjusted(Expr exp) {
			return adjusted.contains(exp);
		}
		
		private void setAdjusted(Expr exp) {
			adjusted.add(exp);
		}
		
		public void adjust() throws RefactoringException {
			for(Iterator i = pending.iterator(); i.hasNext();) {
				Access acc = (Access)i.next();
				adjust(acc);
			}
		}
		
		public void adjust(Expr exp) throws RefactoringException {
			if(isAdjusted(exp))
				return;
			setAdjusted(exp);
			exp.adjust(this);
		}
	}
	
	public void Expr.adjust(AdjustmentTable table) throws RefactoringException {
	}
	
	// adjust on the left first
	public void AbstractDot.adjust(AdjustmentTable table) throws RefactoringException {
		table.adjust(getLeft());
		table.adjust(getRight());
	}
	
	public void ParExpr.adjust(AdjustmentTable table) throws RefactoringException {
		getExpr().adjust(table);
	}
	
	public void ClassAccess.adjust(AdjustmentTable table) throws RefactoringException {
	}
	
	public FileRange Access.getPos() {
		return new FileRange(compilationUnit().relativeName(), getStart(), getEnd());
	}
	
	public void Access.plugInNewAccess(Access newacc) {
		if(isLeftChildOfDot()) {
			Access right = parentDot().getRight();
			Expr p = nestedScope();
			p.replaceWith(newacc.qualifiesAccess(right));
		} else {
			this.unqualifiedScope().replaceWith(newacc);
		}
	}
	
	public void ASTNode.adjustAccess(Access acc) throws RefactoringException {
		throw new RefactoringException("cannot adjust access at "+acc.getPos());
	}
	
	public void Variable.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof VarAccess);
		VarAccess va = (VarAccess)acc;
		if(va.decl() != this) {
			Access newacc = va.access(this);
			if(newacc == null)
				throw new RefactoringException("variable would become shadowed at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		}
	}
	
	public void MethodDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof MethodAccess);
		MethodAccess ma = (MethodAccess)acc;
		if(ma.decl() != this) {
			Access newacc = ma.access(this, (List)ma.getArgList().fullCopy());
			if(newacc == null)
				throw new RefactoringException("couldn't consistently rename method access at "+pos);
			acc.plugInNewAccess(newacc);
		}
	}
	
	public void TypeDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof TypeAccess);
		FileRange pos = acc.getPos();
		TypeAccess tacc = (TypeAccess)acc;
        if(tacc.decl() != this) {
        	boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
            Access newacc = tacc.access(this, ambiguous);
            if(newacc == null)
                throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
            acc.plugInNewAccess(newacc);
        } else {
            ASTNode parent = tacc.getParent();
            int idx = parent.getIndexOfChild(tacc);
            ParseName pn = new ParseName(tacc.getID());
            parent.setChild(pn, idx);
            try {
            	Access tmp = (Access)parent.getChild(idx);
            	if(tmp instanceof VarAccess) {
            		parent.setChild(tacc, idx);
            		boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
            		Access newacc = tacc.access(this, ambiguous);
            		if(newacc == null)
            			throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
            		acc.plugInNewAccess(newacc);
            	}
            } finally {
            	parent.setChild(tacc, idx);
            }
        }
	}
	
	public void PackageDecl.adjustAccess(Access acc) throws RefactoringException {
		ASTNode parent = acc; 
		int idx;
		do {
			acc = (Access)parent;
			parent = acc.getParent();
			idx = parent.getIndexOfChild(acc);
		} while(parent instanceof AbstractDot);
		ParseName pn = new ParseName(acc.packageName());
		parent.setChild(pn, idx);
		try {
			if(parent.getChild(idx) instanceof VarAccess)
				throw new RefactoringException("package access at "+acc.getPos()+" is shadowed");
		} finally {
			parent.setChild(acc, idx);
		}
	}
	
	public void Access.adjust(AdjustmentTable table) throws RefactoringException {
		ASTNode target = table.getTarget(this);
		if(target == null) return;
		target.adjustAccess(this);
	}
	
}
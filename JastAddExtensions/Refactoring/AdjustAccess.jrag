/*
 * This is the central piece of machinery for the name-based refactorings: An 
 * adjustment table keeps track of a list of accesses and the declarations they point
 * to. After a refactoring is performed, the table's adjust() method is invoked
 * which tries to adjust all accesses in the table so that they still point to the
 * same declarations as before.
 */

aspect AdjustAccess {
	
	/* a lockable access can be locked to a target declaration; it will then
	 * behave like a bound access to that declaration
	 * it can also be unlocked, regaining its normal behaviour, or safely
	 * unlocked, which will try to modify the access such that it points to
	 * the declaration it is locked to; if that fails, a refactoring exception is
	 * thrown */
	interface LockableAccess {
		void lock();
		void unlock();
		void unlockSafely() throws RefactoringException;
	}
	
	// TODO: three test cases end in errors; the direct reason seems to be that
	//       the generic declarations of some library methods cannot be accessed
	//       but I don't know yet what that is caused by
	
	VarAccess implements LockableAccess;
	public Variable VarAccess.target;
	public void VarAccess.lock() { target = decl(); }
	public void VarAccess.unlock() { target = null; flushCache(); }
	refine LookupVariable eq VarAccess.decl() {
		if(target == null)
			return LookupVariable.VarAccess.decl();
		return target;
	}
	public void VarAccess.unlockSafely() throws RefactoringException {
		Variable v = target;
		unlock();
		if(v == decl())
			return;
		Access acc = access(v);
		if(acc == null)
			throw new RefactoringException("variable cannot be accessed");
		plugInNewAccess(acc);
	}
	
	TypeAccess implements LockableAccess;
	public TypeDecl TypeAccess.target;
	public void TypeAccess.lock() { target = decl(); }
	public void TypeAccess.unlock() { target = null; flushCache(); }
	// TODO: this should actually refine LookupType.TypeAccess.decl(), but then
	//       we get a conflicting refinement
	refine Generics eq TypeAccess.decl() {
		if(target == null)
			return Generics.TypeAccess.decl();
		return target;
	}
	public void TypeAccess.unlockSafely() throws RefactoringException {
		// TODO: check for obscuring; change also in MergeGenericDecls
		TypeDecl td = target;
		unlock();
		if(td == decl())
			return;
		Access acc = access(td, nameType() == NameType.AMBIGUOUS_NAME);
		if(acc == null)
			throw new RefactoringException("type cannot be accessed");
		plugInNewAccess(acc);
	}
	
	MethodAccess implements LockableAccess;
	public MethodDecl MethodAccess.target;
	public void MethodAccess.lock() { target = decl(); }
	public void MethodAccess.lockOn(MethodDecl target) { this.target = target; }
	public void MethodAccess.unlock() { target = null; flushCache(); }
	refine LookupMethod eq MethodAccess.decl() {
		if(target == null)
			return LookupMethod.MethodAccess.decl();
		return target;
	}
	public void MethodAccess.unlockSafely() throws RefactoringException {
		MethodDecl md = target;
		unlock();
		if(md == decl())
			return;
		Access acc = access(md, (List<Expr>)getArgs().fullCopy());
		if(acc == null)
			throw new RefactoringException("method cannot be accessed");
		plugInNewAccess(acc);
	}
	
	PackageAccess implements LockableAccess;
	public void PackageAccess.lock() { }
	public void PackageAccess.unlock() { }
	public void PackageAccess.unlockSafely() throws RefactoringException {
		// TODO: check for obscuring; change also in MergeGenericDecls
	}
	
	class AdjustmentTable {
		private java.util.List<LockableAccess> adjustments;
	}
	
	public AdjustmentTable.AdjustmentTable() {
		adjustments = new LinkedList<LockableAccess>();
	}
	
	public int AdjustmentTable.size() {
		return adjustments.size();
	}
		
	public void AdjustmentTable.add(LockableAccess acc) {
		adjustments.add(acc);
		acc.lock();
	}
		
	public void AdjustmentTable.adjust() throws RefactoringException {
		try {
			for(LockableAccess acc : adjustments)
				acc.unlockSafely();
		} finally {
			for(LockableAccess acc : adjustments)
				acc.unlock();
		}
	}
		
	public void Access.plugInNewAccess(Access newacc) throws RefactoringException {
		if(isLeftChildOfDot()) {
			Access right = parentDot().getRight();
			Expr p = nestedScope();
			p.replaceWith(newacc.qualifiesAccess(right));
		} else {
			this.unqualifiedScope().replaceWith(newacc);
		}
	}

}
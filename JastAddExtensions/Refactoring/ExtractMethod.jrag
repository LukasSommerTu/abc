import changes.*;

aspect ExtractMethod {
	
	public java.util.List CompilationUnit.extract(String name, Stmt begin, Stmt end) throws RefactoringException {
		check_extraction_preconds(name, begin, end);
		Block begin_host = begin.hostBlock();
		BodyDecl bd = begin_host.hostBodyDecl();
		boolean static_ctxt = false;
		if(bd instanceof StaticInitializer)
			static_ctxt = true;
		if(bd instanceof MethodDecl && ((MethodDecl)bd).isStatic())
			static_ctxt = true;
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		java.util.List changes = new java.util.Vector();
		begin_host.encapsulate(changes, name, begin_idx, end_idx, static_ctxt);
		return changes;
	}
	
	private void CompilationUnit.check_extraction_preconds(String name, Stmt begin, Stmt end)
		throws RefactoringException {
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		Block begin_host = begin.hostBlock();
		Block end_host = end.hostBlock();
		if(begin.isInitOrUpdateStmt() || end.isInitOrUpdateStmt())
			throw new RefactoringException("selection cannot start or end at init or update statements");
		if(!begin.dominates(end))
			throw new RefactoringException("begin must dominate end");
		if(!end.post_dominates(end))
			throw new RefactoringException("end must post-dominate begin");
		if(begin_host == null || end_host == null)
			throw new RefactoringException("invalid statement for extraction");
		if(begin_host != end_host)
			throw new RefactoringException("selection straddles block borders");
		for(int i=begin_idx;i<=end_idx;++i)
			if(begin_host.getStmt(i) instanceof Case)
				throw new RefactoringException("selection cannot contain case labels");
	}
	
	public void Block.encapsulate(java.util.List changes, String name, 
				int begin, int end, boolean static_ctxt) 
			throws RefactoringException {
		Stmt begin_stmt = getStmt(begin);
		Stmt end_stmt = getStmt(end);
		Collection parms = new ArrayList();        // parameters of extracted method
		Collection localVars = new ArrayList();    // local variables of extracted method
		Opt ret = new Opt();                       // what extracted method returns
		Collection savedVars = new ArrayList();    // declarations that need to be inserted before
										           // call to extracted method
		Collection toBeRemoved = new ArrayList();  // declarations that should be removed after
										           // extracting the method
		Set exns = Set.empty();                    // the set of exceptions thrown by
												   // the selection
		Collection visibleDecls = begin_stmt.visibleLocalDecls();
		visibleDecls.addAll(localDeclsBetween(begin, end));
		analyseDeclarations(visibleDecls, begin_stmt, end_stmt, parms, localVars, ret, savedVars, toBeRemoved);
		exns = uncaughtThrowsBetween(begin_stmt, end_stmt);
		Collection bodystmts = new ArrayList();
		for(int i=begin;i<=end;++i)
			bodystmts.add(getStmt(i));
		// create declaration of method
		MethodDecl md = createMethod(static_ctxt, name, parms, ret, exns, localVars, bodystmts);
		// prepare new block body
		Collection stmts = new ArrayList();
		int i;
		for(i=0;i<begin;++i) {
			Stmt s = getStmt(i);
			if(!toBeRemoved.contains(s))
				stmts.add(s);
		}
		for(Iterator iter=savedVars.iterator();iter.hasNext();)
			stmts.add((Stmt)iter.next());
		List args = new List();
		for(Iterator iter=parms.iterator();iter.hasNext();)
			args.add(new VarAccess(((LocalDeclaration)iter.next()).getID()));
		MethodAccess ma = new MethodAccess(name, args);
		// add it as an expression statement, or with an assignment
		if(ret.isEmpty())
			stmts.add(new ExprStmt(ma));
		else {
			LocalDeclaration ld = (LocalDeclaration)ret.getChild(0);
			stmts.add(new ExprStmt(new AssignSimpleExpr(new VarAccess(ld.getID()), ma)));
		}
		// NB: no statements need to be removed after the selection
		for(i=end+1;i<getNumStmt();++i)
			stmts.add(getStmt(i));
		// now record changes to be made
		TypeDecl td = hostBodyDecl().hostType();
		// kludge: method decl needs a parent so we can compute its signature
		md.setParent(td);
		String sig = md.signature();
		md.setParent(null);
		td.addMethod(changes, md, sig, false);
		changes.add(new BlockBodyChange(this, stmts));
	}
	
	private void Block.analyseDeclarations(Collection decls, Stmt begin_stmt, Stmt end_stmt,
			Collection parms, Collection localVars, Opt ret, Collection savedVars, 
			Collection toBeRemoved) throws RefactoringException {
		for(Iterator i=decls.iterator();i.hasNext();) {
			LocalDeclaration decl = (LocalDeclaration)i.next();
			if(decl.isValueParmFor(begin_stmt, end_stmt))
				parms.add(decl.asParameterDeclaration());
			if(decl.isOutParmFor(begin_stmt, end_stmt)) {
				if(!ret.isEmpty())
					throw new RefactoringException("ambiguous return value");
				ret.setChild(((ASTNode)decl).fullCopy(), 0);
			}
			if(decl.shouldMoveInto(begin_stmt, end_stmt)) {
				localVars.add(decl.asVariableDeclaration());
				if(!decl.accessedOutside(begin_stmt, end_stmt) 
						&& decl instanceof VariableDeclaration)
					toBeRemoved.add((ASTNode)decl);
			}
			if(decl.shouldMoveOutOf(begin_stmt, end_stmt) || 
					(decl.shouldDuplicate(begin_stmt, end_stmt) && 
							((Stmt)decl).between(begin_stmt, end_stmt)))
				savedVars.add(decl.asVariableDeclaration());
		}
	}
	
	private MethodDecl Block.createMethod(boolean static_ctxt, String name, 
			Collection parms, Opt ret, 
			Set exns, Collection localVariables, Collection stmts) {
		// modifiers: "private", perhaps with a "static"
		Modifiers mod = new Modifiers();
		mod.addModifier(new Modifier("private"));
		if(static_ctxt)
			mod.addModifier(new Modifier("static"));
		// type access: either "void" or the type of the variable to be assigned to
		Access acc;
		if(ret.isEmpty()) {
			acc = new TypeAccess("void");
		} else {
			LocalDeclaration decl = (LocalDeclaration)ret.getChild(0);
			acc = (Access)decl.getTypeAccess().fullCopy(); 
		}
		// parameter declarations
		List parmdecls = new List();
		for(Iterator i=parms.iterator();i.hasNext();)
			parmdecls.add((ASTNode)i.next());
		// brackets
		// TODO: not implemented
		List brackets = new List();
		// thrown exceptions
		List throwdecls = new List();
		for(Iterator i=exns.iterator();i.hasNext();)
			// TODO: it's not that simple; we need to use accessType here
			throwdecls.add(new TypeAccess(((ThrowStmt)i.next()).getExpr().type().name()));
		// body
		List bodystmts = new List();
		for(Iterator i=localVariables.iterator();i.hasNext();)
			bodystmts.add((ASTNode)i.next());
		for(Iterator i=stmts.iterator();i.hasNext();)
			bodystmts.add((ASTNode)i.next());
		if(!ret.isEmpty()) {
			LocalDeclaration decl = (LocalDeclaration)ret.getChild(0);
			String varname = decl.getID();
			ReturnStmt stmt = new ReturnStmt(new VarAccess(varname));
			bodystmts.add(stmt);
		}
		Block body = new Block(bodystmts);
		return new MethodDecl(mod, acc, name, parmdecls, brackets, throwdecls, new Opt(body));
	}
	
}
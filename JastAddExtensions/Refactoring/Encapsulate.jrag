/*
 * Encapsulate a field:
 *   1. generate getter and setter methods for the field
 *   2. make the field private
 *   3. adjust all references to the field to use the newly provided methods
 */

aspect Encapsulate {

	public void FieldDeclaration.encapsulate() throws RefactoringException {
		Modifiers mod = getModifiers();
		String ucase_id = capitalize(getID());
		String getter_name = "get"+ucase_id;
		String setter_name = "set"+ucase_id;
		java.util.Set uses = uses();
		hostType().addMethod(makeGetter(getter_name, mod), false, false, false);
		hostType().addMethod(makeSetter(setter_name, mod), false, false, false);
		makePrivate();
		for(Iterator i = uses.iterator(); i.hasNext();) {
			VarAccess va = (VarAccess)i.next();
			va.encapsulate(getter_name, setter_name);
		}
	}

	private MethodDecl FieldDeclaration.makeGetter(String getter_name, Modifiers mod) {
		Block getter_body = new Block();
		getter_body.addStmt(new ReturnStmt(new VarAccess(getID())));
		return new MethodDecl((Modifiers)mod.fullCopy(), (Access)getTypeAccess().fullCopy(),
				getter_name, new List(), new List(), 
				new List(), new Opt(getter_body));
	}

	private MethodDecl FieldDeclaration.makeSetter(String setter_name, Modifiers mod) {
		Access fieldacc = new ThisAccess("this").qualifiesAccess(new VarAccess(getID()));
		Access parmacc = new VarAccess(getID());
		Block setter_body = new Block();
		setter_body.addStmt(new ReturnStmt(new AssignSimpleExpr(fieldacc, parmacc)));
		ParameterDeclaration pd = new ParameterDeclaration((Access)getTypeAccess().fullCopy(), getID());
		List parms = new List();
		parms.add(pd);
		return new MethodDecl((Modifiers)mod.fullCopy(), (Access)getTypeAccess().fullCopy(),
				setter_name, parms, new List(), new List(), 
				new Opt(setter_body));
	}

	// adjust a var access to use getter or setter; we need to travel upwards through
	// the AST to find out whether this access is on the left or right hand side of
	// an assignment, and what its surrounding context is
	public void VarAccess.encapsulate(String getter, String setter) {
		Context ctxt = new Context();
		ASTNode ch = this;
		for(ASTNode p=getParent();p!=null&&p instanceof Expr;ch=p,p=p.getParent()) {
			if(p instanceof AssignExpr) {
				Expr rhs = ((AssignExpr)p).getSource();
				Binary implicit_op = ((AssignExpr)p).getImplicitOperator();
				// assignments like a += b are rewritten to a = a + b
				if(implicit_op == null) {
					List args = new List();	args.add(rhs);
					p.replaceWith(ctxt.plugIn(new MethodAccess(setter, args)));
				} else {
					/* TODO: this is dangerous; we copy a subtree in which there
					 *       might be pending adjustments */
					Context ctxt2 = ctxt.fullCopy();
					List args = new List();
					implicit_op.setLeftOperand((Expr)ctxt2.plugIn(new MethodAccess(getter, new List())));
					implicit_op.setRightOperand(rhs);
					args.add(implicit_op);
					p.replaceWith(ctxt.plugIn(new MethodAccess(setter, args)));
				}
			} else if(p instanceof PostDecExpr) {
				// i-- becomes (setI(getI()-1) == 0 ? getI()+1 : getI()+1)
				encapsulate_postfix(p, ctxt, getter, setter, 
						new SubExpr(), new AddExpr());
			} else if(p instanceof PostIncExpr) {
				encapsulate_postfix(p, ctxt, getter, setter, 
						new AddExpr(), new SubExpr());
			} else if(p instanceof PreDecExpr) {
				// --i becomes setI(getI()-1)
				encapsulate_prefix(p, ctxt, getter, setter, new SubExpr());
			} else if(p instanceof PreIncExpr) {
				encapsulate_prefix(p, ctxt, getter, setter, new AddExpr());
			} else if(p instanceof ParExpr) {
				ctxt.wrapIn(p, 0);
				continue;
			} else if(p instanceof AbstractDot && ch == ((AbstractDot)p).getRight()) {
				ctxt.wrapIn(p, 1);
				continue;
			} else {
				replaceWith(new MethodAccess(getter, new List()));
				return;
			}
		}
	}
	
	/*
	 * postfix in- and decrements are tricky, since we need to modify the field's
	 * value and return the _old_ value
	 * 
	 * we use a hack here: i++ is rewritten to (++i == 0 ? i-1 : i-1); the comparison
	 * with 0 has no special significance, we only need it to build the expression
	 */
	static void VarAccess.encapsulate_postfix(ASTNode p, 
			Context ctxt, String getter, String setter, Binary rator, Binary undo) {
		List args = new List();
		Expr getacc = (Expr)ctxt.fullCopy().plugIn(new MethodAccess(getter, new List()));
		rator.setLeftOperand((Expr)getacc.fullCopy());
		rator.setRightOperand(new IntegerLiteral(1));
		args.add(rator);
		undo.setLeftOperand((Expr)getacc.fullCopy());
		undo.setRightOperand(new IntegerLiteral(1));
		Expr setacc = (Expr)ctxt.fullCopy().plugIn(new MethodAccess(setter, args));
		p.replaceWith(
				new ParExpr(
						new ConditionalExpr(new EQExpr(setacc, new IntegerLiteral(0)),
								(Expr)undo.fullCopy(), (Expr)undo.fullCopy())));
	}
	
	/*
	 * prefixes are easier: ++i becomes setI(getI()+1)
	 */
	static void VarAccess.encapsulate_prefix(ASTNode p,
			Context ctxt, String getter, String setter, Binary rator) {
		List args = new List();
		Expr getacc = (Expr)ctxt.fullCopy().plugIn(new MethodAccess(getter, new List()));
		rator.setLeftOperand(getacc);
		rator.setRightOperand(new IntegerLiteral(1));
		args.add(rator);
		p.replaceWith(ctxt.plugIn(new MethodAccess(setter, args)));
	}
	
	syn Binary AssignExpr.getImplicitOperator() = null;
	eq AssignMinusExpr.getImplicitOperator() { return new SubExpr(); }
	eq AssignPlusExpr.getImplicitOperator() { return new AddExpr(); }
	eq AssignAndExpr.getImplicitOperator() { return new AndBitwiseExpr(); }
	eq AssignOrExpr.getImplicitOperator() { return new OrBitwiseExpr(); }
	eq AssignXorExpr.getImplicitOperator() { return new XorBitwiseExpr(); }
	eq AssignDivExpr.getImplicitOperator() { return new DivExpr(); }
	eq AssignModExpr.getImplicitOperator() { return new ModExpr(); }
	eq AssignMulExpr.getImplicitOperator() { return new MulExpr(); }
	eq AssignLShiftExpr.getImplicitOperator() { return new LShiftExpr(); }
	eq AssignRShiftExpr.getImplicitOperator() { return new RShiftExpr(); }
	eq AssignURShiftExpr.getImplicitOperator() { return new URShiftExpr(); }

}
/*
 * Encapsulate a field:
 *   1. generate getter and setter methods for the field
 *   2. make the field private
 *   3. adjust all references to the field to use the newly provided methods
 */

aspect Encapsulate {

	public void FieldDeclaration.encapsulate() throws RefactoringException {
		Collection uses = uses();
		AdjustmentTable table = new AdjustmentTable();
		Accessors accessors = new Accessors(this);
		makePrivate();
		RefactoringException rfe;
		for(Iterator i = uses.iterator(); i.hasNext();) {
			VarAccess va = (VarAccess)i.next();
			rfe = va.encapsulate(va, accessors, table);
			if(rfe != null)
				throw rfe;
		}
		programRoot().clear();
		table.adjust();
	}

	inh RefactoringException VarAccess.encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table);

	eq Program.getChild().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl getter = accessors.accessor("ASTNode");
			Access nacc = new MethodAccess(getter.getID(), new List());
			acc.replaceWith(nacc);
			table.add(nacc, getter);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}
	
	eq AssignExpr.getDest().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor(this.getClass().getSimpleName());
			List args = new List();
			args.add(getSource());
			Access nacc = new MethodAccess(setter.getID(), args);
			acc.replaceWith(nacc);
			replaceWithStripped(getDest());
			table.add(nacc, setter);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}
	
	eq PostfixExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor(this.getClass().getSimpleName());
			Access nacc = new MethodAccess(setter.getID(), new List());
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc, setter);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	eq PreDecExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor("PreDecExpr");
			Access nacc = new MethodAccess(setter.getID(), new List());
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc, setter);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	eq PreIncExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor("PreIncExpr");
			Access nacc = new MethodAccess(setter.getID(), new List());
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc, setter);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	/* [m.replaceWithStripped(n)] replaces node [m] with node [n], but if
	 * [m]'s parent is an expression statement, then any parentheses surrounding
	 * [n] are stripped off first (otherwise the result would not be valid Java) */
	public void ASTNode.replaceWithStripped(ASTNode n) {
		if(getParent() instanceof ExprStmt && n instanceof ParExpr)
			replaceWithStripped(((ParExpr)n).getExpr());
		else
			replaceWith(n);
	}
	
	class Accessors {
		public static final int ACC_GET = 0;
		public static final int ACC_SET = 1;
		public static final int ACC_ASSIGN_PLUS = 2;
		public static final int ACC_ASSIGN_MINUS = 3;
		public static final int ACC_ASSIGN_AND = 4;
		public static final int ACC_ASSIGN_OR = 5;
		public static final int ACC_ASSIGN_XOR = 6;
		public static final int ACC_ASSIGN_DIV = 7;
		public static final int ACC_ASSIGN_MOD = 8;
		public static final int ACC_ASSIGN_MUL = 9;
		public static final int ACC_ASSIGN_LSHIFT = 10;
		public static final int ACC_ASSIGN_RSHIFT = 11;
		public static final int ACC_ASSIGN_URSHIFT = 12;
		public static final int ACC_POSTINC = 13;
		public static final int ACC_POSTDEC = 14;
		public static final int ACC_PREINC = 15;
		public static final int ACC_PREDEC = 16;
		private String fieldName;
		private Access fieldType;
		private Modifiers fieldMods;
		private TypeDecl hostType;
		private Map methods;
		private SimpleSet used;
		
		public Accessors(FieldDeclaration field) throws RefactoringException {
			this.fieldName = field.getID();
			this.fieldType = field.getTypeAccess();
			this.fieldMods = field.getModifiers();
			this.hostType = field.hostType();
			methods = new HashMap();
			used = SimpleSet.emptySet;
			initMethods();
			accessor("ASTNode");
			if(!field.isFinal())
				accessor("AssignSimpleExpr");
		}
		
		private void initMethods() {
			methods.put("ASTNode", makeGetter());
			methods.put("AssignSimpleExpr", makeSetter(new AssignSimpleExpr(), "set"));
			methods.put("AssignPlusExpr", makeSetter(new AssignPlusExpr(), "assignPlus"));
			methods.put("AssignMinusExpr", makeSetter(new AssignMinusExpr(), "assignSub"));
			methods.put("AssignAndExpr", makeSetter(new AssignAndExpr(), "assignAnd"));
			methods.put("AssignOrExpr", makeSetter(new AssignOrExpr(), "assignOr"));
			methods.put("AssignXorExpr", makeSetter(new AssignXorExpr(), "assignXor"));
			methods.put("AssignDivExpr", makeSetter(new AssignDivExpr(), "assignDiv"));
			methods.put("AssignModExpr", makeSetter(new AssignModExpr(), "assignMod"));
			methods.put("AssignMulExpr", makeSetter(new AssignMulExpr(), "assignMul"));
			methods.put("AssignLShiftExpr", makeSetter(new AssignLShiftExpr(), "assignLShift"));
			methods.put("AssignRShiftExpr", makeSetter(new AssignRShiftExpr(), "assignRShift"));
			methods.put("AssignURShiftExpr", makeSetter(new AssignURShiftExpr(), "assignURShift"));
			methods.put("PostIncExpr", makeCrement(new PostIncExpr(), "postInc"));
			methods.put("PostDecExpr", makeCrement(new PostDecExpr(), "postDec"));
			methods.put("PreIncExpr", makeCrement(new PreIncExpr(), "preInc"));
			methods.put("PreDecExpr", makeCrement(new PreDecExpr(), "preDec"));
		}
		
		private MethodDecl makeGetter() {
			String getter_name = "get"+ASTNode.capitalize(fieldName);
			Block getter_body = new Block();
			getter_body.addStmt(new ReturnStmt(new VarAccess(fieldName)));
			return new MethodDecl((Modifiers)fieldMods.fullCopy(), 
					(Access)fieldType.fullCopy(),
					getter_name, new List(), 
					new List(), new Opt(getter_body));
		}
		
		private MethodDecl makeSetter(AssignExpr assign, String name_prefix) {
			String setter_name = name_prefix+ASTNode.capitalize(fieldName);
			Access fieldacc = 
				new ThisAccess("this").qualifiesAccess(new VarAccess(fieldName));
			Access parmacc = new VarAccess(fieldName);
			Block setter_body = new Block();
			assign.setDest(fieldacc);
			assign.setSource(parmacc);
			setter_body.addStmt(new ReturnStmt(assign));
			ParameterDeclaration pd = 
				new ParameterDeclaration((Access)fieldType.fullCopy(), fieldName);
			List parms = new List();
			parms.add(pd);
			return new MethodDecl((Modifiers)fieldMods.fullCopy(), 
					(Access)fieldType.fullCopy(),
					setter_name, parms, new List(), 
					new Opt(setter_body));
		}
		
		private MethodDecl makeCrement(Expr expr, String name_prefix) {
			String mname = name_prefix+ASTNode.capitalize(fieldName);
			Block getter_body = new Block();
			expr.setChild(new VarAccess(fieldName), 0);
			getter_body.addStmt(new ReturnStmt(expr));
			return new MethodDecl((Modifiers)fieldMods.fullCopy(), 
					(Access)fieldType.fullCopy(),
					mname, new List(),  
					new List(), new Opt(getter_body));
		}
		
		public MethodDecl accessor(String classname) throws RefactoringException {
			if(used.contains(classname)) {
				return (MethodDecl)methods.get(classname);
			} else {
				used = used.add(classname);
				MethodDecl md = (MethodDecl)methods.get(classname);
				if(md == null)
					throw new RefactoringException("no accessor for "+classname);
				hostType.addMethod(md, false, false, false);
				return md;
			}
		}

	}

}
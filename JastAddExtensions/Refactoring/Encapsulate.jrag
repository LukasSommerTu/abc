/*
 * Encapsulate a field:
 *   1. generate getter and setter methods for the field
 *   2. make the field private
 *   3. adjust all references to the field to use the newly provided methods
 */

aspect Encapsulate {

	public void FieldDeclaration.encapsulate() throws RefactoringException {
		Modifiers mod = getModifiers();
		String ucase_id = capitalize(getID());
		String getter_name = "get"+ucase_id;
		String setter_name = "set"+ucase_id;
		MethodDecl getter = makeGetter(getter_name, mod);
		MethodDecl setter = makeSetter(setter_name, mod);
		Collection uses = uses();
		AdjustmentTable table = new AdjustmentTable();
		hostType().addMethod(getter, false, false, false);
		if(!isFinal())
			hostType().addMethod(setter, false, false, false);
		makePrivate();
		for(Iterator i = uses.iterator(); i.hasNext();) {
			VarAccess va = (VarAccess)i.next();
			va.encapsulate(getter, setter, table);
		}
		programRoot().clear();
		table.adjust();
	}

	private MethodDecl FieldDeclaration.makeGetter(String getter_name, Modifiers mod) {
		Block getter_body = new Block();
		getter_body.addStmt(new ReturnStmt(new VarAccess(getID())));
		return new MethodDecl((Modifiers)mod.fullCopy(), (Access)getTypeAccess().fullCopy(),
				getter_name, new List(), new List(), 
				new List(), new Opt(getter_body));
	}

	private MethodDecl FieldDeclaration.makeSetter(String setter_name, Modifiers mod) {
		Access fieldacc = new ThisAccess("this").qualifiesAccess(new VarAccess(getID()));
		Access parmacc = new VarAccess(getID());
		Block setter_body = new Block();
		setter_body.addStmt(new ReturnStmt(new AssignSimpleExpr(fieldacc, parmacc)));
		ParameterDeclaration pd = new ParameterDeclaration((Access)getTypeAccess().fullCopy(), getID());
		List parms = new List();
		parms.add(pd);
		return new MethodDecl((Modifiers)mod.fullCopy(), (Access)getTypeAccess().fullCopy(),
				setter_name, parms, new List(), new List(), 
				new Opt(setter_body));
	}

	// adjust a var access to use getter or setter; we need to travel upwards through
	// the AST to find out whether this access is on the left or right hand side of
	// an assignment, and what its surrounding context is
	public void VarAccess.encapsulate(MethodDecl getter, MethodDecl setter, AdjustmentTable table) 
			throws RefactoringException {
		Context ctxt = new Context();
		ASTNode ch = this;
		ASTNode p = getParent();
		while(p != null && p instanceof Expr) {
			if(p instanceof ParExpr) {
				ctxt.wrapIn(p, 0);
			} else if(p instanceof AbstractDot && ch == ((AbstractDot)p).getRight()) {
				ctxt.wrapIn(p, 1);
			} else {
				break;
			}
			ch = p;
			p = p.getParent();
		}
		if(p instanceof AssignExpr && ch == ((AssignExpr)p).getDest()) {
			Expr rhs = ((AssignExpr)p).getSource();
			Binary implicit_op = ((AssignExpr)p).getImplicitOperator();
			// assignments like a += b are rewritten to a = a + b
			if(implicit_op == null) {
				List args = new List();	args.add(rhs);
				Access macc = new MethodAccess(setter.getID(), args);
				p.replaceWithStripped(ctxt.plugIn(macc));
				table.add(macc, setter);
			} else {
				Context ctxt2 = ctxt.fullCopy();
				List args = new List();
				Access gacc = new MethodAccess(getter.getID(), new List());
				Expr dup_lhs = (Expr)ctxt2.plugIn(gacc);
				if(dup_lhs.mayHaveSideEffects(SimpleSet.emptySet.add(getter.getID())))
					throw new RefactoringException("could lead to duplicate side effects");
				implicit_op.setLeftOperand(dup_lhs);
				implicit_op.setRightOperand(rhs);
				args.add(implicit_op);
				Access sacc = new MethodAccess(setter.getID(), args);
				p.replaceWithStripped(ctxt.plugIn(sacc));
				table.add(gacc, getter);
				table.add(sacc, setter);
			}
		} else if(p instanceof PostDecExpr) {
			// i-- becomes (setI(getI()-1) == 0 ? getI()+1 : getI()+1)
			// unless it is at toplevel, where we can treat it like --i
			if(p.getParent() instanceof Expr)
				encapsulate_postfix(p, ctxt, getter, setter, 
						new SubExpr(), new AddExpr(), table);
			else
				encapsulate_prefix(p, ctxt, getter, setter, new SubExpr(), table);
		} else if(p instanceof PostIncExpr) {
			if(p.getParent() instanceof Expr)
				encapsulate_postfix(p, ctxt, getter, setter, 
						new AddExpr(), new SubExpr(), table);
			else
				encapsulate_prefix(p, ctxt, getter, setter, new AddExpr(), table);
		} else if(p instanceof PreDecExpr) {
			// --i becomes setI(getI()-1)
			encapsulate_prefix(p, ctxt, getter, setter, new SubExpr(), table);
		} else if(p instanceof PreIncExpr) {
			encapsulate_prefix(p, ctxt, getter, setter, new AddExpr(), table);
		} else {
			Access gacc = new MethodAccess(getter.getID(), new List());
			replaceWithStripped(gacc);
			table.add(gacc, getter);
		}
	}
	
	/*
	 * postfix in- and decrements are tricky, since we need to modify the field's
	 * value and return the _old_ value
	 * 
	 * we use a hack here: i++ is rewritten to (++i == 0 ? i-1 : i-1); the comparison
	 * with 0 has no special significance, we only need it to build the expression
	 */
	void VarAccess.encapsulate_postfix(ASTNode p, 
			Context ctxt, MethodDecl getter, MethodDecl setter, 
			Binary rator, Binary undo, AdjustmentTable table) 
			throws RefactoringException {
		List args = new List();
		Access gacc = new MethodAccess(getter.getID(), new List());
		Expr getacc = (Expr)ctxt.fullCopy().plugIn(gacc);
		if(getacc.mayHaveSideEffects(SimpleSet.emptySet.add(getter.getID())))
			throw new RefactoringException("could lead to duplicate side effects");
		rator.setLeftOperand((Expr)getacc.fullCopy());
		rator.setRightOperand(new IntegerLiteral(1));
		args.add(rator);
		undo.setLeftOperand((Expr)getacc.fullCopy());
		undo.setRightOperand(new IntegerLiteral(1));
		Access sacc = new MethodAccess(setter.getID(), args);
		Expr setacc = (Expr)ctxt.fullCopy().plugIn(sacc);
		p.replaceWithStripped(
				new ParExpr(
						new ConditionalExpr(new EQExpr(setacc, new IntegerLiteral(0)),
								(Expr)undo.fullCopy(), (Expr)undo.fullCopy())));
		table.add(gacc, getter);
		table.add(sacc, setter);
	}
	
	/*
	 * prefixes are easier: ++i becomes setI(getI()+1)
	 */
	void VarAccess.encapsulate_prefix(ASTNode p,
			Context ctxt, MethodDecl getter, MethodDecl setter, Binary rator,
			AdjustmentTable table) 
			throws RefactoringException {
		List args = new List();
		Access gacc = new MethodAccess(getter.getID(), new List());
		Expr getacc = (Expr)ctxt.fullCopy().plugIn(gacc);
		if(getacc.mayHaveSideEffects(SimpleSet.emptySet.add(getter.getID())))
			throw new RefactoringException("could lead to duplicate side effects");
		rator.setLeftOperand(getacc);
		rator.setRightOperand(new IntegerLiteral(1));
		args.add(rator);
		Access sacc = new MethodAccess(setter.getID(), args);
		p.replaceWithStripped(ctxt.plugIn(sacc));
		table.add(gacc, getter);
		table.add(sacc, setter);
	}
	
	syn Binary AssignExpr.getImplicitOperator() = null;
	eq AssignMinusExpr.getImplicitOperator() { return new SubExpr(); }
	eq AssignPlusExpr.getImplicitOperator() { return new AddExpr(); }
	eq AssignAndExpr.getImplicitOperator() { return new AndBitwiseExpr(); }
	eq AssignOrExpr.getImplicitOperator() { return new OrBitwiseExpr(); }
	eq AssignXorExpr.getImplicitOperator() { return new XorBitwiseExpr(); }
	eq AssignDivExpr.getImplicitOperator() { return new DivExpr(); }
	eq AssignModExpr.getImplicitOperator() { return new ModExpr(); }
	eq AssignMulExpr.getImplicitOperator() { return new MulExpr(); }
	eq AssignLShiftExpr.getImplicitOperator() { return new LShiftExpr(); }
	eq AssignRShiftExpr.getImplicitOperator() { return new RShiftExpr(); }
	eq AssignURShiftExpr.getImplicitOperator() { return new URShiftExpr(); }
	
	/* [m.replaceWithStripped(n)] replaces node [m] with node [n], but if
	 * [m]'s parent is an expression statement, then any parentheses surrounding
	 * [n] are stripped off first (otherwise the result would not be valid Java) */
	public void ASTNode.replaceWithStripped(ASTNode n) {
		if(getParent() instanceof ExprStmt && n instanceof ParExpr)
			replaceWithStripped(((ParExpr)n).getExpr());
		else
			replaceWith(n);
	}

}
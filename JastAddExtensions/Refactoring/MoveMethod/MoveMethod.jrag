aspect MoveMethod {
	public void MethodDecl.doMove() {
		introduce(LOCKED_NAMES, WITH_STMT, RETURN_VOID, FRESH_VARIABLES, DEMAND_FINAL_MODIFIER);
		move();
		eliminate(RETURN_VOID, FRESH_VARIABLES, WITH_STMT, LOCKED_NAMES, DEMAND_FINAL_MODIFIER);
	}
	
	public void MethodDecl.move() {
		new MoveMethodRefactoring(this).execute();
	}
	
	class MoveMethodRefactoring {
		private MethodDecl method;
		private Variable target;
		private ClassDecl targetClass;
		private MethodDecl movedMethod;
		private VariableDeclaration receiver_decl;
		private Block with_block;
		private Stmt delegation;
		
		public MoveMethodRefactoring(MethodDecl method) {
			this.method = method;
		}
		
		public void execute() {
			checkPreconditions();
			target = method.getParameter(0);
			targetClass = (ClassDecl)target.type();
			createMovedMethod();
			createDelegationCall();
			method.setBlock(new Block(new List<Stmt>().add(delegation)));
			targetClass.lockAllNames();
			targetClass.addBodyDecl(movedMethod);
			method.eliminate(ASTNode.WITH_STMT);
			receiver_decl.inline();
		}

		private void checkPreconditions() {
			if(method.getNumParameter() < 1)
				throw new RefactoringException("no parameter to move into");
			if(!method.getParameter(0).type().isClassDecl())
				throw new RefactoringException("can only move into class");
			if(!method.hostType().fromSource() || 
					!method.getParameter(0).type().fromSource())
				throw new RefactoringException("cannot move inside bytecode");
			if(method.isStatic())
				throw new RefactoringException("cannot move static method (yet)");
			if(!method.hasBlock())
				throw new RefactoringException("cannot move body-less method");
			if(!method.getParameter(0).type().canIntroduceMethod(method))
				throw new RefactoringException("cannot introduce method");
		}

		private void createMovedMethod() {
			Modifiers mods = (Modifiers)method.getModifiers().fullCopy();
			Access rettype = new TypeAccess(method.type());
			String name = method.name();
			List<ParameterDeclaration> parms = new List<ParameterDeclaration>();
			List<Access> qualifiers = new List<Access>();
			addParms(parms, qualifiers);
			for(int i=1;i<method.getNumParameter();++i) {
				ParameterDeclaration oldparm = method.getParameter(i);
				parms.add(new ParameterDeclaration(new TypeAccess(oldparm.type()), oldparm.name()));
			}
			List<Access> exns = new List<Access>();
			for(Access exn : method.getExceptions())
				exns.add(new TypeAccess(exn.type()));
			List<Stmt> stmts = new List<Stmt>();
			receiver_decl = new VariableDeclaration(new TypeAccess(targetClass), target.name(), new ThisAccess("this")); 
			stmts.add(receiver_decl);
			for(VarAccess va : target.allUses())
				va.lock(receiver_decl);
			with_block = method.getBlock();
			with_block.lockAllNames();
			WithStmt with = new WithStmt(qualifiers, with_block);
			stmts.add(with);		
			movedMethod = new MethodDecl(mods, rettype, name, parms, exns, new Opt(new Block(stmts)));		
		}

		// add one parameter for every enclosing instance to the parameter list and a binding
		// to it to the list of qualifiers
		private void addParms(List<ParameterDeclaration> parms, List<Access> quals) {
			for(TypeDecl enc=method.hostType();enc!=null;enc=enc.enclosingType()) {
				String parmname = enc.name().toLowerCase();
				ParameterDeclaration parm = new FreshParameter(new TypeAccess(enc), parmname);
				parm.setDemandFinal();
				parms.insertChild(parm, 0);
				quals.insertChild(new LockedVarAccess(parm), 0);
			}
		}

		private void addArgs(List<Expr> args) {
			for(TypeDecl enc=method.hostType();enc!=null;enc=enc.enclosingType()) {
				if(enc == method.hostType())
					args.insertChild(new ThisAccess("this"), 0);
				else
					args.insertChild(new TypeAccess(enc).qualifiesAccess(new ThisAccess("this")), 0);
			}
		}

		private void createDelegationCall() {
			List<Expr> args = new List<Expr>();
			addArgs(args);
			for(int i=1;i<method.getNumParameter();++i)
				args.add(new VarAccess(method.getParameter(i).name()));
			Expr call = new VarAccess(target.name()).qualifiesAccess(new MethodAccess(method.name(), args));
			delegation = new ReturnStmt(call);
		}
	}
}
aspect UndoASTNodeChildren {
	

	refine AST public void ASTNode.setChild(T node, int i) {
		if (Program.isRecordingUndo()) {
			final ASTNode newChild = node;
			final int index = i;
			final boolean children_null = children == null;
			final int children_length = children == null ? -1 : children.length;
			final int oldNumChildren = numChildren;
			final ASTNode newChild_oldParent = node == null ? null : node.parent;
			final int newChild_oldChildIndex = node == null ? -1 : node.childIndex;
			
			final ASTNode oldChild = index < oldNumChildren ? children[index] : null;
//			final ASTNode oldChild_parent = oldChild != null ? oldChild.parent : null;
//			final int oldChild_childIndex = oldChild != null ? oldChild.childIndex : -1;
			
			Program.addUndoAction(new ASTModification() {
				
				@Override
				public void undo() {
					if (children_null)
						children = null;
					else if (index >= children_length) {
						ASTNode[] c = new ASTNode[children_length];
						System.arraycopy(children, 0, c, 0, children_length);
						children = c;
					}
					if (!children_null && index < oldNumChildren)
						children[index] = oldChild;
					
					// restore parent and child index of old node on this place
					// this shouldn't be necessary, but...
//					if (oldChild != null) {
//						oldChild.parent = oldChild_parent;
//						oldChild.childIndex = oldChild_childIndex;
//					}
					if (newChild != null) {
						newChild.parent = newChild_oldParent;
						newChild.childIndex = newChild_oldChildIndex;
					}
					numChildren = oldNumChildren;
				}
			});
		}
		refined(node, i);
	}
	
	refine ASTNode public void ASTNode.removeChild(int i) {
		if (Program.isRecordingUndo()) {
			final int index = i;
			final boolean children_null = children == null;
			final int children_length = children == null ? -1 : children.length;
			final ASTNode child = children == null ? null : children[index];
			final ASTNode child_parent = child == null ? null : child.parent;
			final int child_childIndex = child == null ? -1 : child.childIndex;
			final int oldNumChildren = numChildren;
			Program.addUndoAction(new ASTModification() {
				@Override
				public void undo() {
					if (!children_null) {
						if (children.length < children_length) {
							ASTNode[] c = new ASTNode[children_length];
							System.arraycopy(children, 0, c, 0, children.length);
							children = c;
						}
						System.arraycopy(children, index, children, index + 1, children_length - index - 1);
						children[index] = child;
						if (child != null) {
							child.childIndex = child_childIndex;
							child.parent = child_parent;
							numChildren = oldNumChildren;
						}
					}
				}
			});
		}
		refined(i);
	}
	
	refine AST public void ASTNode.insertChild(T node, int i) {
		if (Program.isRecordingUndo()) {
			final ASTNode newChild = node;
			final int index = i;
			final boolean children_null = children == null;
			final int children_length = children == null ? -1 : children.length;
			final int oldNumChildren = numChildren;
			final ASTNode newChild_oldParent = node == null ? null : node.parent;
			final int newChild_oldChildIndex = node == null ? -1 : node.childIndex;
			Program.addUndoAction(new ASTModification() {
				
				@Override
				public void undo() {
					if (children_null)
						children = null;
					else {
						ASTNode[] c = new ASTNode[children_length];
						System.arraycopy(children, 0, c, 0, index);
						if (index < children_length)
							System.arraycopy(children, index+1, c, index, children_length - index);
						children = c;
					}
					if (newChild != null) {
						newChild.setParent(newChild_oldParent);
						newChild.childIndex = newChild_oldChildIndex;
					}
					numChildren = oldNumChildren;
				}
			});
		}
		refined(node, i);
	}
	
	
	/*refine PermuteParameters public void ASTNode.permute(int[] perm) {
		Program root = (Program) programRootParentFromField();
		if (root != null && root.isRecordingUndo()) {
			System.out.println("NOT! Recording permute action");
		}
		refined(perm);
	}*/
	
}
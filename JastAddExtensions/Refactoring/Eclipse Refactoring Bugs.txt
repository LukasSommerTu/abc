1. Rename Package Doesn't Check for Name Clashes with Classes

   Test case:
     package p;
     class r { ... }

     package p.q;
     ...

   Eclipse allows renaming package p.q to p.r, which results in
   uncompilable code due to a name clash with class r.

   Reported as bug 208200.

2. Encapsulate Field Doesn't Check for Hiding of Method

   Test case:
     class A {
       void getI(String s) { }
       class C { class B { void m() { getI(""); } } private int i; }
     }

   When encapsulating field C.i, Eclipse generates a getter method
   getI() in class C which shadows the access in method C.B.m() and
   leads to uncompilable code.

   Found by Torbjörn. Reported as bug 209315 (which turned out to be a
   duplicate of bug 194997).

3. Encapsulate Field Doesn't Correctly Diagnose Overloading Problems

   Test case:
     class A {
       public int i;
     }
     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.i = 23; 
	 System.out.println("i == "+a.i);
       }
     }

   This code prints "i == 23", as it should. Now we can encapsulate field
   A.i, yielding the following code:

     class A {
       private int i;
       public void setI(int i) { this.i = i; }
       public int getI() { return i; }
     }

     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.setI(23);
	 System.out.println("i == "+a.getI());
     }

   This code compiles and prints "i == 42". Eclipse doesn't even warn
   of any possible clashes.

   Reported as bug 209316.

4. Encapsulate Field Doesn't Check for Invalid Overloading 
   (closely related to 3)

   Test case:
     class A {
       public int i;
     }
     class B extends A {
       private int getI() { return 42; }
     }

   Encapsulating field A.i generates a public getter method A.getI() which
   cannot be overloaded by B.getI(), resulting in a compiler error. The
   same kind of problem occurs if, say, B.getI() would be declared as having
   return type "float".

   Reported as bug 209317 (which turned out to be a duplicate of bug 194996).
   
5. Push down method does not handle "super" accesses correctly.

   Test case:
   	 class A {
   	   void k() { System.out.println(23); }
   	 }
   	 class B extends A {
   	   void m() { super.k(); }
   	   void k() { System.out.println(42); } 
   	 }
   	 class C extends B {
   	   public static void main(String[] args) {
   	     new C().m();
   	   }
   	 }
   	 
   This prints "23". Pushing down B.m into C just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Found by Torbjörn, reported as bug 211755.
   
6. Push down method does not handle field accesses correctly.

   Test case:
     class A {
       protected int x = 23;
       void m() { System.out.println(x); }
     }
     class B extends A {
       protected int x = 42;
       public static void main(String[] args) {
         new B().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Found by Torbjörn, reported as a comment to bug 211755.
   
7. Push down method does not handle type accesses correctly.

   Test case:
     class A {
       class B { public B() { System.out.println(23); } }
       B m() { return new B(); }
     }
     class C extends A {
       class B { public B() { System.out.println(42); } }
       public static void main(String[] args) {
         new C().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42". A similar issue exists with
   "throws" declarations.
   
   Reported as bug 211859.
   
8. Push down method does not handle private method accesses correctly.

   Test case:
     class A {
       private void k() { System.out.println(23); }
       void m() { k(); }
     }
     class B extends A {
       protected void k() { System.out.println(42); }
       public static void main(String[] args) {
         new B().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Reported as bug 211860.
   
9. Push down method does not check for all possible references to the method being
   pushed.
   
   Test case:
     class A {
       void m() { }
     }
     class B extends A {
       public static void main(String[] args) {
         new A().m();
       }
     }
   
   Pushing down A.m into B does not detect the reference to A.m in B.main, so
   the resulting program fails to compile.
   
   Reported as bug 211861, which turned out to be a duplicate of bug 31862.
   
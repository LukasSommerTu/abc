1. Rename Package Doesn't Check for Name Clashes with Classes

   Test case:
     package p;
     class r { ... }

     package p.q;
     ...

   Eclipse allows renaming package p.q to p.r, which results in
   uncompilable code due to a name clash with class r.

   Reported as bug 208200.

   Same bug in Netbeans and IntelliJ.

2. Encapsulate Field Doesn't Check for Hiding of Method

   Test case:
     class A {
       void getI(String s) { }
       class C { class B { void m() { getI(""); } } private int i; }
     }

   When encapsulating field C.i, Eclipse generates a getter method
   getI() in class C which shadows the access in method C.B.m() and
   leads to uncompilable code.

   Found by Torbjörn. Reported as bug 209315 (which turned out to be a
   duplicate of bug 194997).

   Same bug in Netbeans and IntelliJ.

3. Encapsulate Field Doesn't Correctly Diagnose Overloading Problems

   Test case:
     class A {
       public int i;
     }
     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.i = 23; 
	 System.out.println("i == "+a.i);
       }
     }

   This code prints "i == 23", as it should. Now we can encapsulate field
   A.i, yielding the following code:

     class A {
       private int i;
       public void setI(int i) { this.i = i; }
       public int getI() { return i; }
     }

     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.setI(23);
	 System.out.println("i == "+a.getI());
     }

   This code compiles and prints "i == 42". Eclipse doesn't even warn
   of any possible clashes.

   Reported as bug 209316.

   Same bug in Netbeans and IntelliJ.

4. Encapsulate Field Doesn't Check for Invalid Overloading 
   (closely related to 3)

   Test case:
     class A {
       public int i;
     }
     class B extends A {
       private int getI() { return 42; }
     }

   Encapsulating field A.i generates a public getter method A.getI() which
   cannot be overloaded by B.getI(), resulting in a compiler error. The
   same kind of problem occurs if, say, B.getI() would be declared as having
   return type "float".

   Reported as bug 209317 (which turned out to be a duplicate of bug 194996).

   Same bug in Netbeans and IntelliJ.
   
5. Push down method does not handle "super" accesses correctly.

   Test case:
   	 class A {
   	   void k() { System.out.println(23); }
   	 }
   	 class B extends A {
   	   void m() { super.k(); }
   	   void k() { System.out.println(42); } 
   	 }
   	 class C extends B {
   	   public static void main(String[] args) {
   	     new C().m();
   	   }
   	 }
   	 
   This prints "23". Pushing down B.m into C just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Found by Torbjörn, reported as bug 211755.

   Same bug in Netbeans and IntelliJ.
   
6. Push down method does not handle field accesses correctly.

   Test case:
     class A {
       protected int x = 23;
       void m() { System.out.println(x); }
     }
     class B extends A {
       protected int x = 42;
       public static void main(String[] args) {
         new B().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Found by Torbjörn, reported as a comment to bug 211755.

   Same bug in Netbeans and IntelliJ.
   
7. Push down method does not handle type accesses correctly.

   Test case:
     class A {
       class B { public B() { System.out.println(23); } }
       B m() { return new B(); }
     }
     class C extends A {
       class B { public B() { System.out.println(42); } }
       public static void main(String[] args) {
         new C().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42". A similar issue exists with
   "throws" declarations.
   
   Reported as bug 211859.

   Same bug in Netbeans, but not in IntelliJ.
   
8. Push down method does not handle private method accesses correctly.

   Test case:
     class A {
       private void k() { System.out.println(23); }
       void m() { k(); }
     }
     class B extends A {
       protected void k() { System.out.println(42); }
       public static void main(String[] args) {
         new B().m();
       }
     }
     
   This prints "23". Pushing down A.m into B just moves the method without any
   adjustments, so the resulting program prints "42".
   
   Reported as bug 211860.

   Same bug in Netbeans and IntelliJ.
   
9. Push down method does not check for all possible references to the method being
   pushed.
   
   Test case:
     class A {
       void m() { }
     }
     class B extends A {
       public static void main(String[] args) {
         new A().m();
       }
     }
   
   Pushing down A.m into B does not detect the reference to A.m in B.main, so
   the resulting program fails to compile.
   
   Reported as bug 211861, which turned out to be a duplicate of bug 31862.

   Same bug in Netbeans, but not in IntelliJ.
   
10. Renaming a local variable does not check for hiding by field of anonymous class.

	Test case:
  	  public class A {
		Object m() {
		  final int i = 23;
		  return new Object() {
			int j = 42;
			public String toString() {
			  return i+"";
			}
		  };
		}
		public static void main(String[] args) {
		  System.out.println(new A().m());
		}
	  }

	This prints "23". Renaming the local variable i in method A.m to j does not
	notice that the reference in the anonymous class' toString() method will now
	refer to the field j, so the resulting program prints "42".
	
	Reported as bug 213144.
	
11. Renaming an inner class in a supertype can lead to confusion.

	Test case:
	  class A {
	    static class B {
	      static int x = 42;
	    }
	  }
	  
	  public class D {
	    static class C extends A {
	      static int x = 23;
	      static int m() { return C.x; }
	    }
	    public static void main(String[] args) {
	      System.out.println(C.m());
	    }
	  }
	  
	This prints "23". Renaming the class B inside A to C does not notice that the
	reference C.x will now refer to A.C.x instead of D.C.x, so the resulting
	program prints "42".
	
12. Shadowing of a statically imported method or field due to renaming is not recognised.

	Test case:
	  import static java.lang.String.*;

	  public class D {
	    static String m(int i) { return "42"; }
	    public static void main(String[] args) {
		  System.out.println(valueOf(23));
	    }
	  }	
	  
	This prints "23". Renaming the method D.m to valueOf shadows the statically
	imported method String.valueOf, so the resulting program prints "42".
	
13. Liveness analysis in Extract Method is not precise enough.

    Test case:
      public class A {
        void m() {
	  	  int y;
		  int z;
		  try {
			if(3==3)
			  y = 1;
			else
			  throw new Exception("boo");
		  } catch(Throwable t) {
			y=2;
		  }
		  z=y;
		}
	  }
	  
	If we extract the try statement and the following assignment into a method,
	Eclipse infers the local variable y to be live and passes it as a parameter to the
	newly created method. In fact, however, y is not live, so the resulting code
	does not compile due to a violation of the definite assignment restriction.

Just to be fair, here is a test case where Eclipse refuses to refactor, whereas
Netbeans walks into the trap:

	public class A {
	    class C extends Throwable { public C() { System.out.println(42); } }
	    
	    void m() throws Throwable {
	        class C extends Throwable { public C() { System.out.println(23); } }
	        throw new C();
	    }
	
	    public static void main(String[] args) {
	        try {
	            new A().m();
	        } catch (Throwable e) { }
	    }
	}

	Extracting the statement "throw new C();" in A.m is refused by Eclipse,
	whereas Netbeans obliges, adding a spurious "import C;" statement at the beginning
	of the compilation unit, which is not even valid Java.
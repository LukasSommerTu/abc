aspect InlineAssignment {
	
	public void AssignSimpleExpr.inline() throws RefactoringException {
		if(!(getParent() instanceof ExprStmt) || !(getParent().getParent().getParent() instanceof Block))
			throw new RefactoringException("cannot inline that sort of assignment");
		Stmt stmt = (Stmt)getParent();
		Block block = (Block)stmt.getParent().getParent();
		if(!(getDest() instanceof VarAccess))
			throw new RefactoringException("LHS is not a simple variable");
		VarAccess v = (VarAccess)getDest();
		if(!v.decl().isLocalVariable())
			throw new RefactoringException("can only inline assignment to local variable");
		makeConversionExplicit();
		Expr rhs = getSource();
		SmallSet<VarAccess> dsuccs = v.dataSucc();
		// check that all the data successors have this as their only data predecessor and are not destinations
		// and replace them by copies of the RHS
		AdjustmentTable table = new AdjustmentTable();
		for(VarAccess w : dsuccs) {
			rhs.lockAllDFlow(table);
			rhs.lockAllAccesses(table);
			if(w.isDest())
				throw new RefactoringException("cannot inline into destinations");
			if(!w.hasSingleDataPred(v))
				throw new RefactoringException("ambiguous dataflow");
			// TODO: should we parenthesise?
			w.replaceWith(rhs);
			setSource(rhs = (Expr)rhs.fullCopy());
		}
		// delete assignment
		block.removeStmt(stmt);
		block.programRoot().flushCaches();
		table.adjust();
	}
	
	public boolean VarAccess.hasSingleDataPred(ASTNode node) {
		Iterator<ASTNode> dpreds = dataPred().iterator();
		return dpreds.hasNext() && dpreds.next() == node && !dpreds.hasNext();
	}
	
	public void AssignSimpleExpr.makeConversionExplicit() throws RefactoringException {
		if(getDest().type() != getSource().type()) {
			AdjustmentTable table = new AdjustmentTable();
			setSource(new CastExpr(getDest().type().getLockedAccess(table), getSource()));
			programRoot().flushCaches();
			table.adjust();
		}
	}
	
}
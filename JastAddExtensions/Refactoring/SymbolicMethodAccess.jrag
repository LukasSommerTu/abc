aspect SymbolicMethodAccess {
	
	class SymbolicMethodAccess extends SymbolicAccess {
		
		public SymbolicMethodAccess(TypeDecl source, TypeDecl bend, 
									boolean needsQualifier,	MethodDecl target) {
			super(source, bend, needsQualifier, target);
		}

		public SymbolicMethodAccess moveDownTo(TypeDecl td) {
			MethodDecl target = (MethodDecl)this.target;
			bend = td;
			if(!td.localMethods(target.name()).isEmpty())
				needsQualifier = true;
			else if(!needsQualifier)
				source = td;
			return this;
		}
		
		public SymbolicMethodAccess moveInto(TypeDecl td) {
			MethodDecl target = (MethodDecl)this.target;
			if(!td.memberMethods(target.name()).isEmpty())
				needsQualifier = true;
			return this;
		}
		
		public Access computeAccess(NamingContext ctxt, List args) {
			MethodDecl target = (MethodDecl)this.target;
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(ctxt.isStatic()) return null;
				if(source == bend) {
					if(source == ctxt.enclosingType())
						return ma;
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new ThisAccess("this").qualifiesAccess(ma));
					}
				} else if(bend instanceof ClassDecl && 
							source == ((ClassDecl)bend).superclass()) {
					if(bend == ctxt.enclosingType())
						return new SuperAccess("super").qualifiesAccess(ma);
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new SuperAccess("super").qualifiesAccess(ma));
					}
				} else if(target.isStatic()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper == null) return null;
					if(bend == ctxt.enclosingType()) {
						return new ParExpr(new CastExpr(upper, new ThisAccess("this"))).qualifiesAccess(ma);
					} else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return new ParExpr(new CastExpr(upper, outer.qualifiesAccess(new ThisAccess("this")))).
										   qualifiesAccess(ma);
					}
				} else {
					return null;
				}
			} else {
				return ma;
			}
		}
		
		public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
			MethodDecl target = (MethodDecl)this.target;
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(!target.isStatic())
					return null;
				if(ctxt.isStatic())
					return null;
				if(source == bend && source == ctxt.enclosingType())
					return qualifier.qualifiesAccess(ma);
				else if(!qualifier.isTypeAccess()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper != null && bend == ctxt.enclosingType())
						return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
				}
				return null;
			} else {
				return qualifier.qualifiesAccess(ma);
			}
		}	
		
	}

}
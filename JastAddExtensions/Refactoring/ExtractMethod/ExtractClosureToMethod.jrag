aspect ExtractClosureToMethod {
	public MethodDecl AnonymousMethod.extractToMethod(int visibility, String name) {
		TypeDecl typedecl = hostType();
		eliminateOutParams();
		lockAllNames();
		MethodDecl md = asNamedMethod(visibility, name);
		setBlock(new Block(new List()));
		int index = typedecl.getBodyDeclList().getIndexOfChild(hostBodyDecl());
		programRoot().lockMethodNames(name);
		typedecl.getBodyDeclList().insertChild(md, index+1);
		typedecl.flushCaches();
		for(Iterator<MethodDecl> iter=typedecl.localMethodsIterator();iter.hasNext();) {
			MethodDecl md2 = iter.next();
			if(md != md2 && md.signature().equals(md2.signature()))
				throw new RefactoringException("method with same signature exists");
		}
		if(!typedecl.ancestorMethods(md.signature()).isEmpty())
			throw new RefactoringException("extracted method would override or hide other method");
		if(!typedecl.descendantMethods(md.signature()).isEmpty())
			throw new RefactoringException("extracte method would be overridden or hidden by other method");
		replaceWith(md.createLockedAccess(getArgList()));
		return md;
	}

	inh boolean AnonymousMethod.inExplicitConstructorInvocation();
	
	public MethodDecl AnonymousMethod.doExtractToMethod(int visibility, String name) {
		TypeDecl td = hostType();
		MethodDecl md = extractToMethod(visibility, name);
		td.eliminate(LOCKED_NAMES);
		return md;
	}
}
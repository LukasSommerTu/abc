\subsection{\refactoring{Introduce Factory}}
This refactoring introduces a static factory method as a replacement for a given constructor, and updates all uses of the constructor to use this method instead. Implemented in \sourcelink{IntroduceFactory/IntroduceFactory.jrag}.

\begin{algorithm}
\caption{$\refactoring{Introduce Factory}(cd : \type{ConstructorDecl})$}
\begin{algorithmic}[1]
\REQUIRE Java
\ENSURE Java $\cup$ locked names
\medskip
\STATE $f \leftarrow \util{createFactoryMethod}(cd)$
\FORALL{$c \in \{c : \type{ClassInstanceExpr} \mid \util{original}(\util{decl}(c)) = cd \wedge \neg\util{hasTypeDecl}(c)$}
  \STATE $\util{replaceExpr}(c, \type{MethodCall}(\locked{f}, \util{getArgs}(c)))$
\ENDFOR
\end{algorithmic}
\end{algorithm}

We first use \util{createFactoryMethod} to create the factory method corresponding to constructor $cd$ and insert it into the host type of $cd$. The factory method has the same signature as $cd$, but it has its own copies of all type variables of the host type used in $cd$.

Then every class instance expression that uses $cd$ or a parameterised instance of $cd$ and does not have its own anonymous type declaration is replaced by a call to the factory method.

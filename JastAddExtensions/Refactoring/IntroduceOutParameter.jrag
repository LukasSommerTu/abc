aspect IntroduceOutParameter {
	
	public ClosureInvocation ClosureInvocation.introduceOutParameter() throws RefactoringException {
		if(!(getParent() instanceof AssignSimpleExpr))
			return this;
		AssignSimpleExpr parent = (AssignSimpleExpr)getParent();
		if(!(parent.getDest() instanceof VarAccess))
			throw new RefactoringException("cannot introduce non-variable out parameter");
		VarAccess v = (VarAccess)parent.getDest();
		AdjustmentTable table = new AdjustmentTable();
		getBlock().lockAll(table);
		setReturnType(new PrimitiveTypeAccess("void"));
		SimpleSet set = parameterDeclaration(v.name());
		ParameterDeclaration pd;
		if(set.isEmpty()) {
			// check that we can introduce a parameter of this name
			RefactoringException exn = getBlock().acceptLocal(v.name());
			if(exn != null)
				throw exn;
			pd = new ParameterDeclaration(new Modifiers(new List().add(new Modifier("out"))),
										  v.type().getLockedAccess(table),
										  v.name());
			addParameter(pd);
			addArg(new VarAccess(v.name()));
		} else {
			pd = (ParameterDeclaration)set.iterator().next();
			pd.makeOut();
			Expr arg = lookupArg(v.name());
			if(!(arg instanceof VarAccess))
				throw new RefactoringException("not a variable");
			if(arg.type() != v.decl())
				throw new RefactoringException("inconsistent return");
		}
		getBlock().addAssignToReturns(pd, table);
		parent.replaceWith(this);
		programRoot().flushCaches();
		table.adjust();
		return this;
	}
	
	public void ASTNode.addAssignToReturns(Variable v, AdjustmentTable table) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.addAssignToReturns(v, table);
		}
	}
	
	public void ReturnStmt.addAssignToReturns(Variable v, AdjustmentTable table) {
		if(hasResult()) {
			setResult(new AssignSimpleExpr(v.createLockedVarAccess(table), getResult()));
			programRoot().flushCaches();
		}
	}
	
	public void ParameterDeclaration.makeOut() {
		if(isWrite())
			return;
		getModifiers().addModifier(new Modifier("out"));
	}
}
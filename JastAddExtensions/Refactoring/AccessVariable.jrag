import java.util.*;

/*
 * The inherited attribute accessField tries to compute an access to a field. If,
 * for some node n, calling n.accessField(f) yields an access a, then looking up
 * a at node n should yield field f.
 * 
 * For a field named "f", the code will return one of the following
 *   1. a variable access "f" if the field is directly visible
 *   2. a qualified access "this.f", "super.f", or "((A)this).f", if "f" is
 *      visible in this class, its direct superclass, or its ancestor class/interface
 *      "A", respectively
 *   3. a qualified access "A.this.f" or "((B)A.this).f" if "f" is visible in
 *      enclosing class "A", or "A"'s ancestor class "B"
 *   4. null if none of the above works 
 */

aspect AccessVariable {
	
	class SymbolicVarAccess {
		protected Variable target;

		public SymbolicVarAccess(Variable target) {
			this.target = target;
		}
		
		public SymbolicVarAccess protect(ShadowingDetector d) {
			if(d.isShadowed(target))
				return null;
			return this;
		}
		
		public Access getAccess(NamingContext ctxt) {
			if(ctxt.isShadowed(target))	return null;
			return new VarAccess(target.name());
		}
	}

	class SymbolicFieldAccess extends SymbolicVarAccess {
		protected TypeDecl source;
		protected TypeDecl bend;
		protected boolean needsQualifier;

		public SymbolicFieldAccess(TypeDecl source, TypeDecl bend, 
				boolean needsQualifier, Variable decl) {
			super(decl);
			this.source = source;
			this.bend = bend;
			this.needsQualifier = needsQualifier;
		}

		public boolean needsQualifier() { return needsQualifier; }
		public void setNeedsQualifier() { needsQualifier = true; }
		
		public SymbolicVarAccess protect(ShadowingDetector d) {
			if(d.isShadowed(target))
				needsQualifier = true;
			return this;
		}
		
		public Access getAccess(NamingContext ctxt) {
			VarAccess va = new VarAccess(target.name());
			if(needsQualifier || ctxt.isShadowed(target)) {
				if(ctxt.isStatic()) return null;
				if(source == bend) {
					if(source == ctxt.enclosingType())
						return new ThisAccess("this").qualifiesAccess(va);
					else {
						Access outer = ctxt.accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new ThisAccess("this").qualifiesAccess(va));
					}
				} else if(bend instanceof ClassDecl && 
							source == ((ClassDecl)bend).superclass()) {
					if(bend == ctxt.enclosingType())
						return new SuperAccess("super").qualifiesAccess(va);
					else {
						Access outer = ctxt.accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new SuperAccess("super").qualifiesAccess(va));
					}
				} else {
					Access upper = ctxt.accessType(source, false);
					if(upper == null) return null;
					if(bend == ctxt.enclosingType()) {
						return new CastExpr(upper, new ThisAccess("this")).qualifiesAccess(va);
					} else {
						Access outer = ctxt.accessType(bend, false);
						if(outer == null) return null;
						return new ParExpr(new CastExpr(upper, outer.qualifiesAccess(new ThisAccess("this")))).
										qualifiesAccess(va);
					}
				}
			} else {
				return new VarAccess(va);
			}
		}
	}

	inh lazy SymbolicVarAccess TypeDecl.accessVariable(Variable decl);
	inh lazy SymbolicVarAccess BodyDecl.accessVariable(Variable decl);
	inh SymbolicVarAccess Stmt.accessVariable(Variable decl);
	inh lazy SymbolicVarAccess Block.accessVariable(Variable decl);
	inh lazy SymbolicVarAccess ForStmt.accessVariable(Variable decl);
	inh SymbolicVarAccess Expr.accessVariable(Variable decl);
	inh lazy SymbolicVarAccess CatchClause.accessVariable(Variable decl);
	inh SymbolicVarAccess VariableDeclaration.accessVariable(Variable decl);
	inh SymbolicVarAccess ParameterDeclaration.accessVariable(Variable decl);

	eq Program.getChild().accessVariable(Variable decl) = null;

	eq TypeDecl.getBodyDecl(int i).accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessMemberField(decl);
		if(acc != null)	return acc;
		if((inStaticContext() || isStatic()) && decl.isInstanceVariable())
			return null;
		else if(isAnonymous() && inExplicitConstructorInvocation() &&
				decl.isInstanceVariable() && 
				enclosingType().memberFields(decl.name()).contains(decl))
			return null;
		return moveInto(accessVariable(decl));
	}

	// The scope of a parameter of a method is the entire body of the method
	eq MethodDecl.getBlock().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		// A declaration of a method parameter name shadows any other variable declarations
		if(acc != null) return acc;
		// Delegate to other declarations in scope
		return moveInto(accessVariable(decl));
	}

	// A method declaration may only declare one parameter named name
	// This is enforced by a check that the declaration in scope for a declaration is itself
	eq MethodDecl.getParameter().accessVariable(Variable decl) = 
		accessParameterDeclaration(decl);

	eq ConstructorDecl.getBlock().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		return moveInto(accessVariable(decl));
	}

	eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = hostType().accessMemberField(decl); // search members
		if(acc != null && !decl.isInstanceVariable())
			return acc;
		if(hostType().isNestedType() || hostType().isAnonymous())
			return moveInto(hostType().accessVariable(decl));
		return null;
	}

	eq ConstructorDecl.getParameter().accessVariable(Variable decl) =
		accessParameterDeclaration(decl);

	// The scope of a local variable declaration in a block is the rest of
	// the block in which the declaration appears
	eq Block.getStmt(int index).accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessLocalVariableDeclaration(decl, index);
		if(acc != null) return acc;
		return moveInto(accessVariable(decl));
	}

	// The scope of the parameter of an exception handler that is declared in a
	// catch clause of a try statement is the entire block associated with the catch
	eq CatchClause.getBlock().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		return moveInto(accessVariable(decl));
	}

	eq CatchClause.getParameter().accessVariable(Variable decl) = 
		accessParameterDeclaration(decl);

	// The scope of a local variable declared in the ForInit part of the for
	// statement includes all of the following:
	eq ForStmt.getInitStmt().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getCondition().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getUpdateStmt().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getStmt().accessVariable(Variable decl) = localAccess(decl);

	syn lazy SymbolicVarAccess ForStmt.localAccess(Variable decl) {
		SymbolicVarAccess acc = accessLocalVariableDeclaration(decl);
		if(acc != null) return acc;
		return moveInto(accessVariable(decl));
	}

	// Return the first variable declaration named name

	syn lazy SymbolicVarAccess MethodDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i) == decl)
				return new SymbolicVarAccess(decl);
		return null;
	}

	syn lazy SymbolicVarAccess ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i) == decl)
				return new SymbolicVarAccess(decl);
		return null;
	}

	syn lazy SymbolicVarAccess CatchClause.accessParameterDeclaration(Variable decl) = 
		getParameter() == decl ? new SymbolicVarAccess(decl) : null;

	syn lazy SymbolicVarAccess Block.accessLocalVariableDeclaration(Variable decl, int index) {
		for(int i = 0; i<=index; i++)
			if(getStmt(i) == decl)
				return new SymbolicVarAccess(decl);
		return null;
	}

	syn lazy SymbolicVarAccess ForStmt.accessLocalVariableDeclaration(Variable decl) {
		for(int i = 0; i < getNumInitStmt(); i++)
			if(getInitStmt(i) == decl)
				return new SymbolicVarAccess(decl);
		return null;
	}

	eq MethodAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ConstructorAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq SuperConstructorAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ArrayAccess.getExpr().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ArrayTypeWithSizeAccess.getExpr().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ClassInstanceExpr.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);

	eq AbstractDot.getRight().accessVariable(Variable decl) = getLeft().qualifiedAccessVariable(decl);

	eq ParseName.qualifiedAccessVariable(Variable decl) = null;
	eq PackageOrTypeAccess.qualifiedAccessVariable(Variable decl) = null;
	eq AmbiguousAccess.qualifiedAccessVariable(Variable decl) = null;

	// Access control specifies the part of a program where a declared entity can
	// be referred to by a qualified name, field access expression, method
	// invocation expression without a simple name
	syn SymbolicVarAccess Expr.qualifiedAccessVariable(Variable decl) {
		if(type().accessibleFrom(hostType())) {
			SymbolicVarAccess acc = type().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl)) return acc;
		}
		return null;
	}

	eq PackageAccess.qualifiedAccessVariable(Variable decl) = null;

	eq TypeAccess.qualifiedAccessVariable(Variable decl) {
		if(type().accessibleFrom(hostType())) {
			SymbolicVarAccess acc = type().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl) && !decl.isInstanceVariable())
				return acc;
		}
		return null;
	}

	// check whether field is accessible when using this Expr as qualifier
	public boolean Expr.isAccessibleField(Variable decl) {
		return decl instanceof FieldDeclaration && 
				mayAccess((FieldDeclaration)decl);
	}

	syn lazy SymbolicVarAccess TypeDecl.accessMemberField(Variable decl) = 
		accessField(decl);

	syn SymbolicVarAccess TypeDecl.accessLocalField(Variable decl) { 
		for(int i = 0; i < getNumBodyDecl(); i++)
			if(getBodyDecl(i) == decl)
				return new SymbolicFieldAccess(this, this, false, decl);
		return null;
	}

	syn SymbolicVarAccess TypeDecl.accessField(Variable decl) = 
		accessLocalField(decl);
	
	syn boolean Variable.isPrivateField();
	eq FieldDeclaration.isPrivateField() = isPrivate();
	eq VariableDeclaration.isPrivateField() = false;
	eq ParameterDeclaration.isPrivateField() = false;
	
	syn boolean Variable.isAccessibleFrom(TypeDecl td);
	eq FieldDeclaration.isAccessibleFrom(TypeDecl td) = accessibleFrom(td);
	eq VariableDeclaration.isAccessibleFrom(TypeDecl td) = true;
	eq ParameterDeclaration.isAccessibleFrom(TypeDecl td) = true;

	// member fields
	eq ClassDecl.accessField(Variable decl) {
		SymbolicVarAccess acc = accessLocalField(decl);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return moveDownTo(acc);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return moveDownTo(acc);
		}
		return null;
	}

	eq InterfaceDecl.accessField(Variable decl) {
		SymbolicVarAccess acc = accessLocalField(decl);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return moveDownTo(acc);
		}
		return null;
	}
		
	interface LocalScope {
		boolean hasLocalVariable(String name);
	}

	Block implements LocalScope;
	public boolean Block.hasLocalVariable(String name) {
		return localVariableDeclaration(name) != null;
	}
	ConstructorDecl implements LocalScope;
	public boolean ConstructorDecl.hasLocalVariable(String name) {
		return parameterDeclaration(name) != SimpleSet.emptySet;
	}
	MethodDecl implements LocalScope;
	public boolean MethodDecl.hasLocalVariable(String name) {
		return parameterDeclaration(name) != SimpleSet.emptySet;
	}
	CatchClause implements LocalScope;
	public boolean CatchClause.hasLocalVariable(String name) {
		return parameterDeclaration(name) != SimpleSet.emptySet;
	}
	ForStmt implements LocalScope;
	public boolean ForStmt.hasLocalVariable(String name) { 
		return localVariableDeclaration(name) != null;
	}
	
	public Variable Block.localLookupVariable(String name, int index) {
		for(int i=0;i<=index;++i)
			if(getStmt(i) instanceof VariableDeclaration &&
					((VariableDeclaration)getStmt(i)).name().equals(name))
				return (VariableDeclaration)getStmt(i);
		return null;
	}
		
	public SymbolicVarAccess Block.moveInto(SymbolicVarAccess acc, int index) {
		if(acc == null)	return null;
		return acc.protect(getLocalShadowingDetector(index));
	}
		
	public SymbolicVarAccess LocalScope.moveInto(SymbolicVarAccess acc) {
		if(acc == null)	return null;
		return acc.protect(new ShadowingDetector() {
			public boolean isShadowed(PackageAccess pkg) {
				return false;
			}
			public boolean isShadowed(TypeDecl td) {
				return false;
			}
			public boolean isShadowed(Variable v) {
				return hasLocalVariable(v.name());
			}
		});
	}
		
	public SymbolicVarAccess TypeDecl.moveInto(SymbolicVarAccess acc) {
		if(acc == null)
			return null;
		return acc.protect(getShadowingDetector());
	}

	public SymbolicVarAccess TypeDecl.moveDownTo(SymbolicVarAccess acc) {
		if(acc == null)
			return null;
		return acc.protect(getShadowingDetector());
	}
	
	public Access Access.getAccessTo(Variable v) {
		SymbolicVarAccess acc = accessVariable(v);
		if(acc == null) return null;
		return acc.getAccess(getNamingContext());
	}
		
}

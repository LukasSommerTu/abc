aspect ReturnVoid {
	
	/* We extend the language with statements of the form
	 * 
	 *   return e;
	 *   
	 * where e has type void.
	 */
	
	private java.util.Set<ReturnStmt> AdjustmentTable.returnStmts = new java.util.HashSet<ReturnStmt>();
	public void AdjustmentTable.addReturnVoid(ReturnStmt ret) {
		returnStmts.add(ret);
	}

	// replace return void statements by expr stmt + return
	refine ControlFlow public void AdjustmentTable.adjust() throws RefactoringException {
		refined();
		for(ReturnStmt ret : returnStmts) {
			if(ret.hasResult() && ret.type().isVoid()) {
				if(ret.following().equals(ret.returnTarget())) {
					// we don't need a return at all
					ret.replaceWith(new ExprStmt(ret.getResult()));
				} else {
					boolean inBlock = ret.getParent().getParent() instanceof Block;
					if(inBlock) {
						// if we're in a block, simply plug in a return statement
						Block block = (Block)ret.getParent().getParent();
						int idx = block.getIndexOfStmt(ret);
						block.setStmt(new ExprStmt(ret.getResult()), idx);
						block.insertStmt(idx+1, new ReturnStmt());
					} else {
						// otherwise, make a block with a return statement in it
						ret.replaceWith(
								new Block(
										new List().add(
												new ExprStmt(ret.getResult())
										).add(
												new ReturnStmt()
										)
								)
						);
					}
				}
			}
		}
	}

}
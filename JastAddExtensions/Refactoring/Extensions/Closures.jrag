aspect Closures {
	public void ClosureInvocation.toString(StringBuffer s) {
		s.append("(Î» (");
		if(getNumParameter() > 0) {
			getParameter(0).toString(s);
			for(int i = 1; i < getNumParameter(); i++) {
				s.append(", ");
				getParameter(i).toString(s);
			}
		}
		s.append(") : ");
		getReturnType().toString(s);
		if(getNumException() > 0) {
			s.append(" throws ");
			getException(0).toString(s);
			for(int i = 1; i < getNumException(); i++) {
				s.append(", ");
				getException(i).toString(s);
			}
		}
		s.append(" ");
		getBlock().toString(s);
		s.append(")@");
		s.append("(");
		if(getNumArg() > 0) {
			getArg(0).toString(s);
			for(int i = 1; i < getNumArg(); i++) {
				s.append(", ");
				getArg(i).toString(s);
			}
		}
		s.append(")");
	}
	
	public boolean Access.isDeclaredClosureException() {
		if(!(getParent().getParent() instanceof ClosureInvocation))
			return false;
		return ((ClosureInvocation)getParent().getParent()).getExceptions() == getParent();
	}
	
	// equations for some attributes defined elsewhere
	eq ClosureInvocation.getParameter().getBlock() = getBlock();

	eq ClosureInvocation.getParameter().canRenameTo(String new_name) {
		if(!parameterDeclaration(new_name).isEmpty())
			return new RefactoringException("parameter of the same name exists");
		if(!getBlock().canIntroduceLocal(new_name))
			return new RefactoringException("local variable of the same name exists");
		return null;
	}

	// we're not interested in reachability checking for closure invocations
	eq ClosureInvocation.getBlock().reachable() = true;

	eq ClosureInvocation.type() = getReturnType().type();

	// control flow for closure invocations
	inh SmallSet<ASTNode> ClosureInvocation.throwTarget(TypeDecl exn);
	
	// artificial node to represent throws of uncaught exceptions
	private final ExitStmt ClosureInvocation.uncheckedExceptionExit = new ExitStmt();
	syn nta Stmt ClosureInvocation.uncheckedExceptionExit() = uncheckedExceptionExit;
	
	eq ClosureInvocation.first() = getNumArg() == 0 ? getBlock() : getArg(0).first();
	
	syn ASTNode ClosureInvocation.entry() = getBlock();
	syn ASTNode ClosureInvocation.exit() = this;
	
	eq ClosureInvocation.getArg(int i).following() = i < getNumArg()-1 ? singleNode(getArg(i+1).first()) 
			  			  											   : singleNode(getBlock());
	eq ClosureInvocation.getBlock().following() = singleNode(exit());
	eq ClosureInvocation.getReturnType().following() = singleNode(exit());
	eq ClosureInvocation.getException(int i).following() = throwTarget(getException(i).type());
	eq ClosureInvocation.uncheckedExceptionExit().following() = uncheckedExnTarget();

	eq ClosureInvocation.getChild().breakTarget(BreakStmt stmt) = SmallSet.empty();
	eq ClosureInvocation.getChild().continueTarget(ContinueStmt stmt) = SmallSet.empty();
	eq ClosureInvocation.getChild().returnTarget() = singleNode(getReturnType());
	eq ClosureInvocation.getChild().throwTarget(TypeDecl exn) {
		// this selects (somewhat arbitrarily) the left-most matching exception type
		for(Access acc : getExceptions())
			if(exn.instanceOf(acc.type()))
				return singleNode(acc);
		if(exn.isCheckedException())	// JastAddJ's definition of checked/unchecked is confused...
			return singleNode(uncheckedExceptionExit());
		return SmallSet.empty();
	}
	eq ClosureInvocation.getChild().uncheckedExnTarget() = singleNode(uncheckedExceptionExit());

	eq ExitStmt.isPureCFlowNode() = true;
	eq ClosureInvocation.isPureCFlowNode() = true;

	// data flow for closure invocations: parameters are aliased
	public VarAccess ClosureInvocation.unalias(VarAccess var) {
		for(int i=0;i<getNumParameter();++i)
			if(getParameter(i) == var.decl() && getArg(i) instanceof VarAccess)
				return (VarAccess)getArg(i);
		return var;
	}
	public LocalDeclaration ClosureInvocation.unalias(LocalDeclaration decl) {
		for(int i=0;i<getNumParameter();++i)
			if(getParameter(i) == decl && getArg(i) instanceof VarAccess &&
					((VarAccess)getArg(i)).decl() instanceof LocalDeclaration)
				return (LocalDeclaration)((VarAccess)getArg(i)).decl();
		return decl;
	}
	
	eq Block.dataPredFor(VarAccess var) {
		if(getParent() instanceof ClosureInvocation) {
			ClosureInvocation cl = (ClosureInvocation)getParent();
			return super.dataPredFor(cl.unalias(var));
		}
		return super.dataPredFor(var);
	}
	eq ClosureInvocation.dataSuccFor(LocalDeclaration decl) {
		return super.dataSuccFor(unalias(decl));
	}
	eq Access.dataSuccFor(LocalDeclaration decl) {
		if(isDeclaredClosureException()) {
			ClosureInvocation cl = (ClosureInvocation)getParent().getParent();
			return super.dataSuccFor(cl.unalias(decl));
		}
		return super.dataSuccFor(decl);
	}
	eq ExitStmt.dataSuccFor(LocalDeclaration decl) {
		if(getParent() instanceof ClosureInvocation) {
			ClosureInvocation cl = (ClosureInvocation)getParent();
			return super.dataSuccFor(cl.unalias(decl));
		}
		return super.dataSuccFor(decl);
	}
	
	// same for bounded dataflow
	eq Block.hasDataPredBefore(VarAccess var, ASTNode n) {
		if(getParent() instanceof ClosureInvocation) {
			ClosureInvocation cl = (ClosureInvocation)getParent();
			if(this == n)
				return !dataPredFor(cl.unalias(var)).isEmpty();
			return super.hasDataPredBefore(cl.unalias(var), n);
		}
		return super.hasDataPredBefore(var, n);
	}	
	eq ClosureInvocation.hasDataSuccAfter(LocalDeclaration decl, ASTNode n) {
		if(this == n)
			return !dataSuccFor(unalias(decl)).isEmpty();
		return super.hasDataSuccAfter(unalias(decl), n);
	}
	eq Access.hasDataSuccAfter(LocalDeclaration decl, ASTNode n) {
		if(isDeclaredClosureException()) {
			ClosureInvocation cl = (ClosureInvocation)getParent().getParent();
			if(this == n)
				return !dataSuccFor(cl.unalias(decl)).isEmpty();
			return super.hasDataSuccAfter(cl.unalias(decl), n);
		}
		return super.hasDataSuccAfter(decl, n);
	}
	eq ExitStmt.hasDataSuccAfter(LocalDeclaration decl, ASTNode n) {
		if(getParent() instanceof ClosureInvocation) {
			ClosureInvocation cl = (ClosureInvocation)getParent();
			if(this == n)
				return !dataSuccFor(cl.unalias(decl)).isEmpty();
			return super.hasDataSuccAfter(cl.unalias(decl), n);
		}
		return super.hasDataSuccAfter(decl, n);
	}

	// all return statements inside the closure
	syn lazy SmallSet<Stmt> ClosureInvocation.returns() = getReturnType().predStmt();
	// all final, non-return statements inside the closure
	syn lazy SmallSet<Stmt> ClosureInvocation.finals() {
    	SmallSet<Stmt> res = SmallSet.empty();
    	for(ASTNode n : pred()) {
    		if(n == getReturnType())
    			continue;
    		if(n instanceof Stmt) {
    			if(((Stmt)n).canCompleteNormally())
    				res = res.union((Stmt)n);
    		} else {
    			for(Stmt stmt : (SmallSet<Stmt>)n.predStmt())
    				if(stmt.canCompleteNormally())
    					res = res.union(stmt);
    		}
    	}
    	return res;
	}

	// lookup and access is done as for methods
	eq ClosureInvocation.getBlock().lookupVariable(String name) {
		SimpleSet set = parameterDeclaration(name);
		if(!set.isEmpty()) return set;
		return lookupVariable(name);
	}
	eq ClosureInvocation.getParameter().lookupVariable(String name) 
	  = parameterDeclaration(name);
	
	syn SimpleSet ClosureInvocation.parameterDeclaration(String name) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).name().equals(name))
				return (ParameterDeclaration)getParameter(i);
		return SimpleSet.emptySet;
	}
	
	eq ClosureInvocation.getBlock().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}
	eq ClosureInvocation.getParameter().accessVariable(Variable decl) = 
		accessParameterDeclaration(decl);
	
	syn VarAccessInfo ClosureInvocation.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d == decl)
				return new LocalVarAccessInfo(decl);
		return null;
	}
	
	ClosureInvocation implements LocalScope;
	public boolean ClosureInvocation.hasVariable(String name) {
		return parameterDeclaration(name) != SimpleSet.emptySet;
	}	

	syn lazy boolean ParameterDeclaration.isIn()
	  = !isOut() && !isRef();
	syn lazy boolean ParameterDeclaration.isOut() 
	  = getModifiers().numModifier("out") != 0;
	syn lazy boolean ParameterDeclaration.isRef()
	  = getModifiers().numModifier("ref") != 0;
	
	// find argument for parameter
	public Expr ClosureInvocation.lookupArg(String parmname) {
		for(int i = 0; i < getNumParameter(); ++i)
			if(getParameter(i).name().equals(parmname))
				return getArg(i);
		return null;
	}
}
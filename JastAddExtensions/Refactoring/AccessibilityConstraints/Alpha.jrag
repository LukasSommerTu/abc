aspect Alpha {
	// computes minimal access modifier that "this" needs to have in order to be accessible from inside type "type" in package "pkg"
	// "type" may be null, but "pkg" may not
	syn lazy int TypeDecl.minAccess(String pkg, TypeDecl type) {
		if(sourceTypeDecl() != this)
			return sourceTypeDecl().minAccess(pkg, type);
		if(isTopLevelType()) {
			if(this.hostPackage().equals(pkg))
				return ASTNode.VIS_PACKAGE;
		} else if(isMemberType()) {
			BodyDecl bd = (BodyDecl)getParent();
			return bd.minAccess(pkg, type);
		} else {
			// local or anonymous class
			return ASTNode.VIS_PACKAGE;
		}
		return ASTNode.VIS_PUBLIC;
	}
	eq ArrayDecl.minAccess(String pkg, TypeDecl type) = elementType().minAccess(pkg, type);
	
	// see TypeDecl.minAccess(String, TypeDecl)
	syn lazy int BodyDecl.minAccess(String pkg, TypeDecl type) {
		if(type != null && this.hostType().topLevelType() == type.topLevelType())
			return ASTNode.VIS_PRIVATE;
		if(pkg.equals(this.hostType().hostPackage()))
			return ASTNode.VIS_PACKAGE;
		if(type != null && type.withinBodyThatSubclasses(hostType()) != null)
			return ASTNode.VIS_PROTECTED;
		return ASTNode.VIS_PUBLIC;
	}
	eq InstanceInitializer.minAccess(String pkg, TypeDecl type) = -1;
	eq StaticInitializer.minAccess(String pkg, TypeDecl type) = -1;
	
	public int TypeDecl.minAccess(Access acc) { return minAccess(acc.hostPackage(), acc.hostType()); }
	public int BodyDecl.minAccess(Access acc) { return minAccess(acc.hostPackage(), acc.hostType()); }
	
/*	syn lazy int TypeDecl.minAccess(Access acc) {
		if(acc.isQualified()) {
			TypeDecl qualtp = qualifier().type();
			return Math.max(minAccess(qualtp.getPackageDecl(), qualtp), minAccess(acc.hostPackage(), acc.hostType()));
		} else {
			return minAccess(acc.hostPackage(), acc.hostType());
		}
	}
	
	syn lazy int BodyDecl.minAccess(Access acc) {
		if(acc.isQualified()) {
			TypeDecl qualtp = qualifier().type();
			int v = Math.max(minAccess(qualtp.getPackageDecl(), qualtp), minAccess(acc.hostPackage(), acc.hostType()));
			if(v == ASTNode.VIS_PROTECTED && !canAccessAsProtected(acc))
				return ASTNode.VIS_PUBLIC;
			return v;
		} else {
			return minAccess(acc.hostPackage(), acc.hostType());
		}
	}
	
	eq ConstructorDecl.minAccess(Access acc) {
		int v = minAccess(acc.hostPackage(), acc.hostType());
		if(v == ASTNode.VIS_PROTECTED) {
			if(acc instanceof SuperConstructorAccess) {
				return ASTNode.VIS_PROTECTED;
			} else if(acc instanceof ClassInstanceExpr && ((ClassInstanceExpr)acc).hasTypeDecl()) {
				return ASTNode.VIS_PROTECTED;
			} else {
				return ASTNode.VIS_PUBLIC;
			}
		}
		return v;
	}

	// determines whether protected accessibility is enough to access this body declaration from underneath
	// a qualified of type "qualtp" inside type "hosttp"
	syn boolean BodyDecl.canAccessAsProtected(TypeDecl qualtp, TypeDecl hosttp) = true; 
	
	eq FieldDeclaration.canAccessAsProtected(TypeDecl qualtp, TypeDecl hosttp) {
		return isStatic() || qualtp.instanceOf(hosttp);
	}
	
	eq MethodDecl.canAccessAsProtected(Access acc) {
		return isStatic() || qualtp.instanceOf(hosttp);
	}*/
}
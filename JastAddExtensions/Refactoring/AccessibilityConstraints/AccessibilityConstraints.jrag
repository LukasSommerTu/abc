/*
 * This aspect defines classes representing accessibility constraints (AccessibilityConstraint) and the constraint
 * variables/constants that occur in them (AccessModifierConstant, AccessModifierVariable, WithAccessModifier).
 */

aspect AccessibilityConstraints {
	class AccessibilityConstraint {
		// the node which gives rise to this constraint
		private ASTNode node;
		
		// the two sides of the constraint and the operator connecting them
		private WithAccessModifier left, right;
		private Operator op;
		
		public AccessibilityConstraint(ASTNode node, WithAccessModifier left, Operator op, WithAccessModifier right) {
			this.node = node;
			this.left = left;
			this.op = op;
			this.right = right;
			left.referencedBy(this);
			right.referencedBy(this);
		}
		
		// several convenience constructors
		public AccessibilityConstraint(ASTNode node, int left, Visible right) {
			this(node, AccessModifierConstant.fromVisibility(left), Operator.LE, AccessModifierVariable.forVisible(right));
		}
		
		public AccessibilityConstraint(ASTNode node, Visible left, Operator op, int right) {
			this(node, AccessModifierVariable.forVisible(left), op, AccessModifierConstant.fromVisibility(right));
		}
		
		public AccessibilityConstraint(ASTNode node, int left, Operator op, Visible right) {
			this(node, AccessModifierConstant.fromVisibility(left), op, AccessModifierVariable.forVisible(right));
		}
		
		public AccessibilityConstraint(ASTNode node, Visible left, Operator op, WithAccessModifier right) {
			this(node, AccessModifierVariable.forVisible(left), op, right);
		}
		
		public AccessibilityConstraint(ASTNode node, Visible left, Operator op, Visible right) {
			this(node, AccessModifierVariable.forVisible(left), op, AccessModifierVariable.forVisible(right));
		}
		
		// assorted setters and getters
		public boolean fromSource() {
			return node.fromSource();
		}
		
		public ASTNode getNode() {
			return node;
		}
		
		public WithAccessModifier getLeft() {
			return left;
		}
		
		public WithAccessModifier getRight() {
			return right;
		}
		
		public boolean isSolved() {
			return op.eval(left.getAccessModifier(), right.getAccessModifier());
		}
		
		public String toString() {
			return toString(node) + ": " + left + " " + op + " " + right;
		}
		
		public Collection<Visible> referencedVisibles(){
			LinkedList<Visible> res = new LinkedList<Visible>();
			if(left instanceof AccessModifierVariable){
				res.add(((AccessModifierVariable)left).getElement());
			}
			if(right instanceof AccessModifierVariable){
				res.add(((AccessModifierVariable)right).getElement());
			}
			return res;
		}

		// special-purpose pretty printing method for AST nodes that occur in constraints
		public static String toString(ASTNode nd) {
			if(nd instanceof TypeDecl) {
				return ((TypeDecl)nd).fullName();
			}
			if(nd instanceof MethodDecl) {
				MethodDecl md = (MethodDecl)nd;
				return md.hostType().fullName() + "." + md.signature();
			}
			return nd.toString();
		}
	}
	
	
	// abstract supertype for representing both access modifier constants and variables
	abstract class WithAccessModifier {
		public abstract int getAccessModifier();
		public void referencedBy(AccessibilityConstraint constraint){};
		// factory method: a declaration element occurring in a library gives rise to an access modifier
		// constant, otherwise a variable
		public static WithAccessModifier forVisible(Visible vis) {
			if(vis.fromSource())
				return new AccessModifierVariable(vis);
			return AccessModifierConstant.fromVisibility(vis.getVisibility());
		}
	}
	
	class AccessModifierConstant extends WithAccessModifier {
		private int vis;
		
		private AccessModifierConstant(int vis) {
			this.vis = vis;
		}
		
		public int getAccessModifier() {
			return vis;
		}
		
		public static final AccessModifierConstant PRIVATE = new AccessModifierConstant(ASTNode.VIS_PRIVATE);
		public static final AccessModifierConstant PACKAGE = new AccessModifierConstant(ASTNode.VIS_PACKAGE);
		public static final AccessModifierConstant PROTECTED = new AccessModifierConstant(ASTNode.VIS_PROTECTED);
		public static final AccessModifierConstant PUBLIC = new AccessModifierConstant(ASTNode.VIS_PUBLIC);
		
		public static AccessModifierConstant fromVisibility(int vis) {
			switch(vis) {
			case ASTNode.VIS_PRIVATE: return PRIVATE;
			case ASTNode.VIS_PACKAGE: return PACKAGE;
			case ASTNode.VIS_PROTECTED: return PROTECTED;
			case ASTNode.VIS_PUBLIC: return PUBLIC;
			}
			return null;
		}
		
		public String toString() {
			return ASTNode.visibilityToString(vis);
		}
	}
	
	class AccessModifierVariable extends WithAccessModifier {
		private Visible element;
		
		public AccessModifierVariable(Visible element) {
			this.element = element;
		}
		
		public int getAccessModifier() {
			return element.getVisibility();
		}
		
		public Visible getElement() {
			return element;
		}
		
		public String toString() {
			return "visibility(" + AccessibilityConstraint.toString((ASTNode)element) + ")";
		}
		public void referencedBy(AccessibilityConstraint constraint){
			element.referencedBy(constraint);
		}
	}
	
	private Collection<AccessibilityConstraint> ConstructorDecl.referencingAccessibilityConstraints = new HashSet<AccessibilityConstraint>();
	private Collection<AccessibilityConstraint> FieldDeclaration.referencingAccessibilityConstraints = new HashSet<AccessibilityConstraint>();
	private Collection<AccessibilityConstraint> MethodDecl.referencingAccessibilityConstraints = new HashSet<AccessibilityConstraint>();
	private Collection<AccessibilityConstraint> TypeDecl.referencingAccessibilityConstraints = new HashSet<AccessibilityConstraint>();
	public Collection<AccessibilityConstraint> Visible.referencingAccessibilityConstraints(){
		return referencingAccessibilityConstraints;
	}
	public void Visible.referencedBy(AccessibilityConstraint c){
		referencingAccessibilityConstraints.add(c);
	}
}
import java.util.*;

/*
 * The Rename Local Variable refactoring; basic steps are as with Rename Field.
 */

aspect RenameLocalVariable {
	
	// checks that the renaming doesn't lead to a name clash
	private RefactoringException VariableDeclaration.canRenameTo(String new_name) {
		return hostBodyDecl().acceptLocal(new_name);
	}
	
	public void VariableDeclaration.rename(String new_name) throws RefactoringException {
		if(getID().equals(new_name))
			return;
		RefactoringException e = canRenameTo(new_name);
		if(e != null) throw e;
		AdjustmentTable table = find_uses(new_name);
		changeID(new_name);
		programRoot().flushCaches();
		table.adjust();
	}
	
	inh SimpleSet VariableDeclaration.lookupType(String name);
	
	/* in preparation for renaming a variable to new_name, this method finds all
	 * uses of the variable before renaming and all uses of fields, types and
	 * packages that might become shadowed by the renaming and collects them into
	 * an adjustment table */ 
	public AdjustmentTable LocalDeclaration.find_uses(String new_name) {
		AdjustmentTable table = new AdjustmentTable();
		/* first, collect all uses of the variable we are renaming */
		for(Iterator i = uses().iterator(); i.hasNext();) {
			Access acc = (Access)i.next();
			table.add(acc);
		}
		/* now, collect all uses of fields, types, and packages that the variable
		 * might be shadowing after renaming */
		for(Iterator i = lookupVariable(new_name).iterator(); i.hasNext();) {
			Variable v = (Variable)i.next();
			for(Iterator j = v.collectedUses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				table.add(acc);
			}
		}
		for(Iterator i = lookupType(new_name).iterator(); i.hasNext();) {
			TypeDecl d = (TypeDecl)i.next();
			for(Iterator j = d.uses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				// only a type in an ambiguous position can be shadowed by a variable
				if(acc.nameType() == NameType.AMBIGUOUS_NAME)
					table.add(acc);
			}
		}
		PackageDecl pd = programRoot().getPackageDecl(new_name);
		if(pd != null)
			for(Iterator j = pd.prefixUses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				if(acc.nameType() == NameType.AMBIGUOUS_NAME ||
						acc.nameType() == NameType.PACKAGE_OR_TYPE_NAME)
					table.add(acc);
			}
		return table;
	}

}

/* The Remove Unused Method microrefactoring removes a method if it can never be invoked and
 * is never statically bound to, and makes it abstract if it may be statically bound to but
 * can actually never be invoked. */
aspect RemoveUnusedMethod {
	public void MethodDecl.removeUnused(boolean leaveAbstract) {
		if(isCallableFromOutside())
			throw new RefactoringException("method is still used");
		if((leaveAbstract || isReferencedFromOutside()) && canBeAbstract()) {
			if(isAbstract())
				return;
			for(TypeDecl td : inheritingTypes())
				td.makeAbstract();
			setBlockOpt(new Opt());
			getModifiers().addModifier("abstract");
		} else {
			if(!overrides().isEmpty() && allAbstract(overrides()))
				hostType().makeAbstract();
			hostType().removeBodyDecl(this);
		}
	}
	
	// whether this method could be called from outside itself
	syn lazy boolean MethodDecl.isCallableFromOutside() {
		if(isDynamicallyCallable()) {
			for(MethodAccess ma : polyUses())
				if(!ma.isDescendantTo(getBlock()))
					return true;
		} else {
			for(MethodAccess ma : monoUses())
				if(!ma.isDescendantTo(getBlock()))
					return true;
		}
		return false;
	}
	
	// whether this method is referenced from outside itself
	syn lazy boolean MethodDecl.isReferencedFromOutside() {
		for(MethodAccess ma : uses())
			if(!ma.isDescendantTo(getBlock()))
				return true;
		return false;
	}
	
	protected static boolean ASTNode.allAbstract(Collection<MethodDecl> mds) {
		for(MethodDecl md : mds)
			if(!md.isAbstract())
				return false;
		return true;
	}
}
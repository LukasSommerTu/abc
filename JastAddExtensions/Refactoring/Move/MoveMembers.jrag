aspect MoveMembers {
	public void TypeDecl.moveMembers(Collection<MemberDecl> members, TypeDecl target) {
		for(MemberDecl md : members) {
			if(!md.fromSource() || md.isNative())
				throw new RefactoringException("cannot move this member");
			md.makeModifiersExplicit();
			md.moveTo(target);
		}
		programRoot().flushCaches();
	}
	
	public void TypeDecl.doMoveMembers(Collection<MemberDecl> members, TypeDecl target) {
		moveMembers(members, target);
		programRoot().eliminate(LOCKED_DATAFLOW, LOCKED_NAMES);
	}
	
	public void MemberDecl.moveTo(TypeDecl target) {
		throw new RefactoringException("cannot move this kind of member");
	}
	
	public void FieldDeclaration.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert field into library class");
		if(hasInit())
			getInit().lockDataFlow();
		else if(isFinal())
			throw new RefactoringException("cannot move uninitialised final field");
		lockAllNames();
		programRoot().lockNames(name());
		hostType().removeBodyDecl(this);
		target.insertField(this);
	}
	
	public void MethodDecl.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert method into library class");
		if(!isStatic())
			throw new RefactoringException("cannot move instance methods");
		lockAllNames();
		programRoot().lockNames(name());
		TypeDecl host = hostType();
		MethodDecl dummy = (MethodDecl) this.fullCopyAndDetach();
		dummy.setBlockOpt(new Opt());
		target.insertUnusedMethod(dummy);
		host.removeBodyDecl(this);
		dummy.replaceWith(this);
	}
	
	public void MemberTypeDecl.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert type into library class");
		typeDecl().lockAllNames();
		programRoot().lockNames(typeDecl().name());
		hostType().removeBodyDecl(this);
		target.insertUnusedType(typeDecl());
	}
}
aspect MoveMembers {
	public void TypeDecl.moveMembers(Collection<MemberDecl> members, TypeDecl target) {
		for(MemberDecl md : members) {
			if(!md.fromSource() || md.isNative())
				throw new RefactoringException("cannot move this member");
			md.makeModifiersExplicit();
			md.moveTo(target);
		}
		programRoot().flushCaches();
	}
	
	public void TypeDecl.doMoveMembers(Collection<MemberDecl> members, TypeDecl target) {
		moveMembers(members, target);
		programRoot().eliminate(LOCKED_DATAFLOW, LOCKED_NAMES);
	}
	
	public void MemberDecl.moveTo(TypeDecl target) {
		throw new RefactoringException("cannot move this kind of member");
	}
	
	public void FieldDeclaration.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert field into library class");
		if(hasInit())
			getInit().lockDataFlow();
		else if(isFinal())
			throw new RefactoringException("cannot move uninitialised final field");
		for(ThisAccess acc : collectThisAccesses())
			if(acc.isQualified())
				throw new RefactoringException("Pull Up cannot preserve enclosing instances");
		
		lockAllNames();
		programRoot().lockNames(name());
		hostType().removeBodyDecl(this);
		target.insertField(this);
		
		// check that everything went OK wrt types
		Collection<TypeConstraint> typeConstraints =
			programRoot().typeConstraints(new Predicate<TypeConstraint>() {
				public boolean holds(TypeConstraint constr) {
					return constr.relevantForSubtree(FieldDeclaration.this);
				}
			});
		for(TypeConstraint typeConstraint : typeConstraints)
			if(!typeConstraint.solved())
				throw new RefactoringException("type constraint violated: " + typeConstraint.describe());
	}
	
	public void MethodDecl.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert method into library class");
		if(!isStatic())
			throw new RefactoringException("cannot move instance methods");
		lockAllNames();
		programRoot().lockNames(name());
		TypeDecl host = hostType();
		MethodDecl dummy = (MethodDecl) this.fullCopyAndDetach();
		dummy.setBlockOpt(new Opt());
		target.insertUnusedMethod(dummy);
		host.removeBodyDecl(this);
		dummy.replaceWith(this);
	}
	
	public void MemberTypeDecl.moveTo(TypeDecl target) {
		if(!target.fromSource())
			throw new RefactoringException("cannot insert type into library class");
		for(ThisAccess acc : collectThisAccesses())
			if(acc.isQualified())
				throw new RefactoringException("Pull Up cannot preserve enclosing instances");
		
		Program root = programRoot();
		typeDecl().lockAllNames();
		root.lockNames(typeDecl().name());
		hostType().removeBodyDecl(this);
		target.insertUnusedType(typeDecl());
		
		// check that everything went OK wrt types
		Collection<TypeConstraint> typeConstraints =
			root.typeConstraints(new Predicate<TypeConstraint>() {
				public boolean holds(TypeConstraint constr) {
					return constr.relevantForSubtree(MemberTypeDecl.this);
				}
			});
		for(TypeConstraint typeConstraint : typeConstraints)
			if(!typeConstraint.solved())
				throw new RefactoringException("type constraint violated: " + typeConstraint.describe());		
	}
}
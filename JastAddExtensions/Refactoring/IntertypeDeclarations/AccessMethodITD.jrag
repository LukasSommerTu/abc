aspect AccessMethodITD {

	eq IntertypeFieldDeclaration.getInit().accessMethod(MethodDecl md) {
	    MethodAccessInfo acc = introducedType().accessMemberMethod(md);
	    if(acc != null) return acc;
	    acc = accessMethod(md);
	    if(acc != null)
	    	return acc.moveInto(introducedType());
	    return acc;
	}
	
	eq IntertypeMethodDecl.getBlock().accessMethod(MethodDecl md) {
	    MethodAccessInfo acc = introducedType().accessMemberMethod(md);
	    if(acc != null) return acc;
	    acc = accessMethod(md);
	    if(acc != null)
	    	return acc.moveInto(introducedType());
	    return acc;
    }
	
	eq IntertypeConstructorDecl.getConstructorInvocation().accessMethod(MethodDecl md) {
		MethodAccessInfo acc = introducedType().accessMemberMethod(md);
		if(acc != null) return acc;
	    acc = accessMethod(md);
	    if(acc != null)
	    	return acc.moveInto(introducedType());
	    return acc;
	}

	eq IntertypeConstructorDecl.getBlock().accessMethod(MethodDecl md) {
		MethodAccessInfo acc = introducedType().accessMemberMethod(md);
		if(acc != null) return acc;
	    acc = accessMethod(md);
	    if(acc != null)
	    	return acc.moveInto(introducedType());
	    return acc;
	}
	
	/* refine access computation for local methods: intertype declarations can
	 * only be accessed if they aren't zapped; in turn, locally declared methods
	 * can only be accessed if they aren't zapped by an intertype declaration */
	refine MergeGenericDecls public MethodAccessInfo TypeDecl.accessLocalMethod(MethodDecl md) {
		MethodAccessInfo acc = MergeGenericDecls.TypeDecl.accessLocalMethod(md);
		for(Iterator iter = introducedMethods().iterator(); iter.hasNext();) {
			MethodDecl md2 = (MethodDecl)iter.next();
			if(md2.sameSourceDeclAs(md))
				if(md2.zappedByAny((SimpleSet)localMethodsSignatureMap().
									get(md.signature())))
					return null;
				else {
					Collection competitors = memberMethods(md.name());
					competitors.remove(md);
					return new MethodAccessInfo(this, this, false, competitors, md);
				}
			else if(md2.zaps(md))
				return null;
		}
		return acc;
	}
	
	public boolean MethodDecl.zappedByAny(SimpleSet set) {
		if(set == null)
			return false;
		for(Iterator i = set.iterator(); i.hasNext(); ) {
			MethodDecl m = (MethodDecl)i.next();
			if(m.zaps(this))
				return true;
		}
		return false;
	}
	
	// we have to avoid refering to the enclosing aspect as "this" (or "super")
	// if that would happen, we just reject

	refine MethodAccessInfo public Access MethodAccessInfo.computeThisAccess(NamingContext ctxt, List<Expr> args, AdjustmentTable table) {
		if(bend instanceof AspectDecl)
			return null;
		return MethodAccessInfo.MethodAccessInfo.computeThisAccess(ctxt, args, table);
	}
		
	refine MethodAccessInfo public Access MethodAccessInfo.computeSuperAccess(NamingContext ctxt, List<Expr> args, AdjustmentTable table) {
		if(bend instanceof AspectDecl)
			return null;
		return MethodAccessInfo.MethodAccessInfo.computeSuperAccess(ctxt, args, table);
	}

}
aspect AccessVariableITD {

	eq IntertypeMethodDecl.getBlock().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		// A declaration of a method parameter name shadows any other variable declarations
		if(acc != null) return acc;
		acc = introducedType().accessMemberField(decl);
		if(acc != null) 
			return acc.moveInto((MethodDecl)this);
		// Delegate to other declarations in scope
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}
	
	eq IntertypeFieldDeclaration.getInit().accessVariable(Variable decl) {
		SymbolicVarAccess acc = introducedType().accessMemberField(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	SymbolicVarAccess SymbolicVarAccess.moveInto(IntertypeMethodDecl md) {
		return addQualifier(!md.introducedType().memberFields(target.name()).isEmpty() ||
				!md.parameterDeclaration(target.name()).isEmpty());
	}
	
	SymbolicVarAccess SymbolicVarAccess.moveInto(IntertypeFieldDeclaration fd) {
		return addQualifier(!fd.introducedType().memberFields(target.name()).isEmpty());
	}

	// we have to avoid refering to the enclosing aspect as "this" (or "super")
	// if that would happen, we just reject

	refine SymbolicVarAccess public Access SymbolicVarAccess.computeThisAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeThisAccess(ctxt);
	}
		
	refine SymbolicVarAccess public Access SymbolicVarAccess.computeSuperAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeSuperAccess(ctxt);
	}
		
	refine SymbolicVarAccess public Access SymbolicVarAccess.computeMonsterAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeMonsterAccess(ctxt);
	}
	
	// the enclosing type of expressions and accesses has to be the thisType()
	// instead of the hostType()
	
	refine NamingContext public NamingContext Expr.getNamingContext() {
		return new NamingContext() {
			public boolean isStatic() { return inStaticContext(); }
			public TypeDecl enclosingType() { return thisType(); }
			public NamingContext unqualifiedCtxt() { return this; }
			public SimpleSet lookupType(String name) { return Expr.this.lookupType(name); }
			public SimpleSet lookupVariable(String name) { return Expr.this.lookupVariable(name); }
			public Access accessType(TypeDecl td, boolean ambiguous) {
				return Expr.this.access(td, ambiguous);
			}
		};
	}
	
	refine NamingContext public NamingContext Access.getNamingContext() {
		return new NamingContext() {
			public boolean isStatic() { return inStaticContext(); }
			public TypeDecl enclosingType() { return thisType(); }
			public NamingContext unqualifiedCtxt() {
				return Access.this.unqualifiedScope().getNamingContext();
			}
			public SimpleSet lookupType(String name) { 
				return Access.this.lookupType(name); 
			}
			public SimpleSet lookupVariable(String name) { 
				return Access.this.lookupVariable(name); 
			}
			public Access accessType(TypeDecl td, boolean ambiguous) {
				return Access.this.access(td, ambiguous);
			}
		};
	}
	
	
}
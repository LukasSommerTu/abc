aspect AccessVariableITD {

	eq IntertypeMethodDecl.getBlock().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		// A declaration of a method parameter name shadows any other variable declarations
		if(acc != null) return acc;
		acc = introducedType().accessMemberField(decl);
		if(acc != null) 
			return acc.moveInto((MethodDecl)this);
		// Delegate to other declarations in scope
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}
	
	eq IntertypeFieldDeclaration.getInit().accessVariable(Variable decl) {
		SymbolicVarAccess acc = introducedType().accessMemberField(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	SymbolicVarAccess SymbolicVarAccess.moveInto(IntertypeMethodDecl md) {
		return addQualifier(!md.introducedType().memberFields(target.name()).isEmpty() ||
				!md.parameterDeclaration(target.name()).isEmpty());
	}
	
	SymbolicVarAccess SymbolicVarAccess.moveInto(IntertypeFieldDeclaration fd) {
		return addQualifier(!fd.introducedType().memberFields(target.name()).isEmpty());
	}

	// we have to avoid refering to the enclosing aspect as "this" (or "super")
	// if that would happen, we just reject

	refine SymbolicVarAccess public Access SymbolicVarAccess.computeThisAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeThisAccess(ctxt);
	}
		
	refine SymbolicVarAccess public Access SymbolicVarAccess.computeSuperAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeSuperAccess(ctxt);
	}
		
	refine SymbolicVarAccess public Access SymbolicVarAccess.computeMonsterAccess(NamingContext ctxt) {
		if(bend instanceof AspectDecl)
			return null;
		return SymbolicVarAccess.SymbolicVarAccess.computeMonsterAccess(ctxt);
	}
	
}
// some attributes need to be refined to cope with generic, parameterized, and raw types

aspect MergeGenericDecls {
  
	// a coarser form of equality that considers, for example, a method from a generic
	// class and its counterpart from a parametrised instance of the class to be the same
	syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) 
		= sourceTypeDecl() == decl.sourceTypeDecl();
	syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) 
		= sourceMethodDecl() == decl.sourceMethodDecl();
	syn boolean Variable.sameSourceDeclAs(Variable decl) 
		= sourceVariableDecl() == decl.sourceVariableDecl();

	// we need to refine a bunch of methods to use sameSourceDeclAs() instead of "=="
	refine AccessMethod	public MethodAccessInfo TypeDecl.accessLocalMethod(MethodDecl md) {
		for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
			MethodDecl m = (MethodDecl)iter.next();
			if(m.sameSourceDeclAs(md)) {
				Collection competitors = memberMethods(md.name());
				competitors.remove(md);
				return new MethodAccessInfo(this, this, false, competitors, md);
			}
		}
		return null;
	}

	refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return td.getAccessInfo(true);
		return null;
	}

	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		TypeAccessInfo acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return td.getAccessInfo().moveInto(this);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(!decl.isStatic() && decl instanceof FieldDeclaration &&
				((FieldDeclaration)decl).hostType().sameSourceDeclAs(hostType()))
			return null;
	    if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
		for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
			TypeDecl t = (TypeDecl)iter.next();
			if(t.sameSourceDeclAs(td))
				return td.getAccessInfo();
		}
		return null;
	}

	refine AccessType eq CompilationUnit.accessLocallyDefinedType(TypeDecl td) {
		for(TypeDecl td2 : getTypeDecls())
			if(td.sameSourceDeclAs(td2))
				return td.getAccessInfo();
		return null;
	}

	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
			return td.getAccessInfo();
		return null;
	}

	refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
		for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
			FieldDeclaration f = (FieldDeclaration)iter.next();
			if(f.sameSourceDeclAs(decl))
				return new VarAccessInfo(this, this, false, decl);
		}
		return null;
	}

	refine AdjustAccess public void TypeAccess.lock() {
		if(target == null)
			target = decl().isRawType() ? decl().sourceTypeDecl() : decl();
	}

	refine AdjustAccess public void TypeAccess.unlockSafely() throws RefactoringException {
		TypeDecl td = target;
		// check if it has been handled already
		if(td == null)
			return;
		unlock();
		TypeDecl decl = decl().isRawType() ? decl().sourceTypeDecl() : decl();
		if(possiblyObscured() || decl != td) {
			Access acc = td.access(this, nameType());
			if(acc == null)
				throw new RefactoringException("type cannot be accessed");
			plugIn(acc);
		}
	}
	
	public Access ParTypeDecl.accessFromInside(TypeDecl src, NameType nt) {
		if(isRawType())
			return sourceTypeDecl().accessFromInside(src, nt);
		Access base = sourceTypeDecl().accessFromInside(src, NameType.TYPE_NAME);
		if(base == null) return null;
		List<Access> args = new List<Access>();
		for(int i=0;i<getNumArgument();++i) {
			Access arg = getArgument(i).type().accessFromInside(src, NameType.TYPE_NAME);
			if(arg == null) return null;
			args.add(arg);
		}
		return new ParTypeAccess(base, args);
	}
	
	public Access WildcardType.accessFromInside(TypeDecl src, NameType nt) {
		return new BoundTypeAccess("wildcard", "", this);
	}

	public Access ParTypeDecl.access(NamingSite src, NameType nt) {
		if(isRawType())
			return super.access(src, nt);
		Access base = sourceTypeDecl().access(src, NameType.TYPE_NAME);
		if(base == null) return null;
		List<Access> args = new List<Access>();
		for(int i=0;i<getNumArgument();++i) {
			Access arg = getArgument(i).type().access(src, NameType.TYPE_NAME);
			if(arg == null) return null;
			args.add(arg);
		}
		return new ParTypeAccess(base, args);
	}
	
	public Access WildcardType.access(NamingSite src, NameType nt) {
		return new BoundTypeAccess("wildcard", "", this);
	}
	
	public Access ParTypeDecl.access(Access src, NameType nt) {
		return access((NamingSite)src, nt);
	}
	
	public Access WildcardType.access(Access src, NameType nt) {
		return new BoundTypeAccess("wildcard", "", this);
	}
	
	refine AdjustAccess public void VarAccess.lock() {
		if(target == null)
			target = decl().sourceVariableDecl(); 
	}

	refine AdjustAccess public void VarAccess.unlockSafely() throws RefactoringException {
		Variable v = target;
		// check if it has been handled already
		if(v == null)
			return;
		// check that target is visible and can be accessed
		if(!v.accessibleFrom(this))
			throw new RefactoringException("variable is not accessible");
		unlock();
		if(decl().sourceVariableDecl() == v)
			return;
		Access acc = access(v);
		if(acc == null)
			throw new RefactoringException("variable cannot be accessed");
		plugIn(acc);
	}
	
	refine AdjustAccess public void MethodAccess.lock() {
		if(target == null)
			target = decl().sourceMethodDecl(); 
	}

	refine AdjustAccess public void MethodAccess.unlockSafely() throws RefactoringException {
		MethodDecl md = target;
		// check if it has been handled already
		if(md == null)
			return;
		unlock();
		if(decl().sourceMethodDecl() == md)
			return;
		AdjustmentTable table = new AdjustmentTable(programRoot());
		Access acc = md.access(this, getArgs(), table);
		if(acc == null)
			throw new RefactoringException("method cannot be accessed");
		plugIn(acc);
		table.adjust();
	}
	
	refine MethodAccessInfo public Access MethodAccessInfo.computeQualifiedAccess(NamingContext ctxt, TypeDecl qual_type, Expr qualifier, List args, AdjustmentTable table) {
		MethodAccess ma = constructAccess(args, table);
		if(needsQualifier) {
			if(!target.isStatic())
				return null;
			if(ctxt.isStatic())
				if(qualifier.isTypeAccess() && qual_type.sameSourceDeclAs(source))
					return qualifier.qualifiesAccess(ma);
				else
					return null;
			if(source == bend && source.sameSourceDeclAs(qual_type))
				return qualifier.qualifiesAccess(ma);
			else if(!qualifier.isTypeAccess() && bend.sameSourceDeclAs(qual_type))
				return new ParExpr(new CastExpr(source.getLockedAccess(table), qualifier)).qualifiesAccess(ma);
			return null;
		} else {
			return qualifier.qualifiesAccess(ma);
		}
	}
	
	refine VarAccessInfo public Access VarAccessInfo.computeQualifiedAccess(NamingContext outer, TypeDecl qual_type, Expr qualifier) {
		VarAccess va = new VarAccess(target.name());
		if(needsQualifier) {
			if(source == bend && source.sameSourceDeclAs(qual_type))
				return qualifier.qualifiesAccess(va);
			else if(!qualifier.isTypeAccess()) {
				Access upper = outer.accessType(source, NameType.PACKAGE_OR_TYPE_NAME);
				if(upper != null && bend.sameSourceDeclAs(qual_type))
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(new VarAccess(target.name()));
		}
	}
}

aspect MergeGenericDecls {
  
	// a coarser form of equality that considers, for example, a method from a generic
	// class and its counterpart from a parametrised instance of the class to be the same
	syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) = sourceTypeDecl() == decl.sourceTypeDecl();
	syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) = sourceMethodDecl() == decl.sourceMethodDecl();
	syn boolean Variable.sameSourceDeclAs(Variable decl) = sourceVariableDecl() == decl.sourceVariableDecl();

	// we need to refine a bunch of methods to use sameSourceDeclAs() instead of "=="
	refine AccessMethod	public MethodAccessInfo TypeDecl.accessLocalMethod(MethodDecl md) {
		for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
			MethodDecl m = (MethodDecl)iter.next();
			if(m.sameSourceDeclAs(md))
				return new MethodAccessInfo(this, this, false, md); 
		}
		return null;
	}

	refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return td.getAccessInfo(true);
		return null;
	}

	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		TypeAccessInfo acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return td.getAccessInfo().moveInto(this);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(!decl.isStatic() && decl instanceof FieldDeclaration &&
				((FieldDeclaration)decl).hostType().sameSourceDeclAs(hostType()))
			return null;
	    if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
		for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
			TypeDecl t = (TypeDecl)iter.next();
			if(t.sameSourceDeclAs(td))
				return td.getAccessInfo();
		}
		return null;
	}

	refine AccessType eq CompilationUnit.accessLocallyDefinedType(TypeDecl td) {
		for(TypeDecl td2 : getTypeDecls())
			if(td.sameSourceDeclAs(td2))
				return td.getAccessInfo();
		return null;
	}

	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
			return td.getAccessInfo();
		return null;
	}

	refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
		for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
			FieldDeclaration f = (FieldDeclaration)iter.next();
			if(f.sameSourceDeclAs(decl))
				return new VarAccessInfo(this, this, false, decl);
		}
		return null;
	}

	refine AdjustAccess public void Variable.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof VarAccess);
		VarAccess va = (VarAccess)acc;
		if(va.decl().sourceVariableDecl() != this) {
			Access newacc = va.access(this);
			if(newacc == null)
				throw new RefactoringException("variable would become shadowed at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		}
	}

	refine AdjustAccess public void MethodDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof MethodAccess);
		MethodAccess ma = (MethodAccess)acc;
		if(ma.decl().sourceMethodDecl() != this) {
			Access newacc = ma.access(this, (List)ma.getArgList().fullCopy());
			if(newacc == null)
				throw new RefactoringException("couldn't consistently rename method access at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		}
	}

	refine AdjustAccess public void TypeDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof TypeAccess);
		FileRange pos = acc.getPos();
		TypeAccess tacc = (TypeAccess)acc;
		if(tacc.decl().sourceTypeDecl() != this) {
			boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
			Access newacc = tacc.access(this, ambiguous);
			if(newacc == null)
				throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		} else {
			ASTNode parent = tacc.getParent();
			int idx = parent.getIndexOfChild(tacc);
			ParseName pn = new ParseName(tacc.getID());
			parent.setChild(pn, idx);
			try {
				Access tmp = (Access)parent.getChild(idx);
				if(tmp instanceof VarAccess) {
					parent.setChild(tacc, idx);
					boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
					Access newacc = tacc.access(this, ambiguous);
					if(newacc == null)
						throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
					acc.plugInNewAccess(newacc);
				}
			} finally {
				parent.setChild(tacc, idx);
			}
		}
	}

	refine MethodAccessInfo public Access MethodAccessInfo.computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		if(needsQualifier) {
			if(!target.isStatic())
				return null;
			if(ctxt.isStatic())
				if(qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(source))
					return qualifier.qualifiesAccess(ma);
				else
					return null;
			if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
				return qualifier.qualifiesAccess(ma);
			else if(!qualifier.isTypeAccess()) {
				Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
				if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(ma);
		}
	}
	
	refine VarAccessInfo public Access VarAccessInfo.computeQualifiedAccess(NamingContext ctxt, Expr qualifier) {
		VarAccess va = new VarAccess(target.name());
		if(needsQualifier) {
			if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
				return qualifier.qualifiesAccess(va);
			else if(!qualifier.isTypeAccess()) {
				Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
				if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(new VarAccess(target.name()));
		}
	}
}

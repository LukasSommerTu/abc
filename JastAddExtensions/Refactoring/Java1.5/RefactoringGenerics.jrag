aspect RefactoringGenerics {

  syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) = sourceTypeDecl() == decl.sourceTypeDecl();
  syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) = sourceMethodDecl() == decl.sourceMethodDecl();
  syn boolean Variable.sameSourceDeclAs(Variable decl) = sourceVariableDecl() == decl.sourceVariableDecl();

	  refine AccessMethod	public SymbolicMethodAccess TypeDecl.accessLocalMethod(MethodDecl md) {
    for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(m.sameSourceDeclAs(md))
				return new SymbolicMethodAccess(this, this, false, md); 
		}
		return null;
	}

  refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return new SymbolicTypeAccess(true, td);
		return null;
	}

  refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		SymbolicTypeAccess acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return new SymbolicTypeAccess(td).moveInto(this);
		return null;
	}

  refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
    for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if(t.sameSourceDeclAs(td))
			  return new SymbolicTypeAccess(this, false, td);
    }
    return null;
  }

  refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
		    return new SymbolicTypeAccess(false, td);
		return null;
	}

  refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new SymbolicVarAccess(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new SymbolicVarAccess(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
    for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
      FieldDeclaration f = (FieldDeclaration)iter.next();
      if(f.sameSourceDeclAs(decl))
				return new SymbolicVarAccess(this, this, false, decl);
    }
		return null;
	}

  refine RenameType private void TypeDecl.adjustImportDecls() throws RefactoringException {
		Program p = programRoot();
		for(int i = 0; i < p.getNumCompilationUnit(); i++) {
			for(int j=0;j<p.getCompilationUnit(i).getNumImportDecl();++j) {
				ImportDecl id = p.getCompilationUnit(i).getImportDecl(j);
				if(id instanceof SingleTypeImportDecl) {
					Access acc = ((SingleTypeImportDecl)id).getAccess();
					if(acc.type().sameSourceDeclAs(this)) {
						Access tacc = id.access(this, false);
						if(tacc == null)
							throw new RefactoringException("couldn't access type "+this+" from import decl "+id);
						id.replaceWith(new SingleTypeImportDecl(tacc));
					}
				}
			}
		}
	}

  refine AdjustAccess public void Access.adjust(AdjustmentTable table) throws RefactoringException {
		ASTNode target = table.getTarget(this);
		if(target == null) return;
		Access newacc;
        FileRange pos = new FileRange(compilationUnit().relativeName(),
        							  getStart(), getEnd());
		if(target instanceof Variable) {
			if(((VarAccess)this).decl().sourceVariableDecl() != target) {
				newacc = this.access((Variable)target);
				if(newacc == null)
					throw new RefactoringException("variable would become shadowed at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
			}
		} else if(target instanceof MethodDecl) {
			MethodDecl md = (MethodDecl)target;
			if(((MethodAccess)this).decl().sourceMethodDecl() != md) {
				newacc = this.access(md, (List)((MethodAccess)this).getArgList().fullCopy());
				if(newacc == null)
					throw new RefactoringException("couldn't consistently rename method access at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
			}
		} else if(target instanceof TypeDecl) {
			TypeAccess tacc = (TypeAccess)this;
            if(tacc.decl().sourceTypeDecl() != target) {
            	boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                newacc = this.access((TypeDecl)target, ambiguous);
                if(newacc == null)
                    throw new RefactoringException("couldn't consistently rename type access at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
            } else {
                ASTNode parent = tacc.getParent();
                int idx = parent.getIndexOfChild(tacc);
                ParseName pn = new ParseName(tacc.getID());
                parent.setChild(pn, idx);
                try {
                	Access tmp = (Access)parent.getChild(idx);
                	if(tmp instanceof VarAccess) {
                		parent.setChild(tacc, idx);
                		boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
                		newacc = this.access((TypeDecl)target, ambiguous);
                		if(newacc == null)
                			throw new RefactoringException("couldn't consistently rename type access at "+pos);
        				if(isLeftChildOfDot()) {
        					Access right = parentDot().getRight();
        					Expr p = nestedScope();
        					p.replaceWith(newacc.qualifiesAccess(right));
        				} else {
        					this.unqualifiedScope().replaceWith(newacc);
        				}
                	}
                } finally {
                	parent.setChild(tacc, idx);
                }
            }
		} else if(target instanceof PackageDecl) {
			Access acc = this;
			ASTNode parent = acc; int idx;
			do {
				acc = (Access)parent;
				parent = acc.getParent();
				idx = parent.getIndexOfChild(acc);
			} while(parent instanceof AbstractDot);
			ParseName pn = new ParseName(acc.packageName());
			parent.setChild(pn, idx);
			try {
				if(parent.getChild(idx) instanceof VarAccess)
					throw new RefactoringException("package access at "+pos+" is shadowed");
			} finally {
				parent.setChild(acc, idx);
			}
		} else {
			throw new RefactoringException("don't know how to adjust access to "+target.getClass()+" "+target);
		}
	}


/* TODO: fix JastAdd
  refine SymbolicMethodAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
    MethodDecl target = (MethodDecl)this.target;
    MethodAccess ma = new MethodAccess(target.name(), args);
    if(needsQualifier) {
      if(!target.isStatic())
        return null;
      if(ctxt.isStatic())
        if(qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(source))
          return qualifier.qualifiesAccess(ma);
        else
          return null;
      if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
        return qualifier.qualifiesAccess(ma);
      else if(!qualifier.isTypeAccess()) {
        Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
        if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
          return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
      }
      return null;
    } else {
      return qualifier.qualifiesAccess(ma);
    }
  }	

  refine SymbolicVarAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier) {
			Variable target = (Variable)this.target;
			if(isLocalVarAccess()) {
				return qualifier.qualifiesAccess(new VarAccess(target.name()));
			} else {
				VarAccess va = new VarAccess(target.name());
				if(needsQualifier) {
					if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
						return qualifier.qualifiesAccess(va);
					else if(!qualifier.isTypeAccess()) {
						Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
						if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
							return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
					}
					return null;
				} else {
					return qualifier.qualifiesAccess(new VarAccess(target.name()));
				}
			}
		}
    */




  /*
  // delete
  refine AccessVariable eq Expr.qualifiedAccessVariable(Variable decl) {
    if(type().accessibleFrom(hostType())) {
			SymbolicVarAccess acc = type().sourceTypeDecl().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl)) return acc;
		}
		return null;
  }
	
  // delete
  refine AccessVariable eq TypeAccess.qualifiedAccessVariable(Variable decl) {
		if(type().accessibleFrom(hostType())) {
			SymbolicVarAccess acc = type().sourceTypeDecl().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl) && !decl.isInstanceVariable())
				return acc;
		}
		return null;
	}

  // delete
  refine AccessVariable public Access Access.access(Variable v) {
		SymbolicVarAccess acc = accessVariable(v);
		if(acc == null) return null;
		if(isQualified())
			return acc.computeQualifiedAccess(qualifier().type().sourceTypeDecl().getMemberNamingContext(),
										  	  getCompleteQualifier());
		else
			return acc.computeAccess(getNamingContext());
	}

  // delete
	refine AccessVariable eq ClassDecl.accessField(Variable decl) {
		SymbolicVarAccess acc = accessLocalField(decl);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().sourceTypeDecl().accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.sourceTypeDecl().accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}

  // delete
	refine AccessVariable eq InterfaceDecl.accessField(Variable decl) {
		SymbolicVarAccess acc = accessLocalField(decl);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.sourceTypeDecl().accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}

  // delete
  refine AccessMethod eq ClassDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().sourceTypeDecl().accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.sourceTypeDecl().accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}
	
  // delete
	refine AccessMethod eq InterfaceDecl.accessMemberMethod(MethodDecl md) {
		SymbolicMethodAccess acc = accessLocalMethod(md);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.sourceTypeDecl().accessMemberMethod(md);
			if(acc != null && !md.isPrivate() && md.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		acc = typeObject().accessMemberMethod(md);
		if(acc != null && md.isPublic())
			return acc.moveDownTo(this);
		return null;
	}
   
  // delete
  refine AccessMethod eq AbstractDot.getRight().accessMethod(MethodDecl md) = 
		getLeft().type().sourceTypeDecl().accessMemberMethod(md);

  // delete
  refine AccessMethod	public Access Access.access(MethodDecl md, List args) {
		SymbolicMethodAccess acc = accessMethod(md);
		if(acc == null) return null;
		if(isQualified())
			return acc.computeQualifiedAccess(qualifier().type().sourceTypeDecl().getMemberNamingContext(),
										      getCompleteQualifier(), args);
		else
			return acc.computeAccess(getNamingContext(), args);
	}

  // new comparison
	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td == getAccess().type().sourceTypeDecl())
		    return new SymbolicTypeAccess(false, td);
		return null;
	}
	
  // delete
	refine AccessType eq TypeImportOnDemandDecl.accessImportedType(TypeDecl td) {
		if(getAccess() instanceof PackageAccess) {
			String packageName = ((PackageAccess)getAccess()).getPackage();
			if(packageName.equals(td.packageName()) &&
					td.accessibleFromPackage(packageName()))
				return new SymbolicTypeAccess(false, td);
		}
		else {
			SymbolicTypeAccess acc = getAccess().type().sourceTypeDecl().accessMemberType(td);
			if(acc != null && td.accessibleFromPackage(packageName()))
				return new SymbolicTypeAccess(outer, false, td);
		}
		return null;
	}
	

  // delete
	refine AccessType eq Expr.qualifiedAccessType(TypeDecl td) {
		if(typeAccessible(td))
			return type().sourceTypeDecl().accessMemberType(td);
		return null;
	}
	
  // new comparison
	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		SymbolicTypeAccess acc = type().sourceTypeDecl().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sourceTypeDecl() == td)
			return new SymbolicTypeAccess(td).moveInto(this);
		return null;
	}

  // delete
	refine AccessType eq ClassDecl.accessMemberType(TypeDecl td) {
		for(int i = 0; i < getNumBodyDecl(); i++) {
			if(getBodyDecl(i) instanceof MemberTypeDecl) {
				TypeDecl t = ((MemberTypeDecl)getBodyDecl(i)).typeDecl();
				if(t == td)
					return new SymbolicTypeAccess(this, false, td);
			}
		}
		for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
			TypeDecl type = (TypeDecl)outerIter.next();
			SymbolicTypeAccess acc = type.sourceTypeDecl().accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		if(hasSuperclass()) {
			SymbolicTypeAccess acc = superclass().sourceTypeDecl().accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}

  // delete
	refine AccessType eq InterfaceDecl.accessMemberType(TypeDecl td) {
		for(int i = 0; i < getNumBodyDecl(); i++) {
			if(getBodyDecl(i) instanceof MemberTypeDecl) {
				TypeDecl t = ((MemberTypeDecl)getBodyDecl(i)).typeDecl();
				if(t == td)
					return new SymbolicTypeAccess(this, false, td);
			}
		}
		for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
			TypeDecl type = (TypeDecl)outerIter.next();
			SymbolicTypeAccess acc = type.sourceTypeDecl().accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}

  // delete
	refine AccessType public Access Access.access(TypeDecl td, boolean ambiguous) {
		SymbolicTypeAccess acc = accessType(td);
		if(acc == null) return null;
		if(isQualified())
			return acc.computeQualifiedAccess(qualifier().type().sourceTypeDecl().getMemberNamingContext(),
										      ambiguous, getCompleteQualifier());
		else
			return acc.computeAccess(getNamingContext(), ambiguous);
	}

  refine SymbolicMethodAccess public Access SymbolicMethodAccess.computeAccess(NamingContext ctxt, List args) {
			MethodDecl target = (MethodDecl)this.target;
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(ctxt.isStatic()) {
					Access source_acc = ctxt.accessType(source, true);
					if(source_acc == null) return null;
					return source_acc.qualifiesAccess(ma);
				}
				if(source == bend) {
					if(source == ctxt.enclosingType())
						return ma;
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new ThisAccess("this").qualifiesAccess(ma));
					}
				} else if(bend instanceof ClassDecl && 
							source == ((ClassDecl)bend).superclass().sourceTypeDecl()) {
					if(bend == ctxt.enclosingType())
						return new SuperAccess("super").qualifiesAccess(ma);
					else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return outer.qualifiesAccess(new SuperAccess("super").qualifiesAccess(ma));
					}
				} else if(target.isStatic()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper == null) return null;
					if(bend == ctxt.enclosingType()) {
						return new ParExpr(new CastExpr(upper, new ThisAccess("this"))).qualifiesAccess(ma);
					} else {
						Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
						if(outer == null) return null;
						return new ParExpr(new CastExpr(upper, outer.qualifiesAccess(new ThisAccess("this")))).
										   qualifiesAccess(ma);
					}
				} else {
					return null;
				}
			} else {
				return ma;
			}
		}
		
		refine SymbolicMethodAccess public Access SymbolicMethodAccess.computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
			MethodDecl target = (MethodDecl)this.target;
			MethodAccess ma = new MethodAccess(target.name(), args);
			if(needsQualifier) {
				if(!target.isStatic())
					return null;
				if(ctxt.isStatic())
					if(qualifier.isTypeAccess() && qualifier.type().sourceTypeDecl() == source)
						return qualifier.qualifiesAccess(ma);
					else
						return null;
				if(source == bend && source == ctxt.enclosingType())
					return qualifier.qualifiesAccess(ma);
				else if(!qualifier.isTypeAccess()) {
					Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
					if(upper != null && bend == ctxt.enclosingType())
						return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
				}
				return null;
			} else {
				return qualifier.qualifiesAccess(ma);
			}
		}	
    */


}

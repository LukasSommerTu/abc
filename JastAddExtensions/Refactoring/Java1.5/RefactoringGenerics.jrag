aspect RefactoringGenerics {
	// return a list of type declarations for the arguments of a parametrised type
	public Collection<TypeDecl> ParTypeDecl.getArgumentTypes() {
		Collection<TypeDecl> res = new LinkedList<TypeDecl>();
		for(int i=0;i<getNumArgument();++i)
			res.add(getArgument(i).type());
		return res;
	}

	class ParTypeAccessInfo extends TypeAccessInfo {
		private ParTypeDecl target;
		private TypeAccessInfo sourceAccess;

		public ParTypeAccessInfo(boolean needsQualifier, ParTypeDecl target) {
			super(null, needsQualifier, (TypeDecl)target);
			this.target = target;
			this.sourceAccess = ((TypeDecl)target).sourceTypeDecl().getAccessInfo(needsQualifier);
		}
	}

	protected TypeAccessInfo ParTypeAccessInfo.addQualifier(boolean flag) {
		TypeAccessInfo acc = sourceAccess.addQualifier(flag);
		if(acc == null) return null;
		sourceAccess = acc;
		return this;
	}

	public Access ParTypeAccessInfo.computeAccess(NamingContext ctxt, boolean ambiguous) {
		Access source_acc = sourceAccess.computeAccess(ctxt, ambiguous);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		return new ParTypeAccess(source_acc, arg_accs);
	}

	public Access ParTypeAccessInfo.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		Access source_acc = sourceAccess.computeQualifiedAccess(ctxt, ambiguous, qualifier);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		/* the last access in source_acc will be an access to the raw type which we
		 * have to replace by an access to the parametrised type */
		Access last = source_acc.lastAccess();
		ASTNode lastparent = last.getParent();
		int idx = lastparent.getIndexOfChild(last);
		lastparent.setChild(new ParTypeAccess(last, arg_accs), idx);
		return source_acc;
	}

	public TypeAccessInfo ParTypeDecl.getAccessInfo(boolean needsQualifier) {
		return new ParTypeAccessInfo(needsQualifier, this);
	}

	// access computational rules (see Generics.jrag for the corresponding lookup rules)
	eq ParTypeAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);

	public TypeAccessInfo TypeAccessInfo.movePastTypeVars(GenericTypeDecl td) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!td.addTypeVariables(SimpleSet.emptySet, 
												 target.name()).isEmpty());

	}
	
	public TypeAccessInfo TypeAccessInfo.movePastTypeVars(GenericMethodDecl md) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!md.localLookupType(target.name()).isEmpty());
	}

	public TypeAccessInfo TypeAccessInfo.movePastTypeVars(GenericConstructorDecl cd) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!cd.localLookupType(target.name()).isEmpty());
	}

	public TypeAccessInfo GenericTypeDecl.accessTypeVariable(TypeDecl td) {
		GenericTypeDecl original = (GenericTypeDecl)original();
		for(int i = 0; i < original.getNumTypeParameter(); i++) {
			TypeVariable td2 = original.getTypeParameter(i);
			if(td2.sameSourceDeclAs(td))
				return td.getAccessInfo();
		}
		return null;
	}

	eq GenericInterfaceDecl.getSuperInterfaceId().accessType(TypeDecl td) {
		TypeAccessInfo acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericClassDecl.getSuperClassAccess().accessType(TypeDecl td) {
		TypeAccessInfo acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericClassDecl.getImplements().accessType(TypeDecl td) {
		TypeAccessInfo acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericTypeDecl.getTypeParameter().accessType(TypeDecl td) {
		TypeAccessInfo acc = accessMemberType(td);
		if(acc != null) 
			return acc;
		acc = accessTypeVariable(td);
		if(acc != null) 
			return acc.movePastTypeVars(this);
		acc = accessType(td);
		if(acc != null) {
			acc = acc.movePastTypeVars(this);
			if(acc == null) return null;
			acc = acc.moveInto(this);
			if(isClassDecl() && isStatic() && !isTopLevelType()) {
				if(td.isStatic() || 
						(td.enclosingType() != null && instanceOf(td.enclosingType())))
					return acc;
			} else {
				return acc;
			}
		}
		acc = topLevelType().accessType(td);
		if(acc == null) return null;
		acc = acc.movePastTypeVars(this);
		if(acc == null) return null;
		return acc.moveInto(this);
	}

	eq GenericTypeDecl.getBodyDecl(int index).accessType(TypeDecl td) {
		TypeAccessInfo acc = accessMemberType(td);
		if(acc != null)
			return acc;
		if(getBodyDecl(index).visibleTypeParameters()) {
			acc = accessTypeVariable(td);
			if(acc != null)
				return acc.movePastTypeVars(this);
		}
		acc = accessType(td);
		if(acc != null) {
			acc = acc.movePastTypeVars(this);
			if(acc == null) return null;
			acc = acc.moveInto(this);
			if(isClassDecl() && isStatic() && !isTopLevelType()) {
				if(td.isStatic() || 
						(td.enclosingType() != null && instanceOf(td.enclosingType())))
					return acc;
			} else {
				return acc;
			}
		}
		acc = topLevelType().accessType(td);
		if(acc == null) return null;
		acc = acc.movePastTypeVars(this);
		if(acc == null) return null;
		return acc.moveInto(this);
	}
	
	eq ParMethodAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);

	inh TypeAccessInfo GenericMethodDecl.accessType(TypeDecl td);
	syn TypeAccessInfo GenericMethodDecl.localAccessType(TypeDecl td) {
		for(int i = 0; i < getNumTypeParameter(); i++)
			if(original().getTypeParameter(i).sameSourceDeclAs(td))
				return td.getAccessInfo();
		return null;
	}
	eq GenericMethodDecl.getChild().accessType(TypeDecl td) {
		TypeAccessInfo acc = localAccessType(td);
		if(acc != null) return acc;
		acc = accessType(td);
		if(acc != null) return acc.movePastTypeVars(this);
		return null;
	}
	
	eq ParConstructorAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);
	eq ParSuperConstructorAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);
	
	inh TypeAccessInfo GenericConstructorDecl.accessType(TypeDecl td);
	syn TypeAccessInfo GenericConstructorDecl.localAccessType(TypeDecl td) {
	  for(int i = 0; i < getNumTypeParameter(); i++) {
	    if(original().getTypeParameter(i).sameSourceDeclAs(td))
	      return td.getAccessInfo();
	  }
	  return null;
	}
	  
	eq GenericConstructorDecl.getChild().accessType(TypeDecl td) { 
		TypeAccessInfo acc = localAccessType(td);
		if(acc != null) return acc;
		acc = accessType(td);
		if(acc != null) return acc.movePastTypeVars(this);
		return null;
	}
	
	eq ParClassInstanceExpr.getTypeArgument().accessType(TypeDecl td)
	  = unqualifiedScope().accessType(td);

	// TypeVarAccessInfo has the same behaviour as LocalTypeAccessInfo
	class TypeVarAccessInfo extends LocalTypeAccessInfo {
		public TypeVarAccessInfo(boolean needsQualifier, TypeVariable target) {
			super(target);
			addQualifier(needsQualifier);
		}
	}

	public TypeAccessInfo TypeVariable.getAccessInfo(boolean needsQualifier) {
		return new TypeVarAccessInfo(needsQualifier, this);
	}
}

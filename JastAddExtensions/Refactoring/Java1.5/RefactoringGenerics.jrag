aspect RefactoringGenerics {

	// a coarser form of equality that considers, for example, a method from a generic
	// class and its counterpart from a parametrised instance of the class to be the same
	syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) = sourceTypeDecl() == decl.sourceTypeDecl();
	syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) = sourceMethodDecl() == decl.sourceMethodDecl();
	syn boolean Variable.sameSourceDeclAs(Variable decl) = sourceVariableDecl() == decl.sourceVariableDecl();

	// we need to refine a bunch of methods to use sameSourceDeclAs() instead of "=="
	refine AccessMethod	public SymbolicMethodAccess TypeDecl.accessLocalMethod(MethodDecl md) {
		for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
			MethodDecl m = (MethodDecl)iter.next();
			if(m.sameSourceDeclAs(md))
				return new SymbolicMethodAccess(this, this, false, md); 
		}
		return null;
	}

	refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return td.getSymbolicAccess(true);
		return null;
	}

	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		SymbolicTypeAccess acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return td.getSymbolicAccess().moveInto(this);
		return null;
	}

	refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
		for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
			TypeDecl t = (TypeDecl)iter.next();
			if(t.sameSourceDeclAs(td))
				return td.getSymbolicAccess();
		}
		return null;
	}

	refine AccessType eq CompilationUnit.accessLocallyDefinedType(TypeDecl td) {
		for(TypeDecl td2 : getTypeDecls())
			if(td.sameSourceDeclAs(td2))
				return td.getSymbolicAccess();
		return null;
	}
	
	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
			return td.getSymbolicAccess();
		return null;
	}

	refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new SymbolicVarAccess(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new SymbolicVarAccess(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
		for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
			FieldDeclaration f = (FieldDeclaration)iter.next();
			if(f.sameSourceDeclAs(decl))
				return new SymbolicVarAccess(this, this, false, decl);
		}
		return null;
	}

	refine RenameType private void TypeDecl.adjustImportDecls() throws RefactoringException {
		Program p = programRoot();
		for(int i = 0; i < p.getNumCompilationUnit(); i++) {
			for(int j=0;j<p.getCompilationUnit(i).getNumImportDecl();++j) {
				ImportDecl id = p.getCompilationUnit(i).getImportDecl(j);
				if(id instanceof SingleTypeImportDecl) {
					Access acc = ((SingleTypeImportDecl)id).getAccess();
					if(acc.type().sameSourceDeclAs(this)) {
						Access tacc = id.access(this, false);
						if(tacc == null)
							throw new RefactoringException("couldn't access type "+this+" from import decl "+id);
						id.replaceWith(new SingleTypeImportDecl(tacc));
					}
				}
			}
		}
	}

	refine AdjustAccess public void Access.adjust(AdjustmentTable table) throws RefactoringException {
		ASTNode target = table.getTarget(this);
		if(target == null) return;
		Access newacc;
		FileRange pos = new FileRange(compilationUnit().relativeName(),
				getStart(), getEnd());
		if(target instanceof Variable) {
			if(((VarAccess)this).decl().sourceVariableDecl() != target) {
				newacc = this.access((Variable)target);
				if(newacc == null)
					throw new RefactoringException("variable would become shadowed at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
			}
		} else if(target instanceof MethodDecl) {
			MethodDecl md = (MethodDecl)target;
			if(((MethodAccess)this).decl().sourceMethodDecl() != md) {
				newacc = this.access(md, (List)((MethodAccess)this).getArgList().fullCopy());
				if(newacc == null)
					throw new RefactoringException("couldn't consistently rename method access at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
			}
		} else if(target instanceof TypeDecl) {
			TypeAccess tacc = (TypeAccess)this;
			if(tacc.decl().sourceTypeDecl() != target) {
				boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
				newacc = this.access((TypeDecl)target, ambiguous);
				if(newacc == null)
					throw new RefactoringException("couldn't consistently rename type access at "+pos);
				if(isLeftChildOfDot()) {
					Access right = parentDot().getRight();
					Expr p = nestedScope();
					p.replaceWith(newacc.qualifiesAccess(right));
				} else {
					this.unqualifiedScope().replaceWith(newacc);
				}
			} else {
				ASTNode parent = tacc.getParent();
				int idx = parent.getIndexOfChild(tacc);
				ParseName pn = new ParseName(tacc.getID());
				parent.setChild(pn, idx);
				try {
					Access tmp = (Access)parent.getChild(idx);
					if(tmp instanceof VarAccess) {
						parent.setChild(tacc, idx);
						boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
						newacc = this.access((TypeDecl)target, ambiguous);
						if(newacc == null)
							throw new RefactoringException("couldn't consistently rename type access at "+pos);
						if(isLeftChildOfDot()) {
							Access right = parentDot().getRight();
							Expr p = nestedScope();
							p.replaceWith(newacc.qualifiesAccess(right));
						} else {
							this.unqualifiedScope().replaceWith(newacc);
						}
					}
				} finally {
					parent.setChild(tacc, idx);
				}
			}
		} else if(target instanceof PackageDecl) {
			Access acc = this;
			ASTNode parent = acc; int idx;
			do {
				acc = (Access)parent;
				parent = acc.getParent();
				idx = parent.getIndexOfChild(acc);
			} while(parent instanceof AbstractDot);
			ParseName pn = new ParseName(acc.packageName());
			parent.setChild(pn, idx);
			try {
				if(parent.getChild(idx) instanceof VarAccess)
					throw new RefactoringException("package access at "+pos+" is shadowed");
			} finally {
				parent.setChild(acc, idx);
			}
		} else {
			throw new RefactoringException("don't know how to adjust access to "+target.getClass()+" "+target);
		}
	}


	/* TODO: fix JastAdd
  refine SymbolicMethodAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
    MethodDecl target = (MethodDecl)this.target;
    MethodAccess ma = new MethodAccess(target.name(), args);
    if(needsQualifier) {
      if(!target.isStatic())
        return null;
      if(ctxt.isStatic())
        if(qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(source))
          return qualifier.qualifiesAccess(ma);
        else
          return null;
      if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
        return qualifier.qualifiesAccess(ma);
      else if(!qualifier.isTypeAccess()) {
        Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
        if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
          return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
      }
      return null;
    } else {
      return qualifier.qualifiesAccess(ma);
    }
  }	

  refine SymbolicVarAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier) {
			Variable target = (Variable)this.target;
			if(isLocalVarAccess()) {
				return qualifier.qualifiesAccess(new VarAccess(target.name()));
			} else {
				VarAccess va = new VarAccess(target.name());
				if(needsQualifier) {
					if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
						return qualifier.qualifiesAccess(va);
					else if(!qualifier.isTypeAccess()) {
						Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
						if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
							return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
					}
					return null;
				} else {
					return qualifier.qualifiesAccess(new VarAccess(target.name()));
				}
			}
		}
	 */

	// return a list of type declarations for the arguments of a parametrised type
	public Collection<TypeDecl> ParTypeDecl.getArgumentTypes() {
		Collection<TypeDecl> res = new LinkedList<TypeDecl>();
		for(int i=0;i<getNumArgument();++i)
			res.add(getArgument(i).type());
		return res;
	}

	class SymbolicParTypeAccess extends SymbolicTypeAccess {
		private ParTypeDecl target;
		private SymbolicTypeAccess sourceAccess;
		
		public SymbolicParTypeAccess(boolean needsQualifier, ParTypeDecl target) {
			super(null, needsQualifier, (TypeDecl)target);
			this.target = target;
			this.sourceAccess = ((TypeDecl)target).sourceTypeDecl().getSymbolicAccess(needsQualifier);
		}
	}
		
	protected SymbolicTypeAccess SymbolicParTypeAccess.addQualifier(boolean flag) {
		SymbolicTypeAccess acc = sourceAccess.addQualifier(flag);
		if(acc == null) return null;
		sourceAccess = acc;
		return this;
	}
	
	public Access SymbolicParTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous) {
		Access source_acc = sourceAccess.computeAccess(ctxt, ambiguous);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		return new ParTypeAccess(source_acc, arg_accs);
	}

	public Access SymbolicParTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		Access source_acc = sourceAccess.computeQualifiedAccess(ctxt, ambiguous, qualifier);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		// TODO: now we have to fiddle the type arguments into source_acc, which might
		//       be qualified...
		return null;
	}
	
	public SymbolicTypeAccess ParTypeDecl.getSymbolicAccess(boolean needsQualifier) {
		return new SymbolicParTypeAccess(needsQualifier, this);
	}
}

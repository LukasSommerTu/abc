aspect RefactoringGenerics {

	// a coarser form of equality that considers, for example, a method from a generic
	// class and its counterpart from a parametrised instance of the class to be the same
	syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) = sourceTypeDecl() == decl.sourceTypeDecl();
	syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) = sourceMethodDecl() == decl.sourceMethodDecl();
	syn boolean Variable.sameSourceDeclAs(Variable decl) = sourceVariableDecl() == decl.sourceVariableDecl();

	// we need to refine a bunch of methods to use sameSourceDeclAs() instead of "=="
	refine AccessMethod	public SymbolicMethodAccess TypeDecl.accessLocalMethod(MethodDecl md) {
		for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
			MethodDecl m = (MethodDecl)iter.next();
			if(m.sameSourceDeclAs(md))
				return new SymbolicMethodAccess(this, this, false, md); 
		}
		return null;
	}

	refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return td.getSymbolicAccess(true);
		return null;
	}

	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		SymbolicTypeAccess acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return td.getSymbolicAccess().moveInto(this);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		SymbolicVarAccess acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(!decl.isStatic() && decl instanceof FieldDeclaration &&
				((FieldDeclaration)decl).hostType().sameSourceDeclAs(hostType()))
			return null;
	    if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
		for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
			TypeDecl t = (TypeDecl)iter.next();
			if(t.sameSourceDeclAs(td))
				return td.getSymbolicAccess();
		}
		return null;
	}

	refine AccessType eq CompilationUnit.accessLocallyDefinedType(TypeDecl td) {
		for(TypeDecl td2 : getTypeDecls())
			if(td.sameSourceDeclAs(td2))
				return td.getSymbolicAccess();
		return null;
	}

	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
			return td.getSymbolicAccess();
		return null;
	}

	refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new SymbolicLocalVarAccess(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new SymbolicLocalVarAccess(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
		for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
			FieldDeclaration f = (FieldDeclaration)iter.next();
			if(f.sameSourceDeclAs(decl))
				return new SymbolicVarAccess(this, this, false, decl);
		}
		return null;
	}

	refine AdjustAccess public void Variable.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof VarAccess);
		VarAccess va = (VarAccess)acc;
		if(va.decl().sourceVariableDecl() != this) {
			Access newacc = va.access(this);
			if(newacc == null)
				throw new RefactoringException("variable would become shadowed at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		}
	}

	refine AdjustAccess public void MethodDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof MethodAccess);
		MethodAccess ma = (MethodAccess)acc;
		if(ma.decl().sourceMethodDecl() != this) {
			Access newacc = ma.access(this, (List)ma.getArgList().fullCopy());
			if(newacc == null)
				throw new RefactoringException("couldn't consistently rename method access at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		}
	}

	refine AdjustAccess public void TypeDecl.adjustAccess(Access acc) throws RefactoringException {
		assert(acc instanceof TypeAccess);
		FileRange pos = acc.getPos();
		TypeAccess tacc = (TypeAccess)acc;
		if(tacc.decl().sourceTypeDecl() != this) {
			boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
			Access newacc = tacc.access(this, ambiguous);
			if(newacc == null)
				throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
			acc.plugInNewAccess(newacc);
		} else {
			ASTNode parent = tacc.getParent();
			int idx = parent.getIndexOfChild(tacc);
			ParseName pn = new ParseName(tacc.getID());
			parent.setChild(pn, idx);
			try {
				Access tmp = (Access)parent.getChild(idx);
				if(tmp instanceof VarAccess) {
					parent.setChild(tacc, idx);
					boolean ambiguous = tacc.nameType() == NameType.AMBIGUOUS_NAME;
					Access newacc = tacc.access(this, ambiguous);
					if(newacc == null)
						throw new RefactoringException("couldn't consistently rename type access at "+acc.getPos());
					acc.plugInNewAccess(newacc);
				}
			} finally {
				parent.setChild(tacc, idx);
			}
		}
	}


	/* TODO: fix JastAdd
  refine SymbolicMethodAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier, List args) {
    MethodDecl target = (MethodDecl)this.target;
    MethodAccess ma = new MethodAccess(target.name(), args);
    if(needsQualifier) {
      if(!target.isStatic())
        return null;
      if(ctxt.isStatic())
        if(qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(source))
          return qualifier.qualifiesAccess(ma);
        else
          return null;
      if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
        return qualifier.qualifiesAccess(ma);
      else if(!qualifier.isTypeAccess()) {
        Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
        if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
          return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
      }
      return null;
    } else {
      return qualifier.qualifiesAccess(ma);
    }
  }	

  refine SymbolicVarAccess public Access computeQualifiedAccess(NamingContext ctxt, Expr qualifier) {
			Variable target = (Variable)this.target;
			if(isLocalVarAccess()) {
				return qualifier.qualifiesAccess(new VarAccess(target.name()));
			} else {
				VarAccess va = new VarAccess(target.name());
				if(needsQualifier) {
					if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
						return qualifier.qualifiesAccess(va);
					else if(!qualifier.isTypeAccess()) {
						Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
						if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
							return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
					}
					return null;
				} else {
					return qualifier.qualifiesAccess(new VarAccess(target.name()));
				}
			}
		}
	 */

	// return a list of type declarations for the arguments of a parametrised type
	public Collection<TypeDecl> ParTypeDecl.getArgumentTypes() {
		Collection<TypeDecl> res = new LinkedList<TypeDecl>();
		for(int i=0;i<getNumArgument();++i)
			res.add(getArgument(i).type());
		return res;
	}

	class SymbolicParTypeAccess extends SymbolicTypeAccess {
		private ParTypeDecl target;
		private SymbolicTypeAccess sourceAccess;

		public SymbolicParTypeAccess(boolean needsQualifier, ParTypeDecl target) {
			super(null, needsQualifier, (TypeDecl)target);
			this.target = target;
			this.sourceAccess = ((TypeDecl)target).sourceTypeDecl().getSymbolicAccess(needsQualifier);
		}
	}

	protected SymbolicTypeAccess SymbolicParTypeAccess.addQualifier(boolean flag) {
		SymbolicTypeAccess acc = sourceAccess.addQualifier(flag);
		if(acc == null) return null;
		sourceAccess = acc;
		return this;
	}

	public Access SymbolicParTypeAccess.computeAccess(NamingContext ctxt, boolean ambiguous) {
		Access source_acc = sourceAccess.computeAccess(ctxt, ambiguous);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		return new ParTypeAccess(source_acc, arg_accs);
	}

	public Access SymbolicParTypeAccess.computeQualifiedAccess(NamingContext ctxt, 
			boolean ambiguous, Expr qualifier) {
		Access source_acc = sourceAccess.computeQualifiedAccess(ctxt, ambiguous, qualifier);
		if(source_acc == null) return null;
		List<Access> arg_accs = new List<Access>();
		for(TypeDecl td : target.getArgumentTypes()) {
			Access acc = ctxt.accessType(td, false);
			if(acc == null) return null;
			arg_accs.add(acc);
		}
		/* the last access in source_acc will be an access to the raw type which we
		 * have to replace by an access to the parametrised type */
		Access last = source_acc.lastAccess();
		ASTNode lastparent = last.getParent();
		int idx = lastparent.getIndexOfChild(last);
		lastparent.setChild(new ParTypeAccess(last, arg_accs), idx);
		return source_acc;
	}

	public SymbolicTypeAccess ParTypeDecl.getSymbolicAccess(boolean needsQualifier) {
		return new SymbolicParTypeAccess(needsQualifier, this);
	}

	// access computational rules (see Generics.jrag for the corresponding lookup rules)
	eq ParTypeAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);

	public SymbolicTypeAccess SymbolicTypeAccess.movePastTypeVars(GenericTypeDecl td) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!td.addTypeVariables(SimpleSet.emptySet, 
												 target.name()).isEmpty());

	}
	
	public SymbolicTypeAccess SymbolicTypeAccess.movePastTypeVars(GenericMethodDecl md) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!md.localLookupType(target.name()).isEmpty());
	}

	public SymbolicTypeAccess SymbolicTypeAccess.movePastTypeVars(GenericConstructorDecl cd) {
		TypeDecl target = (TypeDecl)this.target;
		return addQualifier(!cd.localLookupType(target.name()).isEmpty());
	}

	public SymbolicTypeAccess GenericTypeDecl.accessTypeVariable(TypeDecl td) {
		GenericTypeDecl original = (GenericTypeDecl)original();
		for(int i = 0; i < original.getNumTypeParameter(); i++) {
			TypeVariable td2 = original.getTypeParameter(i);
			if(td2.sameSourceDeclAs(td))
				return td.getSymbolicAccess();
		}
		return null;
	}

	eq GenericInterfaceDecl.getSuperInterfaceId().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericClassDecl.getSuperClassAccess().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericClassDecl.getImplements().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessTypeVariable(td);
		if(acc != null)
			return acc;
		acc = accessType(td);
		if(acc != null)
			return acc.movePastTypeVars(this);
		return null;
	}

	eq GenericTypeDecl.getTypeParameter().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessMemberType(td);
		if(acc != null) 
			return acc;
		acc = accessTypeVariable(td);
		if(acc != null) 
			return acc.movePastTypeVars(this);
		acc = accessType(td);
		if(acc != null) {
			acc = acc.movePastTypeVars(this);
			if(acc == null) return null;
			acc = acc.moveInto(this);
			if(isClassDecl() && isStatic() && !isTopLevelType()) {
				if(td.isStatic() || 
						(td.enclosingType() != null && instanceOf(td.enclosingType())))
					return acc;
			} else {
				return acc;
			}
		}
		acc = topLevelType().accessType(td);
		if(acc == null) return null;
		acc = acc.movePastTypeVars(this);
		if(acc == null) return null;
		return acc.moveInto(this);
	}

	eq GenericTypeDecl.getBodyDecl(int index).accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessMemberType(td);
		if(acc != null)
			return acc;
		if(getBodyDecl(index).visibleTypeParameters()) {
			acc = accessTypeVariable(td);
			if(acc != null)
				return acc.movePastTypeVars(this);
		}
		acc = accessType(td);
		if(acc != null) {
			acc = acc.movePastTypeVars(this);
			if(acc == null) return null;
			acc = acc.moveInto(this);
			if(isClassDecl() && isStatic() && !isTopLevelType()) {
				if(td.isStatic() || 
						(td.enclosingType() != null && instanceOf(td.enclosingType())))
					return acc;
			} else {
				return acc;
			}
		}
		acc = topLevelType().accessType(td);
		if(acc == null) return null;
		acc = acc.movePastTypeVars(this);
		if(acc == null) return null;
		return acc.moveInto(this);
	}
	
	eq ParMethodAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);

	inh SymbolicTypeAccess GenericMethodDecl.accessType(TypeDecl td);
	syn SymbolicTypeAccess GenericMethodDecl.localAccessType(TypeDecl td) {
		for(int i = 0; i < getNumTypeParameter(); i++)
			if(original().getTypeParameter(i).sameSourceDeclAs(td))
				return td.getSymbolicAccess();
		return null;
	}
	eq GenericMethodDecl.getChild().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = localAccessType(td);
		if(acc != null) return acc;
		acc = accessType(td);
		if(acc != null) return acc.movePastTypeVars(this);
		return null;
	}
	
	eq ParConstructorAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);
	eq ParSuperConstructorAccess.getTypeArgument().accessType(TypeDecl td) 
	  = unqualifiedScope().accessType(td);
	
	inh SymbolicTypeAccess GenericConstructorDecl.accessType(TypeDecl td);
	syn SymbolicTypeAccess GenericConstructorDecl.localAccessType(TypeDecl td) {
	  for(int i = 0; i < getNumTypeParameter(); i++) {
	    if(original().getTypeParameter(i).sameSourceDeclAs(td))
	      return td.getSymbolicAccess();
	  }
	  return null;
	}
	  
	eq GenericConstructorDecl.getChild().accessType(TypeDecl td) { 
		SymbolicTypeAccess acc = localAccessType(td);
		if(acc != null) return acc;
		acc = accessType(td);
		if(acc != null) return acc.movePastTypeVars(this);
		return null;
	}
	
	eq ParClassInstanceExpr.getTypeArgument().accessType(TypeDecl td)
	  = unqualifiedScope().accessType(td);

	// SymbolicTypeVarAccess has the same behaviour as SymbolicLocalTypeAccess
	class SymbolicTypeVarAccess extends SymbolicLocalTypeAccess {
		public SymbolicTypeVarAccess(boolean needsQualifier, TypeVariable target) {
			super(target);
			addQualifier(needsQualifier);
		}
	}

	public SymbolicTypeAccess TypeVariable.getSymbolicAccess(boolean needsQualifier) {
		return new SymbolicTypeVarAccess(needsQualifier, this);
	}
}

aspect MakeGenericMethod {
	
	/* when extracting a block from a generic method into a new method,
	 * we need to give the new method the same type parameters as the old one;
	 * some methods need to be refined to achieve that */
	refine MakeMethod public void CompilationUnit.makeMethod(String name, String vis, Block blk) 
			throws RefactoringException {
		check_make_method_preconds(blk);
		Block host = blk.hostBlock();
		BodyDecl bd = host.hostBodyDecl();
		boolean static_ctxt = false;           // are we in a static context?
		List<TypeVariable> tvars = null;       // type variables of host method (if any)
		if(bd instanceof StaticInitializer)
			static_ctxt = true;
		if(bd instanceof MethodDecl) {
			MethodDecl md = (MethodDecl)bd;
			if(md.isStatic())
				static_ctxt = true;
			if(md instanceof GenericMethodDecl)
				tvars = ((GenericMethodDecl)md).getTypeParameters().fullCopy();
		}
		host.createMethod(name, vis, blk.indexInHostBlock(), blk, static_ctxt, tvars);
	}

	public void Block.createMethod(String name, String vis, int pos, Block blk, 
			boolean static_ctxt, List<TypeVariable> tvars) 
				throws RefactoringException {
		Block hostblock = blk.hostBlock();
		Collection parms = blk.inputParameters();      // parameters of extracted method
		Collection localVars = blk.extraLocalVars();   // local variables of extracted method
		Collection outparms = blk.outputParameters();
		/* there are two different issues having to do with return values of the extracted method:
		 *   1) the method could alter a local variable whose new value should be
		 *   	returned and assigned to the variable
		 *   2) the method might return a result, which should in turn be returned
		 *   	by the method it was extracted from (since we have checked for
		 *      domination already, there will be a _single_ return statement in
		 *      this case, and all control paths will reach this statement) 
		 */
		TypeDecl rettype = typeVoid();    // return type of created method
		// dealing with case 1)
		Opt retvar = new Opt();           // variable returned by extracted method
		if(outparms.size() == 1) {
			Variable outparm = (Variable)outparms.iterator().next();
			retvar = new Opt(((ASTNode)outparm).fullCopy());
			rettype = outparm.type();
		}
		if(outparms.size() > 1)
			throw new RefactoringException("ambiguous return value");
		// dealing with case 2)
		if(blk.returnsValue()) {
			if(!retvar.isEmpty())
				throw new RefactoringException("ambiguous return value");
			BodyDecl bd = hostBodyDecl();
			if(!(bd instanceof MethodDecl))
				throw new RefactoringException("couldn't determine return type of extracted method");
			rettype = ((MethodDecl)bd).type();
		}
		// one last thing to guard against when extracting from a constructor
		if(mayDefFinal())
			throw new RefactoringException("code may assign to a final field");
		// create declaration of method
		AdjustmentTable table = new AdjustmentTable();
		MethodDecl md = createMethodDecl(tvars, static_ctxt, name, vis, parms, 
				retvar, rettype, blk.uncaughtThrows(), localVars, blk, table);
		// insert method invocation and body into type declaration
		hostType().insertMethod(md, hostblock, pos, parms, retvar, rettype);
		// make adjustments
		table.adjust();
	}
	
	private MethodDecl Block.createMethodDecl(List<TypeVariable> tvars, 
				boolean static_ctxt, String name, String visibility,
				Collection parms, Opt retvar, TypeDecl rettype, Set exns, 
				Collection localVariables, Block blk, AdjustmentTable table) 
			throws RefactoringException {
		// modifiers: visibility, perhaps with a "static"
		Modifiers mod = new Modifiers();
		if(!visibility.equals("default"))
			mod.addModifier(new Modifier(visibility));
		if(static_ctxt)
			mod.addModifier(new Modifier("static"));
		// type access: either "void" or the type of the variable to be assigned to
		TypeAccess acc = new TypeAccess("void");
		// lock onto the correct type; we can leave the name as "void", since the
		// unlocking mechanism will compute a type access anyway
		acc.lockOn(rettype);
		// parameter declarations
		List parmdecls = new List();
		for(Iterator i=parms.iterator();i.hasNext();)
			parmdecls.add(((LocalDeclaration)i.next()).asParameterDeclaration());
		// thrown exceptions
		List throwdecls = new List();
		for(Iterator i=exns.iterator();i.hasNext();) {
			TypeDecl exn = ((ThrowStmt)i.next()).getExpr().type();
			Access exnacc = hostBodyDecl().access(exn, false);
			if(exnacc == null)
				throw new RefactoringException("cannot access type "+exn);
			throwdecls.add(exnacc);
		}
		// construct the body
		int i; Iterator iter;
		for(iter=localVariables.iterator(), i=0;iter.hasNext();++i)
			blk.insertStmt(i, (Stmt)iter.next());
		if(!retvar.isEmpty()) {
			Variable decl = (Variable)retvar.getChild(0);
			String varname = decl.name();
			ReturnStmt stmt = new ReturnStmt(new VarAccess(varname));
			blk.insertStmt(blk.getNumStmt(), stmt);
		}
		// lock type accesses
		blk.lockTypeAccesses(table);
		if(tvars == null)
			return new MethodDecl(mod, acc, name, parmdecls, 
					throwdecls, new Opt(blk));
		else
			return new GenericMethodDecl(mod, acc, name, parmdecls,
					throwdecls, new Opt(blk), tvars);
	}
	
	/* when locking type accesses, we shouldn't lock accesses that resolve to
	 * type variables: if the type variable referred to was a type parameter of
	 * the surrounding method, there will be no way to refer to it in the extracted
	 * method, but that isn't really the problem, since the extracted method will
	 * have its own copies of these type variables, and it is the _copies_ that we
	 * should refer to
	 * 
	 * I really don't like this workaround... 
	 */
	refine ExtractBlock public void TypeAccess.lockTypeAccesses(AdjustmentTable table) {
		if(!decl().isTypeVariable())
			table.add(this);
	}
	
}
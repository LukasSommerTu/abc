aspect ClosureSubstitution {
	
	public ClosureInvocation ClosureInvocation.subst() throws RefactoringException {
		renameAway();
		AdjustmentTable table = new AdjustmentTable();
		for(int i=getNumParameter()-1;i>=0;--i) {
			RefactoringException exn = getParameter(i).inline(table);
			if(exn != null)
				throw exn;
		}
		programRoot().flushCaches();
		table.adjust();
		return this;
	}
	
	inh RefactoringException ParameterDeclaration.inline(AdjustmentTable table);
	
	eq ClosureInvocation.getParameter(int i).inline(AdjustmentTable table) {
		ParameterDeclaration pd = getParameter(i);
		Expr arg = getArg(i);
		try {
			if(pd.isIn()) {
				TypeDecl type = pd.type();
				arg.lockAll(table);
				removeParameter(i);
				removeArg(i);
				VariableDeclaration newdecl = new VariableDeclaration(type.getLockedAccess(table), pd.name(), arg);
				getBlock().insertStmt(0, newdecl);
			} else {
				if(!(arg instanceof VarAccess))
					throw new RefactoringException("cannot inline argument");
				Variable decl = ((VarAccess)arg).decl();
				Collection<VarAccess> uses = pd.uses();
				removeParameter(i);
				removeArg(i);
				for(VarAccess v : uses) {
					v.flushCaches();
					v.lockOn(decl);
					table.add(v);
				}
			}
		} catch(RefactoringException rfe) {
			return rfe;
		}
		return null;
	}
	eq Program.getChild().inline(AdjustmentTable table) {
		throw new RuntimeException("Cannot inline non-closure parameters");
	}
	
	//// rename all parameters and local variables to avoid clashes with surrounding locals
	private void ClosureInvocation.renameAway() throws RefactoringException {
		AdjustmentTable table = new AdjustmentTable();
		lockAll(table);
		java.util.Set<LocalDeclaration> vars = new java.util.HashSet<LocalDeclaration>();
		collectLocalDeclarations(vars);
		for(LocalDeclaration v : vars)
			if(nameClash(v.getID()))
				v.setID(pickFreshVarName(v.getID()));
		programRoot().flushCaches();
		table.adjust();
	}
	
	public void ASTNode.collectLocalDeclarations(java.util.Set<LocalDeclaration> res) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.collectLocalDeclarations(res);
		}
	}
	
	public void VariableDeclaration.collectLocalDeclarations(java.util.Set<LocalDeclaration> res) {
		res.add(this);
	}
	
	public void ParameterDeclaration.collectLocalDeclarations(java.util.Set<LocalDeclaration> res) {
		res.add(this);
	}
	
	public void TypeDecl.collectLocalDeclarations(java.util.Set<LocalDeclaration> res) {
		// cut off
	}
	
	private boolean ClosureInvocation.nameClash(String name) {
		SimpleSet set = lookupVariable(name);
		if(set.isEmpty())
			return !canIntroduceLocal(name);
		Variable v = (Variable)set.iterator().next();
		return v.isLocal();
	}
	
	syn lazy boolean Variable.isLocal();
	eq FieldDeclaration.isLocal() = false;
	eq ParameterDeclaration.isLocal() = true;
	eq VariableDeclaration.isLocal() = true;
	
	private String ClosureInvocation.pickFreshVarName(String base) {
		for(int i=0;;++i)
			if(!nameClash(base+i))
				return base+i;
	}
		
}
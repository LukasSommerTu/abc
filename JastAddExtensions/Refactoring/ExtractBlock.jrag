/*
 * The first part of the Extract Method refactoring, Extract Block takes a piece of
 * code (given by its start and end statements) and turns it into a block.
 * 
 * We need to ensure that this is possible (see precondition checks), and possibly
 * move some declarations for variables that are used outside the selection out of
 * the generated block.
 */

aspect ExtractBlock {

  public void Block.extractBlock(int begin, int end) 
    throws RefactoringException {
    new ExtractBlockRefactoring(this, begin, end).execute();
  }

  class ExtractBlockRefactoring {
    Block block;
    int begin;
    int end;
    int n;
    Stmt[] stmts;
    Collection<Stmt>[] preds;
    Set[] succs;
    Block new_block;
    Collection<Variable> vars_used_after_selection;
    AdjustmentTable table;

    public ExtractBlockRefactoring(Block block, int begin, int end) 
        throws RefactoringException {
      this.block = block;
      this.begin = begin;
      this.end = end;
      this.n = end-begin;
      if(begin < 0 || end >= block.getNumStmt() || end < begin)
	throw new RefactoringException("indices out of range");
      stmts = new Stmt[n+1];
      preds = new Collection[n+1];
      succs = new Set[n+1];
      for(int i=0;i<=n;++i) {
	stmts[i] = block.getStmt(begin+i);
	preds[i] = stmts[i].pred();
	succs[i] = stmts[i].succ();
      }
      table = new AdjustmentTable();
    }

    public void execute() throws RefactoringException {
      vars_used_after_selection = varsUsedAfterSelection();
      block.lockAllTypeAccesses(table);
      new_block = block.pullTogether(begin, end);
      flushLocalCaches();
      checkCFlow();
      moveDeclarations();
    }
   
    private void flushLocalCaches() {
      //block.enclosingBodyDecl().flushCaches();
      block.programRoot().flushCaches();
    }

    private void checkCFlow() throws RefactoringException {
      // the first statement should have the same predecessor as before
      // except for the new block
      Collection<Stmt> firstpred = stmts[0].pred();
      firstpred.remove(new_block);
      if(!preds[0].equals(firstpred))
	throw new RefactoringException("couldn't preserve control flow into statement #0");
      // all other statements should have same predecessors
      for(int i=0;i<=n;++i)
	if(!preds[i].equals(stmts[i].pred()))
	  throw new RefactoringException("couldn't preserve control flow into statement #"+i);
      // all statements should have same successors
      for(int i=0;i<=n;++i)
	if(!succs[i].equals(stmts[i].succ()))
	  throw new RefactoringException("couldn't preserve control flow out of statement #"+i);
    }

    private void moveDeclarations() throws RefactoringException {
      Collection<VariableDeclaration> to_be_moved 
	= new ArrayList<VariableDeclaration>();
      // figure out which of the local_vars_used_after_selection 
      // are actually declared within the selection
      for(int i=0;i<=n;++i)
	if(vars_used_after_selection.contains(stmts[i]))
	  to_be_moved.add((VariableDeclaration)stmts[i]);
      for(VariableDeclaration v : to_be_moved) {
	v.split();
	new_block.removeStmt(v);
	block.insertStmt(begin++, v);
      }
      // stmts[] is now outdated, so we might as well nix it
      stmts = null;
      flushLocalCaches();
      table.adjust();
    }

    private Collection<Variable> varsUsedAfterSelection() {
      Collection<Variable> res = new HashSet<Variable>();
      for(int i=end+1;i<block.getNumStmt();++i)
	block.getStmt(i).allAccessedVars(res);
      return res;
    }

  }

  public void ASTNode.removeChild(ASTNode child) {
    removeChild(getIndexOfChild(child));
  }

  public void Block.removeStmt(Stmt stmt) {
    getStmtList().removeChild(stmt);
  }

  // lock all type accesses in a subtree
  public void ASTNode.lockAllTypeAccesses(AdjustmentTable table) {
    lockTypeAccesses(table);
    for(int i = 0; i < getNumChildNoTransform(); i++) {
      ASTNode node = getChildNoTransform(i);
      if(node != null) 
	node.lockAllTypeAccesses(table);
    }
  }

  public void ASTNode.lockTypeAccesses(AdjustmentTable table) {}
  public void TypeAccess.lockTypeAccesses(AdjustmentTable table) {
    super.lockTypeAccesses(table);
    table.add(this);
  }

  // get all variable accesses in a subtree
  public void ASTNode.allAccessedVars(Collection<Variable> res) {
    accessedVars(res);
    for(int i = 0; i < getNumChildNoTransform(); i++) {
      ASTNode node = getChildNoTransform(i);
      if(node != null) 
	node.allAccessedVars(res);
    }
  }

  public void ASTNode.accessedVars(Collection<Variable> res) {}
  public void VarAccess.accessedVars(Collection<Variable> res) {
    super.accessedVars(res);
    res.add(decl());
  }
}
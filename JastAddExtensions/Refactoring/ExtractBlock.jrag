aspect ExtractBlock {
	
	public void CompilationUnit.extractBlock(Stmt begin, Stmt end) 
			throws RefactoringException {
		check_block_extraction_preconds(begin, end);
		Block begin_host = begin.hostBlock();
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		begin_host.encapsulate(begin_idx, end_idx);
	}
	
	private void CompilationUnit.check_block_extraction_preconds(Stmt begin, Stmt end)
			throws RefactoringException {
		if(begin.isInitOrUpdateStmt() || end.isInitOrUpdateStmt())
			throw new RefactoringException("selection cannot start or end at init or update statements");
		if(!begin.dominates(end))
			throw new RefactoringException("begin must dominate end");
		Block begin_host = begin.hostBlock();
		Block end_host = end.hostBlock();
		if(begin_host == null || end_host == null)
			throw new RefactoringException("invalid statement for extraction");
		if(begin_host != end_host)
			throw new RefactoringException("selection straddles block borders");
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		for(int i=begin_idx;i<=end_idx;++i)
			if(begin_host.getStmt(i) instanceof Case)
				throw new RefactoringException("selection cannot contain case labels");
	}
	
	public void Block.encapsulate(int begin, int end) 
			throws RefactoringException {
		Stmt begin_stmt = getStmt(begin);
		Stmt end_stmt = getStmt(end);
		int i; Iterator iter;
		Collection moveOut = localDeclsBetween(begin, end);
		// leave only those decls that are accessed after end
		for(iter=moveOut.iterator();iter.hasNext();) {
			VariableDeclaration vdecl = (VariableDeclaration)iter.next();
			if(!vdecl.accessedAfter(end_stmt))
				iter.remove();
		}
		/*
		 * what we do now:
		 * 1. for every declaration to be moved out, see if it has an initializer
		 *    a) if yes, then insert the declaration (without initializer) at
		 *       position start++ and replace the original definition by an assignment
		 *    b) if no, then insert the declaration at start++ and remove original,
		 *       not forgetting to decrement end
		 * 2. pull statements between start and end together into a block
		 */
		for(iter=moveOut.iterator();iter.hasNext();) {
			VariableDeclaration vd = (VariableDeclaration)iter.next();
			if(vd.hasInit()) {
				Expr init = vd.getInit();
				Stmt assign = new ExprStmt(new AssignSimpleExpr(
					new VarAccess(vd.getID()), init));
				vd.replaceWith(assign);
				vd = (VariableDeclaration)vd.fullCopy();
				vd.setInitOpt(new Opt());
				insertStmt(start++, vd);
			} else {
				moveStmt(vd, start++);
				--end;
			}
		}
		pullTogether(start, end);
	}
	
}
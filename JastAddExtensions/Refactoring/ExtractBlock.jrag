/*
 * The first part of the Extract Method refactoring, Extract Block takes a piece of
 * code (given by its start and end statements) and turns it into a block.
 * 
 * We need to ensure that this is possible (see precondition checks), and possibly
 * move some declarations for variables that are used outside the selection out of
 * the generated block.
 */

aspect ExtractBlock {

	public Block Block.extractBlock(int begin, int end) 
	throws RefactoringException {
		return new ExtractBlockRefactoring(this, begin, end).execute();
	}

	class ExtractBlockRefactoring {
		Block block;
		int begin;
		int end;
		Block new_block;
		AdjustmentTable table;

		public ExtractBlockRefactoring(Block block, int begin, int end) 
		throws RefactoringException {
			this.block = block;
			if (end <= begin) {
				int tmp = end;
				end = begin;
				begin = tmp;
			}
			this.begin = begin;
			this.end = end;
			if(begin < 0 || end >= block.getNumStmt() || end < begin)
				throw new RefactoringException("indices out of range");
			table = new AdjustmentTable();
		}

		public Block execute() throws RefactoringException {
			block.lockAllAccesses(table);
			new_block = new Block(new List());
			block.insertStmt(end+1, new_block);
			for(int i=end;i>=begin;--i) {
				Stmt stmt = block.getStmt(i);
				boolean leftover_decl = stmt.pushIntoBlock();
				// take care of left-over variable declarations
				if(leftover_decl && i > begin) {
					stmt = block.getStmt(i);
					block.removeStmt(i);
					block.insertStmt(begin++, stmt);
					i++;
					flushCaches();
				}
			}
			flushCaches();
			table.adjust();
			return new_block;
		}

		private void flushCaches() {
			block.programRoot().flushCaches();
		}
	}
	
	public Block Stmt.turnIntoBlock() throws RefactoringException {
		if(getParent().getParent() instanceof Block) {
			Block blk = (Block)getParent().getParent();
			int idx = blk.getIndexOfStmt(this);
			return blk.extractBlock(idx, idx);
		} else {
			if(!extractable())
				throw new RefactoringException("not extractable");
			ASTNode parent = getParent();
			AdjustmentTable table = new AdjustmentTable();
			table.addCFlow(this);
			Block new_block = new Block(new List());
			replaceWith(new_block);
			new_block.addStmt(this);
			parent.programRoot().flushCaches();
			table.adjust();
			return new_block;
		}
	}
	
	inh boolean Stmt.extractable();
	eq ConstructorDecl.getConstructorInvocation().extractable() = false;
	eq Block.getStmt(int i).extractable() = true;
	eq IfStmt.getThen().extractable() = true;
	eq IfStmt.getElse().extractable() = true;
	eq WhileStmt.getStmt().extractable() = true;
	eq DoStmt.getStmt().extractable() = true;
	eq ForStmt.getInitStmt(int i).extractable() = false;
	eq ForStmt.getUpdateStmt(int i).extractable() = false;
	eq ForStmt.getStmt().extractable() = true;
	eq EnhancedForStmt.getStmt().extractable() = true;
	
	// all places where the grammar prescribes a block are also not extractable
	// this could be relaxed: we could wrap the block to be extracted into another block first
	eq InstanceInitializer.getBlock().extractable() = false;
	eq StaticInitializer.getBlock().extractable() = false;
	eq ConstructorDecl.getBlock().extractable() = false;
	eq MethodDecl.getBlock().extractable() = false;
	eq SwitchStmt.getBlock().extractable() = false;
	eq SynchronizedStmt.getBlock().extractable() = false;
	eq TryStmt.getBlock().extractable() = false;
	eq TryStmt.getFinally().extractable() = false;
	eq CatchClause.getBlock().extractable() = false;

	public void ASTNode.removeChild(ASTNode child) {
		removeChild(getIndexOfChild(child));
	}

	public void Block.removeStmt(Stmt stmt) {
		getStmtList().removeChild(stmt);
	}

	public void Block.removeStmt(int idx) {
		getStmtList().removeChild(idx);
	}

	// lock all type accesses in a subtree
	public void ASTNode.lockAllTypeAccesses(AdjustmentTable table) {
		for(int i = 0; i < getNumChildNoTransform(); i++) {
			ASTNode node = getChildNoTransform(i);
			if(node != null) 
				node.lockAllTypeAccesses(table);
		}
	}
	public void TypeAccess.lockAllTypeAccesses(AdjustmentTable table) {
		super.lockAllTypeAccesses(table);
		table.add(this);
	}

	// lock all variable accesses in a subtree
	public void ASTNode.lockAllVarAccesses(AdjustmentTable table) {
		for(int i = 0; i < getNumChildNoTransform(); i++) {
			ASTNode node = getChildNoTransform(i);
			if(node != null) 
				node.lockAllVarAccesses(table);
		}
	}
	public void VarAccess.lockAllVarAccesses(AdjustmentTable table) {
		super.lockAllTypeAccesses(table);
		table.add(this);
	}

	// lock all accesses (variable and type) in a subtree
	public void ASTNode.lockAllAccesses(AdjustmentTable table) {
		lockAllTypeAccesses(table);
		lockAllVarAccesses(table);
	}
}

aspect PushDownMethod {	
	/**
	 * The Push Down Method Refactoring.
	 * 
	 * Preconditions:
	 *  - host type of method to be pushed has exactly one child type
	 *  - that child type does not already contain a method with the same signature
	 *  
	 * The preconditions ensure that it is enough to adjust all accesses to
	 * the method being pushed and all accesses within that method.
	 * 
	 * If pushing from an interface to a class, we need to make the pushed
	 * method public and abstract.
	 */
	public void MethodDecl.pushDown() {
		if(isRootMethod() && !hostType().isAbstract())
			throw new RefactoringException("cannot push a root method");
		Collection<TypeDecl> children = hostType().childTypes();
		if(children.size() != 1)
			throw new RefactoringException("can only push down to exactly one subclass");
		TypeDecl child = children.iterator().next();
		if(!child.localMethodsSignature(signature()).isEmpty())
			throw new RefactoringException("method with that signature already exists");
		if(hostType().isInterfaceDecl() && !child.isInterfaceDecl())
			getModifiers().addModifiers("public", "abstract");
		unfoldSynchronized();
		programRoot().lockMethodNames(name());
		lockAllNames();
		hostType().removeBodyDecl(this);
		child.addBodyDecl(this);
		programRoot().flushCaches();
		foldSynchronized();
	}
	
	// check whether this method has ancestors, but all of them are abstract
    private boolean MethodDecl.isRootMethod() {
    	if(overrides().isEmpty())
    		return false;
    	for(MethodDecl anc : overrides())
    		if(!anc.isAbstract())
    			return false;
    	return true;
	}
	
    public void MethodDecl.doPushDown() {
    	pushDown();
    	programRoot().eliminate(LOCKED_NAMES);
    }
}
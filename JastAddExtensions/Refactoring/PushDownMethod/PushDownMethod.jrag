aspect PushDownMethod {	
	/**
	 * The Push Down Method Refactoring.
	 * 
	 * Preconditions:
	 * 	- method to be pushed does not override another method
	 *  - host type of method to be pushed has exactly one child type
	 *  - that child type does not already contain a method with the same signature
	 *  
	 * The preconditions ensure that it is enough to adjust all accesses to
	 * the method being pushed and all accesses within that method.
	 * 
	 * If pushing from an interface to a class, we need to make the pushed
	 * method public and abstract.
	 */
	public void MethodDecl.pushDown() {
		if(!this.overrides().isEmpty())
			throw new RefactoringException("cannot push down overriding method");
		TypeDecl oldhost = hostType();
		Collection<TypeDecl> children = oldhost.childTypes();
		if(children.size() != 1)
			throw new RefactoringException("can only push down to exactly one subclass");
		TypeDecl child = children.iterator().next();
		if(!child.localMethodsSignature(signature()).isEmpty())
			throw new RefactoringException("method with that signature already exists");
		unfoldSynchronized();
		programRoot().lockMethodNames(Collections.singleton(name()));
		lockAllNames();
		moveTo(child);
		if(oldhost.isInterfaceDecl() && !child.isInterfaceDecl())
			makePublicAbstract();
		programRoot().flushCaches();
		foldSynchronized();
	}
	
	// move a method decl to a new type
	private void MethodDecl.moveTo(TypeDecl target) {
		hostType().removeBodyDecl(this);
		target.addBodyDecl(this);
	}
	
	// make a method public and abstract
    private void MethodDecl.makePublicAbstract() {
    	if(!getModifiers().isPublic())
    		getModifiers().addModifier(new Modifier("public"));
    	getModifiers().addModifier(new Modifier("abstract"));
	}
	
    public void MethodDecl.doPushDown() {
    	pushDown();
    	programRoot().eliminate(LOCKED_NAMES);
    }
}
aspect ClosureConversion {
	
	public ClosureInvocation ClosureInvocation.convert() throws RefactoringException {
		return new ClosureConversionRefactoring(this).execute();
	}
	
	class ClosureConversionRefactoring {
		ClosureInvocation cl;
		AdjustmentTable table = new AdjustmentTable();
		class Directionality {
			boolean in;
			boolean out;
		}
		java.util.Set<VarAccess> local_var_accesses;
		Map<LocalDeclaration, Directionality> parms = new HashMap<LocalDeclaration, Directionality>();
		
		public ClosureConversionRefactoring(ClosureInvocation cl) {
			this.cl = cl;
			this.local_var_accesses = cl.localVarAccesses();
		}
		
		public ClosureInvocation execute() throws RefactoringException {
			findParms();
			addParms();
			flushCaches();
			addLocals();
			flushCaches();
			table.adjust();
			return cl;
		}
		
		private void flushCaches() {
			cl.flushCaches();
		}
		
		private void findParms() {
			for(VarAccess v : local_var_accesses) {
				if(hasIncomingDataflowEdge(v))
					addInParm((LocalDeclaration)v.decl());
				if(hasOutgoingDataflowEdge(v))
					addOutParm((LocalDeclaration)v.decl());
			}
		}
		
		private boolean hasIncomingDataflowEdge(VarAccess v) {
			return cl.entry().live((LocalDeclaration)v.decl());
		}
		
		private boolean hasOutgoingDataflowEdge(VarAccess v) {
			return v.isDest() && v.reachable(cl.exit()) 
				&& cl.exit().live((LocalDeclaration)v.decl());
		}
		
		private void addInParm(LocalDeclaration decl) {
			Directionality dir = parms.get(decl);
			if(dir == null)
				dir = new Directionality();
			dir.in = true;
			parms.put(decl, dir);
		}
		
		private void addOutParm(LocalDeclaration decl) {
			Directionality dir = parms.get(decl);
			if(dir == null)
				dir = new Directionality();
			dir.out = true;
			parms.put(decl, dir);
		}
		
		private void addParms() throws RefactoringException {
			for(Map.Entry<LocalDeclaration, Directionality> e : parms.entrySet()) {
				LocalDeclaration decl = e.getKey();
				Directionality dir = e.getValue();
				ParameterDeclaration parmdecl = decl.asLockedParameterDeclaration(table);
				if(dir.in && dir.out)
					parmdecl.getModifiers().addModifier(new Modifier("ref"));
				else if(dir.out)
					parmdecl.getModifiers().addModifier(new Modifier("out"));
				cl.addParameter(parmdecl);
				cl.addArg(new VarAccess(decl.name()));
			}
			putVarArgAtEnd();
		}
		
		// shuffle parameters so that any variable arity parameter comes last 
		private void putVarArgAtEnd() throws RefactoringException {
			ParameterDeclaration varparm = null;
			Expr vararg = null;
			for(int i=0;i<cl.getNumParameter();++i) {
				if(cl.getParameter(i).isVariableArity())
					if(varparm == null) {
						varparm = cl.getParameter(i);
						vararg = cl.getArg(i);
					} else {
						throw new RefactoringException("there can be only one variable-arity argument");
					}
			}
			if(varparm == null)
				return;
			cl.getParameterList().removeChild(varparm);
			cl.getArgList().removeChild(vararg);
			cl.addParameter(varparm);
			cl.addArg(vararg);
		}
		
		private void addLocals() throws RefactoringException {
			for(VarAccess v : local_var_accesses) {
				if(declaredOutside(v)) {
					cl.getBlock().insertStmt(0, new VariableDeclaration(v.type().getLockedAccess(table), v.name()));
					flushCaches();
				}
			}
		}
		
		private boolean declaredOutside(VarAccess v) {
			return !((ASTNode)v.decl()).beneath(cl);
		}
	}

	public boolean ASTNode.beneath(ASTNode n) {
		ASTNode p;
		for(p=this;p!=n&&p!=null;p=p.getParent())
			;
		return p!=null;
	}

	// determine all local declarations referred to in this subtree, which are defined outside root
	public java.util.Set<VarAccess> ASTNode.localVarAccesses() {
		java.util.Set<VarAccess> res = new HashSet<VarAccess>();
		localVarAccesses(res);
		return res;
	}

	public void ASTNode.localVarAccesses(java.util.Set<VarAccess> res) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.localVarAccesses(res);
		}
	}
	
	public void VarAccess.localVarAccesses(java.util.Set<VarAccess> res) {
		if(decl() instanceof LocalDeclaration)
			res.add(this);
		super.localVarAccesses(res);
	}
}
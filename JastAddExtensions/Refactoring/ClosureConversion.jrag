aspect ClosureConversion {
	
	public ClosureInvocation ClosureInvocation.convert() throws RefactoringException {
		AdjustmentTable table = new AdjustmentTable();
		java.util.Set<VarAccess> locals = localVarAccesses();
		for(VarAccess v : locals)
			closeOver(v, table);
		putVarArgAtEnd();
		programRoot().flushCaches();
		for(VarAccess v : locals)
			if(declaredOutside(v))
				localize(v, table);
		table.adjust();
		return this;
	}
	
	public void ClosureInvocation.closeOver(VarAccess v, AdjustmentTable table) throws RefactoringException {
		if(v.hasDataPredBefore(entry()))
			addInParm((LocalDeclaration)v.decl(), table);
		if(v.hasDataSuccAfter(exit()))
			addOutParm((LocalDeclaration)v.decl(), table);
		programRoot().flushCaches();
	}
	
	private void ClosureInvocation.localize(VarAccess v, AdjustmentTable table) throws RefactoringException {
		getBlock().insertStmt(0, new VariableDeclaration(v.type().getLockedAccess(table), v.name()));
		programRoot().flushCaches();
	}
	
	// add an input parameter having the same modifiers, name, and type as decl
	private void ClosureInvocation.addInParm(LocalDeclaration decl, AdjustmentTable table) throws RefactoringException {
		ParameterDeclaration parm = getParameter(decl.name());
		if(parm == null) {
			parm = decl.asLockedParameterDeclaration(table);
			addParameter(parm);
			addArg(new VarAccess(decl.name()));
		}
		if(parm.isOut())
			parm.makeRef();
	}

	// add an output parameter having the same modifiers, name, and type as decl
	private void ClosureInvocation.addOutParm(LocalDeclaration decl, AdjustmentTable table) throws RefactoringException {
		ParameterDeclaration parm = getParameter(decl.name());
		if(parm == null) {
			parm = decl.asLockedParameterDeclaration(table);
			parm.getModifiers().addModifier(new Modifier("out"));
			addParameter(parm);
			addArg(new VarAccess(decl.name()));
		}
		if(!parm.isWrite())
			parm.getModifiers().addModifier(new Modifier("ref"));
	}
	
	private ParameterDeclaration ClosureInvocation.getParameter(String name) {
		for(ParameterDeclaration pd : getParameters())
			if(pd.name().equals(name))
				return pd;
		return null;
	}
			
	// shuffle parameters so that any variable arity parameter comes last 
	private void ClosureInvocation.putVarArgAtEnd() throws RefactoringException {
		ParameterDeclaration varparm = null;
		Expr vararg = null;
		for(int i=0;i<getNumParameter();++i) {
			if(getParameter(i).isVariableArity())
				if(varparm == null) {
					varparm = getParameter(i);
					vararg = getArg(i);
				} else {
					throw new RefactoringException("there can be only one variable-arity argument");
				}
		}
		if(varparm == null)
			return;
		getParameterList().removeChild(varparm);
		getArgList().removeChild(vararg);
		addParameter(varparm);
		addArg(vararg);
	}
	
	private boolean ClosureInvocation.declaredOutside(VarAccess v) {
		return !((ASTNode)v.decl()).beneath(this);
	}

	public boolean ASTNode.beneath(ASTNode n) {
		ASTNode p;
		for(p=this;p!=n&&p!=null;p=p.getParent())
			;
		return p!=null;
	}

	// determine all local declarations referred to in this subtree
	public java.util.Set<VarAccess> ASTNode.localVarAccesses() {
		java.util.Set<VarAccess> res = new HashSet<VarAccess>();
		localVarAccesses(res);
		return res;
	}

	public void ASTNode.localVarAccesses(java.util.Set<VarAccess> res) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.localVarAccesses(res);
		}
	}
	
	public void VarAccess.localVarAccesses(java.util.Set<VarAccess> res) {
		if(decl() instanceof LocalDeclaration)
			res.add(this);
		super.localVarAccesses(res);
	}
}
aspect ClosureConversion {
	public ClosureInvocation ClosureInvocation.convert() throws RefactoringException {
		AdjustmentTable table = new AdjustmentTable();
		java.util.Set<VarAccess> local_accesses = collectLocalAccesses();
		for(VarAccess var : local_accesses)
			introduceParameter(var, table);
		flushCaches();
		for(VarAccess var : local_accesses)
			localizeVariable(var, table);
		table.adjust();
		return this;
	}
	
	private boolean ClosureInvocation.hasIncomingDataflowEdge(VarAccess v) {
		for(CFGNode u : v.dataPred())
			if(!((ASTNode)u).beneath(this))
				return true;
		return false;
	}

	private boolean ClosureInvocation.hasOutgoingDataflowEdge(VarAccess v) {
		for(CFGNode w : v.dataSucc())
			if(!((ASTNode)w).beneath(this))
				return true;
		return false;
	}

	private boolean ClosureInvocation.declaredOutside(VarAccess v) {
		return !((ASTNode)v.decl()).beneath(this);
	}

	public ParameterDeclaration ClosureInvocation.introduceParameter(VarAccess var, AdjustmentTable table) throws RefactoringException {
		ParameterDeclaration pd = null;
		if(hasIncomingDataflowEdge(var))
			pd = introduceInParameter(var, table);
		if(hasOutgoingDataflowEdge(var))
			pd = introduceOutParameter(var, table);
		return pd;
	}
	
	public ParameterDeclaration ClosureInvocation.introduceInParameter(VarAccess var, AdjustmentTable table) throws RefactoringException {
		TypeDecl type = var.type();
		ParameterDeclaration pd;
		SimpleSet set = parameterDeclaration(var.name());
		if(set.isEmpty()) {
			pd = new ParameterDeclaration(type.getLockedAccess(table), var.name());
			addParameter(pd);
			addArg(new VarAccess(var.name()));
		} else {
			pd = (ParameterDeclaration)set.iterator().next();
			if(pd.isOut())
				pd.makeRef();
		}
		return pd;
	}
	
	public ParameterDeclaration ClosureInvocation.introduceOutParameter(VarAccess var, AdjustmentTable table) throws RefactoringException {
		TypeDecl type = var.type();
		ParameterDeclaration pd;
		SimpleSet set = parameterDeclaration(var.name());
		if(set.isEmpty()) {
			pd = new ParameterDeclaration(new Modifiers(new List().add(new Modifier("out"))), 
										  type.getLockedAccess(table), var.name());
			addParameter(pd);
			addArg(new VarAccess(var.name()));
		} else {
			pd = (ParameterDeclaration)set.iterator().next();
			if(pd.isIn())
				pd.makeRef();
		}
		return pd;
	}
	
	public VariableDeclaration ClosureInvocation.localizeVariable(VarAccess var, AdjustmentTable table) throws RefactoringException {
		if(declaredOutside(var))
			return addLocalVariable(var, table);
		return null;
	}

	private VariableDeclaration ClosureInvocation.addLocalVariable(VarAccess v, AdjustmentTable table) throws RefactoringException {
		VariableDeclaration vd = new VariableDeclaration(v.type().getLockedAccess(table), v.name());
		getBlock().insertStmt(0, vd);
		flushCaches();
		return vd;
	}

	public boolean ASTNode.beneath(ASTNode n) {
		ASTNode p;
		for(p=this;p!=n&&p!=null;p=p.getParent())
			;
		return p!=null;
	}

	public java.util.Set<VarAccess> ASTNode.collectLocalAccesses() {
		java.util.Set<VarAccess> res = new HashSet<VarAccess>();
		this.collectLocalAccesses(res);
		return res;
	}

	public void ASTNode.collectLocalAccesses(java.util.Set<VarAccess> res) {
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.collectLocalAccesses(res);
		}
	}
	public void VarAccess.collectLocalAccesses(java.util.Set<VarAccess> res) {
		if(decl() instanceof LocalDeclaration)
			res.add(this);
		super.collectLocalAccesses(res);
	}
	
	public void ParameterDeclaration.makeRef() {
		Modifiers mods = getModifiers();
		for(int i=0;i<mods.getNumModifier();++i) {
			Modifier mod = mods.getModifier(i);
			if(mod.getID().equals("out"))
				mods.getModifiers().removeChild(i);
		}
		mods.addModifier(new Modifier("ref"));
	}
}
aspect ClosureConversion {
  public Closure Closure.convert() throws RefactoringException {
    return new ClosureConversionRefactoring(this).execute();
  }

  class ClosureConversionRefactoring {
    private Closure closure;
    private Application app;
    private java.util.Set<VarAccess> local_accesses;
    private AdjustmentTable table;

    public ClosureConversionRefactoring(Closure closure) throws RefactoringException {
      this.closure = closure;
      if(!(closure.getParent() instanceof Application))
	throw new RefactoringException("only closures in applications can be converted");
      this.app = (Application)closure.getParent();
      this.local_accesses = closure.collectLocalAccesses();
      this.table = new AdjustmentTable();
    }

    public Closure execute() throws RefactoringException {
      for(VarAccess v : local_accesses) {
	if(hasIncomingDataflowEdge(v))
	  addInputParameter(v);
	if(hasOutgoingDataflowEdge(v))
	  addOutputParameter(v);
      }
      for(VarAccess v : local_accesses) {
	if(!closure.hasOutParameter(v.name()) &&
	   hasNoIncomingDataflow(v) && declaredOutside(v)) {
	  Variable decl = v.decl();
	  addLocalVariable(v);
	  removeIfUnused(decl);
	}
      }
      table.adjust();
      return closure;
    }

    private boolean hasIncomingDataflowEdge(VarAccess v) {
      for(CFGNode u : v.reachingDefinitions())
	if(!((ASTNode)u).beneath(closure))
	  return true;
      return false;
    }

    private boolean hasNoIncomingDataflow(VarAccess v) {
      return v.reachingDefinitions().isEmpty();
    }

    private boolean hasOutgoingDataflowEdge(VarAccess v) {
      for(CFGNode w : v.reachedUses())
	if(!((ASTNode)w).beneath(closure))
	  return true;
      return false;
    }

    private boolean declaredOutside(VarAccess v) {
      return !((ASTNode)v.decl()).beneath(closure);
    }

    private TypeAccess getTypeAccessFor(VarAccess v) {
      TypeAccess tp = new TypeAccess(v.type().name());
      tp.lockOn(v.type());
      table.add(tp);
      return tp;
    }

    private void addInputParameter(VarAccess v) {
      if(closure.hasInParameter(v.name()))
	return;
      TypeAccess tp = getTypeAccessFor(v);
      closure.addInParameter(new ParameterDeclaration(tp, v.name()));
      app.addInRand((VarAccess)v.fullCopy());
      closure.programRoot().flushCaches();
    }

    private void addOutputParameter(VarAccess v) {
      if(closure.hasOutParameter(v.name()))
	return;
      TypeAccess tp = getTypeAccessFor(v);
      closure.addOutParameter(new ParameterDeclaration(tp, v.name()));
      app.addOutRand((VarAccess)v.fullCopy());
      closure.programRoot().flushCaches();
    }

    private void addLocalVariable(VarAccess v) throws RefactoringException {
      TypeAccess tp = getTypeAccessFor(v);
      closure.getBlock().insertStmt(0, new VariableDeclaration(tp, v.name()));
      closure.programRoot().flushCaches();
    }

    private void removeIfUnused(Variable decl) throws RefactoringException {
      if(!decl.isLocalVariable())
	return;
      ((VariableDeclaration)decl).removeUnused();
    }
  }

  public boolean ASTNode.beneath(ASTNode n) {
    ASTNode p;
    for(p=this;p!=n&&p!=null;p=p.getParent())
      ;
    return p!=null;
  }

  public java.util.Set<VarAccess> ASTNode.collectLocalAccesses() {
    java.util.Set<VarAccess> res = new HashSet<VarAccess>();
    this.collectLocalAccesses(res);
    return res;
  }

  public void ASTNode.collectLocalAccesses(java.util.Set<VarAccess> res) {
    for(int i=0;i<getNumChild();++i) {
      ASTNode child = getChild(i);
      if(child != null)
	child.collectLocalAccesses(res);
    }
  }
  public void VarAccess.collectLocalAccesses(java.util.Set<VarAccess> res) {
    if(decl() instanceof LocalDeclaration)
      res.add(this);
    super.collectLocalAccesses(res);
  }
}
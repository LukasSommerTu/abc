aspect ClosureConversion {
  public ClosureInvocation ClosureInvocation.convert() throws RefactoringException {
    return new ClosureConversionRefactoring(this).execute();
  }

  class ClosureConversionRefactoring {
    private ClosureInvocation closure;
    private java.util.Set<VarAccess> local_accesses;
    private AdjustmentTable table;

    public ClosureConversionRefactoring(ClosureInvocation closure) {
      this.closure = closure;
      this.local_accesses = closure.collectLocalAccesses();
      this.table = new AdjustmentTable();
    }

    public ClosureInvocation execute() throws RefactoringException {
      // first determine in and out parameters
      java.util.Set<VarAccess> in = new HashSet<VarAccess>();
      java.util.Set<VarAccess> out = new HashSet<VarAccess>();
      for(VarAccess v : local_accesses) {
	if(hasIncomingDataflowEdge(v))
	  in.add(v);
	if(hasOutgoingDataflowEdge(v))
	  out.add(v);
      }
      for(VarAccess v : in)
	addInputParameter(v);
      for(VarAccess v : out)
	addOutputParameter(v);
      // now determine variables to be localised
      for(VarAccess v : local_accesses) {
	if(declaredOutside(v))
	  addLocalVariable(v);
      }
      table.adjust();
      return closure;
    }

    private boolean hasIncomingDataflowEdge(VarAccess v) {
      for(CFGNode u : v.dataPred())
	if(!((ASTNode)u).beneath(closure))
	  return true;
      return false;
    }

    private boolean hasOutgoingDataflowEdge(VarAccess v) {
      for(CFGNode w : v.dataSucc())
	if(!((ASTNode)w).beneath(closure))
	  return true;
      return false;
    }

    private boolean declaredOutside(VarAccess v) {
      return !((ASTNode)v.decl()).beneath(closure);
    }

    private void addInputParameter(VarAccess v) {
      if(closure.hasInParameter(v.name()))
	return;
      closure.addInParameter(
        new ParameterDeclaration(
          v.type().getLockedAccess(table), 
	  v.name()
        )
      );
      closure.addInArg(new VarAccess(v.name()));
      flushCaches();
    }

    private void addOutputParameter(VarAccess v) {
      if(closure.hasOutParameter(v.name()))
	return;
      closure.addOutParameter(
        new ParameterDeclaration(
	  v.type().getLockedAccess(table), 
          v.name()
        )
      );
      closure.addOutArg(new VarAccess(v.name()));
      flushCaches();
    }

    private void addLocalVariable(VarAccess v) throws RefactoringException {
      closure.getBlock().insertStmt(0, 
        new VariableDeclaration(
	  v.type().getLockedAccess(table), 
          v.name()
        )
      );
      flushCaches();
    }

    private void flushCaches() {
      closure.programRoot().flushCaches();
    }
  }

  public boolean ASTNode.beneath(ASTNode n) {
    ASTNode p;
    for(p=this;p!=n&&p!=null;p=p.getParent())
      ;
    return p!=null;
  }

  public java.util.Set<VarAccess> ASTNode.collectLocalAccesses() {
    java.util.Set<VarAccess> res = new HashSet<VarAccess>();
    this.collectLocalAccesses(res);
    return res;
  }

  public void ASTNode.collectLocalAccesses(java.util.Set<VarAccess> res) {
    for(int i=0;i<getNumChild();++i) {
      ASTNode child = getChild(i);
      if(child != null)
	child.collectLocalAccesses(res);
    }
  }
  public void VarAccess.collectLocalAccesses(java.util.Set<VarAccess> res) {
    if(decl() instanceof LocalDeclaration)
      res.add(this);
    super.collectLocalAccesses(res);
  }
}
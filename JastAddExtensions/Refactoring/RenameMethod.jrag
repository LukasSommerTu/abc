import java.util.*;

/*
 * The Rename Method refactoring
 */

aspect RenameMethod {
	
	public void MethodDecl.rename(String new_name) throws RefactoringException {
		// first check which methods override this one/are overriden by this
		// obviously, we need to do that before we change its name
		// ("obvious" after I got tripped up by it, that is)
		SimpleSet overrides = overrides();
		java.util.Set overriders = overriders();
		// rename the method itself
		this.nonCascadingRename(new_name);
		// rename every method it overrides
		for(Iterator i = overrides.iterator();i.hasNext();)
			((MethodDecl)i.next()).nonCascadingRename(new_name);
		// rename every method it is overridden by
		for(Iterator i = overriders.iterator();i.hasNext();)
			((MethodDecl)i.next()).nonCascadingRename(new_name);
	}

	// rename a method, don't care about overriding/overridden methods
	public void MethodDecl.nonCascadingRename(String new_name) throws RefactoringException {
		if(getID().equals(new_name))
			return;
		String sig = signature();
		int idx = sig.indexOf('(');
		String new_sig = new_name + sig.substring(idx);
		// make sure there isn't already a method with the same signature in this type
		if(!hostType().localMethodsSignature(new_sig).isEmpty())
			throw new RefactoringException("couldn't rename: method signature clash");
		// if there are any like-named methods in superclasses, we must be able to override them
		for(Iterator i = hostType().ancestorMethods(new_sig).iterator();i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			if(!canOverrideOrHide(md))
				throw new RefactoringException("renamed method cannot override or hide "+md.hostType().typeName()+"."+md.signature());
		}
		AdjustmentTable table = findEndangered(new_name);
		changeID(new_name);
		programRoot().flushCaches();
		table.adjust();
	}

	private AdjustmentTable MethodDecl.findEndangered(String new_name) {
		AdjustmentTable table = new AdjustmentTable();
		/* first, collect all uses of the method we are renaming */
		for(Iterator i = definiteUses().iterator(); i.hasNext();) {
			Access a = (Access)i.next();
			table.add(a);
		}
		/* now, collect all uses of methods that we might be shadowing after renaming */
		for(Iterator i = lookupMethod(new_name).iterator(); i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			for(Iterator j = md.definiteUses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				table.add(acc);
			}
		}
		return table;
	}

}

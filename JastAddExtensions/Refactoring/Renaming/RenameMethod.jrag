import java.util.*;

/*
 * The Rename Method refactoring
 */

aspect RenameMethod {
	
	public void MethodDecl.rename(String new_name) throws RefactoringException {
		if(getID().equals(new_name))
			return;
		if(!isValidName(new_name))
			throw new RefactoringException("not a valid name: "+new_name);
		// first check which methods override this one/are overriden by this
		// (obviously, we need to do that before we change its name)
		// ("obvious" after I got tripped up by it, that is)
		SimpleSet overrides = overrides();
		java.util.Set overriders = overriders();
		// rename the method itself
		this.nonCascadingRename(new_name);
		// rename every method it overrides
		for(Iterator i = overrides.iterator();i.hasNext();)
			((MethodDecl)i.next()).nonCascadingRename(new_name);
		// rename every method it is overridden by
		for(Iterator i = overriders.iterator();i.hasNext();)
			((MethodDecl)i.next()).nonCascadingRename(new_name);
	}

	// rename a method, don't care about overriding/overridden methods
	public void MethodDecl.nonCascadingRename(String new_name) throws RefactoringException {
		String sig = signature();
		int idx = sig.indexOf('(');
		String new_sig = new_name + sig.substring(idx);
		// make sure there isn't already a method with the same signature in this type
		if(!hostType().localMethodsSignature(new_sig).isEmpty())
			throw new RefactoringException("couldn't rename: method signature clash");
		// if there are any like-named methods in superclasses, we must be able to override them
		for(Iterator i = hostType().ancestorMethods(new_sig).iterator();i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			if(!canOverrideOrHide(md))
				throw new RefactoringException("renamed method cannot override or hide "+md.hostType().typeName()+"."+md.signature());
		}
		AdjustmentTable table = findEndangeredMethodAccesses(new_name);
		changeID(new_name);
		programRoot().flushCaches();
		table.adjust();
	}
	
	private AdjustmentTable MethodDecl.findEndangeredMethodAccesses(String newname) {
		AdjustmentTable table = new AdjustmentTable(programRoot());
		programRoot().findEndangeredMethodAccesses(table, name(), newname);
		return table;
	}
	
	protected void ASTNode.findEndangeredMethodAccesses(AdjustmentTable tbl, 
													String oldname, String newname) {
		for(int i=0;i<getNumChild();++i)
			getChild(i).findEndangeredMethodAccesses(tbl, oldname, newname);
	}
		
	protected void MethodAccess.findEndangeredMethodAccesses(AdjustmentTable tbl,
													String oldname, String newname) {
		String name = name();
		if(name.equals(oldname) || name.equals(newname))
			tbl.add(this);
		// we also need to process the arguments
		for(int i=0;i<getNumChild();++i)
			getChild(i).findEndangeredMethodAccesses(tbl, oldname, newname);
	}
	
}

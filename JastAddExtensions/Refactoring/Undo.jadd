import java.util.*;

/*
 * This aspect implements a global Undo stack that remembers changes to the AST,
 * and rolls them back on demand.
 */

aspect Undo {

	private Stack Program.undoStack = new Stack();
	public Iterator Program.getUndoIterator() { return undoStack.iterator(); }
	public void Program.pushUndo(ASTChange ch) { undoStack.push(ch); }
	
	public void Program.undo() {
		while(!undoStack.empty())
			((ASTChange)undoStack.pop()).undo();
	}
	
	/*refine Names public void Named.changeID(String id) {
		programRoot().pushUndo(new Rename(this, id));
		Names.Named.setID(id);
	}*/
	
	protected void ASTNode.ensureFromSource() throws RefactoringException {
		CompilationUnit cu = compilationUnit();
		if(!cu.fromSource())
			throw new RefactoringException("cannot change binary "+
					"compilation unit "+cu.pathName());
	}
	
	refine Names public void VariableDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.VariableDeclaration.changeID(id);
	}
	refine Names public void ParameterDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.ParameterDeclaration.changeID(id);
	}
	refine Names public void FieldDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.FieldDeclaration.changeID(id);
	}
	refine Names public void ConstructorDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.ConstructorDecl.changeID(id);
	}
	refine Names public void MethodDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.MethodDecl.changeID(id);
	}
	refine Names public void TypeDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.TypeDecl.changeID(id);
	}
	refine Names public void CompilationUnit.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.CompilationUnit.changeID(id);
	}

	refine MakeMethod void TypeDecl.insertMethod(MethodDecl md, Block host, int index, 
			Collection parms, Opt retvar, TypeDecl rettype) 
			throws RefactoringException {
		ensureFromSource();
		MakeMethod.TypeDecl.insertMethod(md, host, index, parms, retvar, rettype);
		programRoot().pushUndo(new MakeMethod(this, md, host, index));
	}
	
	refine Encapsulate void TypeDecl.insertMethod(MethodDecl md) throws RefactoringException {
		ensureFromSource();
		Encapsulate.TypeDecl.insertMethod(md);
		programRoot().pushUndo(new InsertBodyDecl(this, md));
	}
	
	refine ASTUtil void Block.insertStmt(int idx, Stmt stmt) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new InsertStmt(this, idx, stmt));
		ASTUtil.Block.insertStmt(idx, stmt);
	}
	
	refine ASTUtil void Block.moveStmt(Stmt stmt, int new_idx) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new MoveStmt(this, stmt, new_idx));
		ASTUtil.Block.moveStmt(stmt, new_idx);
	}
	
	refine ASTUtil void Block.pullTogether(int start, int end) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new PullTogether(this, start, end));
		ASTUtil.Block.pullTogether(start, end);
	}
	
	// NOTE: we better not refine ASTNode.setChild(), since this is used in a couple
	//       of the other modification operations above
	refine ASTUtil void ASTNode.replaceWith(ASTNode newnode) throws RefactoringException {
		ensureFromSource();
		ASTUtil.ASTNode.replaceWith(newnode);
		programRoot().pushUndo(new ReplaceNode(this, newnode));
	}
	
	refine ASTUtil void FieldDeclaration.makePrivate() throws RefactoringException {
		ensureFromSource();
		ChangeFieldModifiers ch = new ChangeFieldModifiers(this);
		programRoot().pushUndo(ch);
		ASTUtil.FieldDeclaration.makePrivate();
		ch.setNewModifiers(this.getModifiers());
	}
	
	refine PushDownMethod void MethodDecl.makePublicAbstract() throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new ChangeMethodModifiers(this));
		PushDownMethod.MethodDecl.makePublicAbstract();
	}
	
	refine PushDownMethod void MethodDecl.moveTo(TypeDecl target) throws RefactoringException {
		ensureFromSource();
		target.ensureFromSource();
		programRoot().pushUndo(new MoveMethod(this, target));
		PushDownMethod.MethodDecl.moveTo(target);
	}
	
	refine ExtractClass public ClassDecl ClassDecl.createNewStaticMemberClassWithDefaultConstructor(String className) throws RefactoringException {
		ensureFromSource();
		ClassDecl cd =
			ExtractClass.ClassDecl.createNewStaticMemberClassWithDefaultConstructor(className);
		// this relies on the fact that member classes are always inserted as the last body decl
		programRoot().pushUndo(new InsertBodyDecl(this, 
				getBodyDecl(getNumBodyDecl()-1)));
		return cd;
	}
	
	refine ExtractClass public FieldDeclaration ClassDecl.createNewPublicMemberField(Access typeAccess, String fieldName) throws RefactoringException {
		ensureFromSource();
		FieldDeclaration fd =
			ExtractClass.ClassDecl.createNewPublicMemberField(typeAccess, fieldName);
		programRoot().pushUndo(new InsertBodyDecl(this, fd));
		return fd;
	}

	refine ExtractClass public void TypeDecl.removeOldField(BodyDecl bd) {
		programRoot().pushUndo(new RemoveBodyDecl(this, bd));
		ExtractClass.TypeDecl.removeOldField(bd);
	}
}

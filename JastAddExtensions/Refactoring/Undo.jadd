import java.util.*;

/*
 * This aspect implements a global Undo stack that remembers changes to the AST,
 * and rolls them back on demand.
 */

aspect Undo {

	private Stack Program.undoStack = new Stack();
	public Iterator Program.getUndoIterator() { return undoStack.iterator(); }
	public void Program.pushUndo(ASTChange ch) { undoStack.push(ch); }
	
	public void Program.undo() {
		while(!undoStack.empty())
			((ASTChange)undoStack.pop()).undo();
	}
	
	/*refine Names public void Named.changeID(String id) {
		programRoot().pushUndo(new Rename(this, id));
		Names.Named.setID(id);
	}*/
	
	protected void ASTNode.ensureFromSource() throws RefactoringException {
		if(!compilationUnit().fromSource())
			throw new RefactoringException("cannot change library class");
	}
	
	refine Names public void VariableDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.VariableDeclaration.changeID(id);
	}
	refine Names public void ParameterDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.ParameterDeclaration.changeID(id);
	}
	refine Names public void FieldDeclaration.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.FieldDeclaration.changeID(id);
	}
	refine Names public void ConstructorDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.ConstructorDecl.changeID(id);
	}
	refine Names public void MethodDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.MethodDecl.changeID(id);
	}
	refine Names public void TypeDecl.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.TypeDecl.changeID(id);
	}
	refine Names public void CompilationUnit.changeID(String id) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new Rename(this, id));
		Names.CompilationUnit.changeID(id);
	}

	refine MakeMethod void TypeDecl.insertMethod(MethodDecl md, Block host, int index, 
			Collection parms, Opt retvar, TypeDecl rettype) 
			throws RefactoringException {
		ensureFromSource();
		MakeMethod.TypeDecl.insertMethod(md, host, index, parms, retvar, rettype);
		programRoot().pushUndo(new MakeMethod(this, md, host, index));
	}
	
	refine ASTUtil void Block.insertStmt(int idx, Stmt stmt) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new InsertStmt(this, idx, stmt));
		ASTUtil.Block.insertStmt(idx, stmt);
	}
	
	refine ASTUtil void Block.moveStmt(Stmt stmt, int new_idx) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new MoveStmt(this, stmt, new_idx));
		ASTUtil.Block.moveStmt(stmt, new_idx);
	}
	
	refine ASTUtil void Block.pullTogether(int start, int end) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new PullTogether(this, start, end));
		ASTUtil.Block.pullTogether(start, end);
	}
	
	// NOTE: we better not refine ASTNode.setChild(), since this is used in a couple
	//       of the other modification operations above
	refine ASTUtil void ASTNode.replaceWith(ASTNode newnode) throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new ReplaceNode(this, newnode));
		ASTUtil.ASTNode.replaceWith(newnode);
	}
	
	refine ASTUtil void FieldDeclaration.makePrivate() throws RefactoringException {
		ensureFromSource();
		programRoot().pushUndo(new PrivatiseField(this));
		ASTUtil.FieldDeclaration.makePrivate();
	}

}

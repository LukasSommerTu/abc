aspect Locks {
	public boolean MonitorAction.replaceWithReentrantLock() {
		if(!fromSource())
			return false;
		return getAcquiredMonitor().replaceWithReentrantLock(programRoot());
	}
	
	public boolean WaitNotifyMethodCall.replaceWithReentrantLock() {
		if(!fromSource())
			return false;
		return getAcquiredMonitor().replaceWithReentrantLock(acc.programRoot());
	}
	
	public boolean MethodDecl.replaceWithReentrantLock() {
		if(!hasBlock() || !fromSource())
			return false;
		return getAcquiredMonitor().replaceWithReentrantLock(programRoot()); 
	}
	
	public TypeDecl Monitor.typeReentrantLock() { return type.programRoot().typeReentrantLock(); }
	public TypeDecl Monitor.typeCondition()     { return type.programRoot().typeCondition(); }
	
	protected FieldDeclaration Monitor.lockField = null;
	protected FieldDeclaration Monitor.conditionField = null;
	
	protected FieldDeclaration Monitor.createLockField(Modifiers mods, String name) {
		return new FieldDeclaration(mods, typeReentrantLock().createLockedAccess(), name, 
									new ClassInstanceExpr(typeReentrantLock().createLockedAccess(), new List()));
	}
	
	protected FieldDeclaration Monitor.createConditionField(Modifiers mods, String name) {
		return new FieldDeclaration(mods, typeCondition().createLockedAccess(), name,
				  					lockField().createLockedAccess().qualifiesAccess(new MethodAccess("newCondition", new List())));
	}
	
	public boolean Monitor.refactorable() { return type.isClassDecl() && type.fromSource() && !type.isArrayDecl(); }
	public boolean ClassMonitor.refactorable() { return clazz.fromSource() && !clazz.isArrayDecl() && !clazz.isEnumDecl(); }
	public boolean FieldMonitor.refactorable() { return field.fromSource(); }
	
	public FieldDeclaration Monitor.lockField() {
		if(lockField != null || !refactorable())
			return lockField;
		lockField = createLockField(new Modifiers("public"), "lock");
		type.sourceTypeDecl().getBodyDeclList().insertChild(lockField, 0);
		return lockField;
	}
	
	public FieldDeclaration Monitor.conditionField() {
		if(conditionField != null || !refactorable())
			return conditionField;
		conditionField = createConditionField(new Modifiers("public"), "condition");
		type.sourceTypeDecl().getBodyDeclList().insertChild(conditionField, 1);
		return conditionField;
	}
	
	public FieldDeclaration ClassMonitor.lockField() {
		if(lockField != null || !refactorable())
			return lockField;
		lockField = createLockField(new Modifiers("public", "static", "final"), "lock");
		clazz.sourceTypeDecl().getBodyDeclList().insertChild(lockField, 0);
		return lockField;
	}
	
	public FieldDeclaration ClassMonitor.conditionField() {
		if(conditionField != null || !refactorable())
			return conditionField;
		conditionField = createConditionField(new Modifiers("public", "static", "final"), "condition");
		clazz.sourceTypeDecl().getBodyDeclList().insertChild(conditionField, 1);
		return conditionField;
	}
	
	public FieldDeclaration FieldMonitor.lockField() {
		if(lockField != null || !refactorable())
			return lockField;
		if(field.isDedicatedLock()) {
			lockField = field;
			if(field.type() != typeReentrantLock()) {
				field.setTypeAccess(typeReentrantLock().createLockedAccess());
				field.setInit(new ClassInstanceExpr(typeReentrantLock().createLockedAccess(), new List()));
			}
		} else {
			lockField = createLockField((Modifiers)field.getModifiers().fullCopyAndDetach(), field.name()+"_lock");
			field.hostType().sourceTypeDecl().getBodyDeclList().insertChild(lockField, field.getChildIndex()+1);
		}
		return lockField;
	}
	
	public FieldDeclaration FieldMonitor.conditionField() {
		if(conditionField != null || !refactorable())
			return conditionField;
		conditionField = createConditionField(new Modifiers("public", "final"), field.name()+"_condition");
		field.hostType().sourceTypeDecl().getBodyDeclList().insertChild(conditionField, lockField().getChildIndex()+1);
		return conditionField;		
	}
	
	public Access Monitor.createLockAccess(TypeDecl tp, Expr e) {
		Access fa = lockField().createLockedAccess();
		if(e == null)
			return fa;
		if(tp.subtype(type))
			return e.qualifiesAccess(fa);
		return new CastExpr(type.createLockedAccess(), e).qualifiesAccess(fa);
	}
	
	public Access Monitor.createConditionAccess(Expr e) {
		Access fa = conditionField().createLockedAccess();
		return e == null ? fa : e.qualifiesAccess(fa);
	}
	
	public Access ClassMonitor.createLockAccess(TypeDecl tp, Expr e) {
		return lockField().createLockedAccess();
	}
	
	public Access ClassMonitor.createConditionAccess(Expr e) {
		return conditionField().createLockedAccess();
	}
	
	public Access FieldMonitor.createLockAccess(TypeDecl tp, Expr e) {
		lockField();	// make sure it is created
		if(field.isDedicatedLock())
			return (Access)e;
		if(e == null)
			return lockField().createLockedAccess();
		Access acc = (Access)e;
		if(acc.lastAccess() == acc)
			return lockField().createLockedAccess();
		acc.lastAccess().replaceWith(lockField().createLockedAccess());
		return acc;
	}
	
	public Access FieldMonitor.createConditionAccess(Expr e) {
		if(e == null)
			return conditionField().createLockedAccess();
		Access acc = (Access)e;
		if(acc.lastAccess() == acc)
			return conditionField().createLockedAccess();
		acc.lastAccess().replaceWith(conditionField().createLockedAccess());
		return acc;
	}
	
	public boolean ClassMonitor.replaceWithReentrantLock(Program root) {
		LinkedList<MonitorAction> repl = new LinkedList<MonitorAction>();
		for(MonitorAction ma : root.monitorActions())
			if(this.equals(ma.getAcquiredMonitor())) {
				if(!ma.fromSource()) {
					++tests.LockRefactoringTests.involves_library;
					return false;
				} else if(!ma.getAcquiredMonitor().refactorable()) {
					++tests.LockRefactoringTests.not_modifiable;
					return false;
				}
				repl.add(ma);
			} else if(ma.mayEnter(this)) {
				++tests.LockRefactoringTests.ambiguous_action;
				return false;
			}
		for(MonitorAction ma : repl) {
			Expr e = ma.getMonitorExpr();
			if(!e.isPure()) {
				System.err.println("impure expression not refactorable (class monitor)");
				return false;
			}
			ma.replaceWithReentrantLock(this);
		}
		return true;
	}
	
	public boolean FieldMonitor.replaceWithReentrantLock(Program root) {
		LinkedList<MonitorAction> repl = new LinkedList<MonitorAction>();
		for(MonitorAction ma : root.monitorActions())
			if(this.equals(ma.getAcquiredMonitor())) {
				if(!ma.fromSource()) {
					++tests.LockRefactoringTests.involves_library;
					return false;
				} else if(!ma.getAcquiredMonitor().refactorable()) {
					++tests.LockRefactoringTests.not_modifiable;
					return false;
				}
				repl.add(ma);
			} else if(ma.mayEnter(this)) {
				++tests.LockRefactoringTests.ambiguous_action;
				return false;
			}
		for(MonitorAction ma : repl)
			ma.replaceWithReentrantLock(this);
		return true;
	}
	
	public boolean Monitor.replaceWithReentrantLock(Program root) {
		LinkedList<MonitorAction> repl = new LinkedList<MonitorAction>();
		for(MonitorAction ma : root.monitorActions())
			if(ma.getAcquiredMonitor().type().subtype(type)) {
				if(!ma.fromSource()) {
					++tests.LockRefactoringTests.involves_library;
					return false;
				} else if(!ma.getAcquiredMonitor().refactorable()) {
					++tests.LockRefactoringTests.not_modifiable;
					return false;
				}
				repl.add(ma);
			} else if(ma.mayEnter(this)) {
				++tests.LockRefactoringTests.ambiguous_action;
				return false;
			}
		for(MonitorAction ma : repl)
			ma.replaceWithReentrantLock(this);
		return true;
	}
	
	public void SynchronizedStmt.replaceWithReentrantLock(Monitor m) {
		Block b = (Block)getParent().getParent();
		Expr e_copy = (Expr)getExpr().fullCopyAndDetach();
		b.insertStmt(getChildIndex(), createLockStmt(m));
		replace(this).with(new TryStmt(getBlock(), new List(), new Opt(new Block(createUnlockStmt(m, e_copy)))));
	}
	
	public Expr SynchronizedStmt.createLockAccess(Monitor m, Expr e) {
		return m.createLockAccess(e.type(), e);
	}
	
	public Stmt SynchronizedStmt.createLockStmt(Monitor m) {
		return new ExprStmt(createLockAccess(m, getExpr()).qualifiesAccess(new MethodAccess("lock", new List())));
	}
	
	public Stmt SynchronizedStmt.createUnlockStmt(Monitor m, Expr e_copy) {
		return new ExprStmt(createLockAccess(m, e_copy).qualifiesAccess(new MethodAccess("unlock", new List())));
	}
	
	public void MethodDecl.replaceWithReentrantLock(Monitor m) {
		getModifiers().removeModifier("synchronized");
		replace(getBlock()).with(new Block(createLockStmt(m),
										   new TryStmt(getBlock(), new List(), new Opt(new Block(createUnlockStmt(m))))));
	}
	
	public Expr MethodDecl.createLockAccess(Monitor m) {
		return m.createLockAccess(getLockType(), getLockExpr());
	}
	
	public Stmt MethodDecl.createLockStmt(Monitor m) {
		return new ExprStmt(createLockAccess(m).qualifiesAccess(new MethodAccess("lock", new List())));
	}
	
	public Stmt MethodDecl.createUnlockStmt(Monitor m) {
		return new ExprStmt(createLockAccess(m).qualifiesAccess(new MethodAccess("unlock", new List())));
	}
	
	public void WaitNotifyMethodCall.replaceWithReentrantLock(Monitor m) {
		acc.bundleQualifier();
		ASTNode p = acc.isQualified() ? acc.parentDot() : acc;
		Expr q = acc.isQualified() ? acc.qualifier() : null;
		if(acc.decl() == acc.methodNotify()) {
			p.replaceWith(m.createConditionAccess(q).qualifiesAccess(new MethodAccess("signal", new List())));
		} else if(acc.decl() == acc.methodNotifyAll()) {
			p.replaceWith(m.createConditionAccess(q).qualifiesAccess(new MethodAccess("signalAll", new List())));
		} else if(acc.decl() == acc.methodWait()) {
			p.replaceWith(m.createConditionAccess(q).qualifiesAccess(new MethodAccess("await", new List())));			
		} else if(acc.decl() == acc.methodWaitLong()) {
			p.replaceWith(m.createConditionAccess(q).qualifiesAccess(new MethodAccess("awaitNanos", new List().add(new MulExpr(new ParExpr(acc.getArg(0)), new IntegerLiteral("1000"))))));			
		} else if(acc.decl() == acc.methodWaitLongInt()) {
			p.replaceWith(m.createConditionAccess(q).qualifiesAccess(new MethodAccess("awaitNanos", new List().add(new AddExpr(new MulExpr(new ParExpr(acc.getArg(0)), new IntegerLiteral("1000")), new ParExpr(acc.getArg(1)))))));			
		}
	}
	
	public Expr MethodDecl.getLockExpr() {
		if(isStatic())
			return hostType().createLockedAccess().qualifiesAccess(new ClassAccess());
		return new ThisAccess("this");
	}
	
	public TypeDecl MethodDecl.getLockType() {
		return isStatic() ? hostType().classType() : hostType();
	}
}
aspect ReadWriteLocks {
	protected boolean Monitor.isReadWrite = false;
	private Collection<Access> Monitor.lockAccesses = new LinkedList<Access>();
	
	protected Access Monitor.registerLockAccess(Access acc) {
		lockAccesses.add(acc.lastAccess());
		return acc;
	}
	
	refine RefactorLocks public Access Monitor.createLockAccess(Expr e) {
		return isReadWrite ? refined(e).qualifiesAccess(new MethodAccess("writeLock", new List())) : registerLockAccess(refined(e));
	}
	
	refine RefactorLocks public Access ClassMonitor.createLockAccess(Expr e) {
		return isReadWrite ? refined(e).qualifiesAccess(new MethodAccess("writeLock", new List())) : registerLockAccess(refined(e));
	}
	
	refine RefactorLocks public Access FieldMonitor.createLockAccess(Expr e) {
		return isReadWrite ? refined(e).qualifiesAccess(new MethodAccess("writeLock", new List())) : registerLockAccess(refined(e));
	}

	protected void Monitor.makeReadWrite() {
		if(isReadWrite)
			return;
		lockField();
		if(lockField != null) {
			lockField.setTypeAccess(type.lookupType("java.util.concurrent.locks", "ReadWriteLock").createLockedAccess());
			ClassInstanceExpr cie = (ClassInstanceExpr)lockField.getInit();
			cie.setAccess(type.lookupType("java.util.concurrent.locks", "ReentrantReadWriteLock").createLockedAccess());
		}
		if(conditionField != null) {
			AbstractDot ad = (AbstractDot)conditionField.getInit();
			ad.setRight(new MethodAccess("writeLock", new List()).qualifiesAccess(ad.getRight()));
		}
		for(Access acc : lockAccesses)
			ASTNode.replace(acc).with(acc.qualifiesAccess(new MethodAccess("writeLock", new List())));
		lockAccesses.clear();
		isReadWrite = true;
	}
	
	public Access Monitor.createReadLockAccess(Expr e) {
		makeReadWrite();
		Access acc = createLockAccess(e);
		((MethodAccess)acc.lastAccess()).setID("readLock");
		return acc;
	}
	
	refine RefactorLocks public Expr SynchronizedStmt.createLockAccess(Monitor m, Expr e) {
		return writesSharedState() ? refined(m, e) : m.createReadLockAccess(e);
	}
	
	refine RefactorLocks public Expr MethodDecl.createLockAccess(Monitor m) {
		return writesSharedState() ? refined(m) : m.createReadLockAccess(getLockExpr());
	}
	
	// conservative approximation: does this subtree mutate shared state?
	syn lazy boolean ASTNode.writesSharedState() {
		for(int i=0;i<getNumChild();++i)
			if(getChild(i).writesSharedState())
				return true;
		return false;
	}
	
	eq MethodDecl.writesSharedState() = isNative() || !fromSource() || super.writesSharedState();
	eq VarAccess.writesSharedState() = isDest() && decl().isField() || super.writesSharedState();
	eq ArrayAccess.writesSharedState() = isDest() || super.writesSharedState();
	
	// TODO: put in many more methods here
	public static final String[][] ASTNode.pureMethods = {
		{"java.lang", "Object", "equals(java.lang.Object)"},
		{"java.lang", "Object", "hashCode()"},
		{"java.util", "Collection", "contains(java.lang.Object)"},
		{"java.util", "Collection", "containsAll(java.util.Collection)"},
		{"java.util", "Collection", "isEmpty()"},
		{"java.util", "Collection", "size()"},
		{"java.util", "Map", "size()"},
		{"java.util", "Map", "isEmpty()"},
		{"java.util", "Map", "containsKey(java.lang.Object)"},
		{"java.util", "Map", "containsValue(java.lang.Object)"},
		{"java.util", "Map", "get(java.lang.Object)"},
		{"java.util", "Map", "keySet()"},
		{"java.util", "Map", "values()"},
		{"java.util", "Map", "entrySet()"}
	};
	syn lazy Collection<MethodDecl> Program.pureMethods() {
		Collection<MethodDecl> pure = new HashSet<MethodDecl>();
		for(String[] str : pureMethods)
			pure.add((MethodDecl)lookupType(str[0], str[1]).localMethodsSignature(str[2]).iterator().next());
		return pure;
	}
	
	refine Alias eq MethodDecl.isPure() {
		if(programRoot().pureMethods().contains(this))
			return true;
		for(MethodDecl md : overrides())
			if(md.isPure())
				return true;
		return false;
	}
	
	eq MethodAccess.writesSharedState() {
		return !decl().sourceMethodDecl().isPure();
	}
	
	eq ConstructorAccess.writesSharedState() {
		return true;
	}
	
	eq ClassInstanceExpr.writesSharedState() {
		return true;
	}
}
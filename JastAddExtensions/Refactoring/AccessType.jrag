/*
 * The inherited attribute accessType tries to compute an access to a type. If,
 * for some node n, calling n.accessType(t) yields an access a, then looking up
 * a at node n should yield type t.
 * 
 * For a type named "t", the code will return one of the following
 *   1. a type access "t" if the type is directly visible
 *   2. a fully qualified type access if "t" is a toplevel type
 *   3. a type access "A.t" if "t" is enclosed in type "A" and type "A" encloses
 *      the node where "t" is accessed
 *   4. null if none of the above works 
 */

aspect AccessType {
	
	inh NameType Access.nameType();
	
	syn Access ImportDecl.accessType(TypeDecl td) {
		Program prog = programRoot();
		for(int i = 0; i < prog.getNumCompilationUnit(); i++) {
			for(int j = 0; j < prog.getCompilationUnit(i).getNumTypeDecl(); j++) {
				TypeDecl type = prog.getCompilationUnit(i).getTypeDecl(j);
				if(type == td)
					return new TypeAccess(prog.getCompilationUnit(i).packageName(), 
										  td.getID());
			}
		}
		return null;
	}

	/* tries to find a type containing type declaration td by walking outwards from
	 * the node where it was invoked */
	syn TypeDecl TypeDecl.findTypeOutwards(TypeDecl td, boolean ambiguous) {
		String name = td.getID();
		if(isSingletonOf(memberTypes(td.getID()), td))
			return this;
		return isNestedType() ? enclosingType().findTypeOutwards(td, ambiguous) : null;
	}

	/* tries to access type declaration td from inside a certain scope; the flag
	 * ambiguous indicates whether the access occurs in a syntactically ambiguous
	 * position, i.e. a position where a name might both refer to a type or a
	 * variable
	 */
	syn Access Scope.accessType(TypeDecl td, boolean ambiguous) {
		String name = td.getID();
		SimpleSet set = lookupType(name);
		if(isSingletonOf(set, td) && !(ambiguous && !lookupVariable(name).isEmpty()))
			return new TypeAccess(name);
		TypeDecl out = surroundingType().findTypeOutwards(td, ambiguous);
		if(out != null) {
			Access outacc = accessType(out, ambiguous);
			if(outacc != null) return outacc.qualifiesAccess(new TypeAccess(name));
		}
		if(td.isTopLevelType()) {
			String pkg = td.packageName();
			String first_component = pkg.split("\\.")[0];
			if(!(ambiguous && (!lookupVariable(first_component).isEmpty() ||
							 !lookupType(first_component).isEmpty())))
				return new TypeAccess(pkg, td.getID());
		}
		return null;
	}
	
	syn Access Access.accessType(TypeDecl td) {
		NameType nt = nameType();
		boolean ambiguous = nt == NameType.AMBIGUOUS_NAME ||
							nt == NameType.EXPRESSION_NAME;
		if(isQualified())
			qualifier().qualifiedAccessType(td, ambiguous);
		return accessType(td, ambiguous);
	}
	
	syn Access Expr.qualifiedAccessType(TypeDecl td, boolean ambiguous) {
		return type().getBodyDecl(0).accessType(td, ambiguous);
	}

	eq PackageAccess.qualifiedAccessType(TypeDecl td, boolean ambiguous) {
		if(lookupType(packageName(), td.getID()) == td)
			return new TypeAccess(td.getID());
		else
			return null;
	}

	eq TypeAccess.qualifiedAccessType(TypeDecl td, boolean ambiguous) {
		return type().getBodyDecl(0).accessType(td, ambiguous);
	}
	
}

/*
 * The inherited attribute accessType tries to compute an access to a type. If,
 * for some node n, calling n.accessType(t) yields an access a, then looking up
 * a at node n should yield type t.
 *
 * The implementation largely parallels lookupType(), but while doing a lookup,
 * information about how to access the type from the starting point is being 
 * maintained in a SymbolicTypeAccess structure.
 * 
 * For local or anonymous classes, this structure simply contains the type
 * declaration to access. For inner classes, it also refers to a type declaration
 * surrounding the starting point lexically, from where the target declaration
 * is visible (because it is declared there or in a super class). For toplevel
 * types, finally, it stores the type declaration to access and its package name.
 * 
 * Additionally, in both of the latter cases it maintains a flag indicating if
 * the type declaration could be accessed by its name only, or if it needs to be
 * qualified. This flag is initialised to [false] (no qualification needed),
 * but may subsequently be changed to [true] if the declaration is, in fact,
 * accessed at a point where it is shadowed by something else.
 */

aspect AccessType {
	
	interface ShadowingDetector {
		boolean isShadowed(String name);
	}
	
	class SymbolicTypeAccess {
		protected TypeDecl target;
		
		public SymbolicTypeAccess(TypeDecl target) {
			this.target = target;
		}
		
		public TypeDecl getTarget() { return target; }
		
		public Access getAccess(NamingContext ctxt, boolean ambiguous) {
			if(ctxt.isShadowed(target, ambiguous))
				return null;
			return new TypeAccess(target.name()); 
		}
		
		public Access getQualifiedAccess(NamingContext ctxt, boolean ambiguous,
										 Expr qualifier) {
			// raw SymbolicTypeAccesses are for classes that cannot be qualified
			return null;
		}
		
		public SymbolicTypeAccess protect(ShadowingDetector d) {
			if(d.isShadowed(target.name()))
				return null;
			return this;
		}
	}
	
	abstract class QualifiedSymbolicTypeAccess extends SymbolicTypeAccess {
		protected boolean needsQualifier;
		
		public QualifiedSymbolicTypeAccess(boolean needsQualifier, TypeDecl target) {
			super(target);
			this.needsQualifier = needsQualifier;
		}
		
		public boolean needsQualifier() { return needsQualifier; }
		public void setNeedsQualifier() { needsQualifier = true; }
		public SymbolicTypeAccess protect(ShadowingDetector d) {
			if(d.isShadowed(target.name()))
				needsQualifier = true;
			return this;
		}
	}
	
	class SymbolicTopLevelTypeAccess extends QualifiedSymbolicTypeAccess {
		protected String pkg;
		
		public SymbolicTopLevelTypeAccess(String pkg, boolean needsQualifier, TypeDecl target) {
			super(needsQualifier, target);
			this.pkg = pkg;
		}
		
		public String getPkg() { return pkg; }
		
		public Access getAccess(NamingContext ctxt, boolean ambiguous) {
			if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
				if(ctxt.isShadowed(new PackageAccess(pkg), ambiguous))
					return null;
				return new TypeAccess(pkg, target.name());
			} else {
				return new TypeAccess(target.name());
			}
		}
		
		public Access getQualifiedAccess(NamingContext ctxt, boolean ambiguous,
										 Expr qualifier) {
			if(qualifier instanceof PackageAccess) {
				PackageAccess pkgacc = (PackageAccess)qualifier;
				if(pkgacc.packageName().equals(pkg) &&
					!ctxt.isShadowed(pkgacc, ambiguous))
					return qualifier.qualifiesAccess(new TypeAccess(target.name()));
			}
			return null;
		}
		
	}
	
	class SymbolicInnerTypeAccess extends QualifiedSymbolicTypeAccess {
		protected TypeDecl outer;
		
		public SymbolicInnerTypeAccess(TypeDecl outer, boolean needsQualifier, TypeDecl target) {
			super(needsQualifier, target);
			this.outer = outer;
		}
		
		public Access getAccess(NamingContext ctxt, boolean ambiguous) {
			if(needsQualifier || ctxt.isShadowed(target, ambiguous)) {
				if(ambiguous && !outer.memberFields(target.name()).isEmpty())
					return null;
				Access outer_acc = ctxt.accessType(outer, ambiguous);
				if(outer_acc == null) return null;
				return outer_acc.qualifiesAccess(new TypeAccess(target.name()));
			} else {
				return new TypeAccess(target.name());
			}
		}
		
		public Access getQualifiedAccess(NamingContext ctxt, boolean ambiguous,
				 Expr qualifier) {
			if(qualifier.isTypeAccess()) {
				TypeDecl td = qualifier.type();
				// TODO: check that td is something we want to qualify with
				//       (i.e., td == outer, or maybe an ancestor class)
				if(ambiguous && !outer.memberFields(target.name()).isEmpty())
					return null;
				return qualifier.qualifiesAccess(new TypeAccess(target.name()));
			}
			return null;
		}
	}
	
	inh NameType Access.nameType();
	
	inh SymbolicTypeAccess Expr.accessType(TypeDecl td);
	inh SymbolicTypeAccess Stmt.accessType(TypeDecl td);
	inh SymbolicTypeAccess BodyDecl.accessType(TypeDecl td);
	inh SymbolicTypeAccess TypeDecl.accessType(TypeDecl td);
	inh SymbolicTypeAccess CompilationUnit.accessType(TypeDecl td);
	inh SymbolicTypeAccess ImportDecl.accessType(TypeDecl td);

	eq Program.getChild().accessType(TypeDecl td) = accessType(td);

	syn lazy SymbolicTypeAccess Program.accessType(TypeDecl td) {
		addPrimitiveTypes();
		for(int i = 0; i < getNumCompilationUnit(); i++) {
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++) {
				if(getCompilationUnit(i).getTypeDecl(j) == td)
					return new SymbolicTopLevelTypeAccess(td.packageName(), true,
														  td);
			}
		}

		/* the following is probably unneccessary */
		CompilationUnit u = getCompilationUnit(td.fullName());
		if(u != null) {
			addCompilationUnit(u);
			getCompilationUnit(getNumCompilationUnit()-1);
			for(int j = 0; j < u.getNumTypeDecl(); j++) {
				if(u.getTypeDecl(j) == td) {
					return new SymbolicTopLevelTypeAccess(td.packageName(), true,
														  td);
				}
			}
		}
		return null;
	}

	eq MethodAccess.getArg().accessType(TypeDecl td) = unqualifiedScope().accessType(td);
	eq ConstructorAccess.getArg().accessType(TypeDecl td) = unqualifiedScope().accessType(td);
	eq ArrayAccess.getExpr().accessType(TypeDecl td) = unqualifiedScope().accessType(td);
	eq ArrayTypeWithSizeAccess.getExpr().accessType(TypeDecl td) = unqualifiedScope().accessType(td);
	eq ClassInstanceExpr.getArg().accessType(TypeDecl td) = unqualifiedScope().accessType(td);

	eq CompilationUnit.getTypeDecl().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = localAccessType(td);
		if(acc != null && td.accessibleFromPackage(packageName()))
			return acc;
		return null;
	}

	eq TypeDecl.getBodyDecl().accessType(TypeDecl td) = accessTypeFromInside(td);
	
	public SymbolicTypeAccess TypeDecl.accessTypeFromInside(TypeDecl td) {
		SymbolicTypeAccess acc = accessMemberType(td);
		if(acc != null)
			return acc;
		return moveInto(accessType(td));
	}

	eq Block.getStmt(int index).accessType(TypeDecl td) {
	    for(int i = index; i >= 0 && !(getStmt(i) instanceof Case); i--) {
	      if(getStmt(i) instanceof LocalClassDeclStmt) {
	        TypeDecl t = ((LocalClassDeclStmt)getStmt(i)).getClassDecl();
	        if(td == t)
	        	return new SymbolicTypeAccess(td);
	      }
	    }
	    return moveInto(accessType(td), index);
	}
	
	eq ClassInstanceExpr.getAccess().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = accessType(td);
		if(acc != null && isQualified())
			if(!(td.isInnerType() && td.isClassDecl()))
				return null;
		return acc;
	}

	eq ClassInstanceExpr.getTypeDecl().accessType(TypeDecl td) {
		SymbolicTypeAccess acc = localAccessType(td);
		if(acc != null) return acc;
		acc = accessType(td);
		if(acc != null) return moveInto(acc);
		return moveInto(unqualifiedScope().accessType(td));
	}

	eq ParseName.qualifiedAccessType(TypeDecl td) = null;
	eq PackageOrTypeAccess.qualifiedAccessType(TypeDecl td) = null;
	eq AmbiguousAccess.qualifiedAccessType(TypeDecl td) = null;

	eq AbstractDot.getRight().accessType(TypeDecl td) =
		getLeft().qualifiedAccessType(td);
	
	syn SymbolicTypeAccess Expr.qualifiedAccessType(TypeDecl td) {
		if(typeAccessible(td))
			return type().accessMemberType(td);
		return null;
	}
	
	public boolean Expr.typeAccessible(TypeDecl td) {
		return hostType() != null && td.accessibleFrom(hostType()) 
			|| hostType() == null && td.accessibleFromPackage(hostPackage());
	}

	eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		SymbolicTypeAccess acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type() == td)
			return moveInto(new SymbolicTypeAccess(td));
		return null;
	}

	eq PackageAccess.qualifiedAccessType(TypeDecl td) {
		if(td.isTopLevelType() && td.packageName().equals(packageName())) {
			if(nextAccess() instanceof ClassInstanceExpr &&
					td.accessibleFrom(hostType()))
				return new SymbolicTypeAccess(td);
			else if(typeAccessible(td))
				return new SymbolicTypeAccess(td);
		}
		return null;
	}
	
	syn lazy SymbolicTypeAccess ClassInstanceExpr.localAccessType(TypeDecl td) {
		if(hasTypeDecl() && getTypeDecl() == td)
			return new SymbolicTypeAccess(td);
		return null;
	}

	syn lazy SymbolicTypeAccess TypeDecl.accessMemberType(TypeDecl td) = null;
	eq ClassDecl.accessMemberType(TypeDecl td) {
		for(int i = 0; i < getNumBodyDecl(); i++) {
			if(getBodyDecl(i) instanceof MemberTypeDecl) {
				TypeDecl t = ((MemberTypeDecl)getBodyDecl(i)).typeDecl();
				if(t == td)
					return new SymbolicInnerTypeAccess(this, false, td);
			}
		}
		for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
			TypeDecl type = (TypeDecl)outerIter.next();
			SymbolicTypeAccess acc = type.accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return moveDownTo(acc);
		}
		if(hasSuperclass()) {
			SymbolicTypeAccess acc = superclass().accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return moveDownTo(acc);
		}
		return null;
	}

	eq InterfaceDecl.accessMemberType(TypeDecl td) {
		for(int i = 0; i < getNumBodyDecl(); i++) {
			if(getBodyDecl(i) instanceof MemberTypeDecl) {
				TypeDecl t = ((MemberTypeDecl)getBodyDecl(i)).typeDecl();
				if(t == td)
					return new SymbolicInnerTypeAccess(this, false, td);
			}
		}
		for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
			TypeDecl type = (TypeDecl)outerIter.next();
			SymbolicTypeAccess acc = type.accessMemberType(td);
			if(acc != null && !td.isPrivate() && td.accessibleFrom(this))
				return moveDownTo(acc);
		}
		return null;
	}

	syn lazy SymbolicTypeAccess CompilationUnit.localAccessType(TypeDecl td) {
	    for(int i = 0; i < getNumTypeDecl(); i++)
	    	if(getTypeDecl(i) == td)
	    		return new SymbolicTopLevelTypeAccess(packageName(), false, td);
	    SymbolicTypeAccess acc = null;
	    // The scope of a type imported by a single-type-import declaration
	    for(int i = 0; i < getNumImportDecl(); i++) {
	      if(!getImportDecl(i).isOnDemand()) {
	    	  acc = getImportDecl(i).accessImportedType(td);
	    	  if(acc != null) return acc;
	      }
	    }
		 
	    TypeDecl result = lookupType(packageName(), td.name());
		if(result == td)
	    	return new SymbolicTopLevelTypeAccess(packageName(), false, td);
		    
	    // The scope of a type imported by a type-import-on-demand declaration
	    for(int i = 0; i < getNumImportDecl(); i++) {
	      if(getImportDecl(i).isOnDemand())
	    	  acc = getImportDecl(i).accessImportedType(td);
	    	  if(acc != null) return acc;
	    }
	    
	    if(lookupType(PRIMITIVE_PACKAGE_NAME, td.name()) != null)
	    	return new SymbolicTypeAccess(td);
	    
	    if(lookupType("java.lang", td.name()) != null)
	    	return new SymbolicTopLevelTypeAccess("java.lang", false, td);
	    
	    if(lookupType(td.packageName(), td.name()) != null)
	    	return new SymbolicTopLevelTypeAccess(td.packageName(), true, td);

	    return null;
	}

	syn lazy SymbolicTypeAccess ImportDecl.accessImportedType(TypeDecl td) = null;
	
	eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(getAccess().type() == td)
			return new SymbolicTopLevelTypeAccess(td.packageName(), false, td);
		return null;
	}
	
	eq TypeImportOnDemandDecl.accessImportedType(TypeDecl td) {
		if(getAccess() instanceof PackageAccess) {
			String packageName = ((PackageAccess)getAccess()).getPackage();
			if(packageName.equals(td.packageName()) &&
					td.accessibleFromPackage(packageName()))
				return new SymbolicTopLevelTypeAccess(packageName, false, td);
		}
		else {
			TypeDecl outer = getAccess().type();
			SymbolicTypeAccess acc = outer.accessMemberType(td);
			if(acc != null && td.accessibleFromPackage(packageName()))
				return new SymbolicInnerTypeAccess(outer, false, td);
		}
		return null;
	}
	
	public TypeDecl Block.localLookupType(String name, int index) {
		for(int i = index; i >= 0 && !(getStmt(i) instanceof Case); i--) {
			if(getStmt(i) instanceof LocalClassDeclStmt) {
				TypeDecl t = ((LocalClassDeclStmt)getStmt(i)).getClassDecl();
				if(t.name().equals(name))
					return t;
			}
		}
		return null;
	}
	
	public SymbolicTypeAccess Block.moveInto(SymbolicTypeAccess acc, int index) {
		if(acc == null) return null;
		return acc.protect(getTypeShadowingDetector(index));
	}
	
	public SymbolicTypeAccess ClassInstanceExpr.moveInto(SymbolicTypeAccess acc) {
		// TODO: implement
		return acc;
	}
	
	public SymbolicTypeAccess TypeDecl.moveInto(SymbolicTypeAccess acc) {
		if(acc == null)	return null;
		return acc.protect(getTypeShadowingDetector());
	}
	
	public SymbolicTypeAccess TypeDecl.moveDownTo(SymbolicTypeAccess acc) {
		if(acc == null)	return null;
		return acc.protect(getTypeShadowingDetector());
	}
	
	public Access TypeDecl.accessTypeFromInside(TypeDecl td, boolean ambiguous) {
		SymbolicTypeAccess acc = accessTypeFromInside(td);
		if(acc == null) return null;
		return acc.getAccess(getMemberNamingContext(), ambiguous);
	}
	
	public Access BodyDecl.accessType(TypeDecl td, boolean ambiguous) {
		SymbolicTypeAccess acc = accessType(td);
		if(acc == null) return null;
		return acc.getAccess(getNamingContext(), ambiguous);
	}
	
	public Access Expr.accessType(TypeDecl td, boolean ambiguous) {
		SymbolicTypeAccess acc = accessType(td);
		if(acc == null) return null;
		return acc.getAccess(getNamingContext(), ambiguous);
	}
	
	public Access Access.accessType(TypeDecl td, boolean ambiguous) {
		SymbolicTypeAccess acc = accessType(td);
		if(acc == null) return null;
		if(isQualified())
			return acc.getQualifiedAccess(qualifier().type().getMemberNamingContext(),
										  ambiguous, getCompleteQualifier());
		else
			return acc.getAccess(getNamingContext(), ambiguous);
	}
	
}
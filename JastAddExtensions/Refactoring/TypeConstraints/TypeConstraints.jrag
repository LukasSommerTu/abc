import java.util.Arrays;

aspect TypeConstraints {
	public abstract class TypeConstraint {
		private ASTNode node;
		private String cause;
		
		public TypeConstraint(ASTNode node, String cause) {
			this.node = node;
			this.cause = cause;
		}
		
		public abstract boolean solved();
		public abstract String describe();
		
		public boolean fromSource() {
			return node.fromSource();
		}
		
		public String toString() {
			return cause + " at node " + node.toString() + ": " + describe(); 
		}
	}
	
	class SimpleTypeConstraint extends TypeConstraint {
		private TypeConstraintVariable left, right;
		private Operator op;
		
		public SimpleTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, TypeConstraintVariable right) {
			super(node, cause);
			this.left = left;
			this.op = op;
			this.right = right;
		}
		
		public boolean solved() {
			TypeDecl lefttp = left.getConstrainedType().refresh().erasure(),
			         righttp = right.getConstrainedType().refresh().erasure();
			return !lefttp.isReferenceType() || !righttp.isReferenceType() || op.eval(lefttp, righttp);
		}
		
		public String describe() {
			return left.describeConstraintVariable() + " " + op + " " + right.describeConstraintVariable();
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof SimpleTypeConstraint))
				return false;
			SimpleTypeConstraint that = (SimpleTypeConstraint)o;
			return this.left.equals(that.left) && this.op == that.op && this.right.equals(that.right);
		}
	}
	
	class IsArrayTypeConstraint extends TypeConstraint {
		private TypeConstraintVariable var;
		
		public IsArrayTypeConstraint(ASTNode node, String cause, TypeConstraintVariable var) {
			super(node, cause);
			this.var = var;
		}
		
		public boolean solved() {
			return var.getConstrainedType().refresh().isArrayDecl();
		}
		
		public String describe() {
			return var.describeConstraintVariable() + " is array type";
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof IsArrayTypeConstraint))
				return false;
			return this.var.equals(((IsArrayTypeConstraint)o).var);
		}
	}
	
	class DisjunctiveTypeConstraint extends TypeConstraint {
		private Collection<TypeConstraint> constraints;
		
		public DisjunctiveTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, Collection<? extends TypeConstraintVariable> rights) {
			super(node, cause);
			this.constraints = new LinkedList<TypeConstraint>();
			for(TypeConstraintVariable right : rights)
				this.constraints.add(new SimpleTypeConstraint(node, cause, left, op, right));
		}
		
		public DisjunctiveTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, TypeConstraintVariable... rights) {
			this(node, cause, left, op, Arrays.asList(rights));
		}
		
		public boolean solved() {
			for(TypeConstraint tc : constraints)
				if(tc.solved())
					return true;
			return false;
		}
		
		public String describe() {
			StringBuffer res = new StringBuffer();
			boolean first = true;
			for(TypeConstraint tc : constraints) {
				if(first) {
					first = false;
				} else {
					res.append(" or ");
				}
				res.append(tc.describe());
			}
			return res.toString();
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof DisjunctiveTypeConstraint))
				return false;
			DisjunctiveTypeConstraint that = (DisjunctiveTypeConstraint)o;
			return this.constraints.equals(that.constraints);
		}
	}
	
	TypeDecl implements IAmPartiallyOrdered<TypeDecl>;
	public boolean TypeDecl.leq(TypeDecl that) {
		return this.subtype(that);
	}
	
	// a type constraint variable constrains either the type of a program element,
	// or the host type in which it is declared
	interface TypeConstraintVariable { }
	syn TypeDecl TypeConstraintVariable.getConstrainedType();
	syn String TypeConstraintVariable.describeConstraintVariable();
	
	BodyDecl implements TypeConstraintVariable;
	eq BodyDecl.getConstrainedType() = hostType();
	eq BodyDecl.describeConstraintVariable() = "Decl(" + toString() + ")";
	eq MethodDecl.describeConstraintVariable() = "Decl(" + hostType().fullName() + "." + signature() + ")";
	eq ConstructorDecl.describeConstraintVariable() = "Decl(" + signature() + ")";
	eq FieldDeclaration.describeConstraintVariable() = "Decl(" + name() + ")";
	
	Expr implements TypeConstraintVariable;
	eq Expr.getConstrainedType() = type();
	eq Expr.describeConstraintVariable() = "[" + this + "]";
	
	TypeDecl implements TypeConstraintVariable;
	eq TypeDecl.getConstrainedType() = this;
	eq TypeDecl.describeConstraintVariable() = fullName();
	
	public abstract void TypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode);
	public void SimpleTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		if(left == oldNode)
			left = newNode;
		if(right == oldNode)
			right = newNode;
	}
	public void IsArrayTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		if(var == oldNode)
			var = newNode;
	}
	public void DisjunctiveTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		for(TypeConstraint tc : constraints)
			tc.subst(oldNode, newNode);
	}	
}
import java.util.Arrays;
import java.util.Iterator;

aspect TypeConstraints {
	public abstract class TypeConstraint {
		private ASTNode node;
		private String cause;
		
		public TypeConstraint(ASTNode node, String cause) {
			this.node = node;
			this.cause = cause;
		}
		
		public abstract boolean solved();
		public abstract String describe();
		public abstract boolean isFixed();
		public boolean implies(TypeConstraint that) {
			return false;
		}
		
		public boolean fromSource() {
			return node.fromSource();
		}
		
		public String toString() {
			return cause + " at node " + node.toString() + ": " + describe(); 
		}
	}
	
	class SimpleTypeConstraint extends TypeConstraint {
		private TypeConstraintVariable left, right;
		private Operator op;
		
		public SimpleTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, TypeConstraintVariable right) {
			super(node, cause);
			this.left = left;
			this.op = op;
			this.right = right;
		}
		
		public boolean solved() {
			TypeDecl lefttp = left.getConstrainedType().refresh().erasure(),
			         righttp = right.getConstrainedType().refresh().erasure();
			return !lefttp.isReferenceType() || !righttp.isReferenceType() || op.eval(lefttp, righttp);
		}
		
		public String describe() {
			return left.describeConstraintVariable() + " " + op + " " + right.describeConstraintVariable();
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof SimpleTypeConstraint))
				return false;
			SimpleTypeConstraint that = (SimpleTypeConstraint)o;
			return this.left.equals(that.left) && this.op == that.op && this.right.equals(that.right);
		}
		
		public boolean implies(TypeConstraint tc) {
			if(tc instanceof SimpleTypeConstraint) {
				SimpleTypeConstraint that = (SimpleTypeConstraint)tc;
				return this.left.equals(that.left) && this.right.equals(that.right) && that.op == Operator.LE &&
				       (this.op == Operator.EQ || this.op == Operator.LT);
			} else if(tc instanceof DisjunctiveTypeConstraint) {
				for(Iterator<TypeConstraint> iter=((DisjunctiveTypeConstraint)tc).getSubconstraints();iter.hasNext();)
					if(this.implies(iter.next()))
						return true;
				return false;
			} else {
				return false;
			}
		}
		
		public boolean isFixed() {
			return left.isFixed() && right.isFixed();
		}
		
		public TypeConstraintVariable getLeft() { return left; }
		public TypeConstraintVariable getRight() { return right; }
	}
	
	class IsArrayTypeConstraint extends TypeConstraint {
		private TypeConstraintVariable var;
		
		public IsArrayTypeConstraint(ASTNode node, String cause, TypeConstraintVariable var) {
			super(node, cause);
			this.var = var;
		}
		
		public boolean solved() {
			return var.getConstrainedType().refresh().isArrayDecl();
		}
		
		public String describe() {
			return var.describeConstraintVariable() + " is array type";
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof IsArrayTypeConstraint))
				return false;
			return this.var.equals(((IsArrayTypeConstraint)o).var);
		}
		
		public boolean isFixed() {
			return var.isFixed();
		}
	}
	
	class DisjunctiveTypeConstraint extends TypeConstraint {
		private Collection<TypeConstraint> constraints;
		
		public DisjunctiveTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, Collection<? extends TypeConstraintVariable> rights) {
			super(node, cause);
			this.constraints = new LinkedList<TypeConstraint>();
			for(TypeConstraintVariable right : rights)
				this.constraints.add(new SimpleTypeConstraint(node, cause, left, op, right));
		}
		
		public DisjunctiveTypeConstraint(ASTNode node, String cause, TypeConstraintVariable left, Operator op, TypeConstraintVariable... rights) {
			this(node, cause, left, op, Arrays.asList(rights));
		}
		
		public boolean solved() {
			for(TypeConstraint tc : constraints)
				if(tc.solved())
					return true;
			return false;
		}
		
		public String describe() {
			StringBuffer res = new StringBuffer();
			boolean first = true;
			for(TypeConstraint tc : constraints) {
				if(first) {
					first = false;
				} else {
					res.append(" or ");
				}
				res.append(tc.describe());
			}
			return res.toString();
		}
		
		public boolean equals(Object o) {
			if(!(o instanceof DisjunctiveTypeConstraint))
				return false;
			DisjunctiveTypeConstraint that = (DisjunctiveTypeConstraint)o;
			return this.constraints.equals(that.constraints);
		}
		
		public int getNumAlternatives() {
			return constraints.size();
		}
		
		public Iterator<TypeConstraint> getSubconstraints() {
			return constraints.iterator();
		}
		
		public boolean isFixed() {
			for(TypeConstraint tc : constraints)
				if(!tc.isFixed())
					return false;
			return true;
		}
	}
	
	TypeDecl implements IAmPartiallyOrdered<TypeDecl>;
	public boolean TypeDecl.leq(TypeDecl that) {
		return this.subtype(that);
	}
	
	// a type constraint variable constrains either the type of a program element,
	// or the host type in which it is declared
	interface TypeConstraintVariable { }
	syn TypeDecl TypeConstraintVariable.getConstrainedType();
	syn String TypeConstraintVariable.describeConstraintVariable();
	syn boolean TypeConstraintVariable.isFixed();
	syn lazy TypedDeclaration TypeConstraintVariable.getTypedDecl();
	
	BodyDecl implements TypeConstraintVariable;
	eq BodyDecl.getConstrainedType() = hostType();
	eq BodyDecl.describeConstraintVariable() = "Decl(" + toString() + ")";
	eq MethodDecl.describeConstraintVariable() = "Decl(" + hostType().fullName() + "." + signature() + ")";
	eq ConstructorDecl.describeConstraintVariable() = "Decl(" + signature() + ")";
	eq FieldDeclaration.describeConstraintVariable() = "Decl(" + name() + ")";
	eq BodyDecl.isFixed() = true;
	eq BodyDecl.getTypedDecl() = null;
	
	Expr implements TypeConstraintVariable;
	eq Expr.getConstrainedType() = type();
	eq Expr.describeConstraintVariable() = "[" + this + "]";
	eq Expr.isFixed() = !fromSource();
	eq Expr.getTypedDecl() {
		if(isTypeAccess() && getParent() instanceof TypedDeclaration)
			return (TypedDeclaration)getParent();
		if(varDecl() != null)
			return varDecl();
		if(isMethodAccess())
			return ((MethodAccess)((Access)this).lastAccess()).decl();
		return null;
	}
	
	TypeDecl implements TypeConstraintVariable;
	eq TypeDecl.getConstrainedType() = this;
	eq TypeDecl.describeConstraintVariable() = fullName();
	eq TypeDecl.isFixed() = true;
	eq TypeDecl.getTypedDecl() {
		return null;
	}
	
	/*public abstract void TypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode);
	public void SimpleTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		if(left == oldNode)
			left = newNode;
		if(right == oldNode)
			right = newNode;
	}
	public void IsArrayTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		if(var == oldNode)
			var = newNode;
	}
	public void DisjunctiveTypeConstraint.subst(TypeConstraintVariable oldNode, TypeConstraintVariable newNode) {
		for(TypeConstraint tc : constraints)
			tc.subst(oldNode, newNode);
	}*/
	
	public static Collection<TypeConstraintVariable> ASTNode.propagateGeneralisation(Collection<TypeConstraint> constraints, TypeConstraintVariable update, TypeDecl newType) {
		Collection<TypeConstraintVariable> res = new HashSet<TypeConstraintVariable>();
		res.add(update);
		int size;
		do {
			size = res.size();
			for(TypeConstraint constraint : constraints)
				constraint.propagate(newType, res);
		} while(size != res.size());
		return res;
	}
	
	public abstract void TypeConstraint.propagate(TypeDecl newType, Collection<TypeConstraintVariable> update);
	public void SimpleTypeConstraint.propagate(TypeDecl newType, Collection<TypeConstraintVariable> update) {
		if(op == Operator.EQ) {
			if(update.contains(left)) {
				addConstraintVar(update, right);
			} else if(update.contains(right)) {
				addConstraintVar(update, left);
			}
		} else if(op == Operator.LE) {
			if(update.contains(left) && !newType.subtype(right.getConstrainedType())) {
				addConstraintVar(update, right);
			}
		} else if(op == Operator.LT) {
			if(update.contains(left))
				throw new RefactoringException("cannot propagate through constraint " + this);
		} else {
			throw new RefactoringException("cannot propagate through constraint " + this);
		}
	}
	public void IsArrayTypeConstraint.propagate(TypeDecl newType, Collection<TypeConstraintVariable> update) {
		if(update.contains(var) && !newType.isArrayDecl())
			throw new RefactoringException(var + " has to be an array");
	}
	public void DisjunctiveTypeConstraint.propagate(TypeDecl newType, Collection<TypeConstraintVariable> update) {
		SimpleTypeConstraint constr = (SimpleTypeConstraint)constraints.iterator().next();
		if(update.contains(constr.getLeft())) {
			for(Iterator<TypeConstraint> iter=constraints.iterator();iter.hasNext();) {
				constr = (SimpleTypeConstraint)iter.next();
				if(newType.subtype(constr.getRight().getConstrainedType()))
					return;
			}
			throw new RefactoringException("cannot satisfy " + this);
		}
	}
	
	protected void TypeConstraint.addConstraintVar(Collection<TypeConstraintVariable> update, TypeConstraintVariable tcvar) {
		if(tcvar.isFixed())
			throw new RefactoringException("cannot satisfy constraint " + this);
		update.add(tcvar);
	}
}
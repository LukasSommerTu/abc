/*
 * The Extract Interface refactoring
 */
aspect ExtractInterface {
	public void ClassDecl.extractInterface(String pkg, String name, Collection<MethodDecl> methods) {
		if(!fromSource())
			throw new RefactoringException("cannot extract from non-source type");
		if(subtype(typeThrowable())) 
			throw new RefactoringException("cannot extract from throwable type");
		Program root = programRoot();
		List<BodyDecl> body = new List<BodyDecl>();
		Modifiers mods = (Modifiers)getModifiers().fullCopy();
		mods.removeNonToplevelModifiers();
		mods.removeModifier("abstract");
		mods.removeModifier("final");
		mods.removeAnnotations();
		InterfaceDecl newInterface = new InterfaceDecl(mods, name, new List<Access>(), body);
		
		// TODO: determine path to put new compilation unit at
		String pathName = compilationUnit().pathName();
		String path = pathName.substring(0, pathName.lastIndexOf(File.separatorChar)+1);
		root.insertUnusedType(path, pkg == null ? packageName() : pkg, new List<ImportDecl>(), newInterface);
		addImplements(newInterface.createLockedAccess());
		for(MethodDecl md : methods) {
			if(md.hostType() != this)
				throw new RefactoringException("selected method is not a member of this type");
			if(md.isStatic())
				throw new RefactoringException("selected method is static");
			MethodDecl new_md = md.lockedCopyWithEmptyBody();
			new_md.getModifiers().removeModifier("synchronized");
			// it generally doesn't make sense to preserve annotations, so we don't
			new_md.getModifiers().removeAnnotations();
			// for Eclipse compatibility
			new_md.getModifiers().addModifier("abstract");
			new_md.getModifiers().removeModifier("final");	
			// this could be done by the accessibility constraints but in some places (e.g. MethodDecl.overridingMethods()) 
			// low accessibility is used as a break condition so we adjust it here
			new_md.getModifiers().setVisibility(Modifier.VIS_PUBLIC);
			body.add(new_md);
			md.lockOverriding();
			md.addOverriddenMethod(new_md);
		}
		
		Collection<TypeConstraintVariable> updatable = computeUpdatableExprs(root.typeConstraints(this), this, newInterface);
		Collection<String> affectedMethods = new HashSet<String>();
		Collection<TypeDecl> affectedConstructors = new HashSet<TypeDecl>();
		
		findAffectedCallables(updatable, newInterface, affectedMethods, affectedConstructors);
		
		root.lockMethodNames(affectedMethods);
		root.lockConstructorCalls(affectedConstructors);
		root.lockOverridingDependencies(affectedMethods);
		
		for(TypeConstraintVariable tcv : updatable) {
			if(tcv instanceof Expr) {
				Expr e = (Expr)tcv;
				if(e.isTypeAccess())
					e.replaceWith(newInterface.createLockedAccess());
			}			
		}
	}
	
	public void ClassDecl.doExtractInterface(String pkg, String name, Collection<MethodDecl> methods) {
		Program root = programRoot();
		extractInterface(pkg, name, methods);
		root.eliminate(LOCKED_NAMES, LOCKED_OVERRIDING);
	}
	
	public static void ASTNode.findAffectedCallables(Collection<TypeConstraintVariable> update, TypeDecl newType, Collection<String> affectedMethods, Collection<TypeDecl> affectedConstructors) {
		for(TypeConstraintVariable tcv : update) {
			if(tcv instanceof Expr) {
				Expr e = (Expr)tcv;
				if(e.isParameterType()) {
					Callable c = ((ParameterDeclaration)e.getParent()).getParameterisedCallable();
					if(c instanceof MethodDecl)
						affectedMethods.add(((MethodDecl)c).name());
					else if(c instanceof ConstructorDecl)
						affectedConstructors.add(((ConstructorDecl)c).hostType());
				}
				if(e.isLeftChildOfDot() && e.nextAccess() instanceof MethodAccess) {
					MethodAccess ma = (MethodAccess)e.nextAccess();
					MethodDecl oldTarget = ma.decl(),
							   newTarget = oldTarget.ancestorIn(newType);
					// TODO: this should be part of the type constraints
					if(!oldTarget.throwsSameExceptionsAs(newTarget))
						throw new RefactoringException("new target throws different exceptions");
					if(oldTarget.type() != newTarget.type())
						throw new RefactoringException("new target has different return type");
					ma.lock(newTarget);
				}
			}
		}		
	}
}
aspect CollectTypeConstraints {
	coll Collection<TypeConstraint> Program.typeConstraints() [new LinkedHashSet<TypeConstraint>()]
	                                	                      with addAll root Program;
	
	AssignSimpleExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "assignment", getSource(), Operator.LE, getDest()))
	                 to Program.typeConstraints()
	                 for programRoot();
	
	MethodAccess contributes typeConstraints()
	             to Program.typeConstraints()
	             for programRoot();
	
	VarAccess contributes Collections.singleton(new SimpleTypeConstraint(this, "field access", qualifier(), Operator.LE, (FieldDeclaration)decl()))
	          when isQualified()
	          to Program.typeConstraints()
	          for programRoot();
	
	ReturnStmt contributes Collections.singleton(new SimpleTypeConstraint(this, "return", getResult(), Operator.LE, ((MethodDecl)hostBodyDecl()).getTypeAccess()))
	           when hasResult()
	           to Program.typeConstraints()
	           for programRoot();
	
	MethodDecl contributes sourceMethodDecl().overridingTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	FieldDeclaration contributes ((FieldDeclaration)sourceVariableDecl()).hidingTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	ClassInstanceExpr contributes argumentTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	ConstructorAccess contributes argumentTypeConstraints()
    		   to Program.typeConstraints()
    		   for programRoot();

	CastExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "downcast", getTypeAccess(), Operator.LE, getExpr()))
	         when isDownCast()
	         to Program.typeConstraints()
	         for programRoot();

	CastExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "upcast", getExpr(), Operator.LE, getTypeAccess()))
    	     when isUpCast()
			 to Program.typeConstraints()
			 for programRoot();

	ArrayTypeWithSizeAccess contributes Collections.singleton(new DisjunctiveTypeConstraint(this, "sized array type",
				getExpr(), Operator.LE, typeInt().boxed(), typeInt()))
	         to Program.typeConstraints()
	         for programRoot();
	
	ArrayAccess contributes Collections.singleton(new DisjunctiveTypeConstraint(this, "array access (1)",
				getExpr(), Operator.LE, typeInt().boxed(), typeInt()))
			 to Program.typeConstraints()
			 for programRoot();
	
	ArrayAccess contributes Collections.singleton(new IsArrayTypeConstraint(this, "array access (2)", qualifier()))
			 to Program.typeConstraints()
			 for programRoot();
	
	public Collection<TypeConstraint> MethodAccess.typeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		MethodDecl md = decl();
		for(int i=0;i<md.getNumParameter();++i) {
			ParameterDeclaration parm = md.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this
				continue;
			} else {
				Expr arg = getArg(i);
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		if(isQualified())
			constraints.add(new DisjunctiveTypeConstraint(this, "method invocation", qualifier(), Operator.LE, decl().rootDefs()));
		return constraints;
	}
	
	public Collection<TypeConstraint> ClassInstanceExpr.argumentTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		ConstructorDecl cd = decl();
		for(int i=0;i<cd.getNumParameter();++i) {
			ParameterDeclaration parm = cd.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this
				continue;
			} else {
				Expr arg = getArg(i);
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> ConstructorAccess.argumentTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		ConstructorDecl cd = decl();
		for(int i=0;i<cd.getNumParameter();++i) {
			Expr arg = getArg(i);
			ParameterDeclaration parm = cd.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this
				continue;
			} else {
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> MethodDecl.overridingTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		for(MethodDecl that : overrides()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
			constraints.add(new SimpleTypeConstraint(this, "method overriding", this, Operator.LT, that));
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> FieldDeclaration.hidingTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		for(FieldDeclaration that : hiddenFields())
			constraints.add(new SimpleTypeConstraint(this, "field hiding", this, Operator.LT, that));
		return constraints;
	}
	
	syn lazy boolean CastExpr.isDownCast() {
		TypeDecl exprtp = getExpr().type(),
		         restp = getTypeAccess().type();
		return !exprtp.equals(restp) && restp.subtype(exprtp);
	}
	
	syn lazy boolean CastExpr.isUpCast() {
		return getExpr().type().subtype(getTypeAccess().type());
	}
}
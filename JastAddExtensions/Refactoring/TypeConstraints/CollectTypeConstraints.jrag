aspect CollectTypeConstraints {
	// originally, the type constraints were computed using a collection attribute
	// usually, however, we are only interested in collecting all type constraints to do with a certain type C
	// hence we collect them by an AST traversal instead
	
	syn lazy Collection<TypeConstraint> Program.typeConstraints(TypeDecl C) {
		Collection<TypeConstraint> constraints = new LinkedHashSet<TypeConstraint>();
		collectTypeConstraints(C, constraints);
		return constraints;
	}
	
	protected void ASTNode.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		for(int i=0;i<getNumChild();++i)
			getChild(i).collectTypeConstraints(C, constraints);
	}
	
	protected void VariableDeclaration.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasInit() && (C.subtype(getInit().type()) || C.subtype(type())))
			constraints.add(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void FieldDeclaration.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasInit() && (C.subtype(getInit().type()) || C.subtype(type())))
			constraints.add(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		for(FieldDeclaration that : hiddenFields())
			constraints.add(new SimpleTypeConstraint(this, "field hiding", this, Operator.LT, that));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void MethodDecl.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(isMainMethod())
			constraints.add(new SimpleTypeConstraint(this, "main method", 
													 getParameter(0).getTypeAccess(), Operator.EQ, getParameter(0).type()));
		for(MethodDecl that : overriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				if(C.subtype(thisParm.type()))
					constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			if(C.subtype(this.type()) || C.subtype(that.type()))
				constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
			constraints.add(new SimpleTypeConstraint(this, "method overriding", this, Operator.LT, that));
		}
		for(MethodDecl that : indirectlyOverriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				if(C.subtype(thisParm.type()))
					constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			if(C.subtype(this.type()) || C.subtype(that.type()))
				constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
		}
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ReturnStmt.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasResult()) {
			MethodDecl md = (MethodDecl)hostBodyDecl();
			if(C.subtype(getResult().type()) || C.subtype(md.type()))
				constraints.add(new SimpleTypeConstraint(this, "return", getResult(), Operator.LE, md.getTypeAccess()));
		}
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void TryStmt.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		for(CatchClause cc : getCatchClauses())
			if(C.subtype(cc.getParameter().type()))
				constraints.add(new SimpleTypeConstraint(cc, "catch clause", cc.getParameter().getTypeAccess(), Operator.LE, cc.typeThrowable()));
		// TODO: add constraints that types in later catch clauses may not be subtypes of types in earlier ones
		super.collectTypeConstraints(C, constraints);
	}

	protected void AssignSimpleExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(getSource().type()) || C.subtype(getDest().type()))
			constraints.add(new SimpleTypeConstraint(this, "assignment", getSource(), Operator.LE, getDest()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void MethodAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type()))
			constraints.add(new SimpleTypeConstraint(this, "method invocation", this, Operator.EQ, decl().getTypeAccess()));
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && C.subtype(qualifier().type()))
			constraints.add(new DisjunctiveTypeConstraint(this, "method invocation", qualifier(), Operator.LE, decl().rootDefs()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ConstructorAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && C.subtype(qualifier().type()))
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ClassInstanceExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type())) {
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", this, Operator.EQ, C));
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", this, Operator.EQ, getAccess()));
		}
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && C.subtype(qualifier().type()))
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(C, constraints);
	}
	
	public void Call.collectArgumentTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		Callable c = decl();
		for(int i=0;i<c.getNumParameter();++i) {
			ParameterDeclaration parm = c.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this; caution: there might not be a getArg(i)
				continue;
			} else {
				Expr arg = getArg(i);
				if(C.subtype(arg.type()) || C.subtype(parm.type()))
					constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
	}

	protected void VarAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(decl().type()))
			constraints.add(new SimpleTypeConstraint(this, "variable access", this, Operator.EQ, decl().getTypeAccess()));
		if(isQualified() && C.subtype(qualifier().type()))
			constraints.add(new SimpleTypeConstraint(this, "field access", qualifier(), Operator.LE, (FieldDeclaration)decl()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void CastExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(this.type()) || C.subtype(getExpr().type()))
			if(isDownCast())
				constraints.add(new SimpleTypeConstraint(this, "downcast", getTypeAccess(), Operator.LE, getExpr()));
			else if(isUpCast())
				constraints.add(new SimpleTypeConstraint(this, "upcast", getExpr(), Operator.LE, getTypeAccess()));
		if(C.subtype(this.type()))
			constraints.add(new SimpleTypeConstraint(this, "cast", this, Operator.EQ, getTypeAccess()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ArrayTypeWithSizeAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(getExpr().type()))
			constraints.add(new DisjunctiveTypeConstraint(this, "sized array type", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void ArrayAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type()))
			constraints.add(new SimpleTypeConstraint(this, "array access", this, Operator.EQ, type()));
		if(C.subtype(getExpr().type()))
			constraints.add(new DisjunctiveTypeConstraint(this, "array index (1)", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		if(C.subtype(qualifier().type()))
			constraints.add(new IsArrayTypeConstraint(this, "array access (2)", qualifier()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void ArrayInit.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		TypeDecl initializerType = declType().componentType();
		for(Expr e : getInits())
			if(C.subtype(e.type()))
				constraints.add(new SimpleTypeConstraint(e, "array init", e, Operator.LE, initializerType));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ThisAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type()))
			constraints.add(new SimpleTypeConstraint(this, "this", this, Operator.EQ, hostBodyDecl()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ParExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type()))
			constraints.add(new SimpleTypeConstraint(this, "this", this, Operator.EQ, getExpr()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ConditionalExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type())) {
			constraints.add(new SimpleTypeConstraint(this, "conditional", getTrueExpr(), Operator.EQ, getFalseExpr()));
			constraints.add(new SimpleTypeConstraint(this, "conditional", this, Operator.EQ, getTrueExpr()));
		}
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void AbstractDot.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(C.subtype(type()) && !isTypeAccess())
			constraints.add(new SimpleTypeConstraint(this, "abstract dot", this, Operator.EQ, getRight()));
		super.collectTypeConstraints(C, constraints);
	}
	
	syn lazy boolean CastExpr.isDownCast() {
		TypeDecl exprtp = getExpr().type(),
		         restp = getTypeAccess().type();
		return !exprtp.equals(restp) && restp.subtype(exprtp);
	}
	
	syn lazy boolean CastExpr.isUpCast() {
		return getExpr().type().subtype(getTypeAccess().type());
	}
}
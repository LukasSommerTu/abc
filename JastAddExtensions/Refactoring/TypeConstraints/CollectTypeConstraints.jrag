/*
 * Attributes for collecting type constraints. At the moment, this algorithm is somewhat geared towards
 * Extract Interface, and will only collect type constraints involving a given type C or its supertypes.
 * 
 * Most Java 1.4 features are taken care of (exception handling is not quite done yet), but no serious support
 * is offered for Java 5.
 */
aspect CollectTypeConstraints {
	// originally, the type constraints were computed using a collection attribute
	// usually, however, we are only interested in collecting all type constraints fulfilling a certain predicate
	// hence we collect them by an AST traversal instead
	
	public Collection<TypeConstraint> ASTNode.typeConstraints(Predicate<? super TypeConstraint> pred) {
		Collection<TypeConstraint> constraints = new LinkedHashSet<TypeConstraint>();
		collectTypeConstraints(pred, constraints);
		return constraints;
	}
	
	protected void ASTNode.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		for(int i=0;i<getNumChild();++i)
			getChild(i).collectTypeConstraints(pred, constraints);
	}
	
	protected void VariableDeclaration.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(hasInit())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void FieldDeclaration.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(hasInit())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		for(FieldDeclaration that : hiddenFields())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "field hiding", this, Operator.LT, that));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void MethodDecl.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(isMainMethod())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "main method", 
													 getParameter(0).getTypeAccess(), Operator.EQ, getParameter(0).type()));
		for(MethodDecl that : overriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				addConstraint(constraints, pred, new SimpleTypeConstraint(thisParm, "overriding parameter type for method " + that.fullName(), 
																		  thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			addConstraint(constraints, pred, new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type for method " + that.fullName(),
																	  this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "method overriding", this, Operator.LT, that));
		}
		for(MethodDecl that : indirectlyOverriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				addConstraint(constraints, pred, new SimpleTypeConstraint(thisParm, "overriding parameter type for method " + that.fullName(),
																		  thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			addConstraint(constraints, pred, new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type for method " + that.fullName(),
																	  this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
		}
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ReturnStmt.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(hasResult()) {
			MethodDecl md = (MethodDecl)hostBodyDecl();
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "return", getResult(), Operator.LE, md.getTypeAccess()));
		}
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void TryStmt.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		for(CatchClause cc : getCatchClauses())
			addConstraint(constraints, pred, new SimpleTypeConstraint(cc, "catch clause", cc.getParameter().getTypeAccess(), Operator.LE, cc.typeThrowable()));
		// TODO: add constraints that types in later catch clauses may not be subtypes of types in earlier ones
		super.collectTypeConstraints(pred, constraints);
	}

	protected void AssignSimpleExpr.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "assignment", getSource(), Operator.LE, getDest()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void MethodAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "method invocation", this, Operator.EQ, decl().getTypeAccess()));
		collectArgumentTypeConstraints(pred, constraints);
		if(isQualified())
			addConstraint(constraints, pred, new DisjunctiveTypeConstraint(this, "method invocation", qualifier(), Operator.LE, decl().rootDefs()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ConstructorAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		collectArgumentTypeConstraints(pred, constraints);
		if(isQualified())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ClassInstanceExpr.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "constructor invocation", this, Operator.EQ, type()));
		//addConstraint(constraints, pred, new SimpleTypeConstraint(this, "constructor invocation", this, Operator.EQ, getAccess()));
		collectArgumentTypeConstraints(pred, constraints);
		if(isQualified())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	public void Call.collectArgumentTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		Callable c = decl();
		for(int i=0;i<c.getNumParameter();++i) {
			ParameterDeclaration parm = c.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this; caution: there might not be a getArg(i)
				continue;
			} else {
				Expr arg = getArg(i);
				addConstraint(constraints, pred, new SimpleTypeConstraint(arg, "argument passing to callable " + c.fullName(), arg, Operator.LE, parm.getTypeAccess()));
			}
		}
	}

	protected void VarAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "variable access", this, Operator.EQ, decl().getTypeAccess()));
		if(isQualified())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "field access", qualifier(), Operator.LE, (FieldDeclaration)decl()));
		super.collectTypeConstraints(pred, constraints);
	}

	protected void CastExpr.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(isDownCast())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "downcast", getTypeAccess(), Operator.LE, getExpr()));
		else if(isUpCast())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "upcast", getExpr(), Operator.LE, getTypeAccess()));
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "cast", this, Operator.EQ, getTypeAccess()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ArrayTypeWithSizeAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new DisjunctiveTypeConstraint(this, "sized array type", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		super.collectTypeConstraints(pred, constraints);
	}

	protected void ArrayAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "array access", this, Operator.EQ, type()));
		addConstraint(constraints, pred, new DisjunctiveTypeConstraint(this, "array index type", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		addConstraint(constraints, pred, new IsArrayTypeConstraint(this, "array type", qualifier()));
		super.collectTypeConstraints(pred, constraints);
	}

	protected void ArrayInit.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		TypeDecl initializerType = declType().componentType();
		for(Expr e : getInits())
			addConstraint(constraints, pred, new SimpleTypeConstraint(e, "array init", e, Operator.LE, initializerType));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ThisAccess.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "this", this, Operator.EQ, hostBodyDecl()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ParExpr.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "this", this, Operator.EQ, getExpr()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void ConditionalExpr.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "conditional", getTrueExpr(), Operator.EQ, getFalseExpr()));
		addConstraint(constraints, pred, new SimpleTypeConstraint(this, "conditional", this, Operator.EQ, getTrueExpr()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	protected void AbstractDot.collectTypeConstraints(Predicate<? super TypeConstraint> pred, Collection<TypeConstraint> constraints) {
		if(!isTypeAccess())
			addConstraint(constraints, pred, new SimpleTypeConstraint(this, "abstract dot", this, Operator.EQ, getRight()));
		super.collectTypeConstraints(pred, constraints);
	}
	
	syn lazy boolean CastExpr.isDownCast() {
		TypeDecl exprtp = getExpr().type(),
		         restp = getTypeAccess().type();
		return !exprtp.equals(restp) && restp.subtype(exprtp);
	}
	
	syn lazy boolean CastExpr.isUpCast() {
		return getExpr().type().subtype(getTypeAccess().type());
	}
	
	protected static void ASTNode.addConstraint(Collection<TypeConstraint> constraints, Predicate<? super TypeConstraint> pred, TypeConstraint constr) {
		if(pred.holds(constr))
			constraints.add(constr);
	}
	
	// often, we want to collect only type constraints to do with a given type C or one of its supertypes
	public Collection<TypeConstraint> ASTNode.typeConstraints(final TypeDecl C) {
		return typeConstraints(new Predicate<TypeConstraint>() {
			public boolean holds(TypeConstraint constr) {
				return constr.relevantForGeneralisation(C);
			}
		});
	}
	
	public abstract boolean TypeConstraint.relevantForGeneralisation(TypeDecl C);
	public boolean SimpleTypeConstraint.relevantForGeneralisation(TypeDecl C) {
		return left instanceof Expr && C.subtype(((Expr)left).type())
			|| right instanceof Expr && C.subtype(((Expr)right).type());
	}
	public boolean DisjunctiveTypeConstraint.relevantForGeneralisation(TypeDecl C) {
		for(TypeConstraint constr : constraints)
			if(constr.relevantForGeneralisation(C))
				return true;
		return false;
	}
	public boolean IsArrayTypeConstraint.relevantForGeneralisation(TypeDecl C) {
		return var instanceof Expr && C.subtype(((Expr)var).type());
	}
}
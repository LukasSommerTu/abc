aspect CollectTypeConstraints {
	syn lazy Collection<TypeConstraint> Program.typeConstraints(TypeDecl C) {
		Collection<TypeConstraint> constraints = new LinkedHashSet<TypeConstraint>();
		collectTypeConstraints(C, constraints);
		return constraints;
	}
	
	protected void ASTNode.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		for(int i=0;i<getNumChild();++i)
			getChild(i).collectTypeConstraints(C, constraints);
	}
	
	protected void VariableDeclaration.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasInit() && (getInit().type() == C || type() == C))
			constraints.add(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void FieldDeclaration.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasInit() && (getInit().type() == C || type() == C))
			constraints.add(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()));
		for(FieldDeclaration that : hiddenFields())
			constraints.add(new SimpleTypeConstraint(this, "field hiding", this, Operator.LT, that));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void MethodDecl.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(isMainMethod())
			constraints.add(new SimpleTypeConstraint(this, "main method", 
													 getParameter(0).getTypeAccess(), Operator.EQ, getParameter(0).type()));
		for(MethodDecl that : overriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				if(thisParm.type() == C)
					constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			if(this.type() == C || that.type() == C)
				constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
			constraints.add(new SimpleTypeConstraint(this, "method overriding", this, Operator.LT, that));
		}
		for(MethodDecl that : indirectlyOverriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				if(thisParm.type() == C)
					constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			if(this.type() == C || that.type() == C)
				constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
		}
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ReturnStmt.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(hasResult()) {
			MethodDecl md = (MethodDecl)hostBodyDecl();
			if(getResult().type() == C || md.type() == C)
				constraints.add(new SimpleTypeConstraint(this, "return", getResult(), Operator.LE, md.getTypeAccess()));
		}
		super.collectTypeConstraints(C, constraints);
	}

	protected void AssignSimpleExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(getSource().type() == C || getDest().type() == C)
			constraints.add(new SimpleTypeConstraint(this, "assignment", getSource(), Operator.LE, getDest()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void MethodAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "method invocation", this, Operator.EQ, decl().getTypeAccess()));
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && qualifier().type() == C)
			constraints.add(new DisjunctiveTypeConstraint(this, "method invocation", qualifier(), Operator.LE, decl().rootDefs()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ConstructorAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && qualifier().type() == C)
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ClassInstanceExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", this, Operator.EQ, C));
		collectArgumentTypeConstraints(C, constraints);
		if(isQualified() && qualifier().type() == C)
			constraints.add(new SimpleTypeConstraint(this, "constructor invocation", qualifier(), Operator.EQ, qualifier().type()));
		super.collectTypeConstraints(C, constraints);
	}
	
	public void Call.collectArgumentTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		Callable c = decl();
		for(int i=0;i<c.getNumParameter();++i) {
			ParameterDeclaration parm = c.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this; caution: there might not be a getArg(i)
				continue;
			} else {
				Expr arg = getArg(i);
				if(arg.type() == C || parm.type() == C)
					constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
	}

	protected void VarAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(decl().type() == C)
			constraints.add(new SimpleTypeConstraint(this, "variable access", this, Operator.EQ, decl().getTypeAccess()));
		if(isQualified() && qualifier().type() == C)
			constraints.add(new SimpleTypeConstraint(this, "field access", qualifier(), Operator.LE, (FieldDeclaration)decl()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void CastExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(this.type() == C || getExpr().type() == C)
			if(isDownCast())
				constraints.add(new SimpleTypeConstraint(this, "downcast", getTypeAccess(), Operator.LE, getExpr()));
			else if(isUpCast())
				constraints.add(new SimpleTypeConstraint(this, "upcast", getExpr(), Operator.LE, getTypeAccess()));
		if(this.type() == C)
			constraints.add(new SimpleTypeConstraint(this, "cast", this, Operator.EQ, type()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ArrayTypeWithSizeAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(getExpr().type() == C)
			constraints.add(new DisjunctiveTypeConstraint(this, "sized array type", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void ArrayAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "array access", this, Operator.EQ, type()));
		if(getExpr().type() == C)
			constraints.add(new DisjunctiveTypeConstraint(this, "array index (1)", getExpr(), Operator.LE, typeInt().boxed(), typeInt()));
		if(qualifier().type() == C)
			constraints.add(new IsArrayTypeConstraint(this, "array access (2)", qualifier()));
		super.collectTypeConstraints(C, constraints);
	}

	protected void ArrayInit.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		TypeDecl initializerType = declType().componentType();
		for(Expr e : getInits())
			if(e.type() == C)
				constraints.add(new SimpleTypeConstraint(e, "array init", e, Operator.LE, initializerType));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ThisAccess.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "this", this, Operator.EQ, hostBodyDecl()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ParExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "this", this, Operator.EQ, getExpr()));
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void ConditionalExpr.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C) {
			constraints.add(new SimpleTypeConstraint(this, "conditional", getTrueExpr(), Operator.EQ, getFalseExpr()));
			constraints.add(new SimpleTypeConstraint(this, "conditional", this, Operator.EQ, getTrueExpr()));
		}
		super.collectTypeConstraints(C, constraints);
	}
	
	protected void AbstractDot.collectTypeConstraints(TypeDecl C, Collection<TypeConstraint> constraints) {
		if(type() == C)
			constraints.add(new SimpleTypeConstraint(this, "abstract dot", this, Operator.EQ, getRight()));
		super.collectTypeConstraints(C, constraints);
	}
	
	/*coll Collection<TypeConstraint> Program.typeConstraints() [new LinkedHashSet<TypeConstraint>()]
	                                	                      with addAll root Program;
	
	AssignSimpleExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "assignment", getSource(), Operator.LE, getDest()))
	                 to Program.typeConstraints()
	                 for programRoot();
	
	VariableDeclaration contributes Collections.singleton(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()))
				 when hasInit()
				 to Program.typeConstraints()
				 for programRoot();
	
	FieldDeclaration contributes Collections.singleton(new SimpleTypeConstraint(this, "initialisation", getInit(), Operator.LE, getTypeAccess()))
	 			 when hasInit()
	 			 to Program.typeConstraints()
	 			 for programRoot();
	
	MethodAccess contributes typeConstraints()
	             to Program.typeConstraints()
	             for programRoot();
	
	VarAccess contributes Collections.singleton(new SimpleTypeConstraint(this, "field access", qualifier(), Operator.LE, (FieldDeclaration)decl()))
	          when isQualified()
	          to Program.typeConstraints()
	          for programRoot();
	
	ReturnStmt contributes Collections.singleton(new SimpleTypeConstraint(this, "return", getResult(), Operator.LE, ((MethodDecl)hostBodyDecl()).getTypeAccess()))
	           when hasResult()
	           to Program.typeConstraints()
	           for programRoot();
	
	MethodDecl contributes sourceMethodDecl().overridingTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	FieldDeclaration contributes ((FieldDeclaration)sourceVariableDecl()).hidingTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	ClassInstanceExpr contributes argumentTypeConstraints()
	           to Program.typeConstraints()
	           for programRoot();
	
	ConstructorAccess contributes argumentTypeConstraints()
    		   to Program.typeConstraints()
    		   for programRoot();

	CastExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "downcast", getTypeAccess(), Operator.LE, getExpr()))
	         when isDownCast()
	         to Program.typeConstraints()
	         for programRoot();

	CastExpr contributes Collections.singleton(new SimpleTypeConstraint(this, "upcast", getExpr(), Operator.LE, getTypeAccess()))
    	     when isUpCast()
			 to Program.typeConstraints()
			 for programRoot();

	ArrayTypeWithSizeAccess contributes Collections.singleton(new DisjunctiveTypeConstraint(this, "sized array type",
				getExpr(), Operator.LE, typeInt().boxed(), typeInt()))
	         to Program.typeConstraints()
	         for programRoot();
	
	ArrayAccess contributes Collections.singleton(new DisjunctiveTypeConstraint(this, "array access (1)",
				getExpr(), Operator.LE, typeInt().boxed(), typeInt()))
			 to Program.typeConstraints()
			 for programRoot();
	
	ArrayAccess contributes Collections.singleton(new IsArrayTypeConstraint(this, "array access (2)", qualifier()))
			 to Program.typeConstraints()
			 for programRoot();
	
	MethodDecl contributes Collections.singleton(new SimpleTypeConstraint(this, "main method", 
														getParameter(0).getTypeAccess(), Operator.EQ, getParameter(0).type()))
	         when isMainMethod()
	         to Program.typeConstraints()
	         for programRoot();
	
	ArrayInit contributes typeConstraints()
	         to Program.typeConstraints()
	         for programRoot();
	
	public Collection<TypeConstraint> MethodAccess.typeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		MethodDecl md = decl();
		for(int i=0;i<md.getNumParameter();++i) {
			ParameterDeclaration parm = md.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this; caution: there might not be a getArg(i)
				continue;
			} else {
				Expr arg = getArg(i);
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		if(isQualified())
			constraints.add(new DisjunctiveTypeConstraint(this, "method invocation", qualifier(), Operator.LE, decl().rootDefs()));
		return constraints;
	}
	
	public Collection<TypeConstraint> ClassInstanceExpr.argumentTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		ConstructorDecl cd = decl();
		for(int i=0;i<cd.getNumParameter();++i) {
			ParameterDeclaration parm = cd.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this
				continue;
			} else {
				Expr arg = getArg(i);
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> ConstructorAccess.argumentTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		ConstructorDecl cd = decl();
		for(int i=0;i<cd.getNumParameter();++i) {
			Expr arg = getArg(i);
			ParameterDeclaration parm = cd.getParameter(i);
			if(parm.isVariableArity()) {
				// TODO: handle this
				continue;
			} else {
				constraints.add(new SimpleTypeConstraint(arg, "argument passing", arg, Operator.LE, parm.getTypeAccess()));
			}
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> MethodDecl.overridingTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		for(MethodDecl that : overriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}
			constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
			constraints.add(new SimpleTypeConstraint(this, "method overriding", this, Operator.LT, that));
		}
		for(MethodDecl that : indirectlyOverriddenMethods()) {
			for(int i=0;i<getNumParameter();++i) {
				ParameterDeclaration thisParm = this.getParameter(i),
									 thatParm = that.getParameter(i);
				constraints.add(new SimpleTypeConstraint(thisParm, "overriding parameter type", thisParm.getTypeAccess(), Operator.EQ, thatParm.getTypeAccess()));
			}			
			constraints.add(new SimpleTypeConstraint(this.getTypeAccess(), "overriding return type", this.getTypeAccess(), Operator.LE, that.getTypeAccess()));
		}
		return constraints;
	}
	
	public Collection<TypeConstraint> FieldDeclaration.hidingTypeConstraints() {
		Collection<TypeConstraint> constraints = new LinkedList<TypeConstraint>();
		for(FieldDeclaration that : hiddenFields())
			constraints.add(new SimpleTypeConstraint(this, "field hiding", this, Operator.LT, that));
		return constraints;
	}
	
	public Collection<TypeConstraint> ArrayInit.typeConstraints() {
		TypeDecl initializerType = declType().componentType();
		Collection<TypeConstraint> res = new LinkedList<TypeConstraint>();
		for(Expr e : getInits())
			res.add(new SimpleTypeConstraint(e, "array init", e, Operator.LE, initializerType));
		return res;
	}*/
	
	syn lazy boolean CastExpr.isDownCast() {
		TypeDecl exprtp = getExpr().type(),
		         restp = getTypeAccess().type();
		return !exprtp.equals(restp) && restp.subtype(exprtp);
	}
	
	syn lazy boolean CastExpr.isUpCast() {
		return getExpr().type().subtype(getTypeAccess().type());
	}
}
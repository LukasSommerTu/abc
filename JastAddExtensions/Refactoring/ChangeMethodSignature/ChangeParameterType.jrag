aspect ChangeParameterType {
	public void ParameterDeclaration.changeType(TypeDecl newType) {
		if(!type().subtype(newType))
			throw new RefactoringException("unsupported type change");
		
		Program root = programRoot();
		Collection<TypeConstraint> constraints = root.typeConstraints();
		
		Collection<TypedDeclaration> update = propagateGeneralisation(constraints, this, newType);
		
		Collection<String> affectedMethods = new HashSet<String>();
		Collection<TypeDecl> affectedConstructors = new HashSet<TypeDecl>();
		
		for(TypedDeclaration td : update) {
			if(td instanceof ParameterDeclaration) {
				Callable c = ((ParameterDeclaration)td).getParameterisedCallable();
				if(c instanceof MethodDecl)
					affectedMethods.add(((MethodDecl)c).name());
				else if(c instanceof ConstructorDecl)
					affectedConstructors.add(((ConstructorDecl)c).hostType());
			}
		}
		
		programRoot().lockMethodNames(affectedMethods);
		programRoot().lockConstructorCalls(affectedConstructors);
		programRoot().lockOverridingDependencies(affectedMethods);
		
		for(TypedDeclaration td : update) {
			if(!td.canChangeType())
				throw new RefactoringException("type cannot be changed");
			td.setTypeAccess(newType.createLockedAccess());
		}
		
		programRoot().eliminate(LOCKED_NAMES, LOCKED_OVERRIDING);
	}

	syn boolean TypedDeclaration.canChangeType();
	eq MethodDecl.canChangeType() = fromSource() && !isNative();
	syn boolean Variable.canChangeType(); 
	eq FieldDeclaration.canChangeType() = fromSource();
	eq ParameterDeclaration.canChangeType() = fromSource() && (!(getParent().getParent() instanceof MethodDecl) || !((MethodDecl)getParent().getParent()).isNative());
	eq VariableDeclaration.canChangeType() = fromSource();
}
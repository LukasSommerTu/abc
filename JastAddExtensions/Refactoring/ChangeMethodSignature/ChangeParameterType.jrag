aspect ChangeParameterType {
	inh TypeDecl ParameterDeclaration.typeThrowable();
	
	public void ParameterDeclaration.changeType(TypeDecl newType) {
		if(getParameterisedCallable() != null && 
				(!getParameterisedCallable().fromSource() || getParameterisedCallable().isNative()))
			throw new RefactoringException("cannot change this parameter declaration");
		if(!type().subtype(newType))
			throw new RefactoringException("unsupported type change");
		if(type().subtype(typeThrowable())) 
			throw new RefactoringException("cannot change throwable types");
		Program root = programRoot();
		Collection<TypeConstraint> constraints = root.typeConstraints(type());
		
		Collection<TypeConstraintVariable> update = propagateGeneralisation(constraints, this.getTypeAccess(), newType);
		
		Collection<String> affectedMethods = new HashSet<String>();
		Collection<TypeDecl> affectedConstructors = new HashSet<TypeDecl>();
		
		findAffectedCallables(update, newType, affectedMethods, affectedConstructors);
		
		root.lockMethodNames(affectedMethods);
		root.lockConstructorCalls(affectedConstructors);
		root.lockOverridingDependencies(affectedMethods);
		
		for(TypeConstraintVariable tcv : update) {
			if(tcv instanceof Expr) {
				Expr e = (Expr)tcv;
				if(e.isTypeAccess())
					e.replaceWith(newType.createLockedAccess());
			}
	    }
		
		root.flushCaches();
		
		root.eliminate(LOCKED_NAMES, LOCKED_OVERRIDING);
	}
	
	public static void ASTNode.findAffectedCallables(Collection<TypeConstraintVariable> update, TypeDecl newType, Collection<String> affectedMethods, Collection<TypeDecl> affectedConstructors) {
		for(TypeConstraintVariable tcv : update) {
			if(tcv instanceof Expr) {
				Expr e = (Expr)tcv;
				if(e.isParameterType()) {
					Callable c = ((ParameterDeclaration)e.getParent()).getParameterisedCallable();
					if(c instanceof MethodDecl)
						affectedMethods.add(((MethodDecl)c).name());
					else if(c instanceof ConstructorDecl)
						affectedConstructors.add(((ConstructorDecl)c).hostType());
				}
				if(e.isLeftChildOfDot() && e.nextAccess() instanceof MethodAccess) {
					MethodAccess ma = (MethodAccess)e.nextAccess();
					MethodDecl oldTarget = ma.decl(),
							   newTarget = oldTarget.ancestorIn(newType);
					// TODO: this should be part of the type constraints
					if(!oldTarget.throwsSameExceptionsAs(newTarget))
						throw new RefactoringException("new target throws different exceptions");
					ma.lock(newTarget);
				}
			}
		}		
	}
	
	syn boolean Expr.isParameterType() = false;
	eq Access.isParameterType() = isTypeAccess() && getParent() instanceof ParameterDeclaration;
	
	syn boolean Callable.throwsSameExceptionsAs(Callable that) {
		if(this.getExceptionList().getNumChild() != that.getExceptionList().getNumChild())
			return false;
		for(Access exn : this.getExceptionList())
			if(!that.throwsExactException(exn.type()))
				return false;
		return true;
	}
	
	syn lazy boolean Callable.throwsExactException(TypeDecl exnType) {
		for(Access exn : this.getExceptionList())
			if(exn.type().equals(exnType))
				return true;
		return false;
	}
}
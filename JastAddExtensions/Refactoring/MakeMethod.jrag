/*
 * Make Method is the second part of the Extract Method refactoring; it turns a
 * block into a method. Similar to Extract Block, it also needs to check some
 * control flow conditions. Furthermore, it has to determine which local variables
 * to pass as parameters, and which value to return from the created method.
 */

aspect MakeMethod {
	
	public Access Variable.getTypeAccess();
	
	public void CompilationUnit.makeMethod(String name, String vis, Block blk) 
			throws RefactoringException {
		check_make_method_preconds(blk);
		Block host = blk.hostBlock();
		BodyDecl bd = host.hostBodyDecl();
		// check whether the extracted method needs to be static
		boolean static_ctxt = false;
		if(bd instanceof StaticInitializer)
			static_ctxt = true;
		if(bd instanceof MethodDecl && ((MethodDecl)bd).isStatic())
			static_ctxt = true;
		host.createMethod(name, vis, blk.indexInHostBlock(), blk, static_ctxt);
	}

	// the last statement of the block must post-dominate the first one
	private void CompilationUnit.check_make_method_preconds(Block blk) 
			throws RefactoringException {
		if(blk.getNumStmt() > 1) {
			Stmt fst = blk.getStmt(0);
			Stmt lst = blk.getStmt(blk.getNumStmt()-1);
			if(!lst.post_dominates(fst))
				throw new RefactoringException("end must post-dominate begin");
		}
		Block host = blk.hostBlock();
		if(host == null)
			throw new RefactoringException("block to be extracted must be inside some other block");
	}
	
	/* local variables declared before a block and live inside it are input
	 * parameters */
	syn HashSet Block.inputParameters() {
		HashSet parms = new HashSet();
		for(Iterator iter=visibleLocalDecls().iterator();iter.hasNext();) {
			Variable decl = (Variable)iter.next();
			if(decl.isLiveIn(this))
				parms.add(decl);
		}
		return parms;
	}
	
	/* an "extra" local variable is a local variable declared outside a block
	 * which is not live inside, but may be defined inside */
	syn HashSet Block.extraLocalVars() {
		HashSet locals = new HashSet();
		for(Iterator iter=visibleLocalDecls().iterator();iter.hasNext();) {
			LocalDeclaration decl = (LocalDeclaration)iter.next();
			if(!((Variable)decl).isLiveIn(this) && mayDef((Variable)decl)) {
				VariableDeclaration vd = decl.asVariableDeclaration();
				vd.setInitOpt(new Opt());
				locals.add(vd);
			}
		}
		return locals;
	}
	
	/* an output parameter of a block is a local variable declared outside the
	 * block which is live after and may be defined inside the block */
	syn HashSet Block.outputParameters() {
		HashSet parms = new HashSet();
		for(Iterator iter=visibleLocalDecls().iterator();iter.hasNext();) {
			Variable decl = (Variable)iter.next();
			if(decl.isLiveAfter(this) && mayDef(decl))
				parms.add(decl);
		}
		return parms;
	}
	
	// all branch statements have a body of some kind
	public abstract Stmt BranchTargetStmt.getStmt();
	public Stmt SwitchStmt.getStmt() {
		return getBlock();
	}
	
	// we need to check whether the block to be turned into a method returns a result
	syn boolean Stmt.returnsValue() = false;
	eq Block.returnsValue() {
		for(int i=0;i<getNumStmt();++i)
			if(getStmt(i).returnsValue())
				return true;
		return false;
	}
	eq BranchTargetStmt.returnsValue() = getStmt().returnsValue();
	eq IfStmt.returnsValue() 
		= getThen().returnsValue() || hasElse() && getElse().returnsValue();
	eq ReturnStmt.returnsValue() = hasResult();
	
	// expose useful attributes
	inh TypeDecl Block.hostType();
	inh TypeDecl Block.typeVoid();
	
	public void Block.createMethod(String name, String vis, int pos, Block blk, boolean static_ctxt) 
			throws RefactoringException {
		Block hostblock = blk.hostBlock();
		Collection parms = blk.inputParameters();      // parameters of extracted method
		Collection localVars = blk.extraLocalVars();   // local variables of extracted method
		Collection outparms = blk.outputParameters();
		/* there are two different issues having to do with return values of the extracted method:
		 *   1) the method could alter a local variable whose new value should be
		 *   	returned and assigned to the variable
		 *   2) the method might return a result, which should in turn be returned
		 *   	by the method it was extracted from (since we have checked for
		 *      domination already, there will be a _single_ return statement in
		 *      this case, and all control paths will reach this statement) 
		 */
		TypeDecl rettype = typeVoid();    // return type of created method
		// dealing with case 1)
		Opt retvar = new Opt();           // variable returned by extracted method
		if(outparms.size() == 1) {
			Variable outparm = (Variable)outparms.iterator().next();
			retvar = new Opt(((ASTNode)outparm).fullCopy());
			rettype = outparm.type();
		}
		if(outparms.size() > 1)
			throw new RefactoringException("ambiguous return value");
		// dealing with case 2)
		if(blk.returnsValue()) {
			if(!retvar.isEmpty())
				throw new RefactoringException("ambiguous return value");
			BodyDecl bd = hostBodyDecl();
			if(!(bd instanceof MethodDecl))
				throw new RefactoringException("couldn't determine return type of extracted method");
			rettype = ((MethodDecl)bd).type();
		}
		// one last thing to guard against when extracting from a constructor
		if(mayDefFinal())
			throw new RefactoringException("code may assign to a final field");
		// create declaration of method
		MethodDecl md = createMethodDecl(static_ctxt, name, vis, parms, retvar, rettype, 
				blk.uncaughtThrows(), localVars, blk);
		// insert method invocation and body into type declaration
		hostType().insertMethod(md, hostblock, pos, parms, retvar, rettype);
	}
	
	private boolean Block.mayDefFinal() {	
		for(FieldDeclaration fd  : 
			  (Collection<FieldDeclaration>)hostType().localFieldsMap().values())
			if(mayDef(fd) && fd.isFinal())
				return true;
		return false;
	}
	
	private void TypeDecl.insertMethod(MethodDecl md, Block host, int index, 
				Collection parms, Opt retvar, TypeDecl rettype) 
			throws RefactoringException { 
		// prepare the invocation statement
		Stmt invocation;
		List args = new List();
		for(Iterator iter=parms.iterator();iter.hasNext();)
			args.add(new VarAccess(((LocalDeclaration)iter.next()).getID()));
		MethodAccess ma = new MethodAccess(md.getID(), args);
		// add it as an expression statement, or with an assignment
		if(retvar.isEmpty()) {
			// need to add a return if the extracted block returns something itself
			if(rettype != typeVoid())
				invocation = new ReturnStmt(ma);
			else
				invocation = new ExprStmt(ma);
		} else {
			Variable v = (Variable)retvar.getChild(0);
			invocation = new ExprStmt(new AssignSimpleExpr(new VarAccess(v.name()), ma));
		}
		// insert the method
		/* it is crucial that this happens first, since the invocation references
		 * the newly created method, which would make addMethod reject the refactoring */
		addMethod(md, false, false, false);
		// unlock the return type access of the method
		((TypeAccess)md.getTypeAccess()).unlockSafely();
		// insert the invocation at the position where blk used to be
		host.setStmt(invocation, index);
	}
	
	private MethodDecl Block.createMethodDecl(boolean static_ctxt, String name, String visibility,
			Collection parms, Opt retvar, TypeDecl rettype, 
			Set exns, Collection localVariables, Block blk) throws RefactoringException {
		// modifiers: visibility, perhaps with a "static"
		Modifiers mod = new Modifiers();
		if(!visibility.equals("default"))
			mod.addModifier(new Modifier(visibility));
		if(static_ctxt)
			mod.addModifier(new Modifier("static"));
		// type access: either "void" or the type of the variable to be assigned to
		TypeAccess acc = new TypeAccess("void");
		// lock onto the correct type; we can leave the name as "void", since the
		// unlocking mechanism will compute a type access anyway
		acc.lockOn(rettype);
		// parameter declarations
		List parmdecls = new List();
		for(Iterator i=parms.iterator();i.hasNext();)
			parmdecls.add(((LocalDeclaration)i.next()).asParameterDeclaration());
		// thrown exceptions
		List throwdecls = new List();
		for(Iterator i=exns.iterator();i.hasNext();) {
			TypeDecl exn = ((ThrowStmt)i.next()).getExpr().type();
			Access exnacc = hostBodyDecl().access(exn, false);
			if(exnacc == null)
				throw new RefactoringException("cannot access type "+exn);
			throwdecls.add(exnacc);
		}
		// body
		int i; Iterator iter;
		for(iter=localVariables.iterator(), i=0;iter.hasNext();++i)
			blk.insertStmt(i, (Stmt)iter.next());
		if(!retvar.isEmpty()) {
			Variable decl = (Variable)retvar.getChild(0);
			String varname = decl.name();
			ReturnStmt stmt = new ReturnStmt(new VarAccess(varname));
			blk.insertStmt(blk.getNumStmt(), stmt);
		}
		return new MethodDecl(mod, acc, name, parmdecls, throwdecls, new Opt(blk));
	}
		
}
aspect ExtractTemp {
	public VariableDeclaration Expr.extractTemp(String name, boolean makeFinal) {
		if(inextractible())
			throw new RefactoringException("expression is not extractible");
		TypeDecl type = type();
		if(type.isAnonymous())
			type = ((AnonymousDecl)type).superType();
		else if(isInaccessibleTypeVariable(type))
			type = ((TypeVariable)type).uniqueUpperBound();
		return insertUnusedLocal(new VariableDeclaration(type.createLockedAccess(), name)).
			   extractAssignment(this).merge().makeFinal(makeFinal);
	}
	
	public VariableDeclaration Expr.extractTemp(String name) {
		return extractTemp(name, false);
	}
	
	// JastAddJ represents type variable captures as bound accesses to type variables of the generic type
	// this solution is a bit hackish, so let's solve it in a hackish way ;-)
	public boolean Expr.isInaccessibleTypeVariable(TypeDecl td) {
		if(!td.isTypeVariable())
			return false;
		return lookupType(td.name()) != td;
	}
	
	public TypeDecl TypeVariable.uniqueUpperBound() {
		if(getNumTypeBound() != 1)
			throw new RefactoringException("captured type variable does not have unique bound");
		return getTypeBound(0).type();
	}

	// an expression is inextractible if it cannot be replaced by a variable access
	syn boolean Expr.inextractible() = notAnObject() || inInextractiblePosition();

	// expressions that do not by themselves stand for objects
	syn boolean Expr.notAnObject() = type().isVoid();
	eq AbstractDot.notAnObject() = super.notAnObject() || !isArrayAccess() && !isClassAccess() && getRight().notAnObject();
	eq AbstractWildcard.notAnObject() = true;
	eq ArrayAccess.notAnObject() = true;
	eq ClassAccess.notAnObject() = true;
	eq PackageAccess.notAnObject() = true;
	eq ParTypeAccess.notAnObject() = true;
	eq SuperAccess.notAnObject() = true;
	eq TypeAccess.notAnObject() = true;
	eq CastExpr.notAnObject() = super.notAnObject() || getExpr().notAnObject();
	eq ParExpr.notAnObject() = super.notAnObject() || getExpr().notAnObject();
	
	// expressions in positions where they cannot be replaced by a local variable access
	inh boolean Expr.inInextractiblePosition();
	eq Program.getChild().inInextractiblePosition() = false;
	eq ConstructorDecl.getConstructorInvocation().inInextractiblePosition() = true;
	eq ExprStmt.getExpr().inInextractiblePosition() = true;
	eq AssignExpr.getChild().inInextractiblePosition() = false;
	eq PreIncExpr.getChild().inInextractiblePosition() = false;
	eq PreDecExpr.getChild().inInextractiblePosition() = false;
	eq PostfixExpr.getChild().inInextractiblePosition() = false;
	eq AbstractDot.getRight().inInextractiblePosition() = true;
	eq MethodAccess.getArg().inInextractiblePosition() = false;
	eq ConstructorAccess.getArg().inInextractiblePosition() = false;
	eq ArrayAccess.getExpr().inInextractiblePosition() = false;
	eq ArrayTypeWithSizeAccess.getExpr().inInextractiblePosition() = false;
	eq ClassInstanceExpr.getArg().inInextractiblePosition() = false;
	eq ArrayCreationExpr.getArrayInit().inInextractiblePosition() = true;
	eq VariableDeclaration.getInit().inInextractiblePosition() = false;
	
	public VariableDeclaration VariableDeclaration.extractAssignment(Expr expr) {
		return expr.extractAssignment(this);
	}
	
	public VariableDeclaration VariableDeclaration.makeFinal(boolean makeFinal) {
		return makeFinal ? makeFinal() : this;
	}
	
    // stand-alone refactoring
    public void Expr.doExtract(String name, boolean makeFinal) {
    	Program root = programRoot();
    	extractTemp(name, makeFinal);
    	root.eliminate(LOCKED_DATAFLOW, LOCKED_NAMES);
    }
    
    public void Expr.doExtract(String name) {
    	doExtract(name, false);
    }
}
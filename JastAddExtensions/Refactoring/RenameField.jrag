/*
 * The Rename Field refactoring. Like most name-based refactoring, it proceeds in
 * four steps:
 *   1. check preconditions (here: is there a field of the same name already?) 
 *   2. find uses of the field being renamed, and of everything that might be
 *      shadowed by the newly renamed field
 *   3. do the renaming
 *   4. adjust all uses collected in step 2
 */

aspect RenameField {

	public void FieldDeclaration.rename(String new_name) throws RefactoringException {
		if(getID().equals(new_name))
			// haha, very funny
			return;
		if(!hostType().localFields(new_name).isEmpty())
			throw new RefactoringException("couldn't rename: field name clash");
		AdjustmentTable table = findEndangered(new_name);
		changeID(new_name);
		programRoot().flushCaches();
		table.adjust();
	}

	/* in preparation for renaming a field to new_name, this method finds all
	 * uses of the variable before renaming and all uses of fields, types and
	 * packages that might become shadowed by the renaming and collects them into
	 * an adjustment table */ 
	public AdjustmentTable FieldDeclaration.findEndangered(String new_name) {
		AdjustmentTable table = new AdjustmentTable();
		/* first, collect all uses of the field we are renaming */
		for(Iterator i = uses().iterator(); i.hasNext();) {
			Access acc = (Access)i.next();
			table.add(acc);
		}
		/* now, collect all uses of fields and types that the variable
		 * might be shadowing after renaming, in this class or any descendant */
		Collection descendants = hostType().descendants();
		for(Iterator i = descendants.iterator(); i.hasNext();) {
			TypeDecl td = (TypeDecl)i.next();
			findEndangered(new_name, td, table);
		}
		// same for packages
		PackageDecl pd = programRoot().getPackageDecl(new_name);
		if(pd != null)
			for(Iterator j = pd.prefixUses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				if(acc.nameType() == NameType.AMBIGUOUS_NAME ||
						acc.nameType() == NameType.PACKAGE_OR_TYPE_NAME)
					table.add(acc);
			}
		return table;
	}
	
	public AdjustmentTable FieldDeclaration.findEndangered(String new_name,
									TypeDecl td, AdjustmentTable table) {
		if(td.getNumBodyDecl() == 0)
			return table;
		BodyDecl fst = td.getBodyDecl(0);
		for(Iterator i = fst.lookupVariable(new_name).iterator(); i.hasNext();) {
			Variable v = (Variable)i.next();
			for(Iterator j = v.collectedUses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				table.add(acc);
			}
		}
		for(Iterator i = td.lookupType(new_name).iterator(); i.hasNext();) {
			TypeDecl d = (TypeDecl)i.next();
			for(Iterator j = d.uses().iterator(); j.hasNext();) {
				Access acc = (Access)j.next();
				// only a type in an ambiguous position can be shadowed by a variable
				if(acc.nameType() == NameType.AMBIGUOUS_NAME)
					table.add(acc);
			}
		}
		return table;
	}

}
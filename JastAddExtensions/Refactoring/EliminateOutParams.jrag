aspect EliminateOutParams {
  public void ClosureInvocation.eliminateOutParams() throws RefactoringException {
    new EliminateOutParamsRefactoring(this).execute();
  }

  class EliminateOutParamsRefactoring {
    private ClosureInvocation closure;
    private AdjustmentTable table;

    public EliminateOutParamsRefactoring(ClosureInvocation closure) {
      this.closure = closure;
      table = new AdjustmentTable();
    }

    public void execute() throws RefactoringException {
      if(closure.getNumOutParameter() == 0)
	return;
      if(closure.getNumOutParameter() > 1)
	throw new RefactoringException("ambiguous return value");
      ParameterDeclaration parm = closure.getOutParameter(0);
      if(!(closure.getOutArg(0) instanceof VarAccess))
	throw new RefactoringException("cannot eliminate out parameter");
      VarAccess v = (VarAccess)closure.getOutArg(0);
      closure.setOutParameterList(new List<ParameterDeclaration>());
      closure.setReturnType(v.type().getLockedAccess(table));
      if(!closure.hasInParameter(v.name()))
	closure.getBlock().insertStmt(0, new VariableDeclaration(v.type().getLockedAccess(table), v.name()));
      closure.getBlock().addStmt(new ReturnStmt(new VarAccess(v.name())));
      closure.setOutArgList(new List<Expr>());
      AssignExpr assgn = new AssignSimpleExpr(v, null);
      closure.replaceWith(assgn);
      assgn.setSource(closure);
      closure.programRoot().flushCaches();
      table.adjust();
    }
  }

  public TypeAccess TypeDecl.getLockedAccess(AdjustmentTable table) {
    TypeAccess acc = new TypeAccess(this.name());
    acc.lockOn(this);
    table.add(acc);
    return acc;
  }
}
/** The "Split Variable Declaration" refactoring splits a variable declaration
 *  with initialiser like
 *
 *        int x = 42;
 *
 *  into a declaration followed by an assignment like
 *
 *        int x;
 *        x = 42;
 *
 *  For the moment, we require that the original declaration is inside a block
 *  (this is not strictly necessary, since we could create a block to take
 *  up the created statements, but we'd have to be careful about declarations
 *  inside for loops and such then).
 *  
 *  The refactoring returns the newly created assignment, or null if none was created.
 */

aspect SplitVarDecl {
  
  public AssignSimpleExpr VariableDeclaration.split() throws RefactoringException {
    if(!hasInit())
      return null;  // we could throw an exception here, but I think it's better this way
    if(getInit().isArrayInit())
    	throw new RefactoringException("cannot split declaration with array initializer");
    if(!(getParent().getParent() instanceof Block))
      throw new RefactoringException("cannot split declarations outside blocks");
    Block block = (Block)getParent().getParent();
    int idx = block.getIndexOfStmt(this);
    assert(idx != -1);
    AssignSimpleExpr assgn = new AssignSimpleExpr(new VarAccess(name()), getInit());
    this.setInitOpt(new Opt());
    block.insertStmt(idx+1, new ExprStmt(assgn));
    block.flushCaches();
    return assgn;
  }

  public int Block.getIndexOfStmt(Stmt stmt) {
    return getStmtList().getIndexOfChild(stmt);
  }
  
  syn lazy boolean Expr.isArrayInit() = false;
  eq ArrayInit.isArrayInit() = true;

}
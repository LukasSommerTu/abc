// TODO: check that possible targets stay the same, not only the decl
aspect LockedMethodAccess {
	/* A locked method access is a method access that does not obey the normal method lookup
	 * rules, but instead immediately binds to its target. */
	public LockedMethodAccess.LockedMethodAccess(MethodDecl target, List<Expr> args) {
		this(target.name(), args, target.save(), new Opt());
	}
	
	/* If we just store the method declaration an access should bind to, we get into trouble with
	 * ParMethodDecls: we might store a reference to some ParMethodDecl, then somebody flushes the
	 * caches, and a new ParMethodDecl will be created the next time we ask for it. Then inherited
	 * attributes won't work anymore, and things generally become unpleasant.
	 * 
	 * So we store a SavedMethodDecl instead: this is either a wrapper around a regular MethodDecl,
	 * or it represents a ParMethodDecl by its genericMethodDecl() and its list of arguments.*/
	class SavedMethodDecl {
		private MethodDecl md;
		
		public SavedMethodDecl(MethodDecl md) {
			this.md = md;
		}
		
		public MethodDecl getDecl() {
			return md;
		}
	}
	
	class SavedParMethodDecl extends SavedMethodDecl {
		private ArrayList<TypeDecl> parms;
		public SavedParMethodDecl(ParMethodDecl pmd) {
			super(pmd.genericMethodDecl());
			parms = new ArrayList<TypeDecl>();
			for(Access acc : pmd.getTypeArguments())
				parms.add(acc.type());
		}
		
		public MethodDecl getDecl() {
			return ((GenericMethodDecl)super.getDecl()).lookupParMethodDecl(parms);
		}
	}
	
	public SavedMethodDecl MethodDecl.save() { return new SavedMethodDecl(this); }
	public SavedParMethodDecl ParMethodDecl.save() { return new SavedParMethodDecl(this); }
	
	eq LockedMethodAccess.isQualified() = hasQualifier();
	eq LockedMethodAccess.qualifier() = getQualifier();
	eq LockedMethodAccess.isSuperCall() = hasQualifier() ? getQualifier().isSuperAccess() : super.isSuperCall();
	eq LockedMethodAccess.unqualifiedScope() = this;
	
	eq LockedMethodAccess.decls() = SimpleSet.emptySet.add(getTarget().getDecl());
	
	private MethodDecl LockedMethodAccess.unlockedDecl() {
		flushCache();
		SimpleSet set; 
		if(hasQualifier())
			set = maxSpecific(getQualifier().type().memberMethods(name()));
		else
			set = maxSpecific(lookupMethod(name()));
		if(!set.isSingleton())
			return unknownMethod();
		MethodDecl res = (MethodDecl)set.iterator().next();
		return res;
	}
	
	public ASTNode LockedMethodAccess.lock() { return this; }
	public ASTNode LockedMethodAccess.lock(MethodDecl md) {
		this.setTarget(md.save());
		return this;
	}
		
	public void LockedMethodAccess.toString(StringBuffer s) {
		s.append("[[");
		if(hasQualifier()) {
			getQualifier().toString(s);
			s.append(".");
		}
		super.toString(s);
		s.append("]]");
	}
	
	public void LockedMethodAccess.addQualifier(Expr e) {
		if(!hasQualifier())
			setQualifier(e);
		else
			setQualifier(e.qualifiesAccess((Access)getQualifier()));
	}
	
	// introducing fixed method accesses
	public ASTNode MethodAccess.lockMethodNames(Collection<String> endangered) {
		if(endangered.contains(name()))
			return lock();
		else
			return super.lockMethodNames(endangered);
	}
	
	public ASTNode MethodAccess.lock() {
		return lock(decl());
	}
	
	public ASTNode MethodAccess.lock(MethodDecl md) {
		assert md != null && !md.isUnknown();
		MethodDecl target = md.isSubstituted() ? md.sourceMethodDecl() : md;
		LockedMethodAccess lma = new LockedMethodAccess(target, getArgs());
		replaceWith(lma);
		if(lma.isRightChildOfDot()) {
			lma.parentDot().is$Final(false);
		} else if(lma.isLeftChildOfDot()) {
			AbstractDot parent = lma.parentDot();
			if(parent.isRightChildOfDot()) {
				parent.is$Final(false);
				parent.parentDot().is$Final(false);
			}
		}
		return lma;
	}
	
	public boolean MethodDecl.isSubstituted() { return false; }
	public boolean MethodDeclSubstituted.isSubstituted() { return false; }
	
	// pushing qualifiers into LockedMethodAccess
	rewrite AbstractDot {
	  when(getRight() instanceof LockedMethodAccess)
	  to LockedMethodAccess {
		LockedMethodAccess lma = (LockedMethodAccess)getRight();
		lma.addQualifier(getLeft());
		if(hasParentDot())
			parentDot().is$Final(false);
		return lma;
	  }
	}
	 
	rewrite AbstractDot {
	  when(getRight() instanceof AbstractDot &&
			  ((AbstractDot)getRight()).getLeft() instanceof LockedMethodAccess)
	  to AbstractDot {
		AbstractDot r = (AbstractDot)getRight();
		LockedMethodAccess ma = (LockedMethodAccess)r.getLeft();
		ma.addQualifier(getLeft());
		AbstractDot d = new AbstractDot(ma, r.getRight());
		if(hasParentDot())
			parentDot().is$Final(false);
		return d;		  
	  }
	}
	
	// eliminating locked method accesses
	inh TypeDecl LockedMethodAccess.enclosingType();
	public Access LockedMethodAccess.eliminateLockedNames() {
		MethodDecl target = getTarget().getDecl();
		if(fromSource())
			setID(target.name());
		if(unlockedDecl().sameSourceDeclAs(target)) {
			MethodAccess ma = new MethodAccess(name(), getArgs());
			if(hasQualifier())
				return getQualifier().qualifiesAccess(ma);
			else
				return ma;
		} else if(fromSource()) {
			MethodAccessInfo acc;
			if(hasQualifier())
				acc = getQualifier().type().accessMemberMethod(target);
			else
				acc = accessMethod(target);
			if(acc == null)
				throw new RefactoringException("cannot access method "+target.name());
			Access res = acc.eliminate(hasQualifier() ? getQualifier() : null, 
									   enclosingType(), inStaticContext(), getArgs());
			if(res == null)
				throw new RefactoringException("cannot access method "+target.name());
			return res;
		} else {
			throw new RefactoringException("cannot access method "+target.name());
		}
	}
	
	// eliminating locked method accesses
	public Access MethodAccessInfo.eliminate(Expr qualifier, TypeDecl enclosing, 
			boolean inStaticCtxt, List<Expr> args) {
		if(qualifier == null)
			return eliminate(enclosing, inStaticCtxt, args);
		else
			return eliminateQualified(qualifier, enclosing, inStaticCtxt, args);
	}
	
	public Access MethodAccessInfo.eliminate(TypeDecl enclosing, boolean inStaticCtxt, List<Expr> args) {
		if(!directlyVisible) {
			if(target.isStatic())
				return computeStaticAccess(enclosing, args);
			if(inStaticCtxt)
				return null;
			if(source == bend) {
				return computeThisAccess(enclosing, args);
			} else if(bend instanceof ClassDecl && source == ((ClassDecl)bend).superclass()) {
				return computeSuperAccess(enclosing, args);
			} else {
				return null;
			}
		} else {
			return constructAccess(args);
		}
	}
	
	public Access MethodAccessInfo.computeStaticAccess(TypeDecl enclosing, List<Expr> args) {
		return source.createLockedAccess().qualifiesAccess(constructAccess(args));
	}
	
	public Access MethodAccessInfo.computeThisAccess(TypeDecl enclosing, List<Expr> args) {
		MethodAccess ma = constructAccess(args);
		if(source == enclosing)
			return ma;
		else
			return bend.createLockedAccess().qualifiesAccess(new ThisAccess("this").qualifiesAccess(ma));
	}
	
	public Access MethodAccessInfo.computeSuperAccess(TypeDecl enclosing, List<Expr> args) {
		MethodAccess ma = constructAccess(args);
		if(bend == enclosing)
			return new SuperAccess("super").qualifiesAccess(ma);
		else
			return bend.createLockedAccess().qualifiesAccess(new SuperAccess("super").qualifiesAccess(ma));
	}

	protected MethodAccess MethodAccessInfo.constructAccess(List<Expr> args) {
		// check if any of the competitors is more specific than the target for
		// this argument list; then we need casts
		for(MethodDecl cand : competitors)
			if(cand.applicableTo(args) && cand.moreSpecificThan(target))
				return new MethodAccess(target.name(), insertCasts(args));
		return new MethodAccess(target.name(), args);
	}
	
	protected List<Expr> MethodAccessInfo.insertCasts(List<Expr> args) {
		List<Expr> new_args = new List<Expr>();
		for(int i=0;i<target.getNumParameter();++i) {
			ParameterDeclaration parm = target.getParameter(i);
			Expr arg = args.getChild(i);
			TypeDecl tp = parm.type();
			if(parm.isVariableArity() && !arg.type().methodInvocationConversionTo(tp)) {
				List<Expr> varargs = new List<Expr>();
				while(i<args.getNumChild())
					varargs.add(args.getChild(i++));
				new_args.addChild(new ArrayCreationExpr(tp.createLockedAccess(), new Opt(new ArrayInit(varargs))));
			} else {
				new_args.addChild(new CastExpr(tp.createLockedAccess(), arg));
			}
		}
		return new_args;
	}

	public Access MethodAccessInfo.eliminateQualified(Expr qualifier, TypeDecl enclosing,
			boolean inStaticCtxt, List<Expr> args) {
		MethodAccess ma = constructAccess(args);
		if(!directlyVisible) {
			if(!target.isStatic())
				return null;
			if(inStaticCtxt)
				if(qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(source))
					return qualifier.qualifiesAccess(ma);
				else
					return null;
			if(source == bend && source.sameSourceDeclAs(qualifier.type()))
				return qualifier.qualifiesAccess(ma);
			else if(!qualifier.isTypeAccess() && qualifier.type().sameSourceDeclAs(bend))
				return new ParExpr(new CastExpr(source.createLockedAccess(), qualifier)).qualifiesAccess(ma);
			return null;
		} else {
			if(!target.accessibleFrom(enclosing))
				throw new RefactoringException("method not accessible");
			return qualifier.qualifiesAccess(ma);
		}
	}	
}
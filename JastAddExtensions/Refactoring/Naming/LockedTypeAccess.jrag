aspect LockedTypeAccess {
	// not all types have a name
	public boolean TypeDecl.hasName() { return true; }
	public boolean AbstractWildcardType.hasName() { return false; }
	public boolean NullType.hasName() { return false; }
	public boolean EmptyType.hasName() { return false; }
	public boolean AnonymousDecl.hasName() { return false; }
	public boolean ClassDeclSubstituted.hasName() { return false; }
	public boolean GenericClassDeclSubstituted.hasName() { return false; }
	public boolean UnknownType.hasName() { return false; }
	public boolean GLBType.hasName() { return false; }
	public boolean GenericInterfaceDeclSubstituted.hasName() { return false; }
	public boolean LUBType.hasName() { return false; }
	
	/* A locked type access is a type access that does not obey the normal type lookup
	 * rules, but instead immediately binds to its target. */
	private SavedTypeDecl TypeAccess.targetType = null;
	private boolean CompilationUnit.locked = false;
	
	/* We have to store a bit more than just a TypeDecl as the target of a locked type access;
	 * see LockedMethodAccess.jrag */
	class SavedTypeDecl {
		private TypeDecl td;
		
		public SavedTypeDecl(TypeDecl td) {
			this.td = td;
		}
		
		public TypeDecl getDecl() {
			return td;
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			if(td.isGenericType()) {
				GenericTypeDecl gtd = (GenericTypeDecl)td;
				for(int i=0;i<gtd.getNumTypeParameter();++i)
					vars.add(gtd.getTypeParameter(i));
			}
		}
	}
	
	class SavedArrayDecl extends SavedTypeDecl {
		private SavedTypeDecl componentType;
		
		public SavedArrayDecl(ArrayDecl ary) {
			super(ary);
			this.componentType = ary.componentType().save();
		}
		
		public TypeDecl getDecl() {
			return componentType.getDecl().arrayType();
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			componentType.collectUsedTypeVars(vars);
		}
	}
	
	class SavedParTypeDecl extends SavedTypeDecl {
		private ArrayList<SavedTypeDecl> parms;
		public SavedParTypeDecl(ParTypeDecl ptd) {
			super(ptd.genericDecl());
			parms = new ArrayList<SavedTypeDecl>(ptd.getNumArgument());
			for(int i=0;i<ptd.getNumArgument();++i)
				parms.add(ptd.getArgument(i).type().save());
		}
		
		public TypeDecl getDecl() {
			ArrayList<TypeDecl> types = new ArrayList<TypeDecl>(parms.size());
			for(SavedTypeDecl std : parms)
				types.add(std.getDecl());
			return ((GenericTypeDecl)super.getDecl()).lookupParTypeDecl(types);
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			for(SavedTypeDecl parm : parms)
				parm.collectUsedTypeVars(vars);
		}
	}
	
	class SavedRawClassDecl extends SavedTypeDecl {
		public SavedRawClassDecl(RawClassDecl rcd) {
			super(rcd.genericDecl());
		}
		
		public TypeDecl getDecl() { return ((GenericTypeDecl)super.getDecl()).rawType(); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { }
	}
	
	class SavedRawInterfaceDecl extends SavedTypeDecl {
		public SavedRawInterfaceDecl(RawInterfaceDecl rid) {
			super(rid.genericDecl());
		}
		
		public TypeDecl getDecl() { return ((GenericTypeDecl)super.getDecl()).rawType(); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { }
	}
	
	public SavedTypeDecl TypeDecl.save() { return new SavedTypeDecl(this); }
	public SavedTypeDecl ArrayDecl.save() { return new SavedArrayDecl(this); }
	public SavedTypeDecl ParTypeDecl.save() { return new SavedParTypeDecl(this); }
	public SavedTypeDecl RawClassDecl.save() { return new SavedRawClassDecl(this); }
	public SavedTypeDecl RawInterfaceDecl.save() { return new SavedRawInterfaceDecl(this); }
	
	refine LookupType eq TypeAccess.decls() = targetType == null ? refined() : targetType.getDecl();
	refine Generics eq TypeAccess.decl() = targetType == null ? refined() : targetType.getDecl();
	
	refine PrettyPrint public void TypeAccess.toString(StringBuffer s) {
		if(targetType == null) {
			refined(s);
		} else {
			s.append("[[");
			refined(s);
			s.append("]]");
		}
	}
	
	public TypeAccess.TypeAccess(TypeDecl target) {
		setID(target.name());
		targetType = target.save();
	}
	
	public ASTNode TypeAccess.lockNames(Collection<String> endangered) {
		if(targetType == null &&
				(endangered.contains(name()) || endangered.contains(getTopLevelPackage())))
			return lock();
		return super.lockNames(endangered);
	}
	
	public ASTNode ParTypeAccess.lockNames(Collection<String> endangered) {
		String name = getTypeAccess().type().name();
		if(endangered.contains(name))
			return lock();
		return super.lockNames(endangered);
	}
	
	// absolute type access; can't get shadowed anyway
	public ASTNode BytecodeTypeAccess.lockNames(Collection<String> endangered) { return this; }
	
	public ASTNode CompilationUnit.lockNames(Collection<String> endangered) {
		if(fromSource() && !locked && endangered.contains(getID()))
			locked = true;
		return super.lockNames(endangered);
	}
	
	public Access TypeAccess.eliminateLockedNames() {
		return targetType == null ? this : unlock();
	}

	public CompilationUnit CompilationUnit.eliminateLockedNames() {
		if(locked && fromSource()) {
			locked = false;
			// make sure this compilation unit has same name as publicly declared class
			for(TypeDecl t : getTypeDecls()) {
				if(t.isPublic()) {
					setID(t.name());
					break;
				}
			}
		}
		return this;
	}
	
	refine TypeVariableExt protected void TypeAccess.collectUsedTypeVars(Collection<TypeVariable> tvars) {
		if(targetType != null)
			targetType.collectUsedTypeVars(tvars);
		refined(tvars);
	}
	
	public ASTNode TypeAccess.lock() { return lock(decl());	}
	public ASTNode TypeAccess.lock(TypeDecl decl) {
		assert decl != unknownType();
		targetType = decl.save();
		return this;
	}
	
	public ASTNode ParTypeAccess.lock() { return lock(type()); }
	public ASTNode ParTypeAccess.lock(TypeDecl decl) {
		TypeAccess tacc = new TypeAccess(decl);
		replaceWith(tacc);
		return tacc;
	}
	
	public Access TypeAccess.unlock() {
		TypeDecl target = targetType.getDecl();
		if(!target.hasName())
			throw new RefactoringException("cannot unlock access to nameless type");
		try {
			if(hostType() == null && !target.accessibleFromPackage(hostPackage())
					|| hostType() != null && !target.accessibleFrom(hostType()))
				throw new RefactoringException("inaccessible type");
			if(!fromSource()) {
				if(!decl().equals(target))
					throw new RefactoringException("cannot fix access in library");
				return this;
			}
			if(target.isGenericType() && !inImportDecl())
				return unlockGenericTypeAccess((GenericTypeDecl)target);
			if(target.isRawType())
				target = target.erasure();
			if(target.isParameterizedType())
				return unlockParTypeAccess((ParTypeDecl)target);
			if(target.isTypeVariable())
				return unlockTypeVariableAccess((TypeVariable)target);
			if(target instanceof PrimitiveType || target instanceof VoidType)
				return unlockPrimitiveTypeAccess(target);
			if(target.isArrayDecl())
				return unlockArrayTypeAccess((ArrayDecl)target);
			if(target.isLocalClass())
				return unlockLocalClassAccess((ClassDecl)target);
			if(target.isMemberType())
				return unlockMemberTypeAccess(target);
			if(target.isTopLevelType())
				return unlockTopLevelTypeAccess(target);
			throw new Error("cannot fix access to this kind of type");
		} finally {
			targetType = null;
		}
	}
	
	protected Access TypeAccess.unlockPrimitiveTypeAccess(TypeDecl target) {
		if(isQualified())
			throw new RefactoringException("cannot access primitive type under qualifier");
		setID(target.name());
		return this;
	}
	
	protected Access TypeAccess.unlockTypeVariableAccess(TypeVariable target) {
		if(isQualified())
			throw new RefactoringException("cannot access type variable under type qualifier");
		if(!lookupName(target.name()).isSingleton(target))
			throw new RefactoringException("cannot access shadowed/obscured type variable");
		setPackage("");
		setID(target.name());
		return this;
	}
	
	protected Access TypeAccess.unlockLocalClassAccess(ClassDecl target) {
		if(isQualified())
			throw new RefactoringException("cannot access local class under type qualifier");
		if(!lookupName(target.name()).isSingleton(target))
			throw new RefactoringException("cannot access shadowed/obscured local class");
		setPackage("");
		setID(target.name());
		return this;
	}

	protected Access TypeAccess.unlockMemberTypeAccess(TypeDecl target) {
		if(isQualified()) {
			if(!qualifier().isTypeAccess())
				throw new RefactoringException("cannot access member type under non-type qualifier");
			TypeDecl outer = qualifier().type();
			if(!outer.memberTypes(target.name()).isSingleton(target))
				throw new RefactoringException("cannot access shadowed member type");
			setPackage("");
			setID(target.name());
			return this;
		} else {
			if(lookupName(target.name()).isSingleton(target)) {
				setPackage("");
				setID(target.name());
				return this;
			} else {
				TypeDecl outer = target.enclosingType();
				if(!outer.memberTypes(target.name()).isSingleton(target))
					throw new RefactoringException("cannot access shadowed member type");
				setPackage("");
				setID(target.name());
				// TODO: more thought on when precisely this is necessary
				// (rationale here is that if target is a generic type declaration, we are actually
				// trying to build an access to its raw type)
				if(target.isGenericType() && outer.isGenericType())
					outer = ((GenericTypeDecl)outer).rawType();
				return new TypeAccess(outer).qualifiesAccess(this);
			}
		}
	}
	
	protected Access TypeAccess.unlockTopLevelTypeAccess(TypeDecl target) {
		if(isQualified())
			throw new RefactoringException("cannot access toplevel type under qualifier");
		programRoot().flushCaches();
		if(lookupName(target.name()).isSingleton(target)) {
			setPackage("");
			setID(target.name());
			return this;
		}
		setPackage(target.packageName());
		setID(target.name());
		String pkg = getTopLevelPackage();
		SimpleSet s = lookupName(pkg);
		if(!s.isEmpty() && !s.isSingleton(lookupPackage(pkg))
				|| !lookupType(target.packageName(), target.name()).equals(target))
			throw new RefactoringException("cannot access toplevel type");
		return this;
	}
	
	protected Access TypeAccess.unlockParTypeAccess(ParTypeDecl target) {
		List<Access> args = new List<Access>();
		for(int i=0;i<target.getNumArgument();++i)
			args.add(new TypeAccess(target.getArgument(i).type()));
		return new ParTypeAccess(new TypeAccess(((GenericTypeDecl)target.genericDecl()).rawType()), args);
	}
	
	protected Access TypeAccess.unlockGenericTypeAccess(GenericTypeDecl target) {
		List<Access> args = new List<Access>();
		for(int i=0;i<target.getNumTypeParameter();++i)
			args.add(new TypeAccess(target.getTypeParameter(i)));
		return new ParTypeAccess(new TypeAccess(target.rawType()), args);
	}

	protected Access TypeAccess.unlockArrayTypeAccess(ArrayDecl target) {
		return new ArrayTypeAccess(new TypeAccess(target.componentType()));
	}
	
	protected Access ArrayTypeAccess.unlockArrayTypeAccess(ArrayDecl target) {
		setAccess(new TypeAccess(target.componentType()));
		return this;
	}
}
aspect LockedVariableAccess {
	/* A locked variable access is a variable access that does not obey the normal variable lookup
	 * rules, but instead immediately binds to its target. */
	public LockedVarAccess.LockedVarAccess(Variable target) {
		this(target.name(), target, new Opt());
	}
	
	eq LockedVarAccess.decls() = SimpleSet.emptySet.add(getTarget());
	
	LockedVarAccess contributes	this when getTarget() instanceof FieldDeclaration
	to FieldDeclaration.uses() for (FieldDeclaration)getTarget();

	LockedVarAccess contributes	this when getTarget() instanceof VariableDeclaration
	to VariableDeclaration.uses() for (VariableDeclaration)getTarget();

	LockedVarAccess contributes	this when getTarget() instanceof ParameterDeclaration
	to ParameterDeclaration.uses() for (ParameterDeclaration)getTarget();
	
	private Variable LockedVarAccess.unlockedDecl() {
		flushCache();
		SimpleSet set;
		if(hasQualifier())
			// TODO: this is not quite correct; need to filter out some things (see LookupVariable.jrag)
			set = getQualifier().qualifiedLookupVariable(name());
		else
			set = lookupVariable(name());
		if(!set.isSingleton())
			return unknownField();
		Variable res = (Variable)set.iterator().next();
		return res;
	}
		
	public void LockedVarAccess.toString(StringBuffer s) {
		s.append("[[");
		if(hasQualifier()) {
			getQualifier().toString(s);
			s.append(".");
		}
		super.toString(s);
		s.append("]]");
	}
	
	public void LockedVarAccess.addQualifier(Expr e) {
		if(!hasQualifier())
			setQualifier(e);
		else
			setQualifier(e.qualifiesAccess((Access)getQualifier()));
	}
	
	eq LockedVarAccess.isQualified() = hasQualifier();
	eq LockedVarAccess.qualifier() = getQualifier();
	
	// introducing locked variable accesses
	public ASTNode VarAccess.lockNames(Collection<String> endangered) {
		if(endangered.contains(name()))
			return lock();
		else
			return super.lockNames(endangered);
	}
	
	public ASTNode VarAccess.lock() {
		return lock(decl());
	}
	
	public ASTNode VarAccess.lock(Variable target) {
		target = target.isSubstituted() ? target.sourceVariableDecl() : target;
		LockedVarAccess lva = new LockedVarAccess(target);
		replaceWith(lva);
		if(lva.isRightChildOfDot()) {
			lva.parentDot().is$Final(false);
		} else if(lva.isLeftChildOfDot()) {
			AbstractDot parent = lva.parentDot();
			if(parent.isRightChildOfDot()) {
				parent.is$Final(false);
				parent.parentDot().is$Final(false);
			}
		}
		return lva;
	}
	
	public ASTNode LockedVarAccess.lock() { return this; }
	public ASTNode LockedVarAccess.lock(Variable target) { setTarget(target); return this; }
	
	public boolean Variable.isSubstituted() { return false; }
	public boolean FieldDeclarationSubstituted.isSubstituted() { return true; }
	public boolean ParameterDeclarationSubstituted.isSubstituted() { return true; }
	public boolean VariableArityParameterDeclarationSubstituted.isSubstituted() { return true; }
	
	// pushing qualifiers into LockedVarAccess
	rewrite AbstractDot {
		when(getRight() instanceof LockedVarAccess)
		to LockedVarAccess {
			LockedVarAccess lva = (LockedVarAccess)getRight();
			lva.addQualifier(getLeft());
			if(hasParentDot())
				parentDot().is$Final(false);
			return lva;
		  }
		}
		 
	rewrite AbstractDot {
		when(getRight() instanceof AbstractDot &&
				((AbstractDot)getRight()).getLeft() instanceof LockedVarAccess)
		to AbstractDot {
			AbstractDot r = (AbstractDot)getRight();
			LockedVarAccess lva = (LockedVarAccess)r.getLeft();
			lva.addQualifier(getLeft());
			AbstractDot d = new AbstractDot(lva, r.getRight());
			if(hasParentDot())
				parentDot().is$Final(false);
			return d;		  
		}
	}
		
	// eliminating locked variable accesses
	inh TypeDecl LockedVarAccess.enclosingType();
	public Access LockedVarAccess.eliminateLockedNames() {
		Variable target = getTarget();
		if(fromSource())
			setID(target.name());
		if(unlockedDecl().sameSourceDeclAs(target)) {
			if(hasQualifier())
				return getQualifier().qualifiesAccess(new VarAccess(name()));
			else
				return new VarAccess(name());
		} else if(fromSource() && !(target instanceof LocalVariable)) {
			VariableAccessInfo acc;
			if(hasQualifier())
				acc = getQualifier().qualifiedAccessVariable(target);
			else
				acc = accessVariable(target);
			if(acc == null) {
				if(target.isStatic()) {
					TypeDecl host = target.hostType();
					if(host.accessibleFrom(hostType()) && mayAccess((FieldDeclaration)target))
						return host.createLockedAccess().qualifiesAccess(new VarAccess(target.name()));
				}
				throw new RefactoringException("cannot access variable "+target.name());
			}
			return acc.eliminate(hasQualifier() ? getQualifier() : null, enclosingType());
		} else {
			throw new RefactoringException("cannot access variable "+target.name());
		}
	}
	
	// eliminating locked variable accesses
	public Access VariableAccessInfo.eliminate(Expr qualifier, TypeDecl enclosing) {
		FieldDeclaration target = (FieldDeclaration)getVariable();
		if(target.isStatic()) {
			return target.hostType().createLockedAccess().qualifiesAccess(new VarAccess(target.name()));
		} else {
			if(isDirectlyVisible()) {
				if(qualifier != null)
					return qualifier.qualifiesAccess(new VarAccess(target.name()));
				return new VarAccess(target.name());
			} else {
				TypeDecl source = getSource(), bend = getBend();
				VarAccess va = new VarAccess(target.name());
				if(qualifier == null) {
					if(source.sameSourceDeclAs(bend)) {
						if(bend.equals(enclosing)) {                                             // this.f
							return new ThisAccess("this").qualifiesAccess(va);
						} else {                                                                       // B.this.f
							return bend.createLockedAccess().qualifiesAccess(
									new ThisAccess("this").qualifiesAccess(va));
						}
					} else if(bend.isClassDecl() && source.equals(((ClassDecl)bend).superclass())) {
						if(bend.equals(enclosing)) {                                             // super.f
							return new SuperAccess("super").qualifiesAccess(va);
						} else {
							return bend.createLockedAccess().qualifiesAccess(                               // B.super.f
									new SuperAccess("super").qualifiesAccess(va));
						}
					} else {
						if(bend.equals(enclosing)) {
							return new ParExpr(new CastExpr(source.createLockedAccess(),                    // ((S)this).f 
									new ThisAccess("this"))).qualifiesAccess(va);
						} else {
							return new ParExpr(new CastExpr(source.createLockedAccess(),                    // ((S)B.this).f
									bend.createLockedAccess().qualifiesAccess(
											new ThisAccess("this")))).qualifiesAccess(va);
						}
					}
				} else {
					if(!bend.equals(qualifier.type()))
						throw new RefactoringException("cannot access variable");
					if(source.equals(qualifier.type()))
						return qualifier.qualifiesAccess(va);
					return new ParExpr(new CastExpr(source.createLockedAccess(), qualifier)).qualifiesAccess(va);
				}
			}
		}
	}
	
	// a locked this access remembers which enclosing instance it is supposed to refer to;
	// a super access remembers the enclosing instance whose super class it is supposed to refer to
	eq LockedThisAccess.decl() = getTarget();
	eq LockedSuperAccess.decl() = getTarget();
	
	public LockedThisAccess LockedThisAccess.lock() { return this; }
	public LockedThisAccess LockedThisAccess.lock(TypeDecl target) { setTarget(target); return this; }
	public LockedSuperAccess LockedSuperAccess.lock() { return this; }
	public LockedSuperAccess LockedSuperAccess.lock(TypeDecl target) { setTarget(target); return this; }
	
	public void LockedThisAccess.toString(StringBuffer s) {
		s.append("[[this]]");
	}
	public void LockedSuperAccess.toString(StringBuffer s) {
		s.append("[[super]]");
	}
	
	public ThisAccess ThisAccess.lock() {
		return isQualified() ? this : lock(decl());
	}
	public SuperAccess SuperAccess.lock() {
		return isQualified() ? this : lock(decl());
	}
	
	public LockedThisAccess ThisAccess.lock(TypeDecl target) {
		LockedThisAccess lta = new LockedThisAccess("this", target);
		replaceWith(lta);
		return lta;
	}
	public LockedSuperAccess SuperAccess.lock(TypeDecl target) {
		LockedSuperAccess lsa = new LockedSuperAccess("super", target);
		replaceWith(lsa);
		return lsa;
	}
	
	public Access LockedThisAccess.eliminateLockedNames() {
		// TODO: maybe this is OK as long as decl() is a subtype of getTarget()?
		flushCaches();
		if(super.decl().sameSourceDeclAs(getTarget()))
			return new ThisAccess("this");
		if(!fromSource() || isQualified())
			throw new RefactoringException("cannot adjust this access");
		if(!thisType().isInnerTypeOf(getTarget()))
			throw new RefactoringException("enclosing instance not reachable");
		return getTarget().createLockedAccess().qualifiesAccess(new ThisAccess("this"));
	}
	public Access LockedSuperAccess.eliminateLockedNames() {
		// TODO: maybe this is OK as long as decl() is a subtype of getTarget()?
		flushCaches();
		if(super.decl().sameSourceDeclAs(getTarget()))
			return new SuperAccess("super");
		if(!fromSource() || isQualified() || qualifiesMethodAccess())
			throw new RefactoringException("cannot adjust this access");
		if(!thisType().isInnerTypeOf(getTarget()))
			throw new RefactoringException("super instance not reachable");
		return getTarget().createLockedAccess().qualifiesAccess(new SuperAccess("super"));
	}
	
	syn lazy boolean SuperAccess.qualifiesMethodAccess() = hasParentDot() && parentDot().isMethodAccess();
}
aspect SavedTypes {
	/* When locking names, we often need to hold on to references to type declarations for extended
	 * periods of time. This is not a problem for normal type declarations, but it is tricky for
	 * ArrayTypes and ParTypeDecls and such, since these type declarations are in fact NTAs that get
	 * recomputed after cache flushes.
	 * 
	 * Our solution to this is never to hold on to a reference to a type declaration directly, but
	 * rather to a SavedTypeDecl, which wraps around such a reference and recomputes it on demand if
	 * it gets stale. */

	// the easy case: just a wrapper around a TypeDecl
	class SavedTypeDecl {
		private TypeDecl td;
		
		public SavedTypeDecl(TypeDecl td) {
			this.td = td;
		}
		
		public TypeDecl getDecl() {
			return td;
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			if(td.isGenericType()) {
				GenericTypeDecl gtd = (GenericTypeDecl)td;
				for(int i=0;i<gtd.getNumTypeParameter();++i)
					vars.add(gtd.getTypeParameter(i));
			}
		}
	}
	
	// for arrays, save a reference to the component type
	class SavedArrayDecl extends SavedTypeDecl {
		private SavedTypeDecl componentType;
		
		public SavedArrayDecl(ArrayDecl ary) {
			super(ary);
			this.componentType = ary.componentType().save();
		}
		
		public TypeDecl getDecl() {
			return componentType.getDecl().arrayType();
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			componentType.collectUsedTypeVars(vars);
		}
	}
	
	// for parameterised types, save a reference to the generic type and references to all the type arguments
	class SavedParTypeDecl extends SavedTypeDecl {
		private ArrayList<SavedTypeDecl> parms;
		public SavedParTypeDecl(ParTypeDecl ptd) {
			super(ptd.genericDecl());
			parms = new ArrayList<SavedTypeDecl>(ptd.getNumArgument());
			for(int i=0;i<ptd.getNumArgument();++i)
				parms.add(ptd.getArgument(i).type().save());
		}
		
		public TypeDecl getDecl() {
			ArrayList<TypeDecl> types = new ArrayList<TypeDecl>(parms.size());
			for(SavedTypeDecl std : parms)
				types.add(std.getDecl());
			return ((GenericTypeDecl)super.getDecl()).lookupParTypeDecl(types);
		}
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) {
			for(SavedTypeDecl parm : parms)
				parm.collectUsedTypeVars(vars);
		}
	}
	
	// for raw classes, save a reference to the generic type
	class SavedRawClassDecl extends SavedTypeDecl {
		public SavedRawClassDecl(RawClassDecl rcd) {
			super(rcd.genericDecl());
		}
		
		public TypeDecl getDecl() { return ((GenericTypeDecl)super.getDecl()).rawType(); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { }
	}
	
	// same for raw interfaces
	class SavedRawInterfaceDecl extends SavedTypeDecl {
		public SavedRawInterfaceDecl(RawInterfaceDecl rid) {
			super(rid.genericDecl());
		}
		
		public TypeDecl getDecl() { return ((GenericTypeDecl)super.getDecl()).rawType(); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { }
	}
	
	// finally, wildcard types
	class SavedWildcardType extends SavedTypeDecl {
		private Program root;
		public SavedWildcardType(WildcardType wt) { 
			super(wt);
			root = wt.programRoot();
		}
		
		public TypeDecl getDecl() {	return root.wildcards().typeWildcard(); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { }
	}
	
	class SavedWildcardExtendsType extends SavedTypeDecl {
		private Program root;
		private SavedTypeDecl ub;
		public SavedWildcardExtendsType(WildcardExtendsType wet) { 
			super(wet);
			root = wet.programRoot();
			ub = wet.getAccess().type().save();
		}
		
		public TypeDecl getDecl() {	return root.wildcards().lookupWildcardExtends(ub.getDecl()); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { ub.collectUsedTypeVars(vars); }
	}
	
	class SavedWildcardSuperType extends SavedTypeDecl {
		private Program root;
		private SavedTypeDecl lb;
		public SavedWildcardSuperType(WildcardSuperType wst) { 
			super(wst);
			root = wst.programRoot();
			lb = wst.getAccess().type().save();
		}
		
		public TypeDecl getDecl() {	return root.wildcards().lookupWildcardSuper(lb.getDecl()); }
		
		public void collectUsedTypeVars(Collection<TypeVariable> vars) { lb.collectUsedTypeVars(vars); }
	}
	
	// methods for turning a TypeDecl into a SavedTypeDecl
	public SavedTypeDecl TypeDecl.save() { return new SavedTypeDecl(this); }
	public SavedTypeDecl ArrayDecl.save() { return new SavedArrayDecl(this); }
	public SavedTypeDecl ParTypeDecl.save() { return new SavedParTypeDecl(this); }
	public SavedTypeDecl RawClassDecl.save() { return new SavedRawClassDecl(this); }
	public SavedTypeDecl RawInterfaceDecl.save() { return new SavedRawInterfaceDecl(this); }
	public SavedTypeDecl WildcardType.save() { return new SavedWildcardType(this); }
	public SavedTypeDecl WildcardExtendsType.save() { return new SavedWildcardExtendsType(this); }
	public SavedTypeDecl WildcardSuperType.save() { return new SavedWildcardSuperType(this); }
}
/* bind all name uses to their declarations */

aspect Uses {
	
	public Collection<VarAccess> Variable.collectedUses() {
		return uses();
	}
	
	// bind all uses of a variable to its declaration
	coll Collection<VarAccess> FieldDeclaration.uses() [new ArrayList<VarAccess>()] 
	                                                    with add ;
	VarAccess contributes
	this when decl() instanceof FieldDeclaration
	to FieldDeclaration.uses() for (FieldDeclaration)decl();
	
	coll Collection<VarAccess> VariableDeclaration.uses() [new ArrayList<VarAccess>()] 
	                                                       with add;
	VarAccess contributes
	this when decl() instanceof VariableDeclaration
	to VariableDeclaration.uses() for (VariableDeclaration)decl();

	coll Collection<VarAccess> ParameterDeclaration.uses() [new ArrayList<VarAccess>()] 
	                                                        with add;
	VarAccess contributes
	this when decl() instanceof ParameterDeclaration
	to ParameterDeclaration.uses() for (ParameterDeclaration)decl();
	
	// bind all uses of a method to its declaration
	// since this is in general undecidable, we report
	// all uses that possibly might refer to it
	coll Collection<MethodAccess> MethodDecl.uses() [new ArrayList<MethodAccess>()] 
	                                                 with addAll  root Program;
	MethodAccess contributes
	this.asSet() to MethodDecl.uses() for decl();
	
	MethodDecl contributes uses() to MethodDecl.uses() for each overriders();
	
	protected HashSet ASTNode.asSet() {
		HashSet set = new HashSet();
		set.add(this);
		return set;
	}

	// collects all descendants of a type declaration, including itself
	coll Collection<TypeDecl> TypeDecl.descendants() circular [new HashSet<TypeDecl>()] 
	                                                           with addAll root Program;
	TypeDecl contributes 
	this.asSet() to TypeDecl.descendants() for this;

	ClassDecl contributes
	descendants() when hasSuperclass()
	to TypeDecl.descendants() for superclass();
	
	ClassDecl contributes
	descendants() 
	to TypeDecl.descendants() for each interfaces();
	
	InterfaceDecl contributes
	descendants() 
	to TypeDecl.descendants() for each superInterfaces();
	
	// retrieve all interfaces implemented by a class declaration
	public Collection ClassDecl.interfaces() {
		Collection res = new LinkedList();
		for(Iterator i=interfacesIterator();i.hasNext();)
			res.add(i.next());
		return res;
	}
	
	// retrieve all interfaces extended by an interface declaration
	public Collection InterfaceDecl.superInterfaces() {
		Collection res = new LinkedList();
		for(Iterator i=superinterfacesIterator();i.hasNext();)
			res.add(i.next());
		return res;
	}
	
	// collect all method declarations overriding a given method declaration
	coll HashSet MethodDecl.overriders() [new HashSet()] with add root Program;
	MethodDecl contributes this to MethodDecl.overriders() for each overrides();
	
	// get all method declarations overridden by a given method declaration
	syn lazy SimpleSet MethodDecl.overrides() {
		SimpleSet anc = SimpleSet.emptySet;
		for(Iterator i=hostType().ancestorMethods(signature()).iterator();i.hasNext();) {
			MethodDecl md = (MethodDecl)i.next();
			if(overrides(md))
				anc = anc.add(md);
		}
		return anc;
	}

	// bind all uses of a type to its declaration
	coll Collection<TypeAccess> TypeDecl.uses() [new ArrayList<TypeAccess>()] with add root Program;
	TypeAccess contributes
	this to TypeDecl.uses() for (TypeDecl)decl();
	
	eq Program.getChild().findPackageDecl(String name) = getPackageDecl(name);
	inh PackageDecl Access.findPackageDecl(String name);
	
	public static boolean ASTNode.pkgNameStartsWith(String pkg, String str) {
		int strlength = str.length();
		return	pkg.startsWith(str) &&
				(pkg.length() == strlength ||
				 pkg.charAt(strlength) == '.');
 	}
	
	public static String ASTNode.pkgNameFirstComponent(String pkg) {
		int idx = pkg.indexOf('.');
		if(idx == -1)
			return pkg;
		return pkg.substring(0, idx);
	}
	
	syn nta PackageDecl Program.getPackageDecl(String name) {
		// the following gives null-pointer exceptions in generated code
		//return hasPackage(name) ? new PackageDecl(name) : null;
		return new PackageDecl(name);
	}
	
	// bind all uses of a label to its declaration
	coll Collection<Stmt> LabeledStmt.uses() [new ArrayList<Stmt>()] 
	                                         with add root BodyDecl;
	BreakStmt contributes
	this when targetStmt() instanceof LabeledStmt
	to LabeledStmt.uses() for (LabeledStmt)targetStmt();
	
	ContinueStmt contributes
	this when targetStmt() instanceof LabeledStmt
	to LabeledStmt.uses() for (LabeledStmt)targetStmt();
}
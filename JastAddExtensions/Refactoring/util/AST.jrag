aspect AST {
	public static boolean ASTNode.DEBUG = false;
	
	public static String ASTNode.unCapitalise(String s) {
		return Character.toLowerCase(s.charAt(0)) + s.substring(1);
	}
	
	syn String FieldDeclaration.capitalisedName() = Character.toUpperCase(name().charAt(0))+name().substring(1); 
	
	public static Object ASTNode.epsilon(SimpleSet set, Object alt) {
		if(set.size() == 1)
			return set.iterator().next();
		return alt;
	}
	
	public ASTNode ASTNode.getParent(int i) {
		if(i <= 0)
			return this;
		if(getParent() == null)
			return null;
		return getParent().getParent(i-1);
	}
	
	public int ASTNode.getChildIndex() {
		return getParent().getIndexOfChild(this);
	}
	
	public void ASTNode.removeChild(ASTNode child) {
		removeChild(getIndexOfChild(child));
	}
	
	private static void ASTNode.addingChildParentCheck(ASTNode newParent, ASTNode node) {
		if (DEBUG && node != null &&
				node.is$Final() && 
				//programRootParentFromField() != null && programRootParentFromField().isRecordingASTChanges() && 
				node.parent != null && node.parent != newParent //&& node.parent.getIndexOfChild(node) != -1
				)
			throw new RuntimeException("inserting node with parent already set");
	}
	refine ASTNode public void ASTNode.setChild(T node, int i) {
		addingChildParentCheck(this, node);
		refined(node, i);
	}
	refine ASTNode public void ASTNode.insertChild(T node, int i) {
		addingChildParentCheck(this, node);
		refined(node, i);
	}
	public ASTNode<T> ASTNode.fullCopyAndDetach() {
		ASTNode<T> node = fullCopy();
		//node.parent = null;
		return node;
	}
	
	public Program ASTNode.programRoot() {
		ASTNode n=this;
		while(n!=null && !(n instanceof Program))
			n=n.getParent();
		return (Program)n;
	}
	
	public CompilationUnit ASTNode.compilationUnit() {
		ASTNode n=this;
		while(n!=null && !(n instanceof CompilationUnit))
			n=n.getParent();
		return (CompilationUnit)n;
	}
	
	public BodyDecl ASTNode.hostBodyDecl() {
		ASTNode n=this;
		while(n!=null && !(n instanceof BodyDecl))
			n=n.getParent();
		return (BodyDecl)n;
	}
	
	syn lazy boolean ASTNode.fromSource() {
		CompilationUnit cu = compilationUnit();
		return cu == null ? false : cu.fromSource(); 
	}
	
	public boolean Stmt.isInBlock() {
		return getParent() != null && getParent().getParent() instanceof Block;
	}
	
	public boolean Variable.isField() {
		return isClassVariable() || isInstanceVariable();
	}
	
	public void TypeDecl.removeBodyDecl(BodyDecl bd) {
		getBodyDeclList().removeChild(getBodyDeclList().getIndexOfChild(bd));
	}

	public void ASTNode.flushCaches() {
		this.flushCache();
		for(int i=0;i<getNumChild();++i) {
			ASTNode child = getChild(i);
			if(child != null)
				child.flushCaches();
		}
	}
	
	public void BodyDecl.flushCaches() {
		entry.flushCaches();
		exit.flushCaches();
		super.flushCaches();
	}
	
//	public void ASTNode.flushOtherCaches() {
//		this.flushOtherCache();
//		for(int i=0;i<getNumChild();++i) {
//			ASTNode child = getChild(i);
//			if(child != null)
//				child.flushOtherCaches();
//		}
//	}
//	
//	public void BodyDecl.flushOtherCaches() {
//		entry.flushOtherCaches();
//		exit.flushOtherCaches();
//		super.flushOtherCaches();
//	}
//	
//	public void ASTNode.flushPossibleNTAReferencesCaches() {
//		this.flushPossibleNTAReferencesCache();
//		for(int i=0;i<getNumChild();++i) {
//			ASTNode child = getChild(i);
//			if(child != null)
//				child.flushPossibleNTAReferencesCaches();
//		}
//	}
//	
//	public void BodyDecl.flushPossibleNTAReferencesCaches() {
//		entry.flushPossibleNTAReferencesCaches();
//		exit.flushPossibleNTAReferencesCaches();
//		super.flushPossibleNTAReferencesCache();
//	}
	
	protected void ASTNode.replaceWith(ASTNode newnode) {
		ASTNode parent = getParent();
		parent.setChild(newnode, parent.getIndexOfChild(this));
	}
	
	protected void Access.qualifyWith(Expr qual) {
		ASTNode parent = getParent();
		int idx = parent.getIndexOfChild(this);
		parent.setChild(qual.qualifiesAccess(this), idx);
	}
	
	private static int ASTNode.replaceIndex = -1;
	public static ASTNode ASTNode.replace(ASTNode child) {
		ASTNode parent = child.getParent();
		replaceIndex = parent.getIndexOfChild(child);
		return parent;
	}
	public ASTNode ASTNode.with(ASTNode newChild) {
		setChild((T)newChild, replaceIndex);
		newChild.flushCaches();
		return newChild;
	}

	/* JastAddJ stores multiply qualified accesses as right-heavy trees
	 * for example, [A.this.f] is
	 *     .
	 *    / \
	 *   A   .
	 *      / \
	 *    this f
	 *    
	 *  Unfortunately, this makes it rather hard to extract the complete
	 *  qualifier of an access; for example, we'd like to see in this example
	 *  that [f] is qualified by [A.this], not just by [this].
	 *  
	 *  This method rotates the tree to the left; e.g., the above example
	 *  becomes
	 *  
	 *       .
	 *      / \
	 *     .   f
	 *    / \
	 *   A this
	 */
	public void AbstractDot.rotateLeft() {
		Expr l = getLeft(); setLeft(null);
		Access r = getRight(); setRight(null);
		while(r instanceof AbstractDot) {
			AbstractDot rdot = (AbstractDot)r;
			Access rdot_left = (Access) rdot.getLeft(); rdot.setLeft(null);
			l = new AbstractDot(l, rdot_left);
			r = rdot.getRight(); rdot.setRight(null);
		}
		setLeft(l);
		setRight(r);
	}
	
	/* f.bundleQualifier() does the following:
	 * 
	 * 
	 *      .                    .
	 *     / \                  / \
	 *    A   .        ~>      .   f
	 *       / \              / \
	 *     this f            A this
	 *     
	 *     
	 *      .                    .
	 *     / \                  / \
	 *    A   .                .   g
	 *       / \       ~>     / \
	 *     this .            .   f
	 *         / \          / \
	 *        f   g        A this
	 *        
	 */
	public void Access.bundleQualifier() {
		if(isLeftChildOfDot()) {
			AbstractDot parent = parentDot();
			if(!parent.isRightChildOfDot())
				return;
			AbstractDot g = new AbstractDot(null, parent.getRight());
			AbstractDot p = parent.parentDot();
			p.setRight(this);
			while(p.isRightChildOfDot())
				p = p.parentDot();
			p.rotateLeft();
			p.replaceWith(g);
			g.setLeft(p);
		} else if(isRightChildOfDot()) {
			AbstractDot p = parentDot();
			while(p.isRightChildOfDot())
				p = p.parentDot();
			p.rotateLeft();
		}
	}
}
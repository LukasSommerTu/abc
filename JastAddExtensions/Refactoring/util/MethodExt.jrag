aspect MethodExt {
	syn boolean MethodDecl.isUnknown() = hostType().isUnknown();
	
	public void MethodDecl.makeAbstract() {
		if(isNative() || isFinal() || isStatic())
			throw new RefactoringException("cannot make this method abstract");
		getModifiers().addModifier("abstract");
		setBlockOpt(new Opt());
	}
	
	// whether this method could by called either dynamically or statically
	syn lazy boolean MethodDecl.isCallable() = !monoUses().isEmpty() || isDynamicallyCallable();
	
	// all statically resolved calls to this method
	syn lazy Collection<MethodAccess> MethodDecl.monoUses() {
		Collection<MethodAccess> res = new HashSet<MethodAccess>();
		for(MethodAccess ma : uses())
			if(ma.isMonoCall())
				res.add(ma);
		return res;
	}
	
	// whether this method could be called through dynamic dispatch
	syn lazy boolean MethodDecl.isDynamicallyCallable() {
		if(isStatic() || isPrivate())
			return false;
		// not if neither this method nor a method it overrides is ever called
		if(polyUses().isEmpty())
			return false;
		// not if no object of a type that inherits this method is ever constructed
		for(TypeDecl td : inheritingTypes())
			if(td.instancesAreConstructed())
				return true;
		return false;
	}
	
	// all types that inherit a certain method and do not provide an overriding definition
	syn lazy Collection<TypeDecl> MethodDecl.inheritingTypes() {
		if(isStatic() || isPrivate())
			return Collections.singleton(hostType());
		Collection<TypeDecl> result = new HashSet<TypeDecl>();
		LinkedList<TypeDecl> worklist = new LinkedList<TypeDecl>();
		worklist.add(hostType());
		while(!worklist.isEmpty()) {
			TypeDecl td = worklist.pop();
			result.add(td);
			for(TypeDecl child : td.childTypes())
				if(!child.overrides(this))
					worklist.push(child);
		}
		return result;
	}
	
	syn lazy boolean TypeDecl.overrides(MethodDecl md) {
    	for(Iterator<MethodDecl> iter=localMethodsSignature(md.signature()).iterator(); iter.hasNext();)
			if(iter.next().overrides(md))
				return true;
		return false;
	}
	
	syn boolean MethodDecl.canBeAbstract() = !(isStatic() || isPrivate() || isFinal());
	
	// descendantMethods: inverse of ancestorMethods
	syn lazy Collection<MethodDecl> TypeDecl.descendantMethods(String sig) = Collections.EMPTY_SET;
	
	eq ClassDecl.descendantMethods(String sig) {
		Collection<MethodDecl> desc = new HashSet<MethodDecl>();
		for(TypeDecl td : childTypes()) {
			boolean found = false;
			for(Iterator<MethodDecl> iter = td.localMethodsSignature(sig).iterator(); iter.hasNext();) {
				MethodDecl md = iter.next();
				if(!md.isPrivate()) {
					desc.add(md);
					found = true;
				}
			}
			if(!found)
				desc.addAll(td.descendantMethods(sig));
		}
		return desc;
	}
	
	// rootdefs
	syn lazy LinkedList<MethodDecl> MethodDecl.rootdefs() = rootdefs(new LinkedList<MethodDecl>());
	
	public LinkedList<MethodDecl> MethodDecl.rootdefs(LinkedList<MethodDecl> res) {
		if(isPrivate() || isStatic())
			return res;
		SimpleSet ancs = hostType().ancestorMethods(signature());
		if(ancs.isEmpty()) {
			res.add(this);
			return res;
		}
		for(Iterator iter=ancs.iterator();iter.hasNext();)
			((MethodDecl)iter.next()).rootdefs(res);
		return res;
	}
	
	// relatives: all (reflexive, transitive) descendants of rootdefs
	syn lazy LinkedList<MethodDecl> MethodDecl.relatives() {
		LinkedList<MethodDecl> res = new LinkedList<MethodDecl>();
		if(isPrivate() || isStatic()) {
			res.add(this);
		} else {
			for(MethodDecl md : rootdefs())
				md.hostType().descStar(signature(), res, !isPublic() && !isProtected());
		}
		return res;
	}

	public void TypeDecl.descStar(String sig, LinkedList<MethodDecl> res, boolean isPkg) {
		for(Iterator<MethodDecl> iter = localMethodsSignature(sig).iterator(); iter.hasNext();)
			res.add(iter.next());
		for(TypeDecl child : childTypes()) {
			if(!isPkg || this.packageName().equals(child.packageName()))
				child.descStar(sig, res, isPkg);
		}
	}
}
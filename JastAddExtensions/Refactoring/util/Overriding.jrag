aspect Overriding {
	syn lazy boolean MethodDecl.canOverrideOrHide(MethodDecl md) {
		// this code is copy-n-pasted from TypeHierarchyCheck.jrag sans error messages
		if(!isStatic() && !md.isPrivate() && 
				md.accessibleFrom(hostType()) && hostType().instanceOf(md.hostType())) {
			if(md.isStatic())
				return false;
			if(!mayOverrideReturn(md))
				return false;
			for(int i = 0; i < getNumException(); i++) {
				Access e = getException(i);
				boolean found = false;
				for(int j = 0; !found && j < md.getNumException(); j++) {
					if(e.type().instanceOf(md.getException(j).type()))
						found = true;
				}
				if(!found && e.type().isUncheckedException())
					return false;
			}
			if(md.isPublic() && !isPublic() ||
		       md.isProtected() && !(isPublic() || isProtected()) ||
		       !md.isPrivate() && !md.isProtected() && !md.isPublic() && isPrivate())
				return false;
			if(md.isFinal())
				return false;
		} else if(isStatic() && !md.isPrivate() && 
				md.accessibleFrom(hostType()) && hostType().instanceOf(md.hostType())) {
			if(!md.isStatic())
				return false;
			if(type() != md.type())
				return false;
			for(int i = 0; i < getNumException(); i++) {
				Access e = getException(i);
				boolean found = false;
				for(int j = 0; !found && j < md.getNumException(); j++) {
					if(e.type().instanceOf(md.getException(j).type()))
						found = true;
				}
				if(!found)
					return false;
			}
			if(md.isPublic() && !isPublic() ||
			   md.isProtected() && !(isPublic() || isProtected()) ||
			   !md.isPrivate() && !md.isProtected() && !md.isPublic() && isPrivate())
				return false;
			if(md.isFinal())
				return false;
		}
		return true;
	}

	// collect all method declarations overriding a given method declaration
	coll HashSet<MethodDecl> MethodDecl.coll_overriders() [new HashSet<MethodDecl>()] with add root Program;
	MethodDecl contributes this to MethodDecl.coll_overriders() for each overrides();
	
	/* Problem with generics for overriders/overrides:
	 * 
	 * overrides returns MethodDeclSubstituted, so overriders from source class from param superclass don't work
	 * as expected
	 * 
	 */
	
	public HashSet<MethodDecl> MethodDecl.overriders() {
		if(this.isFinal() || this.isPrivate() || this.isStatic())
			return new HashSet<MethodDecl>();
		return coll_overriders();
	}
	
	// get all method declarations overridden by a given method declaration
	syn lazy HashSet<MethodDecl> MethodDecl.overrides() {
		HashSet<MethodDecl> ret = new HashSet<MethodDecl>();
		if(this.isPrivate() || this.isStatic())
			return ret;
		for(Iterator<MethodDecl> iter=possiblyOverriddenAncestors().iterator();
			iter.hasNext();) {
			MethodDecl md = iter.next();
			if(overrides(md))
				ret.add(md);
		}
		return ret;
	}
	
	// get all method declaration hidden by a given method declaration
	syn lazy HashSet<MethodDecl> MethodDecl.hiddenMethods() {
		HashSet<MethodDecl> ret = new HashSet<MethodDecl>();
		if(!this.isStatic())
			return ret;
		for(Iterator<MethodDecl> iter=possiblyOverriddenAncestors().iterator();
			iter.hasNext();) {
			MethodDecl md = iter.next();
			if(hides(md))
				ret.add(md);
		}
		return ret;		
	}
	
	public HashSet<MethodDecl> MethodDecl.possiblyOverriddenAncestors() {
		return hostType().possiblyOverriddenAncestors(signature());
	}
	
	syn HashSet<MethodDecl> TypeDecl.possiblyOverriddenAncestors(String signature) {
		HashSet<MethodDecl> s = new HashSet<MethodDecl>();
		possiblyOverriddenAncestors(s, signature);
		return s;
	}
	
	protected void TypeDecl.possiblyOverriddenAncestors(HashSet<MethodDecl> s, String signature) { }
	
	protected void ClassDecl.possiblyOverriddenAncestors(HashSet<MethodDecl> s, String signature) {
		if (superclass() != null) {
			SimpleSet ss = superclass().localMethodsSignature(signature);
			for (Iterator<MethodDecl> it = ss.iterator(); it.hasNext();) {
				s.add(it.next());
			}
			if (ss.isEmpty()) {
				superclass().possiblyOverriddenAncestors(s, signature);
			}
		}
		
		//methods from interfaces
		int cnt = 0;
		for (Iterator<InterfaceDecl> it = interfacesIterator(); it.hasNext();) {
			InterfaceDecl intf = it.next();
			for (Iterator<MethodDecl> itt = intf.localMethodsSignature(signature).iterator(); itt.hasNext();) {
				s.add(itt.next());
				cnt++;
			}
		}
		if (cnt == 0) {
			for (Iterator<InterfaceDecl> it = interfacesIterator(); it.hasNext();) {
				it.next().possiblyOverriddenAncestors(s, signature);
			}
		}
	}
	
	protected void InterfaceDecl.possiblyOverriddenAncestors(HashSet<MethodDecl> s, String signature) {
		int cnt = 0;
		for (Iterator<InterfaceDecl> it = superinterfacesIterator(); it.hasNext();) {
			InterfaceDecl intf = it.next();
			for (Iterator<MethodDecl> itt = intf.localMethodsSignature(signature).iterator(); itt.hasNext();) {
				s.add(itt.next());
				cnt++;
			}
		}
		if (cnt == 0) {
			for (Iterator<InterfaceDecl> it = superinterfacesIterator(); it.hasNext();) {
				it.next().possiblyOverriddenAncestors(s, signature);
			}
		}
	}
	
	syn lazy Collection<MethodDecl> MethodDecl.rootDefs() {
		if(isPrivate() || isStatic())
			return Collections.singleton(this);
		Collection<MethodDecl> res = new LinkedHashSet<MethodDecl>();
		LinkedList<MethodDecl> worklist = new LinkedList<MethodDecl>();
		worklist.push(this);
		while(!worklist.isEmpty()) {
			MethodDecl md = worklist.pop();
			if(res.contains(md))
				continue;
			if(md.overrides().isEmpty())
				res.add(md);
			worklist.addAll(md.overrides());
		}
		return res;
	}
	
	syn lazy Collection<TypeDecl> TypeDecl.supertypes() = Collections.emptySet();
	eq ClassDecl.supertypes() {
		Collection<TypeDecl> res = new LinkedList<TypeDecl>();
		if(superclass() != null)
			res.add(superclass());
		for(Iterator<InterfaceDecl> iter = interfacesIterator(); iter.hasNext();)
			res.add(iter.next());
		return res;
	}
	eq InterfaceDecl.supertypes() {
		Collection<TypeDecl> res = new LinkedList<TypeDecl>();
		for(Iterator<InterfaceDecl> iter = superinterfacesIterator(); iter.hasNext();)
			res.add(iter.next());
		return res;		
	}
	
	syn lazy Collection<FieldDeclaration> FieldDeclaration.hiddenFields() {
		Collection<FieldDeclaration> res = new LinkedHashSet<FieldDeclaration>();
		for(TypeDecl std : hostType().supertypes()) {
			for(Iterator<FieldDeclaration> iter=std.memberFields(name()).iterator();iter.hasNext();) {
				FieldDeclaration that = iter.next();
				if(that.accessibleFrom(hostType()))
					res.add(that);
			}
		}
		return res;
	}
}
This provides a description of the JastAdd module system.

\subsection{Module System Overview}

A module consists of aspects and classes, and defines the set of external
modules that are visible to the module's members. The module system is based
on the object-oriented java module system presented in \cite{modulesastypes}.

A module is considered to be the type of the collection of classes and aspects
that belong to it. The module system allows the instantiation these module types
within the context of an importing module, defines a subtyping relation
on module types, and a merge operation to manipulate module instances.

The remainder of this section goes into the details of the module system, and shows
how it can be used as a solution to the 

\subsection{Declaration and Membership}

A module is defined in a \texttt{.module} file, and is headed by the module's name:

\begin{lstlisting}[caption={Module Declaration}]
//file prettyprinter.module
module prettyprinter;
...
\end{lstlisting}

Membership to a module is defined in the compilation unit of the members,
similar to a package declaration:

\begin{lstlisting}[caption={Module Membership}]
//file PrettyPrinter.jrag
module prettyprinter; //module membership
public aspect PrettyPrinter {
	public abstract String Expr.prettyPrint();
	
	public String Add.prettyPrint() {
		return getLeft().prettyPrint() + 
				"+" + getRight().prettyPrint();
	}
	
	public String IntLit.prettyPrint() {
		return getIntLit().toString();
	}
}

//file Expr.java
module asttypes; //module membership
package expr; //package declaration
public class Expr {
...
}
\end{lstlisting}

Module and package declarations can coexist in a single compilation unit.
Modules can contain aspects and classes that span multiple packages.

\subsection{Module Access Control}

Packages are not implicitly visible outside the module unless an
\texttt{export} declaration is provided for that package. These declarations
are placed in \texttt{.module} files.

\begin{lstlisting}[caption={Export Package}]
//file asttypes.module
module asttypes;
export package expr, stmt; //export expr and stmt
...

//file prettyprinter.module
module prettyprinter;
export package *; //export all packages
...
\end{lstlisting}

As the example shows, an export package may contain a list of packages, or the
wildcard \texttt{*}, which exposes all packages in the module. Any types that
belong to a package that is not exported are not visible from outside the module.

The module system also introduces the module-private access modifier \textbf{module},
which allows access to a type, method or field from the within the same module. This
allows more fine-grained control over the set of publicly accessible types of a module.

\begin{lstlisting}
//file Expr.java
module asttypes;
//only visible from module asttypes
module class Expr {
	//only visible from module asttypes
	module int moduleField;
	module void moduleMethod() {...}
}
\end{lstlisting}

\subsection{Imports and Instantiation}

Module definitions also contain import declarations, which specify which
other modules are visible to the members of the module. A module imports 
an \textit{instance} of another module, which allows multiple instances
of the same module to exist within a single context.

There are two ways to import a module instance: importing the singleton or
an \textbf{own} instance. Imports may also be alised to allow multiple instances
of the same module to exist in the same context, and be exported so that
they are also accessible through indirection from other modules;

\begin{lstlisting}[caption={Imports}, label={figure:imports}]
//file prettyprinter.module
module prettyprinter;
//import the singleton instance of module parserframework
import parserframework; 
//import an own instance of the module asttypes
import own asttype;
//import another instance of asttype, using an alias and export
import own asttype export as public_ast;
\end{lstlisting}

Imports of \textbf{own} instances without an explicit alias use the name
of the imported module as its alias. To be more specific, line 6 from the above
example is equivalent to
\begin{lstlisting}
import own asttype as asttype;
\end{lstlisting}

Import cycles involving \textbf{own} instances are not allowed as they
lead to infinite module instance creation. Import cycles involving only
singleton instances, however, are allowed.

An aspect can only introduce ITDs to types that are visible from its parent module. 
This allows the use of module imports and access modifiers to control dependencies
caused by ITDs.

Importing the singleton module allows different module to share the same instance
of the same module type. This allows the sharing of classes across modules, as
classes that belong to different instances of a module are not type compatible.
In the presence of the \textbf{merge} operator (described later), a singleton import
also ensures that the imported module is an unmodified version of the base module type.

The visibility of imported modules become important for module qualifiers and the \textbf{merge} operation, described later.

\subsection{Module Qualified Type Accesses}

Allowing two instances of the same module to exist in the same context
requires a way to disambiguate references to the members of the instances.
We introduce \textit{module qualifiers} for type references to explicitly
choose the module to which the type belongs.

A module qualified type access takes this form:

\begin{lstlisting}
modulealias::packagename.TypeName
\end{lstlisting}

The following example uses the module definition from listing \ref{figure:imports}.
The module \texttt{prettyprinter} imports two instances of \texttt{asttype}, with the
aliases \texttt{asttype} and \texttt{public\_ast}. The aspect \texttt{PrettyPrinter},
which belongs to the module, introduces ITDs to each of the \texttt{Add} types
of the instances.

\begin{lstlisting}[caption={Module Qualfiers}]
//file PrettyPrinter.jrag
module prettyprinter;
aspect PrettyPrinter {
	...
	//modifies the Add type in asttypes
	public String asttypes::Add.prettyPrint() {
		//infix print
		return getLeft().prettyPrint() + "+" + 
				getRight().prettyPrint();
	}
	...
	//modifies the Add type in public_ast
	public String public_ast::Add.prettyPrint() {
		//postfix print
		return getLeft().prettyPrint() + 
				getRight().prettyPrint() + "+";
	}
}
\end{lstlisting}

Module qualifiers also allow for indirection. A module can be accessed 
through its importing module if it was exported. A type access
that uses module indirection takes the form:

\begin{lstlisting}
modulealias1::modulealias2::packagename.TypeName
\end{lstlisting}

The following example
shows a small system consisting of the modules \texttt{scanner}, 
\texttt{parser} and \texttt{parserapp}. The parser module imports
the scanner module, and the parser application module imports the
parser. The parser application module then adds an ITD to the classes
\texttt{Scanner} and \texttt{Parser}, which are members of the scanner
and parser modules respectively. The import statements in the 
\texttt{ParserApp.jrag} file in the example are normal java import
statements, to demonstrate that module qualifiers are also allowed
for that language construct.

\begin{lstlisting}
//file scanner.module
module scanner;
export package *;
...

//file parser.module
module parser;
//allow access to imported scanner
import own scanner export as scanner;
export package *;
...

//file parserapp.module
module parserapp;
import own parser;
...

//file ParserApp.jrag
module parserapp;
//module qualifiers are also supported in normal
//java import statements
//from the direct import parser
import parser::Parser;
//indirect through parser to get scanner
import parser::scanner::Scanner;

aspect ParserApp {
	//add an ITD to the direct import parser
	private App Parser.parentApp;
	public void Parser.setParentApp(App app) {...}
	//add an ITD to the indirect import scanner
	private App Scanner.parentApp;
	public void Scanner.setParentApp(App app) {...}
}
\end{lstlisting}

\subsection{Extension}

THe module system in \cite{modulesastypes} introduced the concept of
module extension and class overriding, where a class in a subtype module
overrides a class of the same name in the supertype module to satisfy the 
open/closed principle for modules.

A subtype module declaration takes the form
\begin{lstlisting}
module m2 extends m1;
\end{lstlisting}
where \texttt{m1} is another module in the compilation. The subtype module
inherits all the aspects and classes of the supertype module, and can override
them as well by declaring an aspect or class with the same package and type name.
As with the module system in \cite{modulesastypes}, a subtype module also inherits
the imports and export package declarations of its supertype module.

The usual rules for Java inheritance also apply for module subtyping: single 
inheritance only, and no subtyping cycles.

We extend this to aspects and ITDs, specifying that an aspect in a subtype module
overrides an aspect of the same name in the supertype module. This effectively
replaces all ITDs in the overriden module.

In the following example, we have two parser modules \texttt{parserv1} and \texttt{parserv2},
with the latter being a subtype of the former. The module \texttt{parserv2} inherits
the class \texttt{Program}, which overriding the aspect \texttt{ParseClassFile}. The
application module can then use instances of both modules, with the ITD \texttt{Program.parseClassFile}
being appropriately different for each version.

\begin{lstlisting}
//file parserv1.module
module parserv1;
...

//file Program.java
//base class, inherited by parserv2
module parserv1;
public class Program {...}

//file ParserClassFilev1.jrag
//version 1 parser
module parserv1;
aspect ParseClassFile {
	public void Program.parseClassFile(String file) {...}
}

//file parserv2.module
module parserv2 extends parserv1;
...

//file ParserClassFilev2.jrag
module parserv2;
//has the same name as parserv1::ParseClassFile, 
//overrides that aspect when parserv2 is instantiated
aspect ParseClassFile {
	public void Program.parserClassFile(String file) {...}
}

//file multiversion.module
//a multi-version parser that supports both versions
module multiversion;
import own parserv1;
import own parserv2;
...

//file MultiVersion.java
module multiversion;
public class MultiVersion {
	...
	//version1 parser
	parserv1::Program progv1 = ...;
	//version2 parser
	parserv2::Program progv2 = ...;
	
	//parse depending on version
	void parseClassFile(String file) {
		if (version1) {
		  //this invokes the ITD method introduced in parserv1
			progv1.parseClassFile(file)
		} else if (version2) {
			//while this invokes the parserv2 ITD method
			progv2.parseClassFile(file)
		}
	}
}
\end{lstlisting}

It should be noted that even though the class \texttt{Program}
is inherited by \texttt{parserv2}, the type
\texttt{parserv2::Program} is different from \texttt{parserv1::Program}. Moreover,
these two types are not type compatible.

\subsection{Merge}

Types that belong to different module instances, even if they have the same
base module type, are not type compatible. Though type sharing can be done
in a using singleton instances, this is limited in its usefulness, as the singleton
instance may have imported \textbf{own} instances of another module that you wish to
share.

For these circumstances the module system provides the \textbf{merge} operation,
which 




\subsection{ITD Calculator with Modules}

\subsection{Evaluation}


This provides a description of the JastAdd module system.

\subsection{Module System Overview}

A module consists of aspects and classes, and defines the set of external
modules that are visible to the module's members. The module system is based
on the object-oriented java module system presented in \cite{modulesastypes}.

A module is considered to be the type of the collection of classes and aspects
that belong to it. The module system allows the instantiation these module types
within the context of an importing module, defines a subtyping relation
on module types, and a merge operation to manipulate module instances.

The remainder of this section goes into the details of the module system, and shows
how it can be used as a solution to the 

\subsection{Declaration and Membership}

A module is defined in a \texttt{.module} file, and is headed by the module's name:

\begin{lstlisting}[caption={Module Declaration}]
//file prettyprinter.module
module prettyprinter;
...
\end{lstlisting}

Membership to a module is defined in the compilation unit of the members,
similar to a package declaration:

\begin{lstlisting}[caption={Module Membership}]
//file PrettyPrinter.jrag
module prettyprinter; //module membership
public aspect PrettyPrinter {
	public abstract String Expr.prettyPrint();
	
	public String Add.prettyPrint() {
		return getLeft().prettyPrint() + 
				"+" + getRight().prettyPrint();
	}
	
	public String IntLit.prettyPrint() {
		return getIntLit().toString();
	}
}

//file Expr.java
module asttypes; //module membership
package expr; //package declaration
public class Expr {
...
}
\end{lstlisting}

Module and package declarations can coexist in a single compilation unit.
Modules can contain aspects and classes that span multiple packages.

\subsection{Module Access Control}

Packages are also not implicitly visible outside the module unless an
\texttt{export} declaration is provided for that package. These declarations
are placed in \texttt{.module} files.

\begin{lstlisting}[caption={Export Package}]
//file asttypes.module
module asttypes;
export package expr, stmt; //export expr and stmt
...

//file prettyprinter.module
module prettyprinter;
export package *; //export all packages
...
\end{lstlisting}

As the example shows, an export package may contain a list of packages, or the
wildcard \texttt{*}, which exposes all packages in the module. Any types that
belong to a package that is not exported are not visible from outside the module.

The module system also introduces the module-private access modifier \textbf{module},
which allows access to a type, method or field from the within the same module. This
allows more fine-grained control over the set of publicly accessible types of a module.

\begin{lstlisting}
//file Expr.java
module asttypes;
//only visible from module asttypes
module class Expr {
	//only visible from module asttypes
	module int moduleField;
	module void moduleMethod() {...}
}
\end{lstlisting}

\subsection{Imports and Instantiation}

Module definitions also contain import declarations, which specify which
other modules are visible to the members of the module. A module imports 
an \textit{instance} of another module, which allows multiple instances
of the same module to exist within a single context.

There are two ways to import a module instance: importing the singleton or
an \textbf{own} instance. Imports may also be alised to allow multiple instances
of the same module to exist in the same context, and be exported so that
they are also accessible through indirection from other modules;

\begin{lstlisting}[caption={Imports}, label={figure:imports}]
//file prettyprinter.module
module prettyprinter;
//import the singleton instance of module parserframework
import parserframework; 
//import an own instance of the module asttypes
import own asttype;
//import another instance of asttype, using an alias and export
import own asttype export as public_ast;
\end{lstlisting}

Imports of \textbf{own} instances without an explicit alias use the name
of the imported module as its alias. To be more specific, line 6 from the above
example is equivalent to
\begin{lstlisting}
import own asttype as asttype;
\end{lstlisting}

An aspect can only introduce ITDs to types that are visible from its parent module. 
This allows the use of module imports and access modifiers to control dependencies
caused by ITDs.

Importing the singleton module allows different module to share the same instance
of the same module type. This allows the sharing of classes across modules, as
classes that belong to different instances of a module are not type compatible.
In the presence of the \textbf{merge} operator (described later), a singleton import
also ensures that the imported module is an unmodified version of the base module type.

The visibility of imported modules become important for module qualifiers and the \textbf{merge} operation, described later.

\subsection{Lookup}

Allowing two instances of the same module to exist in the same context
requires a way to disambiguate references to the members of the instances.
We introduce \textit{module qualifiers} for type references to explicitly
choose the module to which the type belongs.

A module qualified type access takes this form:

\begin{lstlisting}
modulealias::packagename.TypeName
\end{lstlisting}

The following example uses the module definition from listing \ref{figure:imports}.
The module \texttt{prettyprinter} imports two instances of \texttt{asttype}, with the
aliases \texttt{asttype} and \texttt{public\_ast}. The aspect \texttt{PrettyPrinter},
which belongs to the module, introduces ITDs to each of the \texttt{Add} types
of the instances.

\begin{lstlisting}[caption={Module Qualfiers}]
//file PrettyPrinter.jrag
module prettyprinter;
aspect PrettyPrinter {
	...
	//modifies the Add type in asttypes
	public String asttypes::Add.prettyPrint() {
		//infix print
		return getLeft().prettyPrint() + "+" + 
				getRight().prettyPrint();
	}
	...
	//modifies the Add type in public_ast
	public String public_ast::Add.prettyPrint() {
		//postfix print
		return getLeft().prettyPrint() + 
				getRight().prettyPrint() + "+";
	}
}
\end{lstlisting}

Module qualifiers also allow for indirection. A module can be accessed 
through its importing module if it was exported. A type access
that uses module indirection takes the form:

\begin{lstlisting}
modulealias1::modulealias2::packagename.TypeName
\end{lstlisting}

The following example
shows a small system consisting of the modules \textbf{scanner}, 
\textbf{parser} and \textbf{parserapp}. The parser module imports
the scanner module, and the parser application module imports the
parser. The parser application module then adds an ITD to the classes
\textbf{Scanner} and \textbf{Parser}, which are members of the scanner
and parser modules respectively. The import statements in the 
\texttt{ParserApp.jrag} file in the example are normal java import
statements, to demonstrate that module qualifiers are also allowed
for that language construct.

\begin{lstlisting}
//file scanner.module
module scanner;
export package *;
...

//file parser.module
module parser;
//allow access to imported scanner
import own scanner export as scanner;
export package *;
...

//file parserapp.module
module parserapp;
import own parser;
...

//file ParserApp.jrag
module parserapp;
//module qualifiers are also supported in normal
//java import statements
//from the direct import parser
import parser::Parser;
//indirect through parser to get scanner
import parser::scanner::Scanner;

aspect ParserApp {
	//add an ITD to the direct import parser
	public void Parser.setParentApp(App app) {...}
	//add an ITD to the indirect import scanner
	public void Scanner.setParentApp(App app) {...}
}
\end{lstlisting}

\subsection{Extension}

\subsection{Merge}

Types that belong to different module instances, even if they have the same
base module type, are not type compatible. Though type sharing can be done
in a using singleton instances, 




\subsection{ITD Calculator with Modules}

\subsection{Evaluation}


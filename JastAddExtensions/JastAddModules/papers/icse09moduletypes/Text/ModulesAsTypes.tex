%------------------------------------------------------------------------- 

As the previous section shows, while the problem of Java modules have been
well studied and multiple solutions exist for different aspects of the problem,
there are still remaining issues such as split packages, versioning constraints 
and extension that remain. We propose that these can be solved by
defining a type system on modules, which will model the current usage
of modules while allowing for the expression of constraints and relations
that were previously not possible.

We now non-formally define a type system over collections of classes. 
A module is a collection of classes, and we consider it to be the type of 
the collection of classes that belong to it. We then proceed to define
relations and operations on modules and, in a later section, show how
these model current module usage. Most of the examples are abridged versions 
taken from the Jhotdraw case study, which is available at INSERT WEBSITE HERE.

\SubSection{Declaration and Membership}

Modules are defined in a {\tt .module} file that begins with a module
declaration:

\begin{lstlisting}
//File org.jhotdraw.module
module org.jhotdraw; ...
\end{lstlisting}

Module membership is declared using syntax that was proposed 
for JSR 294 \cite{superpackageChange}. Membership of a compilation unit is 
declared by adding a module declaration. If a package declaration is present, 
the package name is used as the package name of the file within the module.

\begin{lstlisting}
//File Gradient.java
module org.jhotdraw;
package org.jhotdraw.samples.svg;
public interface Gradient extends Cloneable { ... }
\end{lstlisting}

Split packages cause hard to find problems in current module systems\cite{iJAMComments}. To avoid this, 
a way to specify package membership in a module allowed by declaring the module membership
in the {\tt package-info.java} file of that package.

\begin{lstlisting}
//File org/jhotdraw/app/action/package-info.java
//all classes in package org.jhotdraw.app.action also
//belong to module org.x.y.mymodule
module org.jhotdraw;
package org.jhotdraw.app.action;
\end{lstlisting}

If the module membership specified in a compilation unit's {\tt package-info.java}
file is in conflict with that specified in the file itself, the membership
declared in the file takes precedence, but a warning is issued to flag a possibly
split package.

%------------------------------------------------------------------------- 
\SubSection{Imports}

For a module to be able to access any of another module's classes,
it must first import an instance of that module. This way, imports form
a hard constraint on the visibility of classes.

There are two ways to import a module. The first is to import the singleton
instance of the module. This is done in the following manner:

\begin{lstlisting}
//imports the singleton instance
import org.jhotdraw;
\end{lstlisting}

Importing the singleton instance of a module allows you to share the classes
of that module with other modules that also import it.

Similar to iJAM \cite{iJAM}, a module may also import its \textbf{own} instance of
a module. It is also allowed to rename that instance to allow for multiple
instances of the same module to exist in the same context.

\begin{lstlisting}
//imports an own instance
import own org.jhotdraw;
//imports on own instance with an alias
import own org.jhotdraw as jhotdraw;
\end{lstlisting}

Unlike iJAM, renaming an instance does not implicitly allow other
modules to access that instance. To allow access to other modules, the import
must be exported:

\begin{lstlisting}
//imports an own instance, and makes it available to
//other modules
import own org.jhotdraw export as jhotdraw;
\end{lstlisting}

An import declaration creates a typed module reference that points to the module
instance specified. The type of the reference created is the module
in the import declaration. The module reference can later be pointed to another
instance using the operations \textbf{replace} and \textbf{merge} described
in the following sections.

The visibility of the module instances become important for module
qualified name lookups and the merge and replace operations described in later
sections.

\SubSection{Exported packages}

We allow exported packages similar to {\tt export-package} in OSGi bundles. Unlike OSGi, however,
exporting a package does not automatically allow other modules to gain
access to these packages. A module A must first import another module B
before gaining access to B's exported packages.

Exported packages are declared in the {\tt .module} file:

\begin{lstlisting}
module org.apache.batik1_6;
//allow other modules to access this package
export package 
	org.apache.batik.ext.awt.image,
	org.apache.batik.ext.awt,
	org.apache.batik;
\end{lstlisting}

You may also export all the packages that belong to a module by using
the * wildcard. This is the only way to export classes that belong to
the default package in a module.

\begin{lstlisting}
module org.jhotdraw;
...
//export all packages
export package *;
\end{lstlisting}

%We also allow the \textbf{module} access modifier proposed for JSR294 \cite{JSR294}
%which applies to classes, fields and methods. Module private access only allows
%accesses from classes that belong to the same module.

%\begin{lstlisting}
%module org.x.y; //module membership
%module class C { //only visible in org.x.y
%	public void publicMethod() {...};
%	module void moduleMethod() {...}; //same here
%}
%\end{lstlisting}

\SubSection{Module Qualified Type References}

Type references can now be qualified with module names to explicitly
identify the module that contains the class. Module qualifiers
are separated from package and type names by the \texttt{::} separator,
and also allows for indirection. For example, given the following module:

\begin{lstlisting}
module org.jhotdraw;
import own net.n3.nanoxml export as nanoxml;
import own org.apache.batik export as batik;
export package *;
\end{lstlisting}

The class \texttt{org.jhotdraw.Version} in the module \texttt{org.jhotdraw}
can be accessed as
\begin{lstlisting}
org.jhotdraw::org.jhotdraw.Version
\end{lstlisting}
Classes in \texttt{nanoxml} and \texttt{batik} can be accessed by indirection:
\begin{lstlisting}
org.jhotdraw::nanoxml::net.n3.nanoxml.Version
org.jhotdraw::batik::org.apache.batik.Version
\end{lstlisting}

In this example, a sample application Simple with the module \texttt{org.jhotdraw.samples.simple}
uses the Jhotdraw framework by importing its own instance of the module
\texttt{org.jhotdraw}. The module \texttt{org.jhotdraw} itself uses the 
two libraries \texttt{net.n3.nanoxml} and \texttt{org.apache.batik}, and
exports them so that other modules can also access their classes. The 
application then gets the versions of JHotdraw and its dependencies.

\begin{lstlisting}[caption=Module Qualified Type References,numbers=left]
//File org.jhotdraw.module
module org.jhotdraw;
import own net.n3.nanoxml export as nanoxml;
import own org.apache.batik export as batik;
export package *;

//File org.apache.batik.module
module org.apache.batik;
export package 
	org.apache.batik.ext.awt.image,
	org.apache.batik.ext.awt,
	org.apache.batik;

//File net.n3.nanoxml
module net.n3.nanoxml;
export package net.n3.nanoxml;

//File org.jhotdraw.samples.simple.module
module org.jhotdraw.samples.simple;
//import own instance of jhotdraw
import own org.jhotdraw export as jhotdraw;
export package *;

//File Main.java
//classes in this file belong to this module
module org.jhotdraw.samples.simple;
package org.jhotdraw.samples.simple;
//on-demand import of indirect import
//accesses jhotdraw's batik import
import jhotdraw::batik::org.apache.batik.*;

public class Main {
	//direct imports don't need a qualifier
	String jhotdrawVersion = 
		org.jhotdraw.Version.version;
	//module qualified type name
	String nanoXMLVersion = 
		jhotdraw::nanoxml::net.n3.nanoxml.Version.version;
	//from the on-demand import
	String batikVersion = Version.version;
}
\end{lstlisting}

The class \texttt{org.jhotdraw.Version} can be accessed without
a module qualifier since it is a member of the JHotdraw module, 
which is directly imported by the application Simple. To access
the versions of JHotdraw's dependencies, the type names have to
be qualified with the module qualifier that denotes their parent
module. As \texttt{net.n3.nanoxml.Version} is not a direct import,
it needs to be qualified with \texttt{jhotdraw::nanoxml::}, which
points to the \texttt{nanoxml} import of JHotdraw. The same is
true for \texttt{org.apache.batik.Version}, and as the example shows,
the module qualified names can also be used in import declarations.

The module qualifiers are relative and are looked up in the context 
of the module that contains them. This is necessary to maintain

Types that do not belong to a module are considered to be members of
the ``default'' module. This module has a blank name, and its singleton
instance is implicitly imported by all modules. So, a module-less
type {\tt javax.swing.Action} can be accessed in this way:

\begin{lstlisting}[caption=Default Module Lookups]
module somemodule;
package mypackage;
//import from the default module
import ::javax.swing.Action;
class MyClass {
	Action a = new Action(){...};
}
\end{lstlisting}

It is not strictly necessary to always module qualify accesses to types in
the default module, as long as there are no classes in the current module
or its imported modules that have the same package and type name. However,
if these do exist, it is necessary to use the module qualified name to access
these classes to avoid an ambiguous type error.

%------------------------------------------------------------------------ 
\SubSection{Subtyping}

We now define a subtyping relation on the module type. A module is declared
to be the subtype of another module by using the \textbf{extends} keyword:

\begin{lstlisting}
module defaultsample.defaultjhotdraw 
	extends org.jhotdraw;
\end{lstlisting}

A subtype module inherits all the import declarations and export package declarations 
of its parent module, and can add some more of its own. It also inherits the member 
compilation units (and the types therein) of its supertype.

If a subtype module contains a type with the identical package and type name
to another type which is a member of its supertype module, 
this shadows the type in the supertype module for all type references that
originate from the subtype module, and any other modules that import an
instance of the subtype module.

The following example demonstrates module subtyping and shadowing. The module
\texttt{defaultsample.defaultjhotdraw} extends the module \texttt{org.jhotdraw}. 
It also contains the class \texttt{org.jhotdraw.app.action.AboutAction},
which overrides a class with the same package and name in the supertype module.
The new \texttt{AboutAction} extends the version in the supertype module and
changes the message of the about dialog.

\begin{lstlisting}[caption=Module Subtyping]
//file defaultsample.defaultjhotdraw.module 
module defaultsample.defaultjhotdraw 
	extends org.jhotdraw;
//the batik and nanoxml imports are 
//inherited from org.jhotdraw
export package *;

//file org/jhotdraw/app/action/AboutAction.java
module org.jhotdraw;
package org.jhotdraw.app.action;
//this class will be overriden
public class AboutAction extends AbstractApplicationAction {
	...
	public void actionPerformed(ActionEvent evt) {
		...
		JOptionPane.showMessageDialog(...);
	}
}

//file defaultjhotdraw/app/action/AboutAction.java
module defaultsample.defaultjhotdraw;
package org.jhotdraw.app.action;

import batik::org.apache.batik.Version;
//This class shadows the class
//jhotdraw::org.jhotdraw.app.action.AboutAction
public class AboutAction 
	extends 
	supermodule::org.jhotdraw.app.action.AboutAction {
	...
	public void actionPerformed(ActionEvent evt) {
		...
		//add batik version to about message
		JOptionPane.showMessageDialog(...
			+ "Batik version " + Version.version,
			...);
	}
}

\end{lstlisting}

As the example shows, the overriding \texttt{AboutAction} class extends the
overriden class in the supertype module by using the special 
\texttt{supermodule::} module qualifier to access the overriden class. It
then redefines the only method required to change the behavior as required.
All lookups for the class \texttt{AboutAction} now resolve to the overriding
class, including those in the classes that belong to the supertype module.

Without module subtyping, changing \texttt{AboutAction} without access to the source
would require extending the class and reimplementing the method 
that instantiates it. Module extension allows the same extension without
any reimplementation except for the code that actually changes the behavior of the overriden class.
In cases such as that above, extension using module subtyping could result in savings in
terms of reimplemented framework code by moving extension and
composition to the higher level of abstraction provided by the module.

%------------------------------------------------------------------------- 
\SubSection{Overrides}

Subtyping allows extension or patching of a module without actually
rebuilding a completely new module. However, it does have the disadvantage
of being dependent on the existence of its supertype modules. To get
around this limitation, we define the \textbf{overrides} relation to allow
a module to completely replace another module. A module is declared
to override another using the \textbf{overrides} keyword:

\begin{lstlisting}
module org.apache.batik1_8pre 
	overrides org.apache.batik1_6, org.apache.batik1_7;
\end{lstlisting}

Unlike subtyping, an overriding module does not inherit anything from the
modules it overrides. However, it \textit{must} provide the same exported modules
and packages as its overridden modules to satisfy the external 
clients of these modules.

As is expected, override is inherited by subtype modules. This allows a subtype
of an overriding module to override the same modules as its supertype.

Declaring an overriding module does not automatically change over all references
to the overridden module to use the overriding module. This is done using the
\textbf{replace} operation described in the section below, which also contains
an example of the use of \textbf{overrides}.

%------------------------------------------------------------------------- 
\SubSection{Replace}

While merges can be used to re-bind module references, they are only applicable 
for modules that are subtypes of each other. As overriding modules are not
necessarily subtypes of the modules they override, we introduce the \textbf{replace} operation
to substitute overriding modules for overridden modules. The replace operation
takes a set of target module references to rebind, and the module reference pointing to the 
instance to which the targets are to be bound:

\begin{lstlisting}
replace m1,m2,m3 with m4;
\end{lstlisting}

The replace operation
changes the binding of module references to point to an existing
module instance. A module may replace another if its type is the same or a subtype
of that module, or if its type overrides that of the other.

Continuing the parser example given in the subtyping section above, say we have two 
modules, {\tt staticanalyzer} and {\tt javadocgenerator}, each using {\tt parserv1\_1}
and {\tt parserv1\_2} respectively. We now wish to create a new module that uses these, 
but updates them to {\tt parserv2}, which overrides both {\tt parserv1\_1} and {\tt parserv1\_2}.

\begin{lstlisting}[caption=Module Replace]
//file staticanalyzer.module
module staticanalyzer;
import own parserv1_1 export as parser;
...

//file javadocgenerator.module
module javadocgenerator;
import own parserv1_2 export as parser;
...

//file parserv2.module
module parserv2 
	overrides parserv1_1, parserv1_2;
...

//file myapplication.module
module myapplication;
import own staticanalyzer;
import own javadocgenerator;
import own parserv2;
//replace with newer parser
replace 
	staticanalyzer::parser,
	javadocgenerator::parser
	with parserv2;
\end{lstlisting}

Note that even though the modules {\tt parserv1\_1} and {\tt parserv1\_2}
are not present in the build, it is able to compile successfully when the
module references to these missing modules are replaced with the overriding
module {\tt parserv2}.

%Merge and replace make different modules sure to use the same
%set of classes (avoids nondeterministic class loading). Also, can
%be used to update modules to use newer versions of their imported
%modules. They can also be used to access the namespace of indirect imports
%without qualifiers by merging the indirect imports with a directly
%imported instance of that module.


%------------------------------------------------------------------------- 
\SubSection{Merge}

It is often necessary to make sure that two or more modules use the same
instance of a dependency, to ensure that these
modules are able to share types. As an example, say you have two database
backend modules {\tt mysqlbackend} and {\tt postgresbackend} with a method
{\tt runQuery()} that returns a \texttt{ResultSet}. Further suppose that {\tt ResultSet} is
defined in another module {\tt sqltypes}, which is \textbf{own} imported by both backends.
In order for the return types of both backends to be type compatible, the
reference to {\tt sqltypes} in both backends must also point to the same
instance.

To ensure that the {\tt sqltypes} instances in both {\tt mysqlbackend}
and {\tt postgresbackend} point to the same instance, we use the 
\textbf{merge} operation. Merge operations take a set of merge targets,
and an alias to refer to the merged module:

\begin{lstlisting}
merge m1,m2,m3 [export] as alias;
\end{lstlisting}

The merge operation requires that the types
of the modules being merged be the same or that one is an ancestor of
the other in the subtyping relation (i.e. they are all on the same subtype path). 
It then creates a new instance
of the most general type that is still compatible with the types of the
modules being merged, and then points those module references to the new 
merged module. The old module instances are discarded, unless there
are other references to them that are not part of the merge.

\begin{lstlisting}[caption=Merge]
//file mysqlbackend.module
module mysqlbackend;
import own sqltypes export as sqltypes;
//say package query has a class MySQLQuery
export package query;

//file postgresbackend.module
module postgresbackend;
import own sqltypes export as sqltypes;
//say package query has a class PostgresQuery
export package query;

//file sqltypes.module
module sqltypes;
//say package types has a class ResultSet
export package types;

//file myapplication.module
module myapplication;
import own mysqlbackend;
import own postgresbackend;
//merge the sqltypes
merge 
	mysqlbackend::sqltypes, 
	postgresbackend::sqltypes 
export as sqltypes;

//file Main.java
module myapplication;
import mysqlbackend::query.MySQLQuery;
import postgresbackend::query.PostgresQuery;
import types.ResultSet;
public class Main {
	void someMethod(){
		ResultSet s = null;
		//this would not be possible if the sqltypes
		//module instances are different
		if (mysql) {
			s = new MySQLQuery(...).runQuery();
		} else if (postgres) {
			s = new PostgresQuery(...).runQuery();
		}
		...
	}
}
\end{lstlisting}


It must be noted that the merged instance is a direct import of
the module where the merge was declared and, as the example above shows,
can be re-exported. This means that types in the merged module {\tt sqltypes} 
can be accessed in {\tt myapplication} without the need to use module 
qualifiers unless the type reference is ambiguous. As the example above
shows, {\tt ResultSet} was imported without a module qualifier in
{\tt Main.java}.

Merges are also implicitly inherited by subtype modules. The merge sequence for
a module is given by the list of merge sequences of a module's supertypes, starting
from the farthest ancestor. There is no way to exclude a supertype's merges, as
this may reduce the module signature (the set of module references available) of
the supertype module, which could lead to both internal and external clients of
the module breaking.



\SubSection{Module Interfaces}

Extending the object-oriented metaphor, with module types being classes, we 
now define \textit{module interfaces}, which act similarly to interfaces in Java. A module
interface contains no imports, replaces, merges or even member classes, but they
are allowed to have a set of export package declarations. A module implementing
a module interface must contain and export the packages specified in the interface.

\begin{lstlisting}[caption=Module Interfaces]
//file org.x.y.math.module
module org.x.y.math implements 
	org.x.y.calculus,
	org.x.y.matrices;
export package 
	org.x.y.math.calculus,
	org.x.y.math.matrices,
	org.x.y.math.complex;
	
//file org.x.y.calculus.module
module_interface org.x.y.calculus;
export package org.x.y.math.calculus;

//file org.x.y.matrices.module
module_interface org.x.y.matrices;
export package org.x.y.math.matrices;

//file engine3d.module
module engine3d;
import own org.x.y.matrices export as matrices;

//file enginephysics.module
module enginephysics;
import own org.x.y.calculus export as calculus;

//file myapplication.module
module myapplication;
import own engine3d;
import own enginephysics;
import own org.x.y.math;

replace 
	engine3d::matrices, enginephysics::calculus
	with org.x.y.math;
\end{lstlisting}

Rules for module interface subtyping are similar to those of interfaces in Java:
interfaces can only extend interfaces, and they can not implement other
interfaces. 

Since interfaces do not actually contain any classes, they must be replaced
by a non-interface module when compiling a fully working system. This would
have to be relaxed for separate compilation of modules that reference interfaces
to be possible, and this is expounded a bit more in the section on implications.

\SubSection{Weak Module Interfaces}

It may be the case that an application developer knows the packages that
he wishes to use, but the provider of the module that contains these packages 
did not define a module interface that specifically contains those packages. For
this case, we define a \textit{weak module interface}. Weak module interfaces act similarly
to normal module interfaces, except that it is also implicitly implemented
by all modules that satisfy its export package signature \cite{mcdirmid01jiazzi, componentnextgen}, 
even if these modules did not explicitly declare that they implemented the interface.

Continuing the example given above, weak interfaces allow us to define 
our own interfaces to a module without the module provider's knowledge:

\begin{lstlisting}[caption=Weak Interfaces]
//file mymathinterface.module
weak_module_interface mymathinterface;
export package 
	org.x.y.math.calculus, org.x.y.math.complex;

//file myfourier.module
module myfourier;
import own mymathinterface export as math;

//file myapplication.module
module myapplication;
import own myfourier;
import own org.x.y.math;
//replace the interface with an implementing module
replace myfourier::math with org.x.y.math;
\end{lstlisting}

%Type lookup subsection, excised for lack of space
%\input{Text/TypeLookupSubSection}

\SubSection{Constraints on Modules}

Cycles involving \texttt{import own} are not allowed, as this leads to an infinite loop of
module instance creation. However, cycles of singleton imports are allowed.

Subtyping is single inheritance, as in Java. This avoids ambiguous replace and
merge inheritance order in a subtype module.

Merges cannot be done on singleton instances or modules accessed through a
singleton instance. This is to make sure that other clients using the singleton
instance are not affected by the change.

As with merges, replace targets can not be a singleton instance or a module
accessed through a singleton instance, for similar reasons. 

Merges can only be done on subtype modules in the same path to the root module in
the subtype tree. Furthermore, this should not change the module export signature
of the module being subtyped. This is to guarantee that both internal and external
clients of the module can still rely on their module qualified lookups.

Exported packages in non-interface modules imply that there are classes that actually 
belong to that package. Otherwise module interfaces become less useful.

As mentioned, implementing a module interface means exporting the packages the interface
exports. This is to ensure that the signature contract with the clients of
the interface are satisfied.

All references to an interface module must be replaced. Otherwise all lookups through 
that reference will fail as the interface is empty. 
Module systems for Java and similar languages have been designed 
to deal with the shortcomings of the package as a modularity construct
and the deeper problem of JAR hell, that is, the problems caused
by wrong class lookup when there are multiple versions of a library
in the classpath. There are several module systems that exist or are
proposed for Java-like languages \cite{javajars, OSGi4, netassemblies, JSR294, JSR277}
that address these problems, and the design of these systems have
revolved around the premise of a module as a container for classes
and additional metadata to distinguish different versions of a module.

However, the existing module systems still have limitations under 
certain circumstances. Split packages \cite{iJAMComments} occur when 
a package and its classes occur in more than one visible module. This
causes the same ambiguous class lookup problems caused by JAR hell.

While substantial support for version constraints are supported
for a module's clients at the point of import, current module 
systems do not have a way for module providers to specify backward 
compatibility (or lack thereof) in the module specification. 
This information is usually found in release documentation and 
it becomes the responsibility of a module's clients to update 
their applications based on this information. Similarly, a module's 
supported features are not part of the module's metadata, and it 
is up to the module's users, who have limited 
information on the module compared to the module's providers, to 
keep track of these to keep their application's dependencies correct.

Existing module systems also have limited extension capabilities. Extending
a module's functionality without access to its source code usually 
requires predefined extensibility support coded in by the module's 
providers, usually in the form of access to the points of a class' 
instantiation. Without such explicit support, a client's only option
is usually reimplementation of the parts that contain the instantiation, 
and the use of wrapper classes to reuse and extend behavior.

In this paper we present a different approach to module systems, 
by treating modules as types over a set of classes. First we describe 
usage of existing module systems in section \ref{moduleops}. We then non-formally
define a type system that contains relations and operations on module types 
that closely resemble object-oriented types in section \ref{moduleops}. 
In section \ref{eval} we demonstrate that the type
system is able to express existing usage of modules while providing means 
to avoid pitfalls such as split packages. 
Furthermore, we show that the type system also allows for the
definition of constraints and patterns not previously possible, such
as backward compatibility and module extension. The type system
itself is implemented in a compiler made using the JastAdd\cite{jastadd} compiler construction
framework, and is demonstrated on a small case study on JHotdraw 7.1.
A short description of the implementation is included in section \ref{implementation}.
The paper then ends with sections on related work and conclusions.

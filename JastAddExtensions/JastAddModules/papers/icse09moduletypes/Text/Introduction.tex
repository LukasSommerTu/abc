The definition of modules at different levels of abstraction
has always driven the development of programming languages.
The transition from unstructured assembly to structured programming,
and from there to object-oriented programming has shown that
as programs have grown, new modularization structures have
been designed to handle increased program complexity.

In object-oriented programming, the need for modules as separate
entities from classes is well understood \cite{szyperski92import}.
Java$^{TM}$ provides the package as the basic module construct for the language, but
this has fallen short of expectations when composing programs at
the level of components. The package is too small a construct
to contain whole components, and the access control capabilities
of the default Java access modifiers do not provide enough
information hiding at the component level. Packages also do not
support any meta-data such as versions, which has become important
in the current envirnonment of multiple components requiring
specific versions of their dependencies.

Thus several module systems that include classes across multiple 
packages have been developed and are in relatively widespread use 
for Java and similar languages \cite{OSGi4, netassemblies} There are also several
proposals for adding module constructs to the Java language itself
\cite{JSR294, JSR277}.

In this paper we show that though the existing proposals solve
several different problems involved in creating a module system
for Java, there are still some, such as declaring backward
compatibility and disambiguation of classes in the presence of
split packages, that have not been sufficiently addressed in a
satisfactory manner. We then propose a module system that
views modules as types that have object-oriented properties,
and show that this system can model existing operations on modules,
while allowing the expression of constraints and operations that
are not possible with existing module systems.
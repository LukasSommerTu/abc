Typing modules provides a more elegant solution to jar hell, as it removes the dependence
on classpath order and allows disambiguation of multiple visible types with
module qualifiers. In addition, we have shown that the type system can express
constraints such as backward compatibility that were previously only documented 
and not checked.

Note that the syntax only represents the type system, it is not the only way
to implement it. As mentioned, subtyping is already implicitly implemented
by versions. Other existing features such as loose coupling in OSGi can
also be modeled, if crudely (i.e. by having an implicit singleton import of every other
module inserted into every module). The type system is also not limited to
the current implementation. For example, the import declaration can be 
extended to use OSGi's extensive constraint features for packages and bundles.

Conflicts from possibly split packages can now be handled as an error instead
of nondeterministically choosing the class to load.

Collections of classes are now typed. If aspects are viewed as program transformations,
modules can be used as types to limit the kinds of programs that an aspect may modify, even though 
this contradicts the standard view that aspects are not program transformations. 
Aspects are already dependent on the structure of the programs they affect (i.e. 
an advice or intertype declaration that introduces code to type C most likely
depends on the existence of C), and typing will allow checks on an aspect's applicability
and extent.
This may lead to a saner use of aspects that will preserve the modularity properties
that have made object-orientation so well-accepted.

Merge and replace are imperative operations on modules. As the module system
is now not entirely declarative, a method of viewing the results of these operations
for debugging becomes desirable, even necessary.
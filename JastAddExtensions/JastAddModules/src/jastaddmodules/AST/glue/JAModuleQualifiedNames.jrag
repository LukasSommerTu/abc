
aspect JAModuleQualifiedNames {
	public ModuleDot Expr.moduleQualifiesAccess(Access access) {
		ModuleDot dot = new ModuleDot(this, access);
		dot.lastDot = dot;
		return dot;
	}
	
	//This was cut and paste from ResolveAmbiguousNames. Check with Torbjorn if there is a problem
	private Access ModuleDot.qualifyTailWith(Access expr) {
		if(getRight/*NoTransform*/() instanceof AbstractDot) {
			AbstractDot dot = (AbstractDot)getRight/*NoTransform*/();
			return expr.qualifiesAccess(dot.getRight/*NoTransform*/());
		}
		return expr;
	}
	
	//Adapted from Java1.4Frontend/ResolveAmbiguousNames 
	rewrite ModuleDot {
		when(!duringSyntacticClassification() && leftSide().isPackageAccess() && rightSide().isPackageAccess())
		to Access {
			PackageAccess left = (PackageAccess)leftSide();
			PackageAccess right = (PackageAccess)rightSide();
			left.setPackage(left.getPackage() + Program.MODULE_SEPARATOR + right.getPackage());
			left.setEnd(right.end());
			return qualifyTailWith(left);
		}
	}
	// change a ModuleDot("m1", "Type") into a Dot("m1::", "Type")
	rewrite ModuleDot {
		when(!duringSyntacticClassification() && leftSide().isPackageAccess() && !((Access)leftSide()).hasPrevExpr() && rightSide() instanceof TypeAccess)
		to Access {
			PackageAccess left = (PackageAccess)leftSide();
			TypeAccess right = (TypeAccess)rightSide();
			//change left to left::
			left.setPackage(left.getPackage() + Program.MODULE_SEPARATOR);
			return qualifyTailWith(left.qualifiesAccess(right));
			}
	}


	//returns the mangled type names
	syn String ImportDecl.globalTypeName() {
		Access a = getAccess().lastAccess();
		String name = a.isTypeAccess() ? ((TypeAccess)a).nameWithGlobalPackage() : "";
		while(a.hasPrevExpr() && a.prevExpr() instanceof Access) {
			Access pred = (Access)a.prevExpr();
			if(pred.isTypeAccess()) {
				name = ((TypeAccess)pred).nameWithGlobalPackage() + "." + name;
			}
			a = pred;
		}
		return name;
	}
	
	syn String TypeDecl.globalTypeName() {
		return typeName();
	}
	
	syn String Expr.globalTypeName() = "";
	eq AbstractDot.globalTypeName() = lastAccess().globalTypeName();
	eq TypeAccess.globalTypeName() {
		ModuleCompilationUnit mcu = compilationUnit().getModuleCompilationUnit();
		if (mcu == null) {
			return typeName();
		}
		if (isQualified()) {
			return qualifier().globalTypeName() + "." + name();
		} else {
			return nameWithGlobalPackage();
		}
	}

	//needed for type access
	inh CompilationUnit TypeAccess.compilationUnit();
	syn String TypeAccess.nameWithGlobalPackage() {
		assert (compilationUnit().getModuleCompilationUnit() != null) : "Should be under a ModuleCompilationUnit";
		if (getPackage().equals("")) {
			return name();
		} else {
			ModuleCompilationUnit mcu = compilationUnit().getModuleCompilationUnit();
			String globalPackage = mcu.lookupPackage(getPackage(), mcu);
			//TODO: find out how this affects things
			if (globalPackage == null) {
				globalPackage = getPackage();
			}
			return globalPackage + "." + name();
		}
	}
	
	//refined from QualifiedNames.jrag
	//typeName() returns the global (mangled) package names
	//NOTE: Taken out for now, has way too many unintended effects. Just change the 
	//nameCheck for importDecls
	/* 
	refine QualifiedNames eq TypeDecl.typeName() {
		if (compilationUnit().getModuleCompilationUnit() == null) {
			return QualifiedNames.TypeDecl.typeName();
		}
		
		ModuleCompilationUnit mcu = compilationUnit().getModuleCompilationUnit();
		assert (mcu != null) : "Should have a ModuleCompilationUnit";
		
		if(isNestedType())
			return enclosingType().typeName() + "." + name();
		
		//use the global package name when returning typenames
		String packageName = mcu.lookupPackage(packageName(), mcu);
		if(packageName.equals("") || packageName.equals(PRIMITIVE_PACKAGE_NAME))
			return name();
		return packageName + "." + name();
	}
	
	refine QualifiedNames eq TypeAccess.typeName() {
		ModuleCompilationUnit mcu = hostType().compilationUnit().getModuleCompilationUnit();
		if (mcu == null) {
			return QualifiedNames.TypeAccess.typeName();
		}
		if (isQualified()) {
			return qualifier().typeName() + "." + name();
		} else {
			return nameWithGlobalPackage();
		}
	}
	
	syn String TypeAccess.nameWithGlobalPackage() {
		assert (hostType().compilationUnit().getModuleCompilationUnit() != null) : "Should be under a ModuleCompilationUnit";
		if (getPackage().equals("")) {
			return name();
		} else {
			ModuleCompilationUnit mcu = hostType().compilationUnit().getModuleCompilationUnit();
			String globalPackage = mcu.lookupPackage(getPackage(), mcu);
			//TODO: find out how this affects things
			if (globalPackage == null) {
				globalPackage = getPackage();
			}
			return globalPackage + "." + name();
		}
	}
	*/
}
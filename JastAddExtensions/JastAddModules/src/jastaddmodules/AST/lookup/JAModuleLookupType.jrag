//TODO: The entire type lookup with modules is a hack, using package names
//and disambiguating them as Strings. This was partially by design (since
//module instances are mapped to package names and keeping them as
//package names is more consistent with the output) and partially by convenience
//(the lookupType method parameters are (packageName, typeName)). The "right"
//way to do it is to introduce ModuleAccesses into names and do proper disambiguation.
import jastaddmodules.*;

aspect JAModuleLookupType {
	refine LookupType eq Program.lookupType(String packageName, String typeName) {
		assert (isModuleProcessingComplete()) : "Program.lookupType called before module processing was complete";
		addPrimitiveTypes();
		String fullName = packageName.equals("") ? typeName : packageName + "." + typeName;
		//temporary hack
		for(int i = 0; i < getNumCompilationUnit(); i++) {
			if (getCompilationUnit(i) instanceof ModuleCompilationUnit) {
				ModuleCompilationUnit mcu = (ModuleCompilationUnit)getCompilationUnit(i);
				for (int j = 0; j < mcu.getCompilationUnitList().getNumChild(); j++) {
					CompilationUnit currCU = mcu.getCompilationUnit(j);
					for(int k = 0; k < currCU.getNumTypeDecl(); k++) {
						TypeDecl type = currCU.getTypeDecl(k);
						if(type.fullName().equals(fullName)) {
							return type;
						}
					}
				}
			}
			else {      
				for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++) {
					TypeDecl type = getCompilationUnit(i).getTypeDecl(j);
					if(type.fullName().equals(fullName)) {
						return type;
					}
				}
			}
		}

		//TODO: This is a patch. Find out how getCompilationUnit really works
		CompilationUnit u = getCompilationUnit(fullName);
		if(u != null && !u.fromSource()) { //TODO: if u was fromSource, it should have been found in the loops above. Find out how to remove the fullname from the set
			addCompilationUnit(u);
			getCompilationUnit(getNumCompilationUnit()-1);
			for(int j = 0; j < u.getNumTypeDecl(); j++) {
				if(u.getTypeDecl(j).name().equals(typeName)) {
					return u.getTypeDecl(j);
				}
			}
			//throw new Error("No type named " + typeName + " in file " + fullName + ", " + u.pathName() + ", " + u.relativeName());
		}
		return null;
	}
	
	eq ModuleCompilationUnit.getChild().lookupType(String packageName, String typeName) {
		assert (getHostProgram().isModuleProcessingComplete()) : "Program.lookupType called before module processing was complete";
		
		//local package lookup
		LocalModulePackage localPackage = getLocalPackage(packageName);
		if (localPackage != null) {
			String localPackageName = makeLocalPackageName(packageName, localPackage);
			TypeDecl type = getHostProgram().lookupType(localPackageName, typeName);
			if (type != null) {
				return type;
			}
		}
		
		//TODO: greedy left match on package name
		//Make this more efficient
		String moduleOrPackageName = packageName;
		String localPackageName = null;
		while (moduleOrPackageName.lastIndexOf('.') != -1) {
			if (localPackageName == null) {
				localPackageName = moduleOrPackageName.substring(moduleOrPackageName.lastIndexOf('.') + 1);
			} else {
				localPackageName = moduleOrPackageName.substring(moduleOrPackageName.lastIndexOf('.') + 1) + "." + localPackageName; 
			}
				
			moduleOrPackageName = moduleOrPackageName.substring(0, moduleOrPackageName.lastIndexOf('.'));
			ModuleCompilationUnit importedCU = lookupModule(this, moduleOrPackageName);
			
			//TODO: This is a terrible hack so that lookupType is called on a childCU of importedCU
			if (importedCU != null) {
				Iterator<CompilationUnit> iter = importedCU.getCompilationUnitList().iterator();
				if (iter.hasNext()) {
					TypeDecl type = iter.next().lookupType(localPackageName, typeName);
					if (type != null) {
						return type;
					}
				}
			}
		}
		
		//TODO: Is this even needed?
		//treat the package name as a module name and lookup the module
		ModuleCompilationUnit importedCU = lookupModule(this, packageName);
		if (importedCU != null) {
		//lookup the type using the module's module name
			String modulePackageName = importedCU.getModuleName();
			TypeDecl type = getHostProgram().lookupType(modulePackageName, typeName);
			if (type != null) {
				return type;
			}			
		}
		//if none found, do CompilationUnit.lookupType
		return super.lookupType(packageName, typeName);
	}
	
	//TODO: see how these can be turned to lazy
	public SimpleSet CompilationUnit.memberTypes(SimpleSet set) {
		for(int i = 0; i < getNumTypeDecl(); i++) {
			TypeDecl typeDecl = getTypeDecl(i);
			set = typeDecl.memberTypes(set);
		}
		return set;
	}
	public SimpleSet TypeDecl.memberTypes(SimpleSet set) {
		set = set.add(this);
		return set;
	}
	
	SimpleSet CompilationUnit.memberTypes() {
		return memberTypes(SimpleSet.emptySet);
	}
	syn lazy SimpleSet ModuleCompilationUnit.memberTypes() {
		SimpleSet ret = SimpleSet.emptySet;
		for (CompilationUnit cu : getCompilationUnitList()) {
			ret = cu.memberTypes(ret);
		}
		return ret;
	}
	
	//Get any types that are imported through the module that match name
	syn lazy SimpleSet ModuleCompilationUnit.moduleImportedTypes(String name) {
		return moduleImportedTypes(name, SimpleSet.emptySet);
	}
	SimpleSet ModuleCompilationUnit.moduleImportedTypes(String name, SimpleSet set) {
		//get local module types first
		set = localModuleTypes(name, set);
		if (!set.isEmpty()) {
			return set;
		}
		//"imported" types (types that are in CUs that are members of imported modules)
		for (jastaddmodules.ImportedModule mcu : getImportedModuleMap().values()) {
			set = mcu.getModuleCU().localModuleTypes(name, set);
		}
		return set;
	}
	SimpleSet ModuleCompilationUnit.localModuleTypes(String name, SimpleSet set) {
		//"local" module types (types that are in CUs that are members of the module)
		for (Iterator i = memberTypes().iterator(); i.hasNext() ;) {
			TypeDecl type = (TypeDecl) i.next();
			if (type.name().equals(name)) {
				set = set.add(type);
			}
		}
		return set;
	}
	
	//TODO: Implement module/package disambiguation here
	//Reimplemented LookupType and Generics since I had to insert the module
	//imports right above LookupType
	refine Generics eq CompilationUnit.getChild().lookupType(String name) {
		assert (getHostProgram().isModuleProcessingComplete()) : "Program.lookupType called before module processing was complete";
		if (isInJAModule()) {
			//Reimplement Java1.4Frontend/LookupType...lookupType() + Generics
		    // locally declared types in compilation unit
			SimpleSet set = localLookupType(name);
			if(!set.isEmpty()) return addGenericTypes(set);
			
			// imported types
			set = importedTypes(name);
			if(!set.isEmpty()) return addGenericTypes(set);
			
			// types in the same package
			TypeDecl result = lookupType(packageName(), name);
			if(result != null && result.accessibleFromPackage(packageName())) 
			  return addGenericTypes(SimpleSet.emptySet.add(result));
			
			// types imported on demand
			set = importedTypesOnDemand(name);
			if(!set.isEmpty()) return addGenericTypes(set);
			
			//lookup module imports
			ModuleCompilationUnit mcu = getModuleCompilationUnit();
			assert (mcu != null) : "Should be a member of a module compilation unit";
			
			SimpleSet ret = mcu.moduleImportedTypes(name);
			if (!ret.isEmpty()) {
				return addGenericTypes(ret);
			}
			
			// include primitive types
			result = lookupType(PRIMITIVE_PACKAGE_NAME, name);
			if(result != null) return addGenericTypes(SimpleSet.emptySet.add(result));
			
			// 7.5.5 Automatic Imports
			result = lookupType("java.lang", name);
			if(result != null && result.accessibleFromPackage(packageName()))
			  return addGenericTypes(SimpleSet.emptySet.add(result));
			return addGenericTypes(lookupType(name));
		} else {
			return Generics.CompilationUnit.getChild().lookupType(name);
		}
	}
	
	//Adapted from generics
	public SimpleSet CompilationUnit.addGenericTypes(SimpleSet set) {
    	SimpleSet result = SimpleSet.emptySet;
		for(Iterator iter = set.iterator(); iter.hasNext(); ) {
			TypeDecl typeDecl = (TypeDecl)iter.next();
			if(typeDecl instanceof ParTypeDecl)
				result = result.add(((ParTypeDecl)typeDecl).genericDecl());
			else
				result = result.add(typeDecl);
		}
		return result;
	}
}

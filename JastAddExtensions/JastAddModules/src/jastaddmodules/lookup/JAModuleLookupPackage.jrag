import jastaddmodules.*;

aspect JAModuleLookupPackage {
	//shares cut n paste code with lookupType. Change that if you change this
	//TODO: Refactor to remove cut and paste code
	//returns null if it can't find a package that belongs to a module
	public String ModuleCompilationUnit.lookupPackage(String packageName, ModuleCompilationUnit context) {
		assert (getHostProgram().isModuleProcessingComplete()) : "ModuleCompilationUnit.lookupPackage called before module processing was complete";
		
		//special case for java.** packages, always look at the top level first for a match
		if (packageName.indexOf(Program.MODULE_SEPARATOR) == -1 && 
				packageName.startsWith("java.") &&
				getHostProgram().hasPackage(packageName)) {
			return packageName;
		}
		
		//local package lookup
		LocalModulePackage localModulePackage = getLocalPackage(packageName);
		if (localModulePackage != null&&
				(localModulePackage.isExported() || 
					(!localModulePackage.isExported() && context == this)
				)
			) {
			return makeGlobalPackageName(packageName, localModulePackage);
		}
		//TODO: Add lookups for directly imported modules
			
		String moduleName = packageName;
		String localPackageName = null;
		if (moduleName.lastIndexOf(Program.MODULE_SEPARATOR) != -1) {
			localPackageName = moduleName.substring(moduleName.lastIndexOf(Program.MODULE_SEPARATOR) + 2);
			moduleName = moduleName.substring(0, moduleName.lastIndexOf(Program.MODULE_SEPARATOR));
		} else {
			localPackageName = ""; //this should be properly looked up in the local package names of the module
			moduleName = packageName;
		}
		if (localPackageName.equals(".")) {
			localPackageName = ""; //special case for module::.Type
		}
		if (moduleName.equals(Program.DEFAULT_MODULE_NAME)) {
			if (getHostProgram().hasPackage(localPackageName)) {
				return localPackageName;
			} else {
				return null;
			}
		}
				
		ModuleCompilationUnit importedCU = lookupModule(this, moduleName);
		//TODO: This is a terrible hack so that lookupType is called on a childCU of importedCU
		if (importedCU != null) {
			localModulePackage = importedCU.getLocalPackage(localPackageName);
			//if the package is exported or if it is not exported but lookup is in the same modulecu, return the global package name
			if (localModulePackage != null &&
					(localModulePackage.isExported() || 
						(!localModulePackage.isExported() && context == this)
					)
				) {
				return importedCU.makeGlobalPackageName(localPackageName, localModulePackage);
			}
		}
		//if none found, return check program (is used in hasPackage check in JAModuleLookupPackage)
		if (getHostProgram().hasPackage(packageName)) {
			return packageName;
		} else {
			return null;
		}
	}
	
	inh boolean CompilationUnit.hasPackage(String packageName); //should just call the parent hasPackage
	eq CompilationUnit.getChild().hasPackage(String packageName) {
		if ((getModuleCompilationUnit() == null) && 
			(getHostProgram().getInstanceModuleCU() != null)) {
			//try a lookup through the instance package
			boolean ret = (getHostProgram()
								.getInstanceModuleCU()
								.lookupPackage(packageName, null) != null
								);
			if (ret) {
				return true;
			}
		}
		return hasPackage(packageName);
	}
	
	syn boolean ModuleCompilationUnit.hasPackage(String packageName) {
		boolean ret = (this.lookupPackage(packageName, this) != null);
		if (ret) {
			return true;
		} else {
			return super.hasPackage(packageName);
		}
	}
	eq ModuleCompilationUnit.getChild().hasPackage(String packageName) {
		return hasPackage(packageName);//should call the method above
	}
}
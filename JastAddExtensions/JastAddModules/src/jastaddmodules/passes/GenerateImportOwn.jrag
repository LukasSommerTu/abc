//STANDING NOTE: Make VERY sure that all JAModule passes before the java 
//errorcheck DO NOT TOUCH any AST nodes below CompilationUnit to avoid 
//the REWRITES

//This code generates the module instances defined by the import, merge and
//replace statements in the module files. The merge/replace code here is
//the most crucial part of the entire system. Be careful when modifying it.

//TODO: Try to refactor this to separate out the handling for merges and replaces


import java.util.*;

//generates module CUs and clones subtrees as necessary
//for import owns. Is done after InsertModuleCUs
aspect GenerateImportOwn {

	ModuleCompilationUnit Program.instanceModule = null;
	
	public ModuleCompilationUnit Program.getInstanceModuleCU() {
		return this.instanceModule;
	}
	public void Program.setInstanceModuleCU(ModuleCompilationUnit instanceModule) {
		this.instanceModule = instanceModule;
	}

	public boolean Program.generateImportOwn() {
		if (!hasJAModules()) {
			return true;
		}
		if (!options().hasOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION) || 
			!options().hasValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION)) {
			System.out.println(jastadd.JastAddModules.INSTANCE_MODULES_OPTION + 
				" option is required when there are JA modules in the set of compilation units");
			return false; 
		}
		
		String instanceModuleName = options().getValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION);
		this.setInstanceModuleCU(lookupModuleCUNoTransform(instanceModuleName));
		if (this.instanceModule == null) {
			System.out.println("Instance module " + instanceModuleName + " not found.");
			return false;
		}
		
		//generate import owns starting from the instance module
		getInstanceModuleCU().generateImportOwn(null);
		getInstanceModuleCU().setSourceStatement(null); //debug
		
		return true;
	}

	//context is non-null if the import is an own. If non-null, it creates a new module cu
	//if context is null, it is implicitly exported (i.e. it is one of the base modules
	//and is visible). If not, then it is not exported (i.e. it was generated from an import own
	//statement with no export)	
	//NOTE: Keep these non-lazy, the node removal code in merge depends on separate instances of the modules being removed
	syn ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context) {
		if (context == null) {
			return generateImportOwn(context, "");
		} else {
			return generateImportOwn(context, createOwnName(context, this.getModuleName()));
		}
	}
	syn ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		//if instance module, don't reinstantiate
		if (context == null) {
			ret = this;
		} else {
			ret = instantiateModuleAs(context, alias); 
			ret.addInstanceContext(context);
		}
		if (ret.isModuleInstantiated()) { //can't rely on laziness, as the cache only adds an entry after generateImportOwn returns
			return ret;
		}
		ret.setModuleInstantiated(true);
		ret.setRealInstance(ret);
		
		//create super instances
		ret.instantiateSuperModules();
		
		//process imports
		ret = generateImportCUs(ret);
		
		//process merges
		ret = generateMergeReplaceCUs(ret);
		
		return ret;
	}
	
	//TODO: Should really be static, except for the call to getHostProgram(). See if refactoring
	//is worth it 
	protected ModuleCompilationUnit ModuleCompilationUnit.generateImportCUs(ModuleCompilationUnit ret) {
		assert (ret != null) : "ModuleCompilationUnit parameter should not be null";
		
		LinkedList<ModuleMemberDecl> memberList = ret.getSelfAndSuperMemberList();
		for (ModuleMemberDecl member : memberList) {
			if (!(member instanceof ModuleImportDecl)) {
				continue;
			}
			ModuleImportDecl importDecl = (ModuleImportDecl) member;
			
			ModuleCompilationUnit currImport = null; 
			currImport = getHostProgram().lookupModuleCUNoTransform(importDecl.getImportModule());
			if (currImport == null) {
				String msg = "Unable to find module: " + importDecl.getImportModule().getID();
				importDecl.getImportModule().error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			boolean instantiated = false;
			String localAccessName = currImport.getModuleName();
			if (importDecl.isOwnImport()) {
				ModuleCompilationUnit instanceCU = null;
				instantiated = true;
				//if no export name, generate M$M' name
				if (importDecl.getAsType() instanceof AsTypeNone) {
					instanceCU = currImport.generateImportOwn(ret);
					instanceCU.setSourceStatement(importDecl);
				} else {
					localAccessName = importDecl.getAsModule().getID();
					if (importDecl.getAsType() instanceof AsTypeOwn) {
						instanceCU = currImport.generateImportOwn(ret, createOwnName(ret, importDecl.getAsModule().getID()));
						instanceCU.setSourceStatement(importDecl); 
					} else if (importDecl.getAsType() instanceof AsTypeExport) {
						instanceCU = currImport.generateImportOwn(ret, createExportName(ret, importDecl.getAsModule().getID()));
						instanceCU.setSourceStatement(importDecl); 
					}
				}
				instanceCU.setBaseCU(currImport.getBaseCU());
				currImport = instanceCU;
			} else {
				//check if a synthetic static instance
				if (currImport.isSynthetic()) {
					String msg = "Unable to find module: " + importDecl.getImportModule().getID();
					importDecl.getImportModule().error(msg);
					throw new jastadd.UnrecoverableSemanticError(msg);
				}
				//generate from a null context
				currImport = currImport.generateImportOwn(null);
				currImport.setSourceStatement(importDecl); 
			}
			assert (currImport != null) : "Imported module not instantiated";
			
			ret.checkedAddModuleReference(localAccessName, currImport, currImport.getBaseCU(), importDecl.getAsType(), importDecl.getModuleImportType());
			
			if (instantiated) {
				getHostProgram().getCompilationUnitList().addChild(currImport);			
			}
		}
		return ret;
	}
	
	//This should only be called _after_ the import CUs have been generated.
	//TODO: Should really be static, except for the call to getHostProgram(). See if refactoring
	//is worth it 
	protected ModuleCompilationUnit ModuleCompilationUnit.generateMergeReplaceCUs(ModuleCompilationUnit ret) {
		LinkedList<ModuleMemberDecl> memberList = ret.getSelfAndSuperMemberList();
		for (ModuleMemberDecl member : memberList) {
			//TODO: Move process methods to mergemember/replacemember to remove instanceof test
			if (member instanceof ModuleMergeDecl) {
				ModuleMergeDecl mergeMember = (ModuleMergeDecl)member;
				ret = processMergeMember(mergeMember, ret);
			}
			else if (member instanceof ModuleReplaceDecl) {
				ModuleReplaceDecl replaceMember = (ModuleReplaceDecl)member;
				ret = processReplaceMember(replaceMember, ret);
			}
			//else do nothing
		}
		return ret;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.processMergeMember(ModuleMergeDecl mergeMember, ModuleCompilationUnit ret) {
		//lookup merge targets from ret
		if (mergeMember.getMergeModuleList().getNumChild() < 2) {
			mergeMember.warning("There are less than two modules to merge. This may be an error.");
		}
		Collection<ModuleCompilationUnit> mergeTargets = new HashSet<ModuleCompilationUnit>();
		ModuleCompilationUnit mergeBaseCU = null; //will be the base module of the merged module when it is instantiated 
		for (ModuleAccess access : mergeMember.getMergeModuleList()) {
			ModuleCompilationUnit cu = access.lookupModule(); 
			ModuleReference cuReference = access.lookupModuleReference();
			
			if (cu == null) {
				String msg = "Unable to find module: " + access.getID();
				access.error(msg); 
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			//self replace error
			if (access.getID().equals(ret.getBaseCU().getModuleName())) {
				String msg = "Cannot merge reference to self"; 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			if (mergeBaseCU != null && mostSpecificModule(cuReference.getStaticModuleType(), mergeBaseCU) == null) {
				String msg = "Incompatible modules in merge list: " + mergeBaseCU.getModuleName() + ", " + cu.getBaseCU().getModuleName(); 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			if (mergeTargets.contains(cu)) {
				access.warning("Module " + cu.getModuleName() + " is being merged with itself. This may be a sign of a wrong merge");
			}
			
			if (isAccessedThroughBaseModule(access)) {
				String msg = "Module being merged is a base module or is accessed through a base module. Merging is only allowed for import own modules."; 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			mergeTargets.add(cu);
			if (mergeBaseCU == null) {
				mergeBaseCU = cuReference.getStaticModuleType();
			} else {
				mergeBaseCU = mostSpecificModule(cuReference.getStaticModuleType(), mergeBaseCU);
			}
		}
		//create result copy (instantiate from the base types of the merge targets with ret as a context)
		ModuleCompilationUnit mergedCU = null;
		String mergeAlias = mergeMember.getAsModule().getID();
		if (mergeMember.getAsType() instanceof AsTypeOwn) {
			mergedCU = mergeBaseCU.generateImportOwn(ret, createOwnName(ret, mergeAlias));
		} else if (mergeMember.getAsType() instanceof AsTypeExport) {
			mergedCU = mergeBaseCU.generateImportOwn(ret, createExportName(ret, mergeAlias));
		}
		mergedCU.setSourceStatement(mergeMember); //debug
		getHostProgram().getCompilationUnitList().addChild(mergedCU);
		
		ret = replaceTargets(ret, mergeMember, mergeTargets, mergedCU,
				mergeAlias);
				
		//attach the result copy to ret's import list
		//import type is own. TODO: Check if this is correct
		ret.checkedAddModuleReference(mergeAlias, mergedCU, mergedCU.getBaseCU(), mergeMember.getAsType(), new ModuleImportTypeOwn());
				
		return ret;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.processReplaceMember(ModuleReplaceDecl replaceMember, ModuleCompilationUnit ret) {
		//lookup merge targets from ret
		
		ModuleCompilationUnit replaceCU = replaceMember.getWithModule().lookupModule();
		if (replaceCU == null) {
			String msg = "Unable to find module: " + replaceMember.getWithModule().getID();
			replaceMember.getWithModule().error(msg);
			throw new jastadd.UnrecoverableSemanticError(msg);
		} 
		//Comment out, allow replacement with base modules
		/*
		if (isAccessedThroughBaseModule(replaceMember.getWithModule())) {
			String msg = "Module used for replacement is a base module or is accessed through a base module. Only import owns are allowed to be used for a replace.";
			replaceMember.getWithModule().error(msg);
			throw new jastadd.UnrecoverableSemanticError(msg);
		}
		*/
		
		Collection<ModuleCompilationUnit> replaceTargets = new HashSet<ModuleCompilationUnit>();
		for (ModuleAccess access : replaceMember.getReplaceModuleList()) {
			ModuleCompilationUnit cu = access.lookupModule(); 
			ModuleReference cuReference = access.lookupModuleReference();
			
			if (cu == null) {
				String msg = "Unable to find module: " + access.getID();
				access.error(msg); 
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			//self replace error
			if (access.getID().equals(ret.getBaseCU().getModuleName())) {
				String msg = "Cannot replace reference to self"; 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			//if not type compatible
			if (!cuReference.getStaticModuleType().isInterfaceOf(replaceCU) && 
				!replaceCU.hasSuperModule(cuReference.getStaticModuleType()) &&
				!replaceCU.overridesModule(cuReference.getStaticModuleType()) &&
				!(replaceCU.isSynthetic() || cuReference.getStaticModuleType().isSynthetic()) //allows synthetic types to be inserted anywhere. I know it's bad, but it's the only way to make synthetic references to work. See if there is a better way around this. 
				) {
				String msg = "Incompatible modules in replace: " + replaceCU.getBaseCU().getModuleName() + ", " + cu.getBaseCU().getModuleName(); 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			if (replaceTargets.contains(cu)) {
				access.warning("Module " + cu.getModuleName() + " is being merged with itself. This may be a sign of a wrong merge");
			}
			
			if (isAccessedThroughBaseModule(access)) {
				String msg = "Module being replaced is a base module or is accessed through a base module. Replacement is only allowed for import own modules."; 
				access.error(msg);
				throw new jastadd.UnrecoverableSemanticError(msg);
			}
			
			replaceTargets.add(cu);
		}
		ret = replaceTargets(ret, replaceMember, replaceTargets, replaceCU,
				replaceMember.getWithModule().getID());
		return ret;
	}
	
	//Changes the module references targeted by merge or replace. Detaches
	//the old instances from the tree if no pointers to them exist
	//NOTE: This is the hairiest piece of code in all of JastAddModules. Be careful
	//when changing this
	//TODO: Should really be static, except for the call to getHostProgram(). See if refactoring
	//is worth it 
	protected ModuleCompilationUnit 
		ModuleCompilationUnit.replaceTargets(ModuleCompilationUnit ret,
			ModuleMemberDecl moduleMember,
			Collection<ModuleCompilationUnit> mergeTargets,
			ModuleCompilationUnit mergedCU, String mergeAlias) {
		//TODO: These loops are too hairy. Try to turn the innermost loop into a method
		//foreach merge target
		for (ModuleCompilationUnit mergeTargetCU : mergeTargets) {
		//	foreach context member of the merge target
			for (ModuleCompilationUnit instanceContextCU: mergeTargetCU.getInstanceContext()) {
		//		for each old alias of the mergetargetcu
				Set<String> oldAliases = instanceContextCU.getModuleReferenceAliases(mergeTargetCU);
				for (String oldAlias : oldAliases) { 
		//			detach the merge target from the context member's import list
					AsType oldAsType = instanceContextCU.getModuleReference(oldAlias).getAsType();
					ModuleImportType oldImportType = instanceContextCU.getModuleReference(oldAlias).getModuleImportType();
					ModuleCompilationUnit oldStaticType = instanceContextCU.getModuleReference(oldAlias).getStaticModuleType();
					assert (oldAlias != null) : "Unable to find old alias";
					assert (oldImportType instanceof ModuleImportTypeOwn) : "Mergetargets should all be imported using own";
					instanceContextCU.removeModuleReference(oldAlias);
		//			attach the result copy to the context member's import list (use the old alias and isExported)
					if (ret == instanceContextCU) {//if the merge replaces an import/previous merge in ret
						if (moduleMember instanceof ModuleMergeDecl) {
							//if the mergeCU will replace the current alias and changes its signature, add an error
							ModuleMergeDecl mergeMember = (ModuleMergeDecl) moduleMember; 
							if (oldAsType.isExported() != mergeMember.getAsType().isExported() &&
									oldAlias.equals(mergeAlias)) { //no need to check for import own, as base CUs can't be merged
								String msg = "Merge/replace changes the signature of a merge target: " + oldAlias;
								mergeMember.error(msg);
							}
							//only add if the aliases are not the same. Otherwise the add will happen later using mergeAlias
							if (!(oldAlias.equals(mergeAlias))) {
								instanceContextCU.checkedAddModuleReference(oldAlias, mergedCU, oldStaticType, oldAsType, oldImportType);
							}
						} else {
							//check for replace
							if (!(oldAlias.equals(mergeAlias))) {
								instanceContextCU.checkedAddModuleReference(oldAlias, mergedCU, oldStaticType, oldAsType, oldImportType);
							} else {
								moduleMember.warning("Module is replacing itself: " + oldAlias); 
							}
						}
					} else {
						instanceContextCU.checkedAddModuleReference(oldAlias, mergedCU, oldStaticType, oldAsType, oldImportType);
					}
				}
				
		//		add the context member to the result copy's instance context
				mergedCU.addInstanceContext(instanceContextCU);
			}
		//	detach the mergeTargetCU from the compilationUnit list of the program
			mergeTargetCU.detachFromProgramList();
		//	detach the merge target from ret's import list
			ret.removeModuleReference(mergeTargetCU);
		}
		return ret;
	}
	
	//create a new ModuleCompilationUnit from the current one, using the given alias.
	//Context will be for generating links in the accessibility graph
	//NOTE: Keep this non-lazy, the node removal code in merge depends on separate instances of the modules being removed
	syn ModuleCompilationUnit ModuleCompilationUnit.instantiateModuleAs(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		
		ret = this.fullCopy();
		
		//clear instace related ITDs
		ret.setModuleInstantiated(false);
		ret.setModuleReferences(new HashMap<String, jastaddmodules.ModuleReference>());
		ret.setInstanceContext(new HashSet<ModuleCompilationUnit>());
		
		ret.setModuleName(alias);
		
		return ret;
	}
	
	public String ModuleCompilationUnit.createExportName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "." + alias;
	}
	public String ModuleCompilationUnit.createOwnName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "$" + alias;
	}
	
	public void ModuleCompilationUnit.checkedAddModuleReference(String alias, ModuleCompilationUnit cu, ModuleCompilationUnit staticType, AsType asType, ModuleImportType importType) {
		if (getModuleReference(alias) != null || alias.equals(getBaseCU().getModuleName())) {
			getModuleDecl().error("Ambiguous module name " + alias + " in module " + this.getModuleName());
			//throw new jastadd.UnrecoverableSemanticError("Ambiguous alias " + alias + " in module " + this.getModuleName());
		}
		addModuleReference(alias, cu, staticType, asType, importType);
	}
	
	//Is true if the module was used as an instance in the ModuleCompilationUnit
	//If the module wasn't instantiated, it won't be returned by the compilationUnitIterator()
	protected boolean ModuleCompilationUnit.moduleInstantiated = false;
	public void ModuleCompilationUnit.setModuleInstantiated(boolean b) {
		moduleInstantiated = b;
	}
	public boolean ModuleCompilationUnit.isModuleInstantiated() {
		return moduleInstantiated;
	}
	
	public ModuleMemberDecl ModuleCompilationUnit.sourceStatement = null;
	public void ModuleCompilationUnit.setSourceStatement(ModuleMemberDecl decl) {
		this.sourceStatement = decl;
	}
	public ModuleMemberDecl ModuleCompilationUnit.getSourceStatement() {
		return this.sourceStatement;
	}
	
	public ModuleCompilationUnit ModuleCompilationUnit.mostSpecificModule(
			ModuleCompilationUnit cu1,
			ModuleCompilationUnit cu2) {
		assert (cu1 != null && cu2 != null) : "null parameter passed to mostSpecificModule";
		ModuleCompilationUnit base1 = cu1.getBaseCU();
		ModuleCompilationUnit base2 = cu2.getBaseCU();
		if (base1 == base2) {
			return base1;
		}
		while (base1.getSuperModuleCU() != base2 && base1.getSuperModuleCU() != null) {
			base1 = base1.getSuperModuleCU();
		}
		if (base1.getSuperModuleCU() == base2) {
			return cu1.getBaseCU();
		}
		base1 = cu1.getBaseCU();
		while (base2.getSuperModuleCU() != base1 && base2.getSuperModuleCU() != null) {
			base2 = base2.getSuperModuleCU();
		}
		if (base2.getSuperModuleCU() == base1) {
			return cu2.getBaseCU();
		}
		return null;
	} 
	
	//checks if a module is being accessed through a base module (i.e. there is a MCU in path
	//of the lookup that is a base module
	public boolean ModuleCompilationUnit.isAccessedThroughBaseModule(ModuleAccess access) {
		String localModuleName = access.getID();
		String left = "";
		String right = localModuleName;
		//successively lookup each module in the name, return true if the lookup was 
		do {
			int separatorIndex = right.indexOf(Program.MODULE_SEPARATOR); 
			if (separatorIndex == -1) {
				left = left.equals("") ? 
					right : 
					left + Program.MODULE_SEPARATOR + right;
				right = "";
			} else {
				left = left.equals("") ?
					right.substring(0, separatorIndex) :
					left + Program.MODULE_SEPARATOR + right.substring(0, separatorIndex);
				right = right.substring(separatorIndex + 2);
			}
			ModuleCompilationUnit mcu = lookupModule(this, left);
			if (mcu == null) {
				return false;
			}
			if (!mcu.isInstance()) {
				return true;
			}
		} while (!right.equals(""));
		return false;
	}
}
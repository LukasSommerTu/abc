//STANDING NOTE: Make VERY sure that all JAModule passes before the java 
//errorcheck DO NOT TOUCH any AST nodes below CompilationUnit to avoid 
//the REWRITES



import java.util.*;

//generates module CUs and clones subtrees as necessary
//for import owns. Is done after InsertModuleCUs
aspect GenerateImportOwn {

	ModuleCompilationUnit Program.instanceModule = null;
	
	public ModuleCompilationUnit Program.getInstanceModuleCU() {
		return this.instanceModule;
	}
	public void Program.setInstanceModuleCU(ModuleCompilationUnit instanceModule) {
		this.instanceModule = instanceModule;
	}

	public boolean Program.generateImportOwn() {
		if (!hasJAModules()) {
			return true;
		}
		if (!options().hasOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION) || 
			!options().hasValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION)) {
			System.out.println(jastadd.JastAddModules.INSTANCE_MODULES_OPTION + 
				" option is required when there are JA modules in the set of compilation units");
			return false; 
		}
		
		String instanceModuleName = options().getValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION);
		this.setInstanceModuleCU(lookupModuleCUNoTransform(instanceModuleName));
		if (this.instanceModule == null) {
			System.out.println("Instance module " + instanceModuleName + " not found.");
			return false;
		}
		
		//generate import owns starting from the instance module
		getInstanceModuleCU().generateImportOwn(null);
		getInstanceModuleCU().setSourceStatement("-instance-module"); //debug
		
		return true;
	}

	//context is non-null if the import is an own. If non-null, it creates a new module cu
	//if context is null, it is implicitly exported (i.e. it is one of the base modules
	//and is visible). If not, then it is not exported (i.e. it was generated from an import own
	//statement with no export)	
	//NOTE: Keep these non-lazy, the node removal code in merge depends on separate instances of the modules being removed
	syn ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context) {
		if (context == null) {
			return generateImportOwn(context, "");
		} else {
			return generateImportOwn(context, createOwnName(context, this.getModuleName()));
		}
	}
	syn ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		//if instance module, don't reinstantiate
		if (context == null) {
			ret = this;
		} else {
			ret = instantiateModuleAs(context, alias); 
			ret.addInstanceContext(context);
		}
		if (ret.isModuleInstantiated()) { //can't rely on laziness, as the cache only adds an entry after generateImportOwn returns
			return ret;
		}
		ret.setModuleInstantiated(true);
		
		//process imports
		ret = generateImportCUs(ret);
		
		//process merges
		ret = generateMergeCUs(ret);
		
		return ret;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.generateImportCUs(ModuleCompilationUnit ret) {
		assert (ret != null) : "ModuleCompilationUnit parameter should not be null";
		
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (!(member instanceof ModuleImportDecl)) {
				continue;
			}
			ModuleImportDecl importDecl = (ModuleImportDecl) member;
			
			ModuleCompilationUnit currImport = null; 
			currImport = getHostProgram().lookupModuleCUNoTransform(importDecl.getImportModule());
			if (currImport == null) {
				importDecl.getImportModule().error("Unable to find module: " + importDecl.getImportModule().getID());
				throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + importDecl.getImportModule().getID());
			}
			
			boolean instantiated = false;
			String localAccessName = currImport.getModuleName();
			if (importDecl.isOwnImport()) {
				ModuleCompilationUnit instanceCU = null;
				instantiated = true;
				//if no export name, generate M$M' name
				if (importDecl.getAsType() instanceof AsTypeNone) {
					instanceCU = currImport.generateImportOwn(ret);
					instanceCU.setSourceStatement(importDecl.toString()); //debug
				} else {
					localAccessName = importDecl.getAsModule().getID();
					if (importDecl.getAsType() instanceof AsTypeOwn) {
						instanceCU = currImport.generateImportOwn(ret, createOwnName(ret, importDecl.getAsModule().getID()));
						instanceCU.setSourceStatement(importDecl.toString()); //debug
					} else if (importDecl.getAsType() instanceof AsTypeExport) {
						instanceCU = currImport.generateImportOwn(ret, createExportName(ret, importDecl.getAsModule().getID()));
						instanceCU.setSourceStatement(importDecl.toString()); //debug
					}
				}
				instanceCU.setBaseCU(currImport.getBaseCU());
				currImport = instanceCU;
			} else {
				//generate from a null context
				currImport = currImport.generateImportOwn(null);
				currImport.setSourceStatement(importDecl.toString()); //debug
			}
			assert (currImport != null) : "Imported module not instantiated";
			
			ret.checkedAddImportedModule(localAccessName, currImport, importDecl.getAsType(), importDecl.getModuleImportType());
			
			if (instantiated) {
				getHostProgram().getCompilationUnitList().addChild(currImport);			
			}
		}
		return ret;
	}
	
	//This should only be called _after_ the import CUs have been generated.
	//NOTE: This is the hairiest piece of code in all of JastAddModules. Be careful
	//when changing this
	protected ModuleCompilationUnit ModuleCompilationUnit.generateMergeCUs(ModuleCompilationUnit ret) {
		for (ModuleMemberDecl member : ret.getModuleMemberDeclList()) {
			if (!(member instanceof ModuleMergeDecl)) {
				continue;
			}
			ModuleMergeDecl mergeMember = (ModuleMergeDecl)member; 
			//lookup merge targets from ret
			Collection<ModuleCompilationUnit> mergeTargets = new HashSet<ModuleCompilationUnit>();
			ModuleCompilationUnit mergeBaseCU = null; //used in check for base cu compatibility
			for (ModuleAccess access : mergeMember.getMergeModuleList()) {
				ModuleCompilationUnit cu = access.lookupModule(); 
				
				if (cu == null) {
					access.error("Unable to find module: " + access.getID()); 
					throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + access.getID());
				}
				
				if (mergeBaseCU != null && mostSpecificModule(cu.getBaseCU(), mergeBaseCU) == null) {
					access.error("Incompatible modules in merge list: " + mergeBaseCU.getModuleName() + ", " + cu.getModuleName());
					throw new jastadd.UnrecoverableSemanticError("Incompatible modules in merge list");
				}
				
				if (mergeTargets.contains(cu)) {
					access.warning("Module " + cu.getModuleName() + " is being merged with itself. This may be a sign of a wrong merge");
				}
				
				if (!cu.isInstance()) {
					access.error("Module being merged is a base module. Merging is only allowed for import own modules.");
					throw new jastadd.UnrecoverableSemanticError("Incompatible modules in merge list");
				}
				
				mergeTargets.add(cu);
				if (mergeBaseCU == null) {
					mergeBaseCU = cu.getBaseCU();
				} else {
					mergeBaseCU = mostSpecificModule(cu.getBaseCU(), mergeBaseCU);
				}
			}
			//create result copy (instantiate from the base types of the merge targets with ret as a context)
			ModuleCompilationUnit mergedCU = null;
			String mergeAlias = mergeMember.getAsModule().getID();
			if (mergeMember.getAsType() instanceof AsTypeOwn) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createOwnName(ret, mergeAlias));
			} else if (mergeMember.getAsType() instanceof AsTypeExport) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createExportName(ret, mergeAlias));
			}
			mergedCU.setSourceStatement(mergeMember.toString()); //debug
			getHostProgram().getCompilationUnitList().addChild(mergedCU);
			
			boolean replaceSelf = false; //is set to true if mergedCU itslef is found in the imports of the instance context
			//foreach merge target
			for (ModuleCompilationUnit mergeTargetCU : mergeTargets) {
			//	foreach context member of the merge target
				for (ModuleCompilationUnit instanceContextCU: mergeTargetCU.getInstanceContext()) {
			//		detach the merge target from the context member's import list
					String oldAlias = instanceContextCU.getImportedModuleAlias(mergeTargetCU);
					AsType oldAsType = instanceContextCU.getImportedModule(oldAlias).getAsType();
					ModuleImportType oldImportType = instanceContextCU.getImportedModule(oldAlias).getModuleImportType();
					assert (oldAlias != null) : "Unable to find old alias";
					instanceContextCU.removeImportedModule(oldAlias);
			//		attach the result copy to the context member's import list (use the old alias and isExported)
					if (ret != instanceContextCU) {
						instanceContextCU.checkedAddImportedModule(oldAlias, mergedCU, oldAsType, oldImportType);
					}
			//		add the context member to the result copy's instance context
					mergedCU.addInstanceContext(instanceContextCU);
				}
			//	detach the mergeTargetCU from the compilationUnit list of the program
				mergeTargetCU.detachFromProgramList();
			//	detach the merge target from ret's import list
				ret.removeImportedModule(mergeTargetCU);
			}
			//attach the result copy to ret's import list
			//import type is own. TODO: Check if this is correct
			ret.checkedAddImportedModule(mergeAlias, mergedCU, mergeMember.getAsType(), new ModuleImportTypeOwn());
		}
		return ret;
	}
	
	//create a new ModuleCompilationUnit from the current one, using the given alias.
	//Context will be for generating links in the accessibility graph
	//NOTE: Keep this non-lazy, the node removal code in merge depends on separate instances of the modules being removed
	syn ModuleCompilationUnit ModuleCompilationUnit.instantiateModuleAs(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		
		ret = this.fullCopy();
		
		//clear instace related ITDs
		ret.setModuleInstantiated(false);
		ret.setImportedModules(new HashMap<String, jastaddmodules.ImportedModule>());
		ret.setInstanceContext(new HashSet<ModuleCompilationUnit>());
		
		ret.setModuleName(alias);
		
		return ret;
	}
	
	public String ModuleCompilationUnit.createExportName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "." + alias;
	}
	public String ModuleCompilationUnit.createOwnName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "$" + alias;
	}
	
	public void ModuleCompilationUnit.checkedAddImportedModule(String alias, ModuleCompilationUnit cu, AsType asType, ModuleImportType importType) {
		if (getImportedModule(alias) != null || alias.equals(getBaseCU().getModuleName())) {
			getModuleDecl().error("Ambiguous module name " + alias + " in module " + this.getModuleName());
			//throw new jastadd.UnrecoverableSemanticError("Ambiguous alias " + alias + " in module " + this.getModuleName());
		}
		addImportedModule(alias, cu, asType, importType);
	}
	
	//Is true if the module was used as an instance in the ModuleCompilationUnit
	//If the module wasn't instantiated, it won't be returned by the compilationUnitIterator()
	protected boolean ModuleCompilationUnit.moduleInstantiated = false;
	public void ModuleCompilationUnit.setModuleInstantiated(boolean b) {
		moduleInstantiated = b;
	}
	public boolean ModuleCompilationUnit.isModuleInstantiated() {
		return moduleInstantiated;
	}
	
	public String ModuleCompilationUnit.sourceStatement;
	public void ModuleCompilationUnit.setSourceStatement(String s) {
		this.sourceStatement = s;
	}
	public String ModuleCompilationUnit.getSourceStatement() {
		return this.sourceStatement;
	}
	
	public ModuleCompilationUnit ModuleCompilationUnit.mostSpecificModule(
			ModuleCompilationUnit cu1,
			ModuleCompilationUnit cu2) {
		assert (cu1 != null && cu2 != null) : "null parameter passed to mostSpecificModule";
		ModuleCompilationUnit base1 = cu1.getBaseCU();
		ModuleCompilationUnit base2 = cu2.getBaseCU();
		if (base1 == base2) {
			return base1;
		}
		while (base1.getSuperModuleCU() != base2 && base1.getSuperModuleCU() != null) {
			base1 = base1.getSuperModuleCU();
		}
		if (base1.getSuperModuleCU() == base2) {
			return cu1.getBaseCU();
		}
		base1 = cu1.getBaseCU();
		while (base2.getSuperModuleCU() != base1 && base2.getSuperModuleCU() != null) {
			base2 = base2.getSuperModuleCU();
		}
		if (base2.getSuperModuleCU() == base1) {
			return cu2.getBaseCU();
		}
		return null;
	} 
}
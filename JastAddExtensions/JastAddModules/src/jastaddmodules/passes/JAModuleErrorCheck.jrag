//STANDING NOTE: Make VERY sure that all JAModule passes before the java 
//errorcheck DO NOT TOUCH any AST nodes below CompilationUnit to avoid 
//the REWRITES

import jastaddmodules.ImportedModule;
import jastaddmodules.CycleType;

aspect JAModuleErrorCheck {
	//dependent on Java1.4Frontend/ErrorCheck.CompilationUnit.errors/warnings
	//adapted from abc-ja-exts/CheckModuleErrors.jrag
  	public void Program.initErrHandling(Collection err, Collection warn) {
  		err.clear();
  		warn.clear();
  		
  		for (Object node : getCompilationUnitList()) {
  			CompilationUnit cu = (CompilationUnit) node;
  			if(cu.fromSource()) {
  				cu.initErrHandling();
  			}
  		}
  	}
  	public void CompilationUnit.initErrHandling() {
  		errors.clear();
  		warnings.clear();
  	}
  	public void ModuleCompilationUnit.initErrHandling() {
  		errors.clear();
  		warnings.clear();
		for (CompilationUnit cu : getCompilationUnitList()) {
			cu.initErrHandling();
		}  		
  	}

  	public void Program.collectModuleErrors(Collection err) {
  		for (Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
  			CompilationUnit cu = (CompilationUnit)iter.next();
  			if(cu.fromSource()) {
  				cu.collectModuleErrors(err);
  			}
  		}
  	}
  	public void CompilationUnit.collectModuleErrors(Collection err) {
  		err.addAll(errors);
  	}

	//used in some asserts  	
  	protected boolean Program.errorsFound = false;
  	public boolean Program.errorsFound() {
  		 return this.errorsFound;
  	}
  	public void Program.setErrorsFound(boolean b) {
  		this.errorsFound = b;
  	}
  	refine ErrorCheck public void ASTNode.error(String s) {
  		ErrorCheck.ASTNode.error(s);
  		
		ASTNode node = this;
		while(node != null && !(node instanceof Program)) {
			node = node.getParent();
		}
		Program program = (Program) node;
		program.setErrorsFound(true);
  	}
  	
  	//Single error checks, done before CU insertions/generatOwn
  	public void ASTNode.checkModuleErrorsPass1() {
  		checkModuleDecls();
  		//checkModulePackageDecls();
  		checkModuleCycles();
  		checkDuplicateModuleNames();
  		checkExtendsCycles();
  	
		for (int i = 0 ; i < getNumChild(); i++) {
			getChild(i).checkModuleErrorsPass1();
		}
  	}
  	//STANDING NOTE: Cut off errorcheck at CompilationUnit/ModuleCompilationUnit children
  	//so that the rewrites are not triggered
  	public void CompilationUnit.checkModuleErrorsPass1() {
  		checkModuleDecls();
  		//checkModulePackageDecls();
  		checkModuleCycles();
  		checkDuplicateModuleNames();
  		checkExtendsCycles();

		if (getModuleDecl() != null) {
			getModuleDecl().checkModuleErrorsPass1();  	
		}
  	}
  	
  	//CU module access lookup checks 
  	public void ASTNode.checkModuleDecls() {}
  	//This must be called before the CUs are rearranged by InsertModuleCUs
  	public void CompilationUnit.checkModuleDecls() {
  		if (getModuleDecl() != null && lookupModuleCUNoTransform() == null) {
  			getModuleDecl().getModuleAccess().error("Module not found: " + getModuleDecl().getModuleAccess().getID()); 
  		} 
  	}
  	public void ModuleCompilationUnit.checkModuleDecls() {
  		if (getModuleDecl().hasExtends() && 
  				getHostProgram().lookupModuleCUNoTransform(getModuleDecl().getExtends()) == null) {
  			getModuleDecl().getExtends().error("Module not found: " + getModuleDecl().getExtends().getID());
  		}
  	}
  	
  	//CU package decl (if a module is defined, then a package shouldn't be defined (and vice versa)
  	//unused for now
  	public void ASTNode.checkModulePackageDecls() {}
  	public void CompilationUnit.checkModulePackageDecls() {
  		if (!getPackageDecl().equals("") && getModuleDecl() != null) {
  			getModuleDecl().error("A module declaration cannot be used if there is a package declaration on the compilation unit.");
  		}
  	}
  	
	//Cyclic imports
	public void ASTNode.checkModuleCycles() {}
	public void ModuleCompilationUnit.checkModuleCycles() {
		LinkedList<ImportedModule> visited = new LinkedList<ImportedModule>();
		visited.add(new ImportedModule(this, new AsTypeNone(), new ModuleImportTypeNorm()));
		checkModuleCycles(visited);
	}
	public boolean ModuleCompilationUnit.checkModuleCycles(LinkedList<ImportedModule> visited) {
		boolean noCycles = true;
		
		if (getCycleType(visited) == CycleType.BAD_CYCLE) {
			noCycles = false;
			String cycleStr = "";
			boolean first = true;
			for (ImportedModule cycleMember : visited) {
				if (!first) {
					cycleStr += ", ";
				}
				if (cycleMember.getModuleImportType() instanceof ModuleImportTypeOwn) {
					cycleStr += "own ";
				}
				cycleStr += cycleMember.getModuleCU().getModuleName();
				first = false;
			}
			getModuleDecl().error("Bad import cycle found: " + cycleStr);
			throw new jastadd.UnrecoverableSemanticError("Bad import cycle found: " + cycleStr);
		} else if (getCycleType(visited) == CycleType.CYCLE) {
			return true;
		}
		
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (member instanceof ModuleImportDecl) {
				ModuleImportDecl importDecl = (ModuleImportDecl) member;
				ModuleCompilationUnit importedCU = getHostProgram().lookupModuleCUNoTransform(importDecl.getImportModule());
				if (importedCU == null) { //when the imported module does not exist
					continue;
				}
				if (importedCU == this) {
					importDecl.error("Module imports itself: " + this.getModuleName());
					throw new jastadd.UnrecoverableSemanticError("Module imports itself: " + this.getModuleName());
				}
				LinkedList<ImportedModule> newVisited = new LinkedList<ImportedModule>(visited);
				newVisited.add(new ImportedModule(importedCU, importDecl.getAsType(), importDecl.getModuleImportType()));
				noCycles = importedCU.checkModuleCycles(newVisited);
				if (noCycles == false) {
					return noCycles;
				}
			}
		}
		
		return noCycles;
	}

	//check if the visited path is a bad cycle	
	public CycleType ModuleCompilationUnit.getCycleType(LinkedList<ImportedModule> visited) {
		boolean isBadCycle = false; //true if a member of the cycle is an own type (ModuleImportTypeOwn)
		HashSet<ModuleCompilationUnit> prev = new HashSet<ModuleCompilationUnit>();
		for (Iterator<ImportedModule> iter = visited.iterator(); iter.hasNext(); ) {
			ImportedModule importedModule = iter.next();
			if (importedModule.getModuleImportType() instanceof ModuleImportTypeOwn) {
				isBadCycle = true;
			}
			if (prev.contains(importedModule.getModuleCU())) {
				return isBadCycle? CycleType.BAD_CYCLE : CycleType.CYCLE;
			}
			prev.add(importedModule.getModuleCU());
		}
		return CycleType.NO_CYCLE;
	}
	
	public void ASTNode.checkDuplicateModuleNames() {
	}
	public void ModuleCompilationUnit.checkDuplicateModuleNames() {
		for (String name : getHostProgram().getModuleNames()) {
			if (this.getModuleName().compareTo(name) == 0) {
			getModuleDecl().error("Duplicate module name: " + this.getModuleName());
			throw new jastadd.UnrecoverableSemanticError("Duplicate module name: " + this.getModuleName());
			}
		}
		getHostProgram().getModuleNames().add(this.getModuleName());
	}

	protected Set<String> Program.moduleNames = new HashSet();
	public Set<String> Program.getModuleNames() {
		return this.moduleNames;
	}
	
	
	//refines/implements
	//from Java1.4Frontend/ErrorCheck.jrag
	public void ModuleCompilationUnit.collectErrors() {
		nameCheck();
		typeCheck();
		accessControl();
		exceptionHandling();
		checkUnreachableStmt();
		definiteAssignment();
		checkModifiers();
		
		getModuleDecl().collectErrors();
		getModuleMemberDeclList().collectErrors();
		//Don't go down into child CUs, compilationUnitIterator will go through them anyway
	}
	
}
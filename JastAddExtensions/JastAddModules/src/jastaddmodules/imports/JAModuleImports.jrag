
aspect JAModuleImports {

	//from Java1.5Backend/StaticImports.jrag
	refine StaticImports public void SingleStaticImportDecl.typeCheck() {
		StaticImports.SingleStaticImportDecl.typeCheck();
	}

	
	
	refine NameCheck public void SingleTypeImportDecl.nameCheck() {
		if(!getAccess().type().globalTypeName().equals(globalTypeName()) &&
				!getAccess().type().isUnknown()) {
			error("Single-type import " + typeName() + " is not the canonical name of type " + getAccess().type().typeName());
		}
		else if(allImportedTypes(getAccess().type().name()).size() > 1) {
			error(getAccess().type().name() + " is imported multiple times");
		}
	}

	refine NameCheck public void TypeImportOnDemandDecl.nameCheck() {
		if(getAccess().lastAccess().isTypeAccess() && !getAccess().type().globalTypeName().equals(globalTypeName())) {
			error("On demand type import " + typeName() + ".* is not the canonical name of type " + getAccess().type().typeName());
		}
	}

	inh CompilationUnit TypeImportOnDemandDecl.compilationUnit();
	refine LookupType eq TypeImportOnDemandDecl.importedTypes(String name) {
		SimpleSet set = SimpleSet.emptySet;
		if(getAccess() instanceof PackageAccess) {
			String rawPackageName = ((PackageAccess)getAccess()).getPackage();
			//if in a module, lookup the global package name
			ModuleCompilationUnit mcu = compilationUnit().getModuleCompilationUnit();
			Set<String> packageNames = new HashSet();
			if (mcu != null) {
				//try to find a package in a module. if none, continue with the old value
				packageNames = mcu.lookupPackage(rawPackageName, mcu);
				if (packageNames.isEmpty()) {
					packageNames.add(rawPackageName);
				}
			} else {
				packageNames.add(rawPackageName);
			}
			
			for (String packageName : packageNames) {
				TypeDecl typeDecl = lookupType(packageName, name);
				if(typeDecl != null && typeDecl.accessibleFromPackage(packageName()) &&
						typeDecl.typeName().equals(packageName + "." + name)) {// canonical names match
					set = set.add(typeDecl);
				}
			}
		}
		else {
			for(Iterator iter = getAccess().type().memberTypes(name).iterator(); iter.hasNext(); ) {
				TypeDecl decl = (TypeDecl)iter.next();
				if(decl.accessibleFromPackage(packageName()) &&
						decl.typeName().equals(getAccess().globalTypeName() + "." + name)) {// canonical names match
					set = set.add(decl);
				}
			}
		}
		return set;
	}

}

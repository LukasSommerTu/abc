//STANDING NOTE: Make VERY sure that all JAModule passes DO NOT 
//TOUCH any AST nodes below CompilationUnit to avoid the REWRITES

aspect ModuleCompilationUnit {

	//adapted from ASTGrammar.jrag
	refine ASTGrammar public void Program.addSourceFile(String name) {
		if(name.endsWith(".module")) {
			loadModuleFile(name);
		}
		else {
			ASTGrammar.Program.addSourceFile(name);
		}
	}

	public void Program.loadModuleFile(String name) {
		try {
			File inFile = new File(name);
			FileInputStream is = new FileInputStream(inFile);
			scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
			scanner.enterJastAdd();
			CompilationUnit cu = (CompilationUnit)new parser.JavaParser().parse(scanner, parser.JavaParser.AltGoals.jamodule_compilation_unit);
			scanner.previousState();
			is.close();
			cu.setFromSource(true);
			cu.setRelativeName(name);
			cu.setPathName(inFile.getAbsolutePath());
			addCompilationUnit(cu);
		} catch (Exception e) {
			throw new Error(e.getMessage());
		}
	}
	
	
	//TODO: Would be better if ModuleDecl was a subtype of a PackageDecl 
	//(except PackageDecl has no AST type). See if worth changing.
	//TODO: This is broken, since non-list ast nodes don't do addChild as expected
	ModuleDecl CompilationUnit.moduleDecl;
	
	public ModuleDecl CompilationUnit.getModuleDecl() {
		return this.moduleDecl;
	} 
	public void CompilationUnit.setModuleDecl(ModuleDecl decl) {
		this.moduleDecl = decl;
	}
	
	//NOTE: Keep this non-lazy, as this is called both before and after
	//InsertModuleCUs 
	syn ModuleCompilationUnit ASTNode.lookupModuleCUNoTransform(ModuleAccess access) {
		if (access == null) {
			return null;
		}
		ModuleCompilationUnit ret = null;
		for (int i = 0 ; i < getNumChild(); i++) {
			ret = getChild(i).lookupModuleCUNoTransform(access);
			if (ret != null) {
				return ret;
			}
		}
		return ret;
	}
	syn ModuleCompilationUnit CompilationUnit.lookupModuleCUNoTransform(ModuleAccess access) {
		return null;
	}
	syn ModuleCompilationUnit ModuleCompilationUnit.lookupModuleCUNoTransform(ModuleAccess access) {
		if (access == null) {
			return null;
		}
		ModuleCompilationUnit ret = null;
		for (int i = 0 ; i < getNumChild(); i++) {
			ret = getChild(i).lookupModuleCUNoTransform(access);
			if (ret != null) {
				return ret;
			}
		}
		return ret;
	}
	syn ModuleCompilationUnit ModuleDecl.lookupModuleCUNoTransform(ModuleAccess access) {
		if (getModuleAccess().getID().equals(access.getID())) {
			return getModuleCompilationUnit();
		} else {
			return null;
		}
	}
	public ModuleCompilationUnit CompilationUnit.lookupModuleCUNoTransform() {
		if (this.getModuleDecl() == null) {
			return null;
		}
		return getHostProgram().lookupModuleCUNoTransform(this.getModuleDecl().getModuleAccess());
	}
	public ModuleCompilationUnit Program.lookupModuleCUNoTransform(String moduleName) {
		return this.lookupModuleCUNoTransform(new ModuleAccess(moduleName));
	}
	
	public boolean CompilationUnit.isInJAModule() {
		return (this.lookupModuleCUNoTransform() != null);
	}
	
	eq Program.getChild(int index).getHostProgram() = this;
	inh Program CompilationUnit.getHostProgram();
	
	eq Program.getChild(int index).getModuleCompilationUnit() = null;
	syn ModuleCompilationUnit ModuleCompilationUnit.getModuleCompilationUnit() = this;
	eq ModuleCompilationUnit.getChild(int index).getModuleCompilationUnit() = this;
	inh ModuleCompilationUnit ModuleDecl.getModuleCompilationUnit();
	inh ModuleCompilationUnit ModuleAccess.getModuleCompilationUnit();
	inh ModuleCompilationUnit CompilationUnit.getModuleCompilationUnit();
	
	//TODO: check if cached result remains consistent (don't call before all CUs have been parsed
	syn lazy boolean Program.hasJAModules() {
		for (Iterator iter = compilationUnitIterator(); iter.hasNext();) {
			if (iter.next() instanceof ModuleCompilationUnit) {
				return true;
			}
		}
		return false;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.baseCU = null;
	public void ModuleCompilationUnit.setBaseCU(ModuleCompilationUnit baseCU) {
		this.baseCU = baseCU;
	}
	public ModuleCompilationUnit ModuleCompilationUnit.getBaseCU() {
		return this.baseCU;
	}
	
	
	public void ModuleCompilationUnit.setModuleName(String name) {
		getModuleDecl().getModuleAccess().setID(name);
	}
	public String ModuleCompilationUnit.getModuleName() {
		return getModuleDecl().getModuleAccess().getID();
	}

	//String is the local alias of the imported CU
	protected HashMap<String, ModuleCompilationUnit> ModuleCompilationUnit.importedModules = new HashMap<String, ModuleCompilationUnit>();
	public void ModuleCompilationUnit.setImportedModules(HashMap<String, ModuleCompilationUnit> modules) {
		this.importedModules = modules;
	}
	public void ModuleCompilationUnit.addImportedModule(String alias, ModuleCompilationUnit cu) {
		importedModules.put(alias, cu);
	}
	public ModuleCompilationUnit ModuleCompilationUnit.removeImportedModule(String alias) {
		return importedModules.remove(alias);
	}
	public ModuleCompilationUnit ModuleCompilationUnit.removeImportedModule(ModuleCompilationUnit cu) {
		return importedModules.remove(getImportedModuleAlias(cu));
	}
	public String ModuleCompilationUnit.getImportedModuleAlias(ModuleCompilationUnit cu) {
		for (String key : importedModules.keySet()) {
			if (cu == importedModules.get(key)) {
				return key;
			}
		}
		return null;
	}
	public Map<String, ModuleCompilationUnit> ModuleCompilationUnit.getImportedModuleMap() {
		return importedModules;
	}
	public ModuleCompilationUnit ModuleCompilationUnit.getImportedModule(String name) {
		return importedModules.get(name);
	}

	//a module is an instance module if it was created from a base module
	//base modules are the ones directly generated by the parser
	public boolean ModuleCompilationUnit.isInstance() {
		return this.instanceContext.size() > 0;
	}
	//the context of the instance are the modules that can directly access the module
	protected HashSet<ModuleCompilationUnit> ModuleCompilationUnit.instanceContext = 
		new HashSet<ModuleCompilationUnit>();
	public void ModuleCompilationUnit.setInstanceContext(HashSet<ModuleCompilationUnit> context) {
		this.instanceContext = context;
	} 
	public void ModuleCompilationUnit.addInstanceContext(ModuleCompilationUnit context) {
		this.instanceContext.add(context);
	}
	public boolean ModuleCompilationUnit.removeInstanceContext(ModuleCompilationUnit context) {
		return this.instanceContext.remove(context);
	}
	public void ModuleCompilationUnit.isInInstanceContext(ModuleCompilationUnit context) {
		this.instanceContext.contains(context);
	}
	public HashSet<ModuleCompilationUnit> ModuleCompilationUnit.getInstanceContext() {
		return this.instanceContext;
	}
	
	protected boolean ModuleCompilationUnit.isExported = true;
	public boolean ModuleCompilationUnit.isExported() {
		return isExported;
	}
	public void ModuleCompilationUnit.setIsExported(boolean b) {
		this.isExported = b;
	}
	
	public ModuleCompilationUnit ModuleAccess.lookupModule() {
		ModuleCompilationUnit context = getModuleCompilationUnit();
		if (context == null) {
			return null;
		}
		return context.lookupModule(this.getID());
	}
	public ModuleCompilationUnit ModuleCompilationUnit.lookupModule(String name) {
		return lookupModule(this, name);
	}
	syn lazy ModuleCompilationUnit ModuleCompilationUnit.lookupModule(ModuleCompilationUnit originalContext, String name) {
		//matching is greedy. Find the longest match first, try it and return if a match was found
		SortedSet<String> localAliases = new TreeSet<String>(new Comparator<String>() {
			public int compare(String x, String y) {
				if (x.length() != y.length()) {
					return y.length() - x.length();
				}
				return x.compareTo(y);
			}
		});
		localAliases.addAll(getImportedModuleMap().keySet());
		for (String alias : localAliases) {
			//if alias cannot be a qualifier, proceed to next
			if (!name.startsWith(alias)) {
				continue;
			}
			//if equal match and is visible from the original context, return entry
			//it is visible from the original context iff:
			//	the original context is the same as the current context (i.e. it is a direct import) or
			//	the import was exported
			if (name.equals(alias)) {
				if (originalContext == this) {
					return getImportedModule(alias);
				} else {
					if (getImportedModule(name).isExported()) {
						return getImportedModule(alias);
					}
				}
				continue;
			}
			//check if alias is a qualifier, then lookup in the module
			String trimmedName = name.substring(alias.length());
			if (!trimmedName.startsWith(".")) {
				continue;
			}
			trimmedName = trimmedName.substring(1);
			ModuleCompilationUnit ret = getImportedModule(alias).lookupModule(originalContext, trimmedName);
			if (ret != null) {
				return ret;
			}
		}
		return null;
	}
	

}
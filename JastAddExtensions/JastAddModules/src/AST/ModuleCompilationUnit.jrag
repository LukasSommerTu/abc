
aspect ModuleCompilationUnit {

	//adapted from ASTGrammar.jrag
	refine ASTGrammar public void Program.addSourceFile(String name) {
		if(name.endsWith(".module")) {
			loadModuleFile(name);
		}
		else {
			ASTGrammar.Program.addSourceFile(name);
		}
	}

	public void Program.loadModuleFile(String name) {
		try {
			File inFile = new File(name);
			FileInputStream is = new FileInputStream(inFile);
			scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
			scanner.enterJastAdd();
			CompilationUnit cu = (CompilationUnit)new parser.JavaParser().parse(scanner, parser.JavaParser.AltGoals.jamodule_compilation_unit);
			scanner.previousState();
			is.close();
			cu.setFromSource(true);
			cu.setRelativeName(name);
			cu.setPathName(inFile.getAbsolutePath());
			addCompilationUnit(cu);
		} catch (Exception e) {
			throw new Error(e.getMessage());
		}
	}
	
	refine ASTGrammar private void Program.loadASTFile(String name) {
		try {
			File inFile = new File(name);
			FileInputStream is = new FileInputStream(inFile);
			
			//parse AST file
			scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
			scanner.enterJastAdd();
			CompilationUnit cu = (CompilationUnit)new parser.JavaParser().parse(scanner, parser.JavaParser.AltGoals.ast_file);
			scanner.previousState();
			is.close();
			cu.setPathName(inFile.getAbsolutePath());
			cu.setRelativeName(name);
			
			//generate ASTNode CUs
			List importList = cu.getImportDeclList();
			for(int i = 0; i < cu.getTypeDeclList().getNumChild(); i++) {
				TypeDecl typeDecl = (TypeDecl)cu.getTypeDeclList().getChildNoTransform(i);
				CompilationUnit unit = new CompilationUnit(
					cu.getPackageDecl(),
					(List)importList.fullCopy(),
					new List().add(typeDecl)
				);
				unit.setFromSource(true);
				unit.setRelativeName(name);
				unit.setPathName(".");
				 
				//NEIL: Added modules for generated AST files
				unit.setOrigASTCompilationUnit(cu);
				if (cu.getModuleDecl() != null) {
					unit.setModuleDecl(cu.getModuleDecl());
					unit.addChild(cu.getModuleDecl());
				}
				
				addCompilationUnit(unit);
			}
		} catch (Exception e) {
			throw new Error(e.getMessage());
		}
	}
	
	//TODO: Would be better if ModuleDecl was a subtype of a PackageDecl 
	//(except PackageDecl has not AST type). See if worth changing.
	ModuleDecl CompilationUnit.moduleDecl;
	
	public ModuleDecl CompilationUnit.getModuleDecl() {
		return this.moduleDecl;
	} 
	public void CompilationUnit.setModuleDecl(ModuleDecl decl) {
		this.moduleDecl = decl;
	}
	
	//TODO: Change when moduleCU is inserted above the normal CUs
	//may be too expensive to cache 
	syn lazy ModuleCompilationUnit ASTNode.lookupModuleCU(ModuleAccess access) {
		if (access == null) {
			return null;
		}
		ModuleCompilationUnit ret = null;
		for (int i = 0 ; i < getNumChild(); i++) {
			ret = getChild(i).lookupModuleCU(access);
			if (ret != null) {
				return ret;
			}
		}
		return ret;
	}
	syn lazy ModuleCompilationUnit CompilationUnit.lookupModuleCU(ModuleAccess access) {
		return null;
	}
	syn lazy ModuleCompilationUnit ModuleCompilationUnit.lookupModuleCU(ModuleAccess access) {
		if (access == null) {
			return null;
		}
		ModuleCompilationUnit ret = null;
		for (int i = 0 ; i < getNumChild(); i++) {
			ret = getChild(i).lookupModuleCU(access);
			if (ret != null) {
				return ret;
			}
		}
		return ret;
	}
	syn lazy ModuleCompilationUnit ModuleDecl.lookupModuleCU(ModuleAccess access) {
		if (getModuleAccess().getID().compareTo(access.getID()) == 0) {
			return getModuleCompilationUnit();
		} else {
			return null;
		}
	}
	public ModuleCompilationUnit CompilationUnit.lookupModuleCU() {
		if (this.getModuleDecl() == null) {
			return null;
		}
		return getHostProgram().lookupModuleCU(this.getModuleDecl().getModuleAccess());
	}
	//TODO: Fix this hack when the modulename stabilizes
	public ModuleCompilationUnit Program.lookupModuleCU(String moduleName) {
		return this.lookupModuleCU(new ModuleAccess(moduleName));
	}
	public boolean CompilationUnit.isInJAModule() {
		return (this.lookupModuleCU() != null);
	}
	
	eq Program.getChild(int index).getHostProgram() = this;
	inh Program CompilationUnit.getHostProgram();
	
	eq Program.getChild(int index).getModuleCompilationUnit() = null;
	eq ModuleCompilationUnit.getChild(int index).getModuleCompilationUnit() = this;
	inh ModuleCompilationUnit ModuleDecl.getModuleCompilationUnit();
	inh ModuleCompilationUnit ModuleAccess.getModuleCompilationUnit();
	
	protected CompilationUnit CompilationUnit.origASTCompilationUnit = null;
	public CompilationUnit CompilationUnit.getOrigASTCompilationUnit() {
		return this.origASTCompilationUnit;
	}
	public void CompilationUnit.setOrigASTCompilationUnit(CompilationUnit astCU) {
		this.origASTCompilationUnit = astCU;
	}
	public boolean CompilationUnit.isGeneratedFromAST() {
		return (this.origASTCompilationUnit != null);
	}
	
	//TODO: check if cached result remains consistent (don't call before all CUs have been parsed
	syn lazy boolean Program.hasJAModules() {
		for (Iterator iter = compilationUnitIterator(); iter.hasNext();) {
			if (iter.next() instanceof ModuleCompilationUnit) {
				return true;
			}
		}
		return false;
	}
}
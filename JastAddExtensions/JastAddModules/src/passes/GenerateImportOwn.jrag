import java.util.*;

//generates module CUs and clones subtrees as necessary
//for import owns. Is done after InsertModuleCUs
aspect GenerateImportOwn {

	ModuleCompilationUnit Program.instanceModule = null;
	
	public ModuleCompilationUnit Program.getInstanceModuleCU() {
		return this.instanceModule;
	}
	public void Program.setInstanceModuleCU(ModuleCompilationUnit instanceModule) {
		this.instanceModule = instanceModule;
	}

	public boolean Program.generateImportOwn() {
		if (!hasJAModules()) {
			return true;
		}
		if (!options().hasOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION) || 
			!options().hasValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION)) {
			System.out.println(jastadd.JastAddModules.INSTANCE_MODULES_OPTION + 
				" option is required when there are JA modules in the set of compilation units");
			return false; 
		}
		
		String instanceModuleName = options().getValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION);
		this.setInstanceModuleCU(lookupModuleCUNoTransform(instanceModuleName));
		if (this.instanceModule == null) {
			System.out.println("Instance module " + instanceModuleName + " not found.");
			return false;
		}
		
		//generate import owns starting from the instance module
		getInstanceModuleCU().generateImportOwn(null);
		
		return true;
	}

	//context is non-null if the import is an own. If non-null, it creates a new module cu
	//if context is null, it is implicitly exported (i.e. it is one of the base modules
	//and is visible). If not, then it is not exported (i.e. it was generated from an import own
	//statement with no export)	
	syn lazy ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context) {
		if (context == null) {
			return generateImportOwn(context, "", true);
		} else {
			return generateImportOwn(context, createOwnName(context, this.getModuleName()), false);
		}
	}
	syn lazy ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context, String alias, boolean isExported) {
		ModuleCompilationUnit ret = null;
		//if instance module, don't reinstantiate
		if (context == null) {
			ret = this;
		} else {
			ret = instantiateModuleAs(context, alias); 
			ret.addInstanceContext(context);
		}
		ret.setIsExported(isExported);
		
		//process imports
		ret = generateImportCUs(ret);
		
		//process merges
		ret = generateMergeCUs(ret);
		
		return ret;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.generateImportCUs(ModuleCompilationUnit ret) {
		assert (ret != null) : "ModuleCompilationUnit parameter should not be null";
		
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (!(member instanceof ModuleImportDecl)) {
				continue;
			}
			ModuleImportDecl importDecl = (ModuleImportDecl) member;
			
			ModuleCompilationUnit currImport = null; 
			currImport = getHostProgram().lookupModuleCUNoTransform(importDecl.getImportModule());
			if (currImport == null) {
				importDecl.getImportModule().error("Unable to find module: " + importDecl.getImportModule().getID());
				throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + importDecl.getImportModule().getID());
			}
			
			boolean instantiated = false;
			String localAccessName = currImport.getModuleName();
			if (importDecl.isOwnImport()) {
				ModuleCompilationUnit instanceCU = null;
				instantiated = true;
				//if no export name, generate M$M' name
				if (importDecl.getAsType() instanceof AsTypeNone) {
					instanceCU = currImport.generateImportOwn(ret);
				} else {
					localAccessName = importDecl.getAsModule().getID();
					if (importDecl.getAsType() instanceof AsTypeOwn) {
						instanceCU = currImport.generateImportOwn(ret, createOwnName(ret, importDecl.getAsModule().getID()), false);
					} else if (importDecl.getAsType() instanceof AsTypeExport) {
						instanceCU = currImport.generateImportOwn(ret, createExportName(ret, importDecl.getAsModule().getID()), true);
					}
				}
				instanceCU.setBaseCU(currImport.getBaseCU());
				currImport = instanceCU;
			} else {
				//generate from a null context
				currImport = currImport.generateImportOwn(null);
			}
			assert (currImport != null) : "Imported module not instantiated";
			
			ret.checkedAddImportedModule(localAccessName, currImport);
			if (instantiated) {
				getHostProgram().getCompilationUnitList().addChild(currImport);			
			}
		}
		return ret;
	}
	
	protected ModuleCompilationUnit ModuleCompilationUnit.generateMergeCUs(ModuleCompilationUnit ret) {
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (!(member instanceof ModuleMergeDecl)) {
				continue;
			}
			ModuleMergeDecl mergeMember = (ModuleMergeDecl)member; 
			//lookup merge targets
			Collection<ModuleCompilationUnit> mergeTargets = new HashSet<ModuleCompilationUnit>();
			ModuleCompilationUnit mergeBaseCU = null; //used in check for base cu compatibility
			for (ModuleAccess access : mergeMember.getMergeModuleList()) {
				ModuleCompilationUnit cu = access.lookupModule(); //TODO: Check if it is correct to make lookupModule() lazy
				
				if (cu == null) {
					access.error("Unable to find module: " + access.getID()); 
					throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + access.getID());
				}
				
				if (mergeBaseCU != null && cu.getBaseCU() != mergeBaseCU) {
					access.error("Incompatible modules in merge list: " + mergeBaseCU.getModuleName() + ", " + cu.getModuleName());
					throw new jastadd.UnrecoverableSemanticError("Incompatible modules in merge list");
				}
				
				mergeTargets.add(cu);
				mergeBaseCU = cu.getBaseCU();
			}
			//create result copy (instantiate from the base types of the merge targets with ret as a context)
			ModuleCompilationUnit mergedCU = null;
			String mergeAlias = mergeMember.getAsModule().getID();
			if (mergeMember.getAsType() instanceof AsTypeOwn) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createOwnName(ret, mergeAlias), false);
			} else if (mergeMember.getAsType() instanceof AsTypeExport) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createExportName(ret, mergeAlias), true);
			}
			getHostProgram().getCompilationUnitList().addChild(mergedCU);
			
			//foreach merge target
			for (ModuleCompilationUnit mergeTargetCU : mergeTargets) {
			//	foreach context member of the merge target
				for (ModuleCompilationUnit instanceContextCU: mergeTargetCU.getInstanceContext()) {
			//		detach the merge target from the context member's import list
					String oldAlias = instanceContextCU.getImportedModuleAlias(mergeTargetCU);
					assert (oldAlias != null) : "Unable to find old alias";
					instanceContextCU.removeImportedModule(oldAlias);
			//		detach the mergeTargetCU from the compilationUnit list of the instancecontext
					int mergeTargetCUIndex = getHostProgram().getCompilationUnitList().getIndexOfChild(mergeTargetCU);
					getHostProgram().getCompilationUnitList().removeChild(mergeTargetCUIndex);
			//		attach the result copy to the context member's import list (use the old alias)
					if (ret != instanceContextCU) {
						instanceContextCU.checkedAddImportedModule(oldAlias, mergedCU);
					}
			//		add the context member to the result copy's instance context
					mergedCU.addInstanceContext(instanceContextCU);
				}
			//	detach the merge target from ret's import list
				if (ret.getImportedModuleMap().values().contains(mergeTargetCU)) {
					ret.removeImportedModule(mergeTargetCU);
				}
			}
			//attach the result copy to ret's import list
			ret.checkedAddImportedModule(mergeAlias, mergedCU);
		}
		return ret;
	}
	
	
	
	//create a new ModuleCompilationUnit from the current one, using the given alias.
	//Context will be for generating links in the accessibility graph
	syn lazy ModuleCompilationUnit ModuleCompilationUnit.instantiateModuleAs(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		
		ret = this.fullCopy();
		
		//clear ITDs
		ret.setImportedModules(new HashMap<String, ModuleCompilationUnit>());
		ret.setInstanceContext(new HashSet<ModuleCompilationUnit>());
		
		ret.setModuleName(alias);
		
		return ret;
	}
	
	public String ModuleCompilationUnit.createExportName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "." + alias;
	}
	public String ModuleCompilationUnit.createOwnName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "$" + alias;
	}
	
	public void ModuleCompilationUnit.checkedAddImportedModule(String alias, ModuleCompilationUnit cu) {
		if (getImportedModule(alias) != null) {
			getModuleDecl().error("Ambiguous module name " + alias + " in module " + this.getModuleName());
			//throw new jastadd.UnrecoverableSemanticError("Ambiguous alias " + alias + " in module " + this.getModuleName());
		}
		addImportedModule(alias, cu);
	}
}
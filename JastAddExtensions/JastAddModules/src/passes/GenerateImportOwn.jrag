import java.util.*;

//generates module CUs and clones subtrees as necessary
//for import owns. Is done after InsertModuleCUs
aspect GenerateImportOwn {

	ModuleCompilationUnit Program.instanceModule = null;
	
	public ModuleCompilationUnit Program.getInstanceModuleCU() {
		return this.instanceModule;
	}
	public void Program.setInstanceModuleCU(ModuleCompilationUnit instanceModule) {
		this.instanceModule = instanceModule;
	}

	public boolean Program.generateImportOwn() {
		if (!hasJAModules()) {
			return true;
		}
		if (!options().hasOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION) || 
			!options().hasValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION)) {
			error(jastadd.JastAddModules.INSTANCE_MODULES_OPTION + 
				" option is required when there are JA modules in the set of compilation units");
			return false; 
		}
		
		String instanceModuleName = options().getValueForOption(jastadd.JastAddModules.INSTANCE_MODULES_OPTION);
		this.setInstanceModuleCU(lookupModuleCUNoTransform(instanceModuleName));
		if (this.instanceModule == null) {
			error("Instance module " + instanceModuleName + " not found.");
			return false;
		}
		
		//generate import owns starting from the instance module
		getInstanceModuleCU().generateImportOwn(null);
		
		return true;
	}

	//context is non-null if the import is an own. If non-null, it creates a new module cu	
	public ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context) {
		if (context == null) {
			return generateImportOwn(context, "");
		} else {
			return generateImportOwn(context, createOwnName(context, this.getModuleName()));
		}
	}
	public ModuleCompilationUnit ModuleCompilationUnit.generateImportOwn(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		//if instance module, don't reinstantiate
		if (context == null) {
			ret = this;
		} else {
			ret = instantiateModuleAs(context, alias); 
			ret.addInstanceContext(context);
		}
		
		//process imports
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (!(member instanceof ModuleImportDecl)) {
				continue;
			}
			ModuleImportDecl importDecl = (ModuleImportDecl) member;
			
			ModuleCompilationUnit currImport = null; 
			currImport = getHostProgram().lookupModuleCUNoTransform(importDecl.getImportModule());
			if (currImport == null) {
				importDecl.getImportModule().error("Unable to find module: " + importDecl.getImportModule().getID());
				throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + importDecl.getImportModule().getID());
			}
			
			boolean instantiated = false;
			String localAccessName = currImport.getModuleName();
			if (importDecl.isOwnImport()) {
				ModuleCompilationUnit instanceCU = null;
				instantiated = true;
				//if no export name, generate MfromM' name
				if (importDecl.getExportModule() instanceof NullModuleAccess) {
					instanceCU = currImport.generateImportOwn(ret);
				} else {
					//export names have an implicit qualifier
					instanceCU = currImport.generateImportOwn(ret, createExportName(ret, importDecl.getExportModule().getID()));
				} 
				instanceCU.setBaseCU(currImport.getBaseCU());
				currImport = instanceCU;
			} else {
				//generate from a null context
				currImport = currImport.generateImportOwn(null);
			}
			assert (currImport != null) : "Imported module not instantiated";
			
			ret.addImportedModule(localAccessName, currImport);
			if (instantiated) {
				getHostProgram().getCompilationUnitList().addChild(currImport);			
			}
		}
		
		//TODO: process merges
		for (ModuleMemberDecl member : getModuleMemberDeclList()) {
			if (!(member instanceof ModuleMergeDecl)) {
				continue;
			}
			ModuleMergeDecl mergeMember = (ModuleMergeDecl)member; 
			//lookup merge targets
			Collection<ModuleCompilationUnit> mergeTargets = new HashSet<ModuleCompilationUnit>();
			ModuleCompilationUnit mergeBaseCU = null; //used in check for base cu compatibility
			for (ModuleAccess access : mergeMember.getMergeModuleList()) {
				ModuleCompilationUnit cu = ret.getImportedModule(access.getID());
				
				if (cu == null) {
					access.error("Unable to find module: " + access.getID()); 
					throw new jastadd.UnrecoverableSemanticError("Unable to find module: " + access.getID());
				}
				
				if (mergeBaseCU != null && cu.getBaseCU() != mergeBaseCU) {
					access.error("Incompatible modules in merge list: " + mergeBaseCU.getModuleName() + ", " + cu.getModuleName());
					throw new jastadd.UnrecoverableSemanticError("Incompatible modules in merge list");
				}
				
				mergeTargets.add(cu);
				mergeBaseCU = cu.getBaseCU();
			}
			//create result copy (instantiate from the base types of the merge targets with ret as a context)
			ModuleCompilationUnit mergedCU = null;
			if (mergeMember.getMergeAsType() instanceof MergeAsTypeOwn) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createOwnName(ret, mergeMember.getAsModule().getID()));
			} else if (mergeMember.getMergeAsType() instanceof MergeAsTypeExport) {
				mergedCU = mergeBaseCU.generateImportOwn(ret, createExportName(ret, mergeMember.getAsModule().getID()));
			}
			//foreach merge target
			//	foreach context member of the merge target
			//		detach the merge target from the context member's import list
			//		attach the result copy to the context member's import list
			//		add the context member to the result copy's instance context
			//	detach the merge target from ret's import list
			//attach the result copy to ret's import list
			//add this instance to the result copy's instance context
		}
		
		return ret;
	}
	
	
	
	//create a new ModuleCompilationUnit from the current one, using the given alias.
	//Context will be for generating links in the accessibility graph
	public ModuleCompilationUnit ModuleCompilationUnit.instantiateModuleAs(ModuleCompilationUnit context, String alias) {
		ModuleCompilationUnit ret = null;
		
		//TODO: Make more efficient later (shallow copy first, then fill in with a fullcopy after full instantiation
		ret = this.fullCopy();
		
		//clear ITDs
		ret.setImportedModules(new HashMap<String, ModuleCompilationUnit>());
		ret.setInstanceContext(new HashSet<ModuleCompilationUnit>());
		
		ret.setModuleName(alias);
		
		//TODO: Change the import references in the context to point to the newly created module 
		
		return ret;
	}
	
	public String ModuleCompilationUnit.createExportName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "." + alias;
	}
	public String ModuleCompilationUnit.createOwnName(ModuleCompilationUnit context, String alias) {
		return context.getModuleName() + "$" + alias;
	}
}
aspect Liveness {
	
	public boolean Variable.isLiveIn(Block blk) {
		if(blk.getNumStmt() == 0)
			return false;
		return isLiveBetween(blk.getStmt(0), blk.getStmt(blk.getNumStmt()-1));
	}
	
	syn lazy boolean Variable.isLiveBetween(Stmt begin, Stmt end) circular [false] {
		if(begin.mayUse(this)) return true;
		if(begin.mayDef(this)) return false;
		if(begin == end) return false;
		for(Iterator i=begin.gsucc(begin, end).iterator();i.hasNext();) {
			Stmt next = (Stmt)i.next();
			if(isLiveBetween(next, end))
				return true;
		}
		return false;
	}
	
	syn lazy boolean Variable.isLiveAfter(Stmt stmt) circular [false] {
		Block host = stmt.hostBlock();
		for(Iterator i=stmt.following().iterator();i.hasNext();) {
			Stmt next = (Stmt)i.next();
			if(!next.between(host, -1, Integer.MAX_VALUE))
				continue;
			if(isLiveAtOrAfter(next))
				return true;
		}
		return false;
	}
	
	syn lazy boolean Variable.isLiveAtOrAfter(Stmt stmt) circular [false] {
		if(stmt.mayUse(this)) return true;
		if(stmt.mayDef(this)) return false;
		Block host = stmt.hostBlock();
		for(Iterator i=stmt.succ().iterator();i.hasNext();) {
			Stmt next = (Stmt)i.next();
			if(!next.between(host, -1, Integer.MAX_VALUE))
				continue;
			if(isLiveAtOrAfter(next))
				return true;
		}
		return false;
	}
	
	syn lazy boolean LocalDeclaration.mayDefBetween(Stmt begin, Stmt end) circular [false] {
		if(begin.mayDef(this)) return true;
		if(begin == end) return false;
		for(Iterator i=begin.gsucc(begin, end).iterator();i.hasNext();)
			if(mayDefBetween((Stmt)i.next(), end))
				return true;
		return false;
	}
	
	syn lazy boolean LocalDeclaration.accessedOutside(Stmt begin, Stmt end) = 
		accessedBefore(begin) || accessedAfter(end);
	
	syn lazy boolean LocalDeclaration.accessedBefore(Stmt stmt) circular [false] {
		for(Iterator i=stmt.pred().iterator();i.hasNext();) {
			Stmt before = (Stmt)i.next();
			if(!before.between(getBlock(), -1, Integer.MAX_VALUE))
				continue;
			if(before.mayAccess(this))
				return true;
			if(accessedBefore(before))
				return true;
		}
		return false;
	}
	
	syn lazy boolean LocalDeclaration.accessedAfter(Stmt stmt) circular [false] {
		for(Iterator i=stmt.succ().iterator();i.hasNext();) {
			Stmt next = (Stmt)i.next();
			if(!next.between(getBlock(), -1, Integer.MAX_VALUE))
				continue;
			if(next.mayAccess(this))
				return true;
			if(accessedAfter(next))
				return true;
		}
		return false;
	}
	
}
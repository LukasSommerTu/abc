aspect LocalAttributes {
  
  // this is a bit simpler for local attributes
  FieldDeclaration LocalSynDecl.generateBeginCache(List statements, TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f = generateCacheField(typeDecl, fieldName);
    if(getNumParameter() == 0) {
      FieldDeclaration computedFlag = fieldComputedFlag(typeDecl);
      FieldDeclaration value = fieldComputedValue(typeDecl);
 
      Stmt thenBranch =
        new Block(
          new List().add(
            debugPrint(name() + " cached for ")
          ).add(
            new ReturnStmt(
              value.createQualifiedBoundAccess()
            )
          )
        );

      // check whether the cache is valid
      Stmt ifStmt = 
        new IfStmt(computedFlag.createQualifiedBoundAccess(),
          thenBranch,
          new Opt()
        );
      statements.add(ifStmt);
    }
    else {
      // check whether the cache contains an entry for the current arguments,
      Stmt thenBlock =
        new Block(
          new List().add(
	    new ReturnStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "get",
                  new List().add(new VarAccess("args"))
                )
              )
            )
          )
        );
      Stmt outerIf =
        new IfStmt(
          f.createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "containsKey",
              new List().add(new VarAccess("args"))
            )
          ),
          thenBlock
        );
      statements.add(outerIf);
    }

    // print a debugging message
    statements.add(debugPrint("Recomputing " + name() + " for "));
    recordRewriteState(statements);

    return f;
  }

  void LocalSynDecl.generateEndCache(List statements, TypeDecl typeDecl, FieldDeclaration f) {
    Stmt thenBranch;
    Stmt elseBranch = null;
    if(getNumParameter() == 0) {
      thenBranch = new Block(
        new List().add(
          AssignExpr.asStmt(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
            new VarAccess("res")
          )
        ).add(
          AssignExpr.asStmt(
            fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
            new BooleanLiteral("true")
          )
        )
      );
    }
    else {
      thenBranch =
        new Block(
          new List().add(
            new ExprStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "put",
                  new List().add(new VarAccess("args")).add(new VarAccess("res"))
                )
              )
            )
          )
        );
    }
    conditionalOnRewrite(statements, thenBranch, elseBranch);
  }

  FieldDeclaration LocalSynDecl.generateCacheField(TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f = null;
    if(getNumParameter() != 0) {
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        new ParTypeAccess(
          new TypeAccess("java.util", "Map"),
          new List().add(
            new TypeAccess("java.lang", "Object")
          ).add(
            returnType.createQualifiedAccess()
          )
        ),
        fieldName,
        new ClassInstanceExpr(
          new ParTypeAccess(
            new TypeAccess("java.util", "HashMap"),
            new List().add(
              new TypeAccess("java.lang", "Object")
            ).add(
              returnType.createQualifiedAccess()
            )
          ),
          new List(),
          new Opt()
        )
      );
      f = typeDecl.addMemberField(f);
      typeDecl.addClearCode(f);
    }
    return f;
  }

/***DUPLICATED...***/

  FieldDeclaration LocalInhDecl.generateBeginCache(List statements, TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f = generateCacheField(typeDecl, fieldName);
    if(getNumParameter() == 0) {
      FieldDeclaration computedFlag = fieldComputedFlag(typeDecl);
      FieldDeclaration value = fieldComputedValue(typeDecl);
 
      Stmt thenBranch =
        new Block(
          new List().add(
            debugPrint(name() + " cached for ")
          ).add(
            new ReturnStmt(
              value.createQualifiedBoundAccess()
            )
          )
        );

      // check whether the cache is valid
      Stmt ifStmt = 
        new IfStmt(computedFlag.createQualifiedBoundAccess(),
          thenBranch,
          new Opt()
        );
      statements.add(ifStmt);
    }
    else {
      // check whether the cache contains an entry for the current arguments,
      Stmt thenBlock =
        new Block(
          new List().add(
	    new ReturnStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "get",
                  new List().add(new VarAccess("args"))
                )
              )
            )
          )
        );
      Stmt outerIf =
        new IfStmt(
          f.createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "containsKey",
              new List().add(new VarAccess("args"))
            )
          ),
          thenBlock
        );
      statements.add(outerIf);
    }

    // print a debugging message
    statements.add(debugPrint("Recomputing " + name() + " for "));
    recordRewriteState(statements);

    return f;
  }

  void LocalInhDecl.generateEndCache(List statements, TypeDecl typeDecl, FieldDeclaration f) {
    Stmt thenBranch;
    Stmt elseBranch = null;
    if(getNumParameter() == 0) {
      thenBranch = new Block(
        new List().add(
          AssignExpr.asStmt(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
            new VarAccess("res")
          )
        ).add(
          AssignExpr.asStmt(
            fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
            new BooleanLiteral("true")
          )
        )
      );
    }
    else {
      thenBranch =
        new Block(
          new List().add(
            new ExprStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "put",
                  new List().add(new VarAccess("args")).add(new VarAccess("res"))
                )
              )
            )
          )
        );
    }
    conditionalOnRewrite(statements, thenBranch, elseBranch);
  }

  FieldDeclaration LocalInhDecl.generateCacheField(TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f = null;
    if(getNumParameter() != 0) {
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        new ParTypeAccess(
          new TypeAccess("java.util", "Map"),
          new List().add(
            new TypeAccess("java.lang", "Object")
          ).add(
            returnType.createQualifiedAccess()
          )
        ),
        fieldName,
        new ClassInstanceExpr(
          new ParTypeAccess(
            new TypeAccess("java.util", "HashMap"),
            new List().add(
              new TypeAccess("java.lang", "Object")
            ).add(
              returnType.createQualifiedAccess()
            )
          ),
          new List(),
          new Opt()
        )
      );
      f = typeDecl.addMemberField(f);
      typeDecl.addClearCode(f);
    }
    return f;
  }
}
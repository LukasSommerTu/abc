aspect CreateEvalMethods {
  public void TypeDecl.addCaseFor(List list, int i, MethodDecl m) {
    list.add(new ConstCase(new IntegerLiteral(i)));
    List args = new List();
    args.add(new ThisAccess("this"));
    if(m.getNumParameter() == 3) {
      TypeDecl type = m.getParameter(1).type();
      if(type.isPrimitive())
        type = type.boxed();
      args.add(new CastExpr(type.createQualifiedAccess(), new VarAccess("args")));
    }
    else if(m.getNumParameter() > 3) {
      for(int j = 1; j < m.getNumParameter() - 1; j++) {
        TypeDecl type = m.getParameter(j).type();
        if(type.isPrimitive())
          type = type.boxed();
        args.add(
          new CastExpr(
            type.createQualifiedAccess(),
            new ParExpr(
              new CastExpr(
                new TypeAccess("java.util", "ArrayList"),
                new VarAccess("args")
              )
            ).qualifiesAccess(
              new MethodAccess(
                "get",
                new List().add(new IntegerLiteral(j-1))
              )
            )
          )
        );
      }
    }
    if(m.getNumParameter() > 1)
      args.add(new VarAccess("args"));
    list.add(new ReturnStmt(m.createBoundAccess(args)));
  }

  public MethodDecl TypeDecl.createEvalMethod() {
    return null;
  }
  public MethodDecl ClassDecl.createEvalMethod() {
    MethodDecl method = (MethodDecl)getAccessor(this, "eval");
    if(method != null) return method;

    List list = new List();
    // Add default case that throws an exception
    list.add(new DefaultCase());
    if(astNode() == this) {
      list.add(
        new ThrowStmt(
          new ClassInstanceExpr(
            new TypeAccess("java.lang", "UnsupportedOperationException"),
            new List().add(
              new AddExpr(
                new StringLiteral("Can not find method to dispatch in " + name() + ": "),
                new VarAccess("attr")
              )
            ),
            new Opt()
          )
        )
      );
      list.add(new ConstCase(new IntegerLiteral(0)));
      list.add(new ReturnStmt(new VarAccess("parent")));
      list.add(new ConstCase(new IntegerLiteral(1)));
      list.add(new ReturnStmt(
        new MethodAccess(
          "getChild",
          new List().add(new ThisAccess("this")).add(new CastExpr(new TypeAccess("java.lang", "Integer"), new VarAccess("args")))
        )
      ));
      list.add(new ConstCase(new IntegerLiteral(2)));
      list.add(new ReturnStmt(new VarAccess("numChildren")));
    }
    else {
      list.add(
        new ReturnStmt(
          new SuperAccess("super").qualifiesAccess(
            new MethodAccess(
              "eval",
              new List().add(
                new VarAccess("attr")
              ).add(
                new VarAccess("args")
              )
            )
          )
        )
      );
    }

    // Create a block with a single SwitchStmt switching on "attr" and 
    // using the list of cases created above
    Block b = new Block(
      new List().add(
        new SwitchStmt(
          new VarAccess("attr"),
          new Block(list)
        )
      )
    );

    if(this == astNode()) {
      for(Iterator iter = memberMethods("eval").iterator(); iter.hasNext(); ) {
        MethodDecl d = (MethodDecl)iter.next();
        if(d.getNumParameter() == 2 && d.getParameter(0).type().isInt() && d.getParameter(1).type().isObject()) {
          method = d;
          d.setBlock(b);
        }
      }
    }
    else {
      // Create a list of parameters for the generated eval method
      List parameterList = new List();
      parameterList.add(new ParameterDeclaration(new PrimitiveTypeAccess("int"), "attr"));
      parameterList.add(new ParameterDeclaration(new TypeAccess("java.lang", "Object"), "args"));

      // Create the eval method
      method = new MethodDecl(
          new Modifiers(new List().add(new Modifier("public")).add(new Modifier("synthetic"))),
          new TypeAccess("java.lang", "Object"),
          "eval",
          parameterList,
          new List(),
          new Opt(b)
          );
      method = addMemberMethod(method);
    }
    addAccessor(this, "eval", method);
    return method;
  }

  syn lazy ArrayList<MethodDecl> TypeDecl.evalTable() = (ArrayList<MethodDecl>)Collections.EMPTY_LIST;
  // we want to compute a unique index of a particular method signature
  // the index has to be that same for all overriding methods
  // 1) take the table from the superclass
  // 2) iterate over local methods that do not have an ancestor definition
  eq ClassDecl.evalTable() {
    ArrayList<MethodDecl> list = new ArrayList<MethodDecl>();
    if(hasSuperclass())
      list.addAll(superclass().evalTable());
    if(this == astNode()) {
      list.add(findGetParentMethod());
      list.add(findGetChildMethod());
      list.add(findGetNumChildMethod());
      for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        if(!m.type().isVoid() && (!hasSuperclass() || superclass().ancestorMethods(m.signature()).isEmpty())) {
	    if(!list.contains(m)) {
            list.add(m);
	    }
        }
      }
    }
    else if(this instanceof ASTDecl) {
      for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        /*if(m instanceof AttributeDecl && ((AttributeDecl)m).isLazy()) {*/
	if(!m.type().isVoid() /*&& (!hasSuperclass() || superclass().ancestorMethods(m.signature()).isEmpty())*/) {
            list.add(m);
	}
        //}
      }
    }
    return list;
  }

  private MethodDecl ClassDecl.findGetParentMethod() {
     for(Iterator iter = memberMethods("getParent").iterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        if(m.getNumParameter() == 0)
          return m;
      }
      throw new UnsupportedOperationException("Could not find getParent method");
  }
  private MethodDecl ClassDecl.findGetChildMethod() {
     for(Iterator iter = memberMethods("getChild").iterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        if(m.getNumParameter() == 1 && m.getParameter(0).type().isInt())
          return m;
      }
      throw new UnsupportedOperationException("Could not find getChild method");
  }
  private MethodDecl ClassDecl.findGetNumChildMethod() {
      for(Iterator iter = memberMethods("getNumChild").iterator(); iter.hasNext(); ) {
        MethodDecl m = (MethodDecl)iter.next();
        if(m.getNumParameter() == 0)
          return m;
      }
      throw new UnsupportedOperationException("Could not find getNumChild method");
  }

  syn lazy int MethodDecl.evalIndex() {
    int i = hostType().evalTable().indexOf(this);
    if(i == -1)
	throw new UnsupportedOperationException("Did not find method "+
            hostType().typeName() + "." + signature() + " in eval table");
    return i;
  }

  eq AttributeDecl.evalIndex() {
    int i = introducedType().evalTable().indexOf(this);
    if(i == -1)
	throw new UnsupportedOperationException("Did not find attribute "+
            introducedType().typeName()+ "." + signature() + " in eval table");
    return i;
  }


  refine IntertypeFieldCodegeneration public void ClassDecl.generateIntertypeDecls() {
    if(this instanceof ASTDecl || this == astNode()) {
      createEvalMethod();
    }
    IntertypeFieldCodegeneration.ClassDecl.generateIntertypeDecls();
  }
}

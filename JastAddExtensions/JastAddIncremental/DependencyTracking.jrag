aspect DependencyTracking {

  // refine to make sure that every equation gets its own eval index
  refine AttributesCodegeneration public void SynEq.createIntertypeMethod(TypeDecl introducedType) {
    if(introducedType.isInterfaceDecl()) {
      // equations do never generate code in interfaces
    }
    else {
      generateIntertypeDecls();
      MethodDecl aspectMethod = createAspectMethod();
      int lineNum = getParameterList().sourceLineNumber();
      MethodDecl delegateMethod = decl().generateAttributeDecl(introducedType, aspectMethod, lineNum, shouldBeCached(), this.evalIndex());
      introducedType.addMemberMethod(delegateMethod);
      if(hostType() != introducedType) {
        aspectMethod.generateSuperDispatchDelegate(introducedType);
      }
    }
  }


  /** For every lexeme, adapt its getter method to register a dependency. 

      Take, for example, the grammar production
      
        BasicBox : Box ::= <Width:int> <Height:int>

      Remember that JastAdd creates a class <code>BasicBox</code> containing, 
      among others, a field <code>Width$value</code> and an accessor method 
      <code>getWidth</code>.

      Assuming that the eval index of <code>Width</code> is 29, the definition
      of <code>getWidth</code> should be made to look like this:

      <pre>
        public int getWidth() {
	  Main.registerDependency(new Dependency(this, 29), Width$value);
	  return Width$value;
	}
      </pre>
    */
  refine Rewrites public void ASTDecl.generateIntertypeDecls() {
    refined();
    for(Iterator iter = components().iterator(); iter.hasNext(); ) {
      ASTChild child = (ASTChild)iter.next();
      if(child instanceof ASTTokenChild && !child.isNTA()) {
        for(Iterator i2 = memberMethods("get" + child.name()).iterator(); i2.hasNext(); ) {
          MethodDecl m = (MethodDecl)i2.next();
          if(m.getNumParameter() == 0) {
            ClassInstanceExpr expr = new ClassInstanceExpr(
              new TypeAccess("Dependency"),
              new List().add(
                new ThisAccess("this")
              ).add(
                new IntegerLiteral(m.evalIndex())
              ),
              new Opt()
            );
  
            m.getBlock().getStmtList().insertChild(
              new ExprStmt(
                new TypeAccess("Main").qualifiesAccess(
                  new MethodAccess(
                    "registerDependency",
                    new List().add(
                      expr
                    ).add(
                      new VarAccess(child.name() + "$value")
                    )
                  )
                )
              ),
              0
            );

	    // insert a clause into the [switch] statement in method [eval]
            MethodDecl evalMethod = createEvalMethod();
            SwitchStmt switchStmt = (SwitchStmt)evalMethod.getBlock().getStmt(0);
            List list = switchStmt.getBlock().getStmtList();
            list.add(new ConstCase(new IntegerLiteral(m.evalIndex())));
            list.add(new ReturnStmt(new VarAccess(child.name() + "$value")));
          }
        }
      }
    }
  }

  /** Generates methods corresponding to a synthesised attribute.

      A lazy attribute is implemented by three methods: A wrapper method
      having the same name as the attribute, a cache method whose name
      ends in <code>$cache</code>, and a an implementation method whose
      name starts with <code>impl$body$</code>.

      The wrapper method calls the cache method, registers a dependency,
      and then returns the result of the cache method. The cache method,
      in turn, provides a caching wrapper around the implementation method.

      We need to distinguish the cache method from the implementation method:
      When determining whether a <code>MemoLine</code> hits, i.e. whether the
      cached value of some attribute is still valid, we may need to evaluate
      other attributes to find out whether their value has changed. During
      this evaluation, however, we are not interested in creating new
      dependencies (after all, these dependencies are already in the memo
      line), thus the <code>eval</code> method calls the cache method
      instead of the wrapper method.
   */
  refine AttributesCodegeneration public MethodDecl SynDecl.generateAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum, boolean isLazy) {
    if(isNTA() || declaredNTA()) {
      return refined(typeDecl, aspectMethod, lineNum, isLazy);
    }
    return generateAttributeDecl(typeDecl, aspectMethod, lineNum, isLazy, evalIndex());
  }

  public MethodDecl SynDecl.generateAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum, boolean isLazy, int evalIndex) {
    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy) {
      // wrap parameters into an Object to facilitate caching and dependency tracking
      addParameterStructure(statements);
        
      /* build parameter list to call cache method: since the cache method is
	 static, the first argument is a this pointer, then come the arguments
	 of the wrapper method, followed by their wrapped representation */
      List args = new List();
      args.add(new ThisAccess("this"));
      for(int i = 0; i < getNumParameter(); i++) {
        args.add(getParameter(i).createAccess());
      }
      if(getNumParameter() > 0)
        args.add(new VarAccess("parameters$"));
      
      // generate cache method
      MethodDecl cacheMethod = generateCacheAttributeDecl(typeDecl, aspectMethod, lineNum);

      recordRewriteState(statements);
      // add call to cache method and assignment to store its result in local variable res
      statements.add(
          new VariableDeclaration(
            type().createQualifiedAccess(),
            "res",
            cacheMethod.createBoundAccess(args)
          )
      );

      // add dependency tracking
      ClassInstanceExpr expr;
      if(getNumParameter() == 0) {
        expr = new ClassInstanceExpr(
          new TypeAccess("Dependency"),
          new List().add(
            new ThisAccess("this")
          ).add(
	    new IntegerLiteral(evalIndex)
          ),
          new Opt()
        );
      }
      else {
        expr = new ClassInstanceExpr(
          new TypeAccess("Dependency"),
          new List().add(
            new ThisAccess("this")
          ).add(
            new IntegerLiteral(evalIndex)
          ).add(
            new VarAccess("parameters$")
          ),
          new Opt()
        );
      }
      Stmt registerDependency =
        new ExprStmt(
          new TypeAccess("Main").qualifiesAccess(
            new MethodAccess(
              "registerDependency",
              new List().add(
                expr
              ).add(
                new VarAccess("res")
              )
            )
          )
        );

      conditionalOnRewrite(statements, registerDependency, null);
      // and finally a return statement for res
      statements.add(
        new ReturnStmt(new VarAccess("res"))
      );

      // add case entry in typeDecl, for evalIndex, and cacheMethod
      MethodDecl evalMethod = typeDecl.createEvalMethod();
      SwitchStmt switchStmt = (SwitchStmt)evalMethod.getBlock().getStmt(0);
      List caseList = switchStmt.getBlock().getStmtList();
      typeDecl.addCaseFor(caseList, evalIndex, cacheMethod);
    }
    else {
      // non-lazy are done as before
      addComputeCall(statements, aspectMethod);
      addReturnStmt(statements, typeDecl, isLazy);
    }

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    return
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC),
        type().createQualifiedAccess(),
        delegateName(),
        copyParameterList(getParameterList()),
        new List(),
        new Opt(new Block(statements))
     );
  }

  /** Creates a conditional print statement of the form
      <pre>
        if(Main.DEBUG)
	  System.out.println(...messag... + getDebugID());
      </pre> */
  Stmt AttributeDecl.debugPrint(String s) {
    return new IfStmt(
      new TypeAccess("Main").qualifiesAccess(
        new VarAccess("DEBUG")
      ),
      new ExprStmt(
        new TypeAccess("java.lang", "System").qualifiesAccess(
          new VarAccess("out")
        ).qualifiesAccess(
          new MethodAccess(
            "println", 
            new List().add(
              new AddExpr(
                new StringLiteral(s), 
                new ThisAccess("this").qualifiesAccess(
                  new MethodAccess("getDebugID", new List())
		)
              )
            )
          )
        )
      ),
      new Opt()
    );
  }

  /** Generates the cache method for a lazy synthesised attribute. */
  private MethodDecl SynDecl.generateCacheAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum) {
    List statements = new List();

    // generate caching prologue
    FieldDeclaration f = generateBeginCache(statements, typeDecl, uniqueSignatureName() + "$cache");

    // add call to implementation method
    List args = new List();
    args.add(new VarAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(new VarAccess(getParameter(i).name()));
    }
    statements.add(
        new VariableDeclaration(
          type().createQualifiedAccess(),
          "res",
          aspectMethod.createBoundAccess(args)
        )
    );
  
    // NTAs need to be put into the tree
    if(declaredNTA()) {
      statements.add(
        new ExprStmt(
          new VarAccess("res").qualifiesAccess(
            new MethodAccess(
              "setParent",
              new List().add(new ThisAccess("this"))
            )
          )
        )
      );
    }
    else if(isNTA()) {
      statements.add(
        new ExprStmt(
          new ThisAccess("this").qualifiesAccess(
            new MethodAccess(
              "set" + name().substring(3), // replace initial get with set
              new List().add(
                new VarAccess("res")
              )
            )
          )
        )
      );
    }

    // generate caching epilogue
    generateEndCache(statements, typeDecl, f);

    // and return statement
    statements.add(
      new ReturnStmt(new VarAccess("res"))
    );

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    // the parameter list of the cache method contains a this pointer,
    // the attribute arguments, and (if there are any arguments) their
    // wrapped up representation
    // thus, the cache method either has exactly one argument, or more than two
    List parameterList = new List();
    parameterList.add(new ParameterDeclaration(typeDecl.createQualifiedAccess(), "this"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(new ParameterDeclaration(getParameter(i).type().createQualifiedAccess(), getParameter(i).name()));
    if(getNumParameter() > 0)
      parameterList.add(new ParameterDeclaration(new TypeAccess("java.lang", "Object"), "args"));

    // return _and_ add the cache method
    return
    typeDecl.addMemberMethod(
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC | Modifiers.ACC_STATIC),
        type().createQualifiedAccess(),
        delegateName() + "$cache",
        parameterList,
        new List(),
        new Opt(new Block(statements))
     )
    );
  }

  /** Generates methods corresponding to an inherited attribute. Basically
      the same as for synthesised attributes. */
  refine AttributesCodegeneration public void InhDecl.generateAttributeDecl(TypeDecl typeDecl, int lineNum) {
    if(isNTA() || declaredNTA()) {
      refined(typeDecl, lineNum);
      return;
    }

    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy()) {
      addParameterStructure(statements);
        
      List args = new List();
      args.add(new ThisAccess("this"));
      for(int i = 0; i < getNumParameter(); i++) {
        args.add(getParameter(i).createAccess());
      }
      if(getNumParameter() > 0)
        args.add(new VarAccess("parameters$"));
      
      MethodDecl cacheMethod = generateCacheAttributeDecl(lineNum);

      recordRewriteState(statements);

      statements.add(
          new VariableDeclaration(
            type().createQualifiedAccess(),
            "res",
            cacheMethod.createBoundAccess(args)
          )
      );

      ClassInstanceExpr expr;
      if(getNumParameter() == 0) {
        expr = new ClassInstanceExpr(
          new TypeAccess("Dependency"),
          new List().add(
            new ThisAccess("this")
          ).add(
            new IntegerLiteral(evalIndex())
          ),
          new Opt()
        );
      }
      else {
        expr = new ClassInstanceExpr(
          new TypeAccess("Dependency"),
          new List().add(
            new ThisAccess("this")
          ).add(
            new IntegerLiteral(evalIndex())
          ).add(
            new VarAccess("parameters$")
          ),
          new Opt()
        );
      }
      Stmt registerDependency = 
        new ExprStmt(
          new TypeAccess("Main").qualifiesAccess(
            new MethodAccess(
              "registerDependency",
              new List().add(
                expr
              ).add(
                new VarAccess("res")
              )
            )
          )
        );
      conditionalOnRewrite(statements, registerDependency, null);

      statements.add(
        new ReturnStmt(new VarAccess("res"))
      );

      // add case entry in typeDecl, for evalIndex, and cacheMethod
      MethodDecl evalMethod = typeDecl.createEvalMethod();
      SwitchStmt switchStmt = (SwitchStmt)evalMethod.getBlock().getStmt(0);
      List caseList = switchStmt.getBlock().getStmtList();
      typeDecl.addCaseFor(caseList, evalIndex(), cacheMethod);
    }
    else {
      addComputeCall(statements);
      addReturnStmt(statements, typeDecl, isLazy());
    }

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    // public type name(p0, ... , pN-1) { ... }
    typeDecl.addMemberMethod(
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC),
        type().createQualifiedAccess(),
        delegateName(),
        copyParameterList(getParameterList()),
        new List(),
        new Opt(new Block(statements))
      )
    );
  }
  void AttributeDecl.recordRewriteState(List list) {
    // int num$ = this.state().boundariesCrossed;
    list.add(
      new VariableDeclaration(
        new TypeAccess("int"),
        "num$",
        new ThisAccess("this").qualifiesAccess(new MethodAccess("state", new List()).qualifiesAccess(new VarAccess("boundariesCrossed")))
      )
    );
    // boolean localFinal$ = this.is$Final()
    list.add(
      new VariableDeclaration(
        new TypeAccess("boolean"),
        "localFinal$",
        new ThisAccess("this").qualifiesAccess(new MethodAccess("is$Final", new List()))
      )
    );
  }
  void AttributeDecl.conditionalOnRewrite(List list, Stmt thenBranch, Stmt elseBranch) {
    // localFinal$ && num$ == this.state().boundariesCrossed
    Expr cond = new AndLogicalExpr(
      new VarAccess("localFinal$"),
      new EQExpr(
        new VarAccess("num$"),
        new ThisAccess("this").qualifiesAccess(new MethodAccess("state", new List()).qualifiesAccess(new VarAccess("boundariesCrossed")))
      )
    );
    list.add(
      new IfStmt(
        cond,
        thenBranch,
        elseBranch == null ? new Opt() : new Opt(elseBranch)
      )
    );
  }


  /** Generates cache method for inherited attributes. Again, this is
      basically the same as for synthesised attributes, except for
      the invocation of the implementation method. */
  private MethodDecl InhDecl.generateCacheAttributeDecl(int lineNum) {
    TypeDecl typeDecl = introducedType();
    List statements = new List();
    FieldDeclaration f = generateBeginCache(statements, typeDecl, uniqueSignatureName() + "$cache");

    List args = new List();
    args.add(new VarAccess("this"));
    args.add(new NullLiteral("null"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(new VarAccess(getParameter(i).name()));
    }

    // implementation method is invoked on parent
    statements.add(
        new VariableDeclaration(
          type().createQualifiedAccess(),
          "res",
          new ThisAccess("this").qualifiesAccess(
            new MethodAccess("getParent", new List()).qualifiesAccess(
              new BoundMethodAccess(definingInterfaceName(), args, inhEqDelegate())
            )
          )
        )
    );

    generateEndCache(statements, typeDecl, f);
    statements.add(
      new ReturnStmt(new VarAccess("res"))
    );

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    List parameterList = new List();
    parameterList.add(new ParameterDeclaration(typeDecl.createQualifiedAccess(), "this"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(new ParameterDeclaration(getParameter(i).type().createQualifiedAccess(), getParameter(i).name()));
    if(getNumParameter() > 0)
      parameterList.add(new ParameterDeclaration(new TypeAccess("java.lang", "Object"), "args"));

    return
    typeDecl.addMemberMethod(
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC | Modifiers.ACC_STATIC),
        type().createQualifiedAccess(),
        definingInterfaceName() + "$cache",
        parameterList,
        new List(),
        new Opt(new Block(statements))
     )
    );
  }


  /** Generates caching prologue.

      If the attribute has no parameters, we create three fields: A cache field,
      which is of type <code>MemoLine</code>; a flag to indicate whether the
      value has been computed; a value field to contain the cached value.

      For a non-parameterised integer attribute <code>height</code>, for 
      example, we create the three fields
      <pre>
        private MemoLine height$cache = new MemoLine();
	private  boolean height$computed = false;
	private  int height$value;
      </pre>

      The caching prologue then looks like this:
      <pre>
        if(height$computed &amp;&amp; this.memoValid()) {
	  if(Main.DEBUG) 
	    System.out.println("height cached for " + getDebugID());
	  return this$.height$value;
        }
	if(Main.DEBUG) 
	  System.out.println("Recomputing height for " + getDebugID());
	Main.pushMemoLine(height$cache);
      </pre>

      If there are parameters, we instead create a single cache field, which is
      a map from Objects (representing parameter tuples) to CachedValues.

      For an attribute <code>lookupVar</code> with a <code>String</code>
      parameter which returns a <code>Variable</code>, that field would be
      declared as
      <pre>
          private Map&lt;Object, CachedValue&gt; lookup$cache 
	    = new HashMap&lt;Object, CachedValue&gt;();
      </pre>

      The caching prologue then becomes:
      <pre>
        CachedValue v$;
	if(lookup$cache.containsKey(args)) {
	  v$ = lookup$cache.get(args);
	  if(v$.line.hit()) 
	    return (java.lang.String)v$.value;
	  else 
	    v$.line.clear();
	} else {
	  v$ = new test.CachedValue();
	  lookup$cache.put(args, v$);
	}
	if(test.Main.DEBUG) 
	  System.out.println("Recomputing lookup for " + getDebugID());
	Main.pushMemoLine(v$.line);
      </pre>

      (Actually, since the caching method is static, some method calls
      have to be qualified with an explicit <code>this</code> pointer.)
   */
  FieldDeclaration AttributeDecl.generateBeginCache(List statements, TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f = generateCacheField(typeDecl, fieldName);
    if(getNumParameter() == 0) {
      FieldDeclaration computedFlag = fieldComputedFlag(typeDecl);
      FieldDeclaration value = fieldComputedValue(typeDecl);
 
      Stmt thenBranch =
        new Block(
          new List().add(
            debugPrint(name() + " cached for ")
          ).add(
            new ReturnStmt(
              value.createQualifiedBoundAccess()
            )
          )
        );

      // check whether the cache is valid, and whether the memoline hits
      Stmt ifStmt = 
        new IfStmt(
          new AndLogicalExpr(
            computedFlag.createQualifiedBoundAccess(),
            new ThisAccess("this").qualifiesAccess(
              new MethodAccess("memoValid", new List())
            )
          ),
          thenBranch,
          new Opt()
        );
      statements.add(ifStmt);
    }
    else {
      statements.add(
        new VariableDeclaration(
          new TypeAccess("CachedValue"),
          "v$"
        )
      );
      // check whether the cache contains an entry for the current arguments,
      // and whether the corresponding memoline hits; if so, return the
      // value; if not, either allocate a fresh entry (if there was none),
      // or clear the memoline
      Stmt thenBlock =
        new Block(
          new List().add(
            AssignExpr.asStmt(
              new VarAccess("v$"),
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "get",
                  new List().add(new VarAccess("args"))
                )
              )
            )
          ).add(
            new IfStmt(
              new VarAccess("v$").qualifiesAccess(
                new VarAccess("node")
              ).qualifiesAccess(
                new MethodAccess("memoValid", new List())
              ),
              new ReturnStmt(
                new CastExpr(
                  returnType.createQualifiedAccess(),
                  new VarAccess("v$").qualifiesAccess(new VarAccess("value"))
                )
              )
            )
          )
        );
      Stmt elseBlock =
        new Block(
          new List().add(
            AssignExpr.asStmt(
              new VarAccess("v$"),
              new ClassInstanceExpr(
                new TypeAccess("CachedValue"),
                new List().add(new ThisAccess("this")), // HERE
                new Opt()
              )
            )
          ).add(
            new ExprStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "put",
                  new List().add(new VarAccess("args")).add(new VarAccess("v$"))
                )
              )
            )
          )
        );
            
      Stmt outerIf =
        new IfStmt(
          f.createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "containsKey",
              new List().add(new VarAccess("args"))
            )
          ),
          thenBlock,
          elseBlock
        );
      statements.add(outerIf);
    }

    // print a debugging message
    statements.add(debugPrint("Recomputing " + name() + " for "));
    recordRewriteState(statements);

    // push the memo line
    if(getNumParameter() == 0) {
      statements.add(
        new ExprStmt(
          new TypeAccess("Main").qualifiesAccess(
            new MethodAccess(
              "pushMemoLine", 
              new List().add(
                new ThisAccess("this").qualifiesAccess(
                  new MethodAccess("getMemoLine", new List())
                )
              )
            )
          )
        )
      );
    }
    else {
      statements.add(
        new ExprStmt(
          new TypeAccess("Main").qualifiesAccess(
            new MethodAccess(
              "pushMemoLine", 
              new List().add(
                new VarAccess("v$").qualifiesAccess(
                  new VarAccess("node")
                ).qualifiesAccess(
                  new MethodAccess("getMemoLine", new List())
                )
              )
            )
          )
        )
      );
    }
    return f;
  }

  /** Generates caching epilogue.

      First, the memo line is popped. Then, for an unparameterised attribute,
      the value field is written and the computed flag is set. For a
      parameterised attribute, the value field of the CachedValue object
      is set. */
  void AttributeDecl.generateEndCache(List statements, TypeDecl typeDecl, FieldDeclaration f) {
    statements.add(
      new ExprStmt(
        new TypeAccess("Main").qualifiesAccess(new MethodAccess("popMemoLine", new List()))
      )
    );
    Stmt thenBranch;
    Stmt elseBranch = null;
    if(getNumParameter() == 0) {
      thenBranch = new Block(
        new List().add(
          AssignExpr.asStmt(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
            new VarAccess("res")
          )
        ).add(
          AssignExpr.asStmt(
            fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
            new BooleanLiteral("true")
          )
        )
      );
    }
    else {
      thenBranch =
        AssignExpr.asStmt(
          new VarAccess("v$").qualifiesAccess(new VarAccess("value")),
          new VarAccess("res")
        );
      elseBranch =
        new ExprStmt(
          f.createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "remove",
              new List().add(new VarAccess("args"))
            )
          )
        );
    }
    conditionalOnRewrite(statements, thenBranch, elseBranch);
  }

  /** Generates the cache field. */
  FieldDeclaration AttributeDecl.generateCacheField(TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    if(getNumParameter() == 0) {
      return null;
    }
    else {
      FieldDeclaration f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        new ParTypeAccess(
          new TypeAccess("java.util", "Map"),
          new List().add(
            new TypeAccess("java.lang", "Object")
          ).add(
            new TypeAccess("CachedValue")
          )
        ),
        fieldName,
        new ClassInstanceExpr(
          new ParTypeAccess(
            new TypeAccess("java.util", "HashMap"),
            new List().add(
              new TypeAccess("java.lang", "Object")
            ).add(
              new TypeAccess("CachedValue")
            )
          ),
          new List(),
          new Opt()
        )
      );
      f = typeDecl.addMemberField(f);
      typeDecl.addFlushCode(
        f,
        new ClassInstanceExpr(
          new ParTypeAccess(
            new TypeAccess("java.util", "HashMap"),
            new List().add(
              new TypeAccess("java.lang", "Object")
            ).add(
              new TypeAccess("CachedValue")
            )
          ),
          new List(),
          new Opt()
        )
      );
      return f;
    }
  }

}

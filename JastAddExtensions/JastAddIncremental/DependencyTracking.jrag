aspect DependencyTracking {

  /** For every lexeme, adapt its getter method to register a dependency, and
      its setter to trigger propagation.

      Take, for example, the grammar production
      
        BasicBox : Box ::= <Width:int> <Height:int>

      Remember that JastAdd creates a class <code>BasicBox</code> containing, 
      among others, a field <code>Width$value</code> and accessor methods
      <code>getWidth</code> and <code>setWidth</code>.

      We need to create a field

      <pre>
        DependentList getWidth$dep = new DependentList();
      </pre>

      to store the cacheroots depending on this attribute.

      The definition of <code>getWidth</code> should look like this:

      <pre>
        public int getWidth() {
	  getWidth$dep.add(state().getCurrentCacheRoot());
	  return Width$value;
	}
      </pre>

      The definition of <code>setWidth</code> will be:

      <pre>
        public void setWidth(int value) {
	  Width$value = value;
	  getWidth$dep.propagate();
	}
      </pre>
    */
  refine Rewrites public void ASTDecl.generateIntertypeDecls() {
    refined();
    for(Iterator iter = components().iterator(); iter.hasNext(); ) {
      ASTChild child = (ASTChild)iter.next();
      if(child instanceof ASTTokenChild) {
	FieldDeclaration depfield = createDepField(child.name() + "$dep");
        if(!child.isNTA()) {
	  MethodDecl getter = getChildGetter(child.name());
          getter.getBlock().getStmtList().insertChild(
            new ExprStmt(
	      depfield.createQualifiedBoundAccess().qualifiesAccess(
	        new MethodAccess(
		  "add",
		  new List().add(
		    accessState().qualifiesAccess(
		      new MethodAccess(
		        "getCurrentCacheRoot",
		        new List()
		      )
		    )
		  )
	        )
	      )
	    ),
            0
          );
	}
      }
    }
  }

  /** Finds the getter method for a child. */
  public MethodDecl ASTDecl.getChildGetter(String name) {
    for(Iterator i = memberMethods("get" + name).iterator(); i.hasNext(); ) {
      MethodDecl m = (MethodDecl)i.next();
      if(m.getNumParameter() == 0)
        return m;
    }
    assert(false);
    return null;
  }


  /** Finds the setter method for a child. */
  public MethodDecl ASTDecl.getChildSetter(String name) {
    for(Iterator i = memberMethods("set" + name).iterator(); i.hasNext(); ) {
      MethodDecl m = (MethodDecl)i.next();
      if(m.getNumParameter() == 1)
        return m;
    }
    assert(false);
    return null;
  }

  /** Generates methods corresponding to a synthesised attribute.

      A lazy attribute is implemented by three methods: A wrapper method
      having the same name as the attribute, a cache method whose name
      ends in <code>$cache</code>, and a an implementation method whose
      name starts with <code>impl$body$</code>.

      The wrapper method calls the cache method, registers a dependency,
      and then returns the result of the cache method. The cache method,
      in turn, provides a caching wrapper around the implementation method.

      We need to distinguish the cache method from the implementation method:
      When determining whether a <code>MemoLine</code> hits, i.e. whether the
      cached value of some attribute is still valid, we may need to evaluate
      other attributes to find out whether their value has changed. During
      this evaluation, however, we are not interested in creating new
      dependencies (after all, these dependencies are already in the memo
      line), thus the <code>eval</code> method calls the cache method
      instead of the wrapper method.
   */
  refine AttributesCodegeneration public MethodDecl SynDecl.generateAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum, boolean isLazy) {
    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy) {
      // wrap parameters into an Object to facilitate caching and dependency tracking
      addParameterStructure(statements);
        
      /* build parameter list to call cache method: since the cache method is
	 static, the first argument is a this pointer, then come the arguments
	 of the wrapper method, followed by their wrapped representation */
      List args = new List();
      args.add(new ThisAccess("this"));
      for(int i = 0; i < getNumParameter(); i++) {
        args.add(getParameter(i).createAccess());
      }
      if(getNumParameter() > 0)
        args.add(new VarAccess("parameters$"));
      
      // generate cache method
      MethodDecl cacheMethod = generateCacheAttributeDecl(typeDecl, aspectMethod, lineNum);

      recordRewriteState(statements);
      // add call to cache method and assignment to store its result in local variable res
      statements.add(
          new VariableDeclaration(
            type().createQualifiedAccess(),
            "res",
            cacheMethod.createBoundAccess(args)
          )
      );

      // add dependency tracking
      Stmt registerDependency;
      if(getNumParameter() == 0) {
        registerDependency = new ExprStmt(
	  new VarAccess(name()+"$cache").qualifiesAccess(
	    new MethodAccess(
	      "add",
	      new List().add(
	        accessState().qualifiesAccess(
	          new MethodAccess(
		    "getCurrentCacheRoot",
		    new List()
		  )
	        )
	      )
	    )
	  )
	);
      } else {
        registerDependency = new ExprStmt(
	  new VarAccess(uniqueSignatureName()+"$cache").qualifiesAccess(
	    new MethodAccess(
	      "addDependent",
	      new List().add(
	        new VarAccess("parameters$")
	      ).add(
	        accessState().qualifiesAccess(
                  new MethodAccess(
                    "getCurrentCacheRoot",
		    new List()
		  )
	        )
	      )
	    )
	  )
	);
      }

      conditionalOnRewrite(statements, registerDependency);
      // and finally a return statement for res
      statements.add(
        new ReturnStmt(new VarAccess("res"))
      );
    }
    else {
      // non-lazy are done as before
      addComputeCall(statements, aspectMethod);
      addReturnStmt(statements, typeDecl, isLazy);
    }

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    return
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC),
        type().createQualifiedAccess(),
        delegateName(),
        copyParameterList(getParameterList()),
        new List(),
        new Opt(new Block(statements))
     );
  }

  syn String AttributeDecl.cacheMethodName();
  eq SynDecl.cacheMethodName() = delegateName() + "$cache";
  eq InhDecl.cacheMethodName() = definingInterfaceName() + "$cache";

  /** Generates the cache method for a lazy synthesised attribute. */
  private MethodDecl SynDecl.generateCacheAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum) {
    List statements = new List();

    // generate caching prologue
    FieldDeclaration f = generateBeginCache(statements, typeDecl, uniqueSignatureName() + "$cache");

    // add call to implementation method
    List args = new List();
    args.add(new VarAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(new VarAccess(getParameter(i).name()));
    }
    statements.add(
        new VariableDeclaration(
          type().createQualifiedAccess(),
          "res",
          aspectMethod.createBoundAccess(args)
        )
    );
  
    // NTAs need to be put into the tree 
    if(declaredNTA()) {
      statements.add(
        new ExprStmt(
          new VarAccess("res").qualifiesAccess(
            new MethodAccess(
              "setParent",
              new List().add(new ThisAccess("this")).add(new BooleanLiteral("false"))
            )
          )
        )
      );
      makeNTAFinal(statements, new VarAccess("res"));
    }
    else if(isNTA()) {
      statements.add(
        new ExprStmt(
          new ThisAccess("this").qualifiesAccess(
            new MethodAccess(
              "set" + name().substring(3), // replace initial get with set
              new List().add(
                new VarAccess("res")
              ).add(
	        new BooleanLiteral("false")
	      )
            )
          )
        )
      );
      if(!bindsToTokenChild())
	makeNTAFinal(statements, new VarAccess("res"));
    }

    // generate caching epilogue
    generateEndCache(statements, typeDecl, f);

    // and return statement
    statements.add(
      new ReturnStmt(new VarAccess("res"))
    );

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    // the parameter list of the cache method contains a this pointer,
    // the attribute arguments, and (if there are any arguments) their
    // wrapped up representation
    // thus, the cache method either has exactly one argument, or more than two
    List parameterList = new List();
    parameterList.add(new ParameterDeclaration(typeDecl.createQualifiedAccess(), "this"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(new ParameterDeclaration(getParameter(i).type().createQualifiedAccess(), getParameter(i).name()));
    if(getNumParameter() > 0)
      parameterList.add(new ParameterDeclaration(new TypeAccess("java.lang", "Object"), "args"));

    // add the cache method
    MethodDecl cacheMethod =
      typeDecl.addMemberMethod(
        new MethodDecl(
          Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC | Modifiers.ACC_STATIC),
          type().createQualifiedAccess(),
          cacheMethodName(),
          parameterList,
          new List(),
          new Opt(new Block(statements))
       )
      );
    // add recomputation code
    typeDecl.addClearCode(f, this, cacheMethod);

    return cacheMethod;
  }

  /** Generates methods corresponding to an inherited attribute. Basically
      the same as for synthesised attributes. */
  refine AttributesCodegeneration public void InhDecl.generateAttributeDecl(TypeDecl typeDecl, int lineNum) {
    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy()) {
      addParameterStructure(statements);
        
      List args = new List();
      args.add(new ThisAccess("this"));
      for(int i = 0; i < getNumParameter(); i++) {
        args.add(getParameter(i).createAccess());
      }
      if(getNumParameter() > 0)
        args.add(new VarAccess("parameters$"));
      
      MethodDecl cacheMethod = generateCacheAttributeDecl(lineNum);

      recordRewriteState(statements);

      statements.add(
          new VariableDeclaration(
            type().createQualifiedAccess(),
            "res",
            cacheMethod.createBoundAccess(args)
          )
      );

      // add dependency tracking
      Stmt registerDependency;
      if(getNumParameter() == 0) {
        registerDependency = new ExprStmt(
	  new VarAccess(name()+"$cache").qualifiesAccess(
	    new MethodAccess(
	      "add",
	      new List().add(
	        accessState().qualifiesAccess(
	          new MethodAccess(
		    "getCurrentCacheRoot",
		    new List()
		  )
	        )
	      )
	    )
	  )
	);
      } else {
        registerDependency = new ExprStmt(
	  new VarAccess(uniqueSignatureName()+"$cache").qualifiesAccess(
	    new MethodAccess(
	      "addDependent",
	      new List().add(
	        new VarAccess("parameters$")
	      ).add(
	        accessState().qualifiesAccess(
                  new MethodAccess(
                    "getCurrentCacheRoot",
		    new List()
		  )
	        )
	      )
	    )
	  )
	);
      }
      conditionalOnRewrite(statements, registerDependency);

      statements.add(
        new ReturnStmt(new VarAccess("res"))
      );
    }
    else {
      addComputeCall(statements);
      addReturnStmt(statements, typeDecl, isLazy());
    }

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    // public type name(p0, ... , pN-1) { ... }
    typeDecl.addMemberMethod(
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC),
        type().createQualifiedAccess(),
        delegateName(),
        copyParameterList(getParameterList()),
        new List(),
        new Opt(new Block(statements))
      )
    );
  }

  void AttributeDecl.recordRewriteState(List list) {
    if(isNTA() || declaredNTA())
      return;
    // int num$ = this.state().boundariesCrossed;
    list.add(
      new VariableDeclaration(
        new TypeAccess("int"),
        "num$",
        new ThisAccess("this").qualifiesAccess(new MethodAccess("state", new List()).qualifiesAccess(new VarAccess("boundariesCrossed")))
      )
    );
    // boolean localFinal$ = this.is$Final()
    list.add(
      new VariableDeclaration(
        new TypeAccess("boolean"),
        "localFinal$",
        new ThisAccess("this").qualifiesAccess(new MethodAccess("is$Final", new List()))
      )
    );
  }

  void AttributeDecl.conditionalOnRewrite(List list, Stmt thenBranch) {
    if(isNTA() || declaredNTA()) {
      list.add(thenBranch);
    } else {
      // localFinal$ && num$ == this.state().boundariesCrossed
      Expr cond = new AndLogicalExpr(
	new VarAccess("localFinal$"),
        new EQExpr(
          new VarAccess("num$"),
          new ThisAccess("this").qualifiesAccess(new MethodAccess("state", new List()).qualifiesAccess(new VarAccess("boundariesCrossed")))
        )
      );
      list.add(new IfStmt(cond, thenBranch));
    }
  }


  /** Generates cache method for inherited attributes. Again, this is
      basically the same as for synthesised attributes, except for
      the invocation of the implementation method. */
  private MethodDecl InhDecl.generateCacheAttributeDecl(int lineNum) {
    TypeDecl typeDecl = introducedType();
    List statements = new List();
    FieldDeclaration f = generateBeginCache(statements, typeDecl, uniqueSignatureName() + "$cache");

    List args = new List();
    args.add(new VarAccess("this"));
    args.add(new NullLiteral("null"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(new VarAccess(getParameter(i).name()));
    }

    // implementation method is invoked on parent
    statements.add(
        new VariableDeclaration(
          type().createQualifiedAccess(),
          "res",
          new ThisAccess("this").qualifiesAccess(
            new MethodAccess("getParent", new List()).qualifiesAccess(
              new BoundMethodAccess(definingInterfaceName(), args, inhEqDelegate())
            )
          )
        )
    );

    generateEndCache(statements, typeDecl, f);
    statements.add(
      new ReturnStmt(new VarAccess("res"))
    );

    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    List parameterList = new List();
    parameterList.add(new ParameterDeclaration(typeDecl.createQualifiedAccess(), "this"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(new ParameterDeclaration(getParameter(i).type().createQualifiedAccess(), getParameter(i).name()));
    if(getNumParameter() > 0)
      parameterList.add(new ParameterDeclaration(new TypeAccess("java.lang", "Object"), "args"));

    MethodDecl cacheMethod =
    typeDecl.addMemberMethod(
      new MethodDecl(
        Modifiers.create(Modifiers.ACC_PUBLIC | Modifiers.ACC_SYNTHETIC | Modifiers.ACC_STATIC),
        type().createQualifiedAccess(),
        cacheMethodName(),
        parameterList,
        new List(),
        new Opt(new Block(statements))
     )
    );

    typeDecl.addClearCode(f, this, cacheMethod);

    return cacheMethod;
  }

  syn boolean AttributeDecl.hasPrimitiveReturnType() = type().isPrimitive();


  /** Generates caching prologue. */
  FieldDeclaration AttributeDecl.generateBeginCache(List statements, TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(hasPrimitiveReturnType())
      returnType = returnType.boxed();

    FieldDeclaration f = generateCacheField(typeDecl, fieldName);
    if(getNumParameter() == 0) {
      FieldDeclaration computedTimeStamp = fieldComputedTimeStamp(typeDecl);
      FieldDeclaration value = fieldComputedValue(typeDecl);

      // check whether the cache is valid
      Stmt ifStmt = 
        new IfStmt(
          new GEExpr(
	    computedTimeStamp.createQualifiedBoundAccess(),
	    new ThisAccess("this").qualifiesAccess(
              new MethodAccess(
                "getCacheRoot",
                new List()
              )
            ).qualifiesAccess(
              new MethodAccess(
                "getLastFlushed",
                new List()
              )
            )
          ),
	  new ReturnStmt(value.createQualifiedBoundAccess())
	);
      statements.add(ifStmt);
    }
    else {
      // check whether the cache contains an entry for the current arguments,
      // and return it if so
      statements.add(
        new IfStmt(
          new GEExpr(
	    f.createQualifiedBoundAccess().qualifiesAccess(
              new MethodAccess(
                "last_computed",
                new List().add(new VarAccess("args"))
              )
            ),
	    new ThisAccess("this").qualifiesAccess(
              new MethodAccess(
                "getCacheRoot",
                new List()
              )
            ).qualifiesAccess(
              new MethodAccess(
                "getLastFlushed",
                new List()
              )
            )
          ),
	  new ReturnStmt(
	    new CastExpr(
	      returnType.createQualifiedAccess(),
	      f.createQualifiedBoundAccess().qualifiesAccess(
	        new MethodAccess(
	      	  "get",
	      	  new List().add(new VarAccess("args"))
		)
	      )
	    )
	  )
	)
      );
    }

    recordRewriteState(statements);

    // push the current cache root
    statements.add(
      new ExprStmt(
        accessState().qualifiesAccess(
          new MethodAccess(
            "pushCacheRoot",
     	    new List().add(
	      new ThisAccess("this").qualifiesAccess(
		new MethodAccess(
		  "getCacheRoot",
		  new List()
		)
	      )
	    )
          )
        )
      )
    );
    return f;
  }

  /** Generates caching epilogue. */
  void AttributeDecl.generateEndCache(List statements, TypeDecl typeDecl, FieldDeclaration f) {
    statements.add(
      new ExprStmt(
        accessState().qualifiesAccess(new MethodAccess("popCacheRoot", new List()))
      )
    );
    Stmt update;
    if(getNumParameter() == 0) {
      update = new Block(
        new List().add(
	  // boolean changed;
          new VariableDeclaration(
            new TypeAccess("boolean"),
            "changed"
          )
        ).add(
          // for primitive return types:
          //   changed = last_flushed != -1 && value != res
          // for others:
          //   changed = last_flushed != -1 && 
          //     (value == null ? res != null : !value.equals(res))
          AssignExpr.asStmt(
            new VarAccess("changed"),
            new AndLogicalExpr(
              new NEExpr(
                fieldComputedTimeStamp(typeDecl).createQualifiedBoundAccess(),
                new IntegerLiteral("-1")
              ),
              hasPrimitiveReturnType() ?
              new NEExpr(
                fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
                new VarAccess("res")
              )
              :
              new ParExpr(
  	        new ConditionalExpr(
                  new EQExpr(
                    fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
                    new NullLiteral("null")
                  ),
                  new NEExpr(
                    new VarAccess("res"),
                    new NullLiteral("null")
  	          ),
                  new LogNotExpr(
                    fieldComputedValue(typeDecl).createQualifiedBoundAccess().
                    qualifiesAccess(
                      new MethodAccess(
                        "equals",
                        new List().add(new VarAccess("res"))
                      )
                    )
                  )
		)
	      )
	    )
          )
        ).add(
          // value = res;
          AssignExpr.asStmt(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
            new VarAccess("res")
          )
        ).add(
          // last_computed = this$.getCacheRoot().getLastFlushed();
          AssignExpr.asStmt(
            fieldComputedTimeStamp(typeDecl).createQualifiedBoundAccess(),
            new ThisAccess("this").qualifiesAccess(
              new MethodAccess(
                "getCacheRoot",
                new List()
              )
            ).qualifiesAccess(
              new MethodAccess(
                "getLastFlushed",
                new List()
              )
            )
          )
        ).add(
          // if(changed)
          //   dep.propagate();
          new IfStmt(
            new VarAccess("changed"),
            new ExprStmt(
              f.createQualifiedBoundAccess().qualifiesAccess(
                new MethodAccess(
                  "propagate",
                  new List()
                )
              )
            )
          )
        )
      );
    }
    else {
      update = new ExprStmt(
        f.createQualifiedBoundAccess().qualifiesAccess(
	  new MethodAccess(
	    "put",
	    new List().add(
	      new VarAccess("args")
	    ).add(
	      new VarAccess("res")
	    )
	  )
	)
      );
    }
    conditionalOnRewrite(statements, update);
  }

  FieldDeclaration ASTDecl.createDepField(String fieldName) {
    FieldDeclaration f = new FieldDeclaration(
      new Modifiers(new List().add(new Modifier("private"))),
      new TypeAccess("DependentList"),
      fieldName,
      new ClassInstanceExpr(
        new TypeAccess("DependentList"),
        new List().add(new ThisAccess("this")),
        new Opt()
      )
    );
    f = addMemberField(f);
    return f;
  }

  /** Generates the cache field. */
  FieldDeclaration AttributeDecl.generateCacheField(TypeDecl typeDecl, String fieldName) {
    TypeDecl returnType = type();
    if(returnType.isPrimitive())
      returnType = returnType.boxed();

    FieldDeclaration f;
    if(getNumParameter() == 0) {
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
	new TypeAccess("DependentList"),
	fieldName,
	new ClassInstanceExpr(
	  new TypeAccess("DependentList"),
	  new List().add(new ThisAccess("this")),
	  new Opt()
	)
      );
    }
    else {
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
	new TypeAccess("AST", "AttributeCache"),
	fieldName,
        new ClassInstanceExpr(
	  new TypeAccess("AST", "AttributeCache"),
          new List().add(new ThisAccess("this")),
          new Opt()
        )
      );
    }
    f = typeDecl.addMemberField(f);
    return f;
  }

  /** Generates the value timestamp for 0-arg lazy attributes. */
  syn String AttributeDecl.computedTimeStampName() = uniqueSignatureName() + "$last_updated";
  private HashMap AttributeDecl.fieldComputedTimeStampAdded = new HashMap();
  protected FieldDeclaration AttributeDecl.fieldComputedTimeStamp(TypeDecl typeDecl) {
    if(fieldComputedTimeStampAdded.containsKey(typeDecl))
      return (FieldDeclaration)fieldComputedTimeStampAdded.get(typeDecl);

    Expr init = new IntegerLiteral("-1");
    FieldDeclaration f =
      new FieldDeclaration(
        Modifiers.create(Modifiers.ACC_PRIVATE | Modifiers.ACC_SYNTHETIC),
        new TypeAccess("int"),
        computedTimeStampName(),
        init
      );
    f = typeDecl.addMemberField(f);
    fieldComputedTimeStampAdded.put(typeDecl, f);
    return f;
  }

  void TypeDecl.addClearCode(FieldDeclaration f, AttributeDecl attrDecl, MethodDecl cacheMethod) {
    MethodDecl m = flushCacheMethod();
    List list = m.getBlock().getStmtList();
    Stmt clearStmt;
    if(attrDecl.getNumParameter() == 0) {
      clearStmt = new IfStmt(
        new NEExpr(
          attrDecl.fieldComputedTimeStamp(this).createQualifiedBoundAccess(),
	  new IntegerLiteral("-1")
	),
        new ExprStmt(
          cacheMethod.createBoundAccess(
            new List().add(new ThisAccess("this"))
 	  )
	)
      );
    } else if(attrDecl.getNumParameter() == 1) {
      TypeDecl argtype = attrDecl.getParameter(0).type();
      if(argtype.isPrimitive())
        argtype = argtype.boxed();
      clearStmt = new EnhancedForStmt(
        new VariableDeclaration(
          new TypeAccess("java.lang", "Object"),
          "arg"
        ),
        f.createQualifiedBoundAccess().qualifiesAccess(
          new MethodAccess(
            "getKeys",
            new List()
          )
        ),
        new ExprStmt(
	  cacheMethod.createBoundAccess(
            new List().add(
              new ThisAccess("this")
            ).add(
              new CastExpr(
                argtype.createQualifiedAccess(),
                new VarAccess("arg")
              )
            ).add(
              new VarAccess("arg")
            )
          )
        )
      );
    } else {
      List cacheMethodArgs = new List().add(new ThisAccess("this"));
      for(int i=0;i<attrDecl.getNumParameter();++i) {
        TypeDecl argtype = attrDecl.getParameter(i).type();
	if(argtype.isPrimitive())
	  argtype = argtype.boxed();
        cacheMethodArgs.add(
          new CastExpr(
            argtype.createQualifiedAccess(),
            new ParExpr(
              new CastExpr(
                new TypeAccess("java.util", "List"),
                new VarAccess("args")
              )
            ).qualifiesAccess(
              new MethodAccess(
                "get",
                new List().add(new IntegerLiteral(i+""))
	      )
            )
          )
        );
      }
      cacheMethodArgs.add(new VarAccess("args"));
      clearStmt = new EnhancedForStmt(
        new VariableDeclaration(
          new TypeAccess("java.lang", "Object"),
          "args"
        ),
        f.createQualifiedBoundAccess().qualifiesAccess(
          new MethodAccess(
            "getKeys",
            new List()
          )
        ),
        new ExprStmt(cacheMethod.createBoundAccess(cacheMethodArgs))
      );
    }
    list.add(clearStmt);
  }

  Expr ASTNode.accessState() {
    return new ThisAccess("this").qualifiesAccess(new MethodAccess("state", new List()));
  }

}

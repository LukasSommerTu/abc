import java.util.Iterator;

import org.eclipse.ltk.core.refactoring.*;
import org.eclipse.core.resources.IFile;
import org.eclipse.text.edits.TextEdit;
import org.eclipse.text.edits.ISourceModifier;
import org.eclipse.text.edits.MoveSourceEdit;
import org.eclipse.text.edits.MoveTargetEdit;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.ReplaceEdit;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.ltk.core.refactoring.Change;
import org.jastadd.plugin.jastaddj.util.FileUtil;
import org.eclipse.core.runtime.Path;
import org.eclipse.jdt.internal.corext.refactoring.nls.changes.CreateFileChange;
import org.eclipse.ltk.core.refactoring.resource.DeleteResourceChange;

import AST.ASTModification;
import AST.ASTNode;

aspect CreateTextEdit {
	
	
	/* a change accumulator keeps track of changes happening to multiple files;
	 * it creates one TextFileChange for every file affected and adds incoming
	 * ReplaceEdits to them
	 */
	class ChangeAccumulator {
		public static final boolean DEBUG = true;
		
		private String name;
		private CompositeChange changes;
		private Map<IFile, TextFileChange> changemap;
		
		public ChangeAccumulator(String name) {
			this.name = name;
			changes = new CompositeChange(name);
			changemap = new HashMap<IFile, TextFileChange>();
		}

		// retrieve the text file change object for file
		private TextFileChange changeForFile(IFile file) {
			TextFileChange tfc;
			if(!changemap.containsKey(file)) {
				// create a new one
				tfc = new TextFileChange(name, file);
				tfc.setEdit(new MultiTextEdit());
				changes.add(tfc);
				changemap.put(file, tfc);
			}
			else {
				tfc = changemap.get(file);
			}
			return tfc;
		}
		
		/**
		 * copied from TextEdit as ReplaceEdit is final and we want to be able to replace zero length edits
		 */
		public boolean covers(TextEdit thiss, TextEdit other) {
			int thisOffset= thiss.getOffset();
			int otherOffset= other.getOffset();
			return thisOffset <= otherOffset && otherOffset + other.getLength() <= thisOffset + thiss.getLength();
		}
		
		public void addEdit(IFile file, TextEdit te) {
			TextFileChange tfc = changeForFile(file);
			/* we need to avoid overlaping changes
			 * new changes added here should cover the old ones or not conflict
			 */
			MultiTextEdit mte = (MultiTextEdit)tfc.getEdit();
			java.util.Set covered = new java.util.HashSet();
			for(int i=0; i<mte.getChildren().length; ++i) {
				TextEdit te2 = mte.getChildren()[i];
				if(covers(te, te2))
						covered.add(te2);
//				else if(te2.covers(te)) {
//					if(te2 instanceof MoveSourceEdit && te instanceof ReplaceEdit) {
//						MoveSourceEdit cse = (MoveSourceEdit)te2;
//						ReplaceEdit re = (ReplaceEdit)te;
//						((MoveMethodSourceModifier)cse.getSourceModifier()).addReplaceEdit(re);
//					}
//					return;
//				}
			}
			for(Iterator iter=covered.iterator();iter.hasNext();) {
				TextEdit te2 = (TextEdit)iter.next();
//				if(te instanceof MoveSourceEdit && te2 instanceof ReplaceEdit) {
//					MoveSourceEdit cse = (MoveSourceEdit)te;
//					ReplaceEdit re = (ReplaceEdit)te2;
//					((MoveMethodSourceModifier)cse.getSourceModifier()).addReplaceEdit(re);
//				}
				mte.removeChild(te2);
			}
			tfc.addEdit(te);
		}

		public void addEdit(IFile file, int offset, int length, String contents) {
			addEdit(file, new ReplaceEdit(offset, length, contents));
		}

		// creates the TextChanges corresponding to the ASTModification in some iterator
		// and adds them to the accumulator
		public void addAllEdits(Collection<ASTModification> col) {
			Iterator<ASTModification> iter = col.iterator();
			while(iter.hasNext()) {
				ASTModification m = iter.next();
				if (m instanceof ASTModificationCompilationUnitSetId) {
					ASTModificationCompilationUnitSetId mm = (ASTModificationCompilationUnitSetId) m;
					compilationUnitOriginalPath.put((CompilationUnit) mm.node, mm.oldPathName);
				}
			}
			iter = col.iterator();
			while(iter.hasNext()) {
				ASTModification m = iter.next();
				if (DEBUG) System.out.print(m.toString() + " :: ");
				m.redo();
				m.createTextEdit(this);
			}
		}
		
		// directly add a non-TextChange
		public void addChange(Change ch) {
			changes.add(ch);
		}
		
		public Change getChanges() {
			return changes;
		}
		
		public Map<CompilationUnit, String> compilationUnitOriginalPath = new HashMap<CompilationUnit, String>();

		public String getPathName(IJastAddNode node) {
			CompilationUnit cu = ((ASTNode) node).compilationUnit();
			if (this.compilationUnitOriginalPath.containsKey(cu))
				return this.compilationUnitOriginalPath.get(cu);
			else
				return cu.pathName();
		}
		
		private java.util.Set<ASTNode> printed = new HashSet<ASTNode>();
		public void addPrinted(ASTNode node) {
			printed.add(node);
		}
		// returns topmost parent that was already printed or the node
		public ASTNode printedParent(ASTNode node) {
			ASTNode ret = node;
			while (!(node instanceof Program) && node != null) {
				if (printed.contains(node))
					ret = node;
				node = node.getParent();
			}
			return ret;
		}
		
		/**
		 * nodes that changed parent during the refactoring, i.e. their location info is bad
		 */
		public java.util.Set<ASTNode> moved = new HashSet<ASTNode>();
		public ASTNode getMovedAncestor(ASTNode node) {
			ASTNode ret = null;
			while (!(node instanceof Program) && node != null) {
				if (moved.contains(node))
					ret = node;
				node = node.getParent();
			}
			return ret;
		}
	}
	
	refine PrettyPrint public void ConstructorDecl.toString(StringBuffer s) {
		boolean hasConstructorsWithParameters = false;
		for (ConstructorDecl cd : (Collection<ConstructorDecl>) hostType().constructors())
			if (cd.getNumParameter() > 0) {
				hasConstructorsWithParameters = true;
				break;
			}
				
		if (this.getVisibility() == hostType().getVisibility() && 
				getConstructorAccess() instanceof SuperConstructorAccess &&
				this.getBlock().getNumStmt() == 0 &&
				!hasConstructorsWithParameters)
			/*don't print*/;
		else
			refined(s);
	}
	
	
	public void ASTModification.createTextEdit(ChangeAccumulator accu) {
		//throw new UnsupportedOperationException("ASTModification.createTextEdit()");
		if (accu.DEBUG) System.out.println("Changes : " + this.toString() + " undefined");
	}
	
	public void ASTModificationReplaceEdit.createTextEdit(ChangeAccumulator accu) {
		if (!isInTree)
			return;
		ASTNode printedParent = accu.printedParent(node);
		if (node != null && !printedParent.equals(node)) {
			reprintNode(accu, printedParent);
			return;
		}
		if (node.getCompilationUnit() == null || !node.getCompilationUnit().fromSource())
			return;
		int offset = node.createOffset(start);
		int length = node.createOffset(end) - offset + 1;
		if (offset < 0 || length < 0) {
			reprintNode(accu, node.getParent());
			return;
		}
		IFile file = FileUtil.getFile(accu.getPathName(node));
		if (accu.DEBUG) System.out.println("Changes : " + this.toString() + " " + node.getClass().getName() + " " + file.getName() + " " + offset + " " + length + " " + oldValue + " " + newValue);
		accu.addPrinted(node);
		accu.addEdit(file, offset, length, newValue);
	}
	
	public void ASTModificationCompilationUnitSetId.createTextEdit(ChangeAccumulator accu) {
		if (!isInTree)
			System.out.println("!!!!!");
		if (accu.DEBUG) System.out.println("Changes : " + this.toString() + " " + node.getClass().getName() + " " + accu.getPathName(node) + " " + oldValue + " " + newValue);
		accu.addChange(new RenameCompilationUnitChange(org.jastadd.plugin.jastaddj.util.FileUtil.getFile(accu.getPathName(node)).getFullPath(), oldValue, newValue));
	}
	
	public void ASTModificationSetChild.createTextEdit(ChangeAccumulator accu) {

		if (!isInTree)
			return;

		if (!(newChild instanceof CompilationUnit && ((CompilationUnit) newChild).fromSource()) &&
				(parent.getCompilationUnit() == null || !parent.getCompilationUnit().fromSource()))
			return;
		
		if (parent != newChild_oldParent && !(newChild instanceof CompilationUnit))
				accu.moved.add(newChild);
		
		ASTNode replace = oldChild;
		ASTNode<ASTNode> with = newChild;
		
		if (newChild instanceof CompilationUnit) { // we are adding/removing/replace a compilation unit
			System.out.print("");
			if (replace == null)
				replace = with;
			try {
				final Path path = new Path(((CompilationUnit) newChild).destinationPath());
				String defaultCharset = ResourcesPlugin.getWorkspace().getRoot().getDefaultCharset();
				Change ch = new CreateFileChange(path, "", defaultCharset) {

					@Override
					public RefactoringStatus isValid(IProgressMonitor pm) throws CoreException {
						return new RefactoringStatus();
					}

					@Override
					public Change perform(IProgressMonitor pm) throws CoreException, OperationCanceledException {
						// the action does not create the file, so create it here, it however provides an undo action

//						boolean fileCreated = false;
//						try {
//							fileCreated = path.toFile().createNewFile();
//						} catch (IOException e) {
//						}
//						ResourcesPlugin.getWorkspace().getRoot().getFile(path.removeLastSegments(1)).refreshLocal(1, new SubProgressMonitor(pm, 1));
//						if (fileCreated)
							return new DeleteResourceChange(path, true); // FIXME: false??
//						else
//							return new NullChange();
					}

				};
				accu.addChange(ch);
			} catch (CoreException e) {
				throw new RuntimeException(e);
			}
			// TODO: handle remove/replace of CU
		}

		if (replace == null && with == null)
			return;
		if (replace == null || with == null) {
			replace = parent;
			with = replace;
		}

		ASTNode printedParent = accu.printedParent(replace);
		if (replace != null && !printedParent.equals(replace)) {
			replace = with = printedParent;
		}

		// reprint parent if 
		if (replace instanceof List || replace instanceof Opt)
			replace = with;
		while (replace instanceof List /*equiv to: replace instanceof Opt*/) {
			replace = replace.getParent();
			with = replace;
		}
		
		
		int offset = replace.createOffset(replace.getStart());
		int length = replace.createOffset(replace.getEnd()) - offset + 1;
		
		// special offset and length for CompilationUnit
		if (replace instanceof CompilationUnit) {
			offset = 0;
			length = 0; // used if file !exists, e.g. when adding new compilation unit
			try {
				length = FileUtil.readTextFile(accu.getPathName(replace)).length();
			} catch (IOException e) {
			}
		}
	
		if (offset < 0 || length < 0 || accu.getMovedAncestor(replace) != null) {
			reprintNode(accu, replace.getParent());
			return;
		}
		
		IFile file = FileUtil.getFile(accu.getPathName(replace));
		System.out.println("Changes : " + this.toString() + " " + replace.getClass().getName() + " " + file.getName() + " " + offset + " " + length);
		
		String with_ = "!!!ERROR!!!"; // useful when some child*() is null
		try {
			with_ = with.toString();
		} catch (NullPointerException e) {
			
		}
		accu.addPrinted(replace);
		accu.addEdit(file, offset, length, with_);
	}
	
	protected void ASTModification.reprintNode(ChangeAccumulator accu, ASTNode node) {

		if (node == null)
			return;
		if (node.getCompilationUnit() == null || !node.getCompilationUnit().fromSource())
			return;
		
		
		// if we would overlap previous edit of parent*() node, reprint the parent insted
		ASTNode printedParent = accu.printedParent(node);
		if (node != null && !printedParent.equals(node)) {
			node = printedParent;
		}
		
		while (node instanceof List || node instanceof Opt)
			node = node.getParent();
		
		int offset = node.createOffset(node.getStart());
		int length = node.createOffset(node.getEnd()) - offset + 1;
		
		// special handling for CompilationUnit (when we are reprinting it
		if (node instanceof CompilationUnit) {
			offset = 0;
			length = 0; // used when the file !exists, e.g. when we added new CompilationUnit
			try {
				length = FileUtil.readTextFile(accu.getPathName(node)).length();
			} catch (IOException e) {
			}
		}
		

		if (offset < 0 || length < 0 || accu.getMovedAncestor(node) != null) {
			reprintNode(accu, node.getParent());
			return;
		}
		
		IFile file = FileUtil.getFile(accu.getPathName(node));
		System.out.println("Changes : reprintNode : " + node.getClass().getName() + " " + file.getName() + " " + offset + " " + length);
		
		String node_ = "!!!ERROR!!!"; // useful when some child*() is null
		try {
			node_ = node.toString();
		} catch (Exception e) { }
		
		accu.addPrinted(node);
		accu.addEdit(file, offset, length, node_);
	}
	
	public void ASTModificationInsertChild.createTextEdit(ChangeAccumulator accu) {
		if (!isInTree)
			return;
		accu.moved.add(newChild);
		// TODO: if we have concrete syntax of the child use it
		reprintNode(accu, parent);
	}
	
	public void ASTModificationRemoveChild.createTextEdit(ChangeAccumulator accu) {
		if (!isInTree)
			return;
		accu.moved.add(child);
		reprintNode(accu, parent);
	}
	
	
	
//	
//	// every ASTChange should be able to create a text edit that corresponds to
//	// its action; however, this method is as yet unimplemented for some changes...
//	public void ASTChange.eclipseASTEdit(ChangeAccumulator accu) {
//		throw new UnsupportedOperationException("ASTNode.createTextEdit()");
//	}
//	
//	// we need to store a copy of the new node's pretty printed representation
//	private String ReplaceNode.afterText;
//	refine Changes ReplaceNode.ReplaceNode(ASTNode before, ASTNode after) {
//		Changes.ReplaceNode.ReplaceNode(before, after);
//		this.afterText = after.toString();
//	}
//	public void ReplaceNode.createTextEdit(ChangeAccumulator accu) {
//		int offset = before.getBeginOffset();
//		int length = before.getEndOffset() - offset + 1;
//		accu.addEdit(FileUtil.getFile(after), offset, length, afterText);
//	}
//
//	public void Rename.createTextEdit(ChangeAccumulator accu) {
//		entity.createRenameTextEdit(accu, old_name, new_name);
//	}
//	
//	// creates a TextEdit corresponding to a rename of this entity
//	public void Named.createRenameTextEdit(ChangeAccumulator accu, 
//			String old_name, String new_name);
//
//	public void VariableDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void ParameterDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void FieldDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void MethodDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void ConstructorDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void TypeDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void CompilationUnit.createRenameTextEdit(ChangeAccumulator accu, 
//			String old_name, String new_name) {
//		IFile file = FileUtil.getFile(this);
//		accu.addChange(new RenameCompilationUnitChange(file, old_name, new_name));
//	}
//	
	class RenameCompilationUnitChange extends ResourceChange {
		private final IPath path;
		private final String old_name;
		private final String new_name;
		private final long stamp_to_restore;
		
		public RenameCompilationUnitChange(IPath path, String old_name, String new_name) {
			this(path, old_name, new_name, IResource.NULL_STAMP);
		}
		
		public RenameCompilationUnitChange(IPath path, String old_name, String new_name, long stamp_to_restore) {
			this.path = path;
			this.old_name = old_name;
			this.new_name = new_name;
			this.stamp_to_restore = stamp_to_restore;
		}

		protected final IResource getResource() {
			return ResourcesPlugin.getWorkspace().getRoot().findMember(path);
		}

		public Object getModifiedElement() {
			return JavaCore.create(getResource());
		}

		public String getNewName() {
			return new_name;
		}

		public String getOldName() {
			return old_name;
		}

		public final Change perform(IProgressMonitor pm) throws CoreException {
			try {
				pm.beginTask("Renaming Compilation Unit", 1);
				IResource resource = getResource();
				IPath newPath = createNewPath();
				Change result = createUndoChange(resource.getModificationStamp());
				doRename(new SubProgressMonitor(pm, 1));
				if (stamp_to_restore != IResource.NULL_STAMP) {
					IResource newResource = ResourcesPlugin.getWorkspace().getRoot().findMember(newPath);
					newResource.revertModificationStamp(stamp_to_restore);
				}
				return result;
			} finally {
				pm.done();
			}
		}
		
		protected IPath createNewPath() {
			//final IPath path = FileUtil.getFile(pathName).getFullPath();
			if (path.getFileExtension() != null) {
        String extension = path.getFileExtension();
				return path.removeFileExtension().removeLastSegments(1).append(getNewName()).addFileExtension(extension);
			} else
				return path.removeLastSegments(1).append(getNewName());
		}

		protected Change createUndoChange(long stampToRestore) throws JavaModelException {
			return new RenameCompilationUnitChange(createNewPath(), getNewName(), getOldName(), stampToRestore);
		}

		protected void doRename(IProgressMonitor pm) throws CoreException {
			getResource().move(createNewPath(), false, pm);
		}
		
		public String getName() {
			return "Rename Compilation Unit " + old_name + " to " + new_name;
		}

		protected IResource getModifiedResource() {	
			return getResource();
		}
	}
	
	class MoveMethodSourceModifier implements ISourceModifier {
		private final MoveSourceEdit parent;
		private final ArrayList<ReplaceEdit> edits;
		
		public MoveMethodSourceModifier(MoveSourceEdit parent) {
			this.parent = parent;
			this.edits = new ArrayList<ReplaceEdit>();
		}
		
		private MoveMethodSourceModifier(MoveSourceEdit parent, ArrayList<ReplaceEdit> edits) {
			this.parent = parent;
			this.edits = edits;
		}

		public ISourceModifier copy() {
			ArrayList<ReplaceEdit> newlist = new ArrayList<ReplaceEdit>();
			for(ReplaceEdit re : edits)
				newlist.add((ReplaceEdit)re.copy());
			return new MoveMethodSourceModifier(parent, newlist);
		}

		public ReplaceEdit[] getModifications(String arg0) {
			return edits.toArray(new ReplaceEdit[]{});
		}
		
		public void addReplaceEdit(ReplaceEdit re) {
			ReplaceEdit nre = new ReplaceEdit(re.getOffset()-parent.getOffset(), re.getLength(), re.getText());
			edits.add(nre);
		}
		
	}
//	
//	public void MoveMethod.createTextEdit(ChangeAccumulator accu) {
//		IFile origfile = FileUtil.getFile(origin);
//		IFile destfile = FileUtil.getFile(destination);
//		int origoffset = method.getBeginOffset();
//		int origlength = method.getEndOffset() - origoffset + 1;
//		int destoffset = destination.possibleInsertOffset();
//		MoveSourceEdit cse = new MoveSourceEdit(origoffset, origlength);
//		MoveTargetEdit cte = new MoveTargetEdit(destoffset, cse);
//		cse.setTargetEdit(cte);
//		cse.setSourceModifier(new MoveMethodSourceModifier(cse));
//		accu.addEdit(origfile, cse);
//		accu.addEdit(destfile, cte);
//	}
//
//	public void ChangeFieldModifiers.createTextEdit(ChangeAccumulator accu) {
//    	IFile file = FileUtil.getFile(field);
//    	int offset = old_modifiers.getBeginOffset();
//    	if(offset == -1)
//    		offset = field.getBeginOffset();
//    	assert(offset >= 0);
//    	int length = old_modifiers.getEndOffset() == -1 ? 0 : old_modifiers.getEndOffset() - offset + 1;
//    	accu.addEdit(file, offset, length, new_modifiers.toString()+" ");
//	}
//	
//	// we need to store a copy of the body decl's pretty printed representation
//	private String InsertBodyDecl.bdText;
//	refine Changes InsertBodyDecl.InsertBodyDecl(TypeDecl td, BodyDecl bd) {
//		Changes.InsertBodyDecl.InsertBodyDecl(td, bd);
//		this.bdText = bd.toString();
//	}
//	public void InsertBodyDecl.createTextEdit(ChangeAccumulator accu) {
//		IFile file = FileUtil.getFile(td);
//		int destoffset = td.possibleInsertOffset();
//		accu.addEdit(file, destoffset, 0, bdText);
//	}
//	public void InsertBodyDecl.updateText() {
//		this.bdText = bd.toString();
//	}
//	
//	public void RemoveBodyDecl.createTextEdit(ChangeAccumulator accu) {
//    	IFile file = FileUtil.getFile(td);
//    	int offset = bd.getBeginOffset();
//    	int length = bd.getEndOffset() - offset + 1;
//    	accu.addEdit(file, offset, length, "");
//	}
//	
//	// try to guess a good place to insert a new member
//	public int TypeDecl.possibleInsertOffset() {
//		for(int i=0;i<getNumBodyDecl();++i) {
//			BodyDecl bd = getBodyDecl(i);
//			if(bd.getEndOffset() > 0)
//				return bd.getBeginOffset()-1; 
//		}
//		return getEndOffset() == -1 ? -1 : getEndOffset() - 1;
//	}
}

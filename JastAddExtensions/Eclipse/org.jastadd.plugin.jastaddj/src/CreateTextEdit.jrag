import java.util.Iterator;

import org.eclipse.ltk.core.refactoring.*;
import org.eclipse.core.resources.IFile;
import org.eclipse.text.edits.TextEdit;
import org.eclipse.text.edits.ISourceModifier;
import org.eclipse.text.edits.MoveSourceEdit;
import org.eclipse.text.edits.MoveTargetEdit;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.ReplaceEdit;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.ltk.core.refactoring.Change;
import org.jastadd.plugin.jastaddj.util.FileUtil;

import AST.ASTNode;

aspect CreateTextEdit {
	/**
	 * one state for all AST nodes in the program, aj there were
	 * rewrites happening on nodes that were not attached to the tree yet
	 */
	protected static ASTNode$State ASTNode.state2 = null;
	refine ASTNode public final ASTNode$State ASTNode.state() {
        if(state2 == null) {
            if(parent == null) {
                 state2 = new ASTNode$State();
            }
            else {
                state2 = parent.state();
            }
        }
        state = state2;
        return state2;
    }
	
	
	/* a change accumulator keeps track of changes happening to multiple files;
	 * it creates one TextFileChange for every file affected and adds incoming
	 * ReplaceEdits to them
	 */
	class ChangeAccumulator {
		private String name;
		private CompositeChange changes;
		private Map<IFile, TextFileChange> changemap;
		
		public ChangeAccumulator(String name) {
			this.name = name;
			changes = new CompositeChange(name);
			changemap = new HashMap<IFile, TextFileChange>();
		}

		// retrieve the text file change object for file
		private TextFileChange changeForFile(IFile file) {
			TextFileChange tfc;
			if(!changemap.containsKey(file)) {
				// create a new one
				tfc = new TextFileChange(name, file);
				tfc.setEdit(new MultiTextEdit());
				changes.add(tfc);
				changemap.put(file, tfc);
			}
			else {
				tfc = changemap.get(file);
			}
			return tfc;
		}
		
		public void addEdit(IFile file, TextEdit te) {
			TextFileChange tfc = changeForFile(file);
			/* when inserting the new edit into tfc, we must be careful to avoid
			 * overlapping edits; our solution here is very simple: walk through
			 * all changes already in tfc, if one of them covers the new change
			 * we don't need to add it, if some of them are covered by the new
			 * change, remove them 
			 * 
			 * a subtlety arises with replace edits nested inside move source edits;
			 * we want those to be allowed, but they have to be handled specially */
			MultiTextEdit mte = (MultiTextEdit)tfc.getEdit();
			java.util.Set covered = new java.util.HashSet();
			for(int i=0; i<mte.getChildren().length; ++i) {
				TextEdit te2 = mte.getChildren()[i];
				if(te.covers(te2))
						covered.add(te2);
//				else if(te2.covers(te)) {
//					if(te2 instanceof MoveSourceEdit && te instanceof ReplaceEdit) {
//						MoveSourceEdit cse = (MoveSourceEdit)te2;
//						ReplaceEdit re = (ReplaceEdit)te;
//						((MoveMethodSourceModifier)cse.getSourceModifier()).addReplaceEdit(re);
//					}
//					return;
//				}
			}
			for(Iterator iter=covered.iterator();iter.hasNext();) {
				TextEdit te2 = (TextEdit)iter.next();
				if(te instanceof MoveSourceEdit && te2 instanceof ReplaceEdit) {
					MoveSourceEdit cse = (MoveSourceEdit)te;
					ReplaceEdit re = (ReplaceEdit)te2;
					((MoveMethodSourceModifier)cse.getSourceModifier()).addReplaceEdit(re);
				}
				mte.removeChild(te2);
			}
			tfc.addEdit(te);
		}

		public void addEdit(IFile file, int offset, int length, String contents) {
			addEdit(file, new ReplaceEdit(offset, length, contents));
		}

		// creates the TextChanges corresponding to the ASTModification in some iterator
		// and adds them to the accumulator
		public void addAllEdits(Collection<ASTModification> col) {
			Iterator<ASTModification> iter = col.iterator();
			while(iter.hasNext()) {
				ASTModification m = iter.next();
				if (m instanceof ASTModificationCompilationUnitSetId) {
					ASTModificationCompilationUnitSetId mm = (ASTModificationCompilationUnitSetId) m;
					compilationUnitOriginalPath.put((CompilationUnit) mm.node, mm.oldPathName);
				}
			}
			iter = col.iterator();
			while(iter.hasNext())
				iter.next().createTextEdit(this);
		}
		
		// directly add a non-TextChange
		public void addChange(Change ch) {
			changes.add(ch);
		}
		
		public Change getChanges() {
			return changes;
		}
		
		public Map<CompilationUnit, String> compilationUnitOriginalPath = new HashMap<CompilationUnit, String>();

		public String getPathName(IJastAddNode node) {
			CompilationUnit cu = ((ASTNode) node).compilationUnit();
			if (this.compilationUnitOriginalPath.containsKey(cu))
				return this.compilationUnitOriginalPath.get(cu);
			else
				return cu.pathName();
		}
		
		private java.util.Set<ASTNode> printed = new HashSet<ASTNode>();
		public void addPrinted(ASTNode node) {
			printed.add(node);
		}
		// returns topmost parent that was already printed or the node
		public ASTNode printedParent(ASTNode node) {
			ASTNode ret = node;
			while (!(node instanceof Program) && node != null) {
				if (printed.contains(node))
					ret = node;
				node = node.getParent();
			}
			return ret;
		}
	}
	
	
//	refine PrettyPrint eq ASTNode.extractIndent() {
//		if(getParent() == null)
//			return "";
//		String indent = getParent().extractIndent();
//		if(getParent().addsIndentationLevel())
//			indent += "\t";//"  ";
//		return indent;
//	}
	
	refine PrettyPrint public void ConstructorDecl.toString(StringBuffer s) {
		boolean hasConstructorsWithParameters = false;
		for (ConstructorDecl cd : (Collection<ConstructorDecl>) hostType().constructors())
			if (cd.getNumParameter() > 0) {
				hasConstructorsWithParameters = true;
				break;
			}
				
		if (this.getVisibility() == hostType().getVisibility() && 
				getConstructorAccess() instanceof SuperConstructorAccess &&
				this.getBlock().getNumStmt() == 0 &&
				!hasConstructorsWithParameters)
			/*don't print*/;
		else
			refined(s);
	}
	
	
	public void ASTModification.createTextEdit(ChangeAccumulator ca) {
		//throw new UnsupportedOperationException("ASTModification.createTextEdit()");
	}
	
	public void ASTModificationReplaceEdit.createTextEdit(ChangeAccumulator accu) {
		ASTNode printedParent = accu.printedParent(node);
		if (node != null && !printedParent.equals(node)) {
			node = printedParent;
		}
		int offset = node.createOffset(start);
		int length = node.createOffset(end) - offset + 1;
		if (node.getCompilationUnit() == null || !node.getCompilationUnit().fromSource() || offset < 0 || length <= 0)
			return;
		IFile file = FileUtil.getFile(accu.getPathName(node));
		System.out.println(node.getClass().getName() + " " + file.getName() + " " + offset + " " + length + " " + oldValue + " " + newValue);
		accu.addPrinted(node);
		accu.addEdit(file, offset, length, newValue);
	}
	
	public void ASTModificationCompilationUnitSetId.createTextEdit(ChangeAccumulator accu) {
		System.out.println(node.getClass().getName() + " " + accu.getPathName(node) + " " + oldValue + " " + newValue);
		accu.addChange(new RenameCompilationUnitChange(org.jastadd.plugin.jastaddj.util.FileUtil.getFile(accu.getPathName(node)).getFullPath(), oldValue, newValue));

//		//new FileUtil.getFile(accu.getPathName(node)).getFullPath()
//		accu.addChange(new RenameCompilationUnitChange(new org.eclipse.core.runtime.Path(oldPathName.replaceFirst(".*(?=test2)", "")), oldValue, newValue));
	}
	
	public void ASTModificationSetChild.createTextEdit(ChangeAccumulator accu) {

		if (parent.getCompilationUnit() == null || !parent.getCompilationUnit().fromSource())
			return;
		
		ASTNode replace = oldChild;
		ASTNode<ASTNode> with = newChild;
		

		ASTNode printedParent = accu.printedParent(replace);
		if (replace != null && !printedParent.equals(replace)) {
			replace = with = printedParent;
		}
		

		if (replace == null && with == null)
			return;
		if (replace == null || with == null) {
			replace = parent;
			with = replace;
		}
		
//		if (replace instanceof Opt && replace.getChild(0) != null && with.getChild(0) != null) {
//			replace = replace.getChild(0);
//			with = with.getChild(0);
//		}
		if (replace instanceof List || replace instanceof Opt/* || with instanceof AST.AmbiguousAccess*/)
			replace = with;
		while (replace instanceof List || replace instanceof Opt/* || with instanceof AST.AmbiguousAccess*/) {
			replace = replace.getParent();
			with = replace;
		}
		
		
		int offset = replace.createOffset(replace.getStart());
		int length = replace.createOffset(replace.getEnd()) - offset + 1;
		if (replace instanceof CompilationUnit) {
			offset = 0;
			length = Integer.MAX_VALUE;
		}
	
		if (offset < 0 || length <= 0) {
			return;
		}
		IFile file = FileUtil.getFile(accu.getPathName(replace));
		System.out.println(replace.getClass().getName() + " " + file.getName() + " " + offset + " " + length + " setting child");
		String with_ = "!!!ERROR!!!";
		try {
			with_ = with.toString();
		} catch (Exception e) {
			
		}
		accu.addPrinted(replace);
		accu.addEdit(file, offset, length, with_);
	}
	
	protected void ASTModification.reprintNode(ChangeAccumulator accu, ASTNode node) {

		if (node.getCompilationUnit() == null || !node.getCompilationUnit().fromSource())
			return;
		
		ASTNode replace = node;
		ASTNode<ASTNode> with = node;

		if (replace == null && with == null)
			return;
		
		ASTNode printedParent = accu.printedParent(replace);
		if (replace != null && !printedParent.equals(replace)) {
			replace = with = printedParent;
		}
		
		if (replace instanceof List || replace instanceof Opt /*|| with instanceof AST.AmbiguousAccess*/)
			replace = with;
		while (replace instanceof List || replace instanceof Opt /*|| with instanceof AST.AmbiguousAccess*/) {
			replace = replace.getParent();
			with = replace;
		}
		
		int offset = replace.createOffset(replace.getStart());
		int length = replace.createOffset(replace.getEnd()) - offset + 1;
		if (offset < 0 || length <= 0) {
			return;
		}
		IFile file = FileUtil.getFile(accu.getPathName(replace));
		System.out.println(replace.getClass().getName() + " " + file.getName() + " " + offset + " " + length + " setting child");
		String with_ = "!!!ERROR!!!";
		try {
			with_ = with.toString();
		} catch (Exception e) {
			
		}
		accu.addPrinted(replace);
		accu.addEdit(file, offset, length, with_);
	}
	
	public void ASTModificationInsertChild.createTextEdit(ChangeAccumulator accu) {
		// TODO: if we have concrete syntax of the child use it
		reprintNode(accu, parent);
	}
	
	public void ASTModificationRemoveChild.createTextEdit(ChangeAccumulator accu) {
		reprintNode(accu, parent);
	}
	
	
	
	// TODO: supress unnecessary constructor printing and reordering
	
	
	
//	
//	// every ASTChange should be able to create a text edit that corresponds to
//	// its action; however, this method is as yet unimplemented for some changes...
//	public void ASTChange.eclipseASTEdit(ChangeAccumulator accu) {
//		throw new UnsupportedOperationException("ASTNode.createTextEdit()");
//	}
//	
//	// we need to store a copy of the new node's pretty printed representation
//	private String ReplaceNode.afterText;
//	refine Changes ReplaceNode.ReplaceNode(ASTNode before, ASTNode after) {
//		Changes.ReplaceNode.ReplaceNode(before, after);
//		this.afterText = after.toString();
//	}
//	public void ReplaceNode.createTextEdit(ChangeAccumulator accu) {
//		int offset = before.getBeginOffset();
//		int length = before.getEndOffset() - offset + 1;
//		accu.addEdit(FileUtil.getFile(after), offset, length, afterText);
//	}
//
//	public void Rename.createTextEdit(ChangeAccumulator accu) {
//		entity.createRenameTextEdit(accu, old_name, new_name);
//	}
//	
//	// creates a TextEdit corresponding to a rename of this entity
//	public void Named.createRenameTextEdit(ChangeAccumulator accu, 
//			String old_name, String new_name);
//
//	public void VariableDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void ParameterDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void FieldDeclaration.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void MethodDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void ConstructorDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void TypeDecl.createRenameTextEdit(ChangeAccumulator accu, String old_name, String new_name) {
//		int offset = createOffset(IDstart);
//		int offsetEnd = createOffset(IDend);
//		int length = offsetEnd - offset + 1;
//		accu.addEdit(FileUtil.getFile(this), offset, length, new_name);
//	}
//
//	public void CompilationUnit.createRenameTextEdit(ChangeAccumulator accu, 
//			String old_name, String new_name) {
//		IFile file = FileUtil.getFile(this);
//		accu.addChange(new RenameCompilationUnitChange(file, old_name, new_name));
//	}
//	
	class RenameCompilationUnitChange extends ResourceChange {
		private final IPath path;
		private final String old_name;
		private final String new_name;
		private final long stamp_to_restore;
		
		public RenameCompilationUnitChange(IPath path, String old_name, String new_name) {
			this(path, old_name, new_name, IResource.NULL_STAMP);
		}
		
		public RenameCompilationUnitChange(IPath path, String old_name, String new_name, long stamp_to_restore) {
			this.path = path;
			this.old_name = old_name;
			this.new_name = new_name;
			this.stamp_to_restore = stamp_to_restore;
		}

		protected final IResource getResource() {
			return ResourcesPlugin.getWorkspace().getRoot().findMember(path);
		}

		public Object getModifiedElement() {
			return JavaCore.create(getResource());
		}

		public String getNewName() {
			return new_name;
		}

		public String getOldName() {
			return old_name;
		}

		public final Change perform(IProgressMonitor pm) throws CoreException {
			try {
				pm.beginTask("Renaming Compilation Unit", 1);
				IResource resource = getResource();
				IPath newPath = createNewPath();
				Change result = createUndoChange(resource.getModificationStamp());
				doRename(new SubProgressMonitor(pm, 1));
				if (stamp_to_restore != IResource.NULL_STAMP) {
					IResource newResource = ResourcesPlugin.getWorkspace().getRoot().findMember(newPath);
					newResource.revertModificationStamp(stamp_to_restore);
				}
				return result;
			} finally {
				pm.done();
			}
		}
		
		protected IPath createNewPath() {
			//final IPath path = FileUtil.getFile(pathName).getFullPath();
			if (path.getFileExtension() != null) {
        String extension = path.getFileExtension();
				return path.removeFileExtension().removeLastSegments(1).append(getNewName()).addFileExtension(extension);
			} else
				return path.removeLastSegments(1).append(getNewName());
		}

		protected Change createUndoChange(long stampToRestore) throws JavaModelException {
			return new RenameCompilationUnitChange(createNewPath(), getNewName(), getOldName(), stampToRestore);
		}

		protected void doRename(IProgressMonitor pm) throws CoreException {
			getResource().move(createNewPath(), false, pm);
		}
		
		public String getName() {
			return "Rename Compilation Unit " + old_name + " to " + new_name;
		}

		protected IResource getModifiedResource() {	
			return getResource();
		}
	}
	
	class MoveMethodSourceModifier implements ISourceModifier {
		private final MoveSourceEdit parent;
		private final ArrayList<ReplaceEdit> edits;
		
		public MoveMethodSourceModifier(MoveSourceEdit parent) {
			this.parent = parent;
			this.edits = new ArrayList<ReplaceEdit>();
		}
		
		private MoveMethodSourceModifier(MoveSourceEdit parent, ArrayList<ReplaceEdit> edits) {
			this.parent = parent;
			this.edits = edits;
		}

		public ISourceModifier copy() {
			ArrayList<ReplaceEdit> newlist = new ArrayList<ReplaceEdit>();
			for(ReplaceEdit re : edits)
				newlist.add((ReplaceEdit)re.copy());
			return new MoveMethodSourceModifier(parent, newlist);
		}

		public ReplaceEdit[] getModifications(String arg0) {
			return edits.toArray(new ReplaceEdit[]{});
		}
		
		public void addReplaceEdit(ReplaceEdit re) {
			ReplaceEdit nre = new ReplaceEdit(re.getOffset()-parent.getOffset(), re.getLength(), re.getText());
			edits.add(nre);
		}
		
	}
//	
//	public void MoveMethod.createTextEdit(ChangeAccumulator accu) {
//		IFile origfile = FileUtil.getFile(origin);
//		IFile destfile = FileUtil.getFile(destination);
//		int origoffset = method.getBeginOffset();
//		int origlength = method.getEndOffset() - origoffset + 1;
//		int destoffset = destination.possibleInsertOffset();
//		MoveSourceEdit cse = new MoveSourceEdit(origoffset, origlength);
//		MoveTargetEdit cte = new MoveTargetEdit(destoffset, cse);
//		cse.setTargetEdit(cte);
//		cse.setSourceModifier(new MoveMethodSourceModifier(cse));
//		accu.addEdit(origfile, cse);
//		accu.addEdit(destfile, cte);
//	}
//
//	public void ChangeFieldModifiers.createTextEdit(ChangeAccumulator accu) {
//    	IFile file = FileUtil.getFile(field);
//    	int offset = old_modifiers.getBeginOffset();
//    	if(offset == -1)
//    		offset = field.getBeginOffset();
//    	assert(offset >= 0);
//    	int length = old_modifiers.getEndOffset() == -1 ? 0 : old_modifiers.getEndOffset() - offset + 1;
//    	accu.addEdit(file, offset, length, new_modifiers.toString()+" ");
//	}
//	
//	// we need to store a copy of the body decl's pretty printed representation
//	private String InsertBodyDecl.bdText;
//	refine Changes InsertBodyDecl.InsertBodyDecl(TypeDecl td, BodyDecl bd) {
//		Changes.InsertBodyDecl.InsertBodyDecl(td, bd);
//		this.bdText = bd.toString();
//	}
//	public void InsertBodyDecl.createTextEdit(ChangeAccumulator accu) {
//		IFile file = FileUtil.getFile(td);
//		int destoffset = td.possibleInsertOffset();
//		accu.addEdit(file, destoffset, 0, bdText);
//	}
//	public void InsertBodyDecl.updateText() {
//		this.bdText = bd.toString();
//	}
//	
//	public void RemoveBodyDecl.createTextEdit(ChangeAccumulator accu) {
//    	IFile file = FileUtil.getFile(td);
//    	int offset = bd.getBeginOffset();
//    	int length = bd.getEndOffset() - offset + 1;
//    	accu.addEdit(file, offset, length, "");
//	}
//	
//	// try to guess a good place to insert a new member
//	public int TypeDecl.possibleInsertOffset() {
//		for(int i=0;i<getNumBodyDecl();++i) {
//			BodyDecl bd = getBodyDecl(i);
//			if(bd.getEndOffset() > 0)
//				return bd.getBeginOffset()-1; 
//		}
//		return getEndOffset() == -1 ? -1 : getEndOffset() - 1;
//	}
}

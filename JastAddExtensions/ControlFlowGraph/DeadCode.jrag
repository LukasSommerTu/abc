aspect DeadCode {	

	// Add dead code check

	// EN: Moving this to CFNode
	/*
	syn lazy boolean Stmt.isDead();
	syn lazy boolean Expr.isDead();
	eq Stmt.isDead() = !def().compl(out()).isEmpty();
	eq Expr.isDead() = !def().compl(out()).isEmpty();
	*/
	syn lazy boolean CFNode.isDead();
	eq CFNode.isDead() = !def().compl(out()).isEmpty();

	//	eq VariableDeclaration.isDead() = false; // Lets keep all declarations dead or alive ... 
	
	// Collect dead code in each compilation unit
	coll HashSet CompilationUnit.deadCode() [new HashSet()] with add root CompilationUnit;
	Stmt contributes this when isDead() to CompilationUnit.deadCode() for enclosingCompilationUnit();
	VarAccess contributes this when isDead() to CompilationUnit.deadCode() for enclosingCompilationUnit();
	
	// Make sure each statement knows its enclosing compilation unit
	inh CompilationUnit CFNode.enclosingCompilationUnit();

	// EN: Raising the level for this equation to capture all nodes
	//	eq CompilationUnit.getTypeDecl(int i).enclosingCompilationUnit() = this;
	eq Program.getCompilationUnit(int i).enclosingCompilationUnit() = getCompilationUnit(i);
}	

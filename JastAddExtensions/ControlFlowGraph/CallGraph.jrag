aspect CallGraph {

	// Call graph nodes
	interface CGNode {
		TypeDecl hostType();
		// Implementation for this attribute is located in CallGraphVisual.jrag
		String visualCallGraphName();
	}
	BodyDecl implements CGNode;

	// Collect callees from children of BodyDecl
	coll SmallSet<CGNode> BodyDecl.callees() [SmallSet.mutable()] with add root TypeDecl;
	MethodAccess contributes callees() to BodyDecl.callees() for enclosingBodyDecl();
	ConstructorAccess contributes decl() to BodyDecl.callees() for enclosingBodyDecl();
	ClassInstanceExpr contributes decl() to BodyDecl.callees() for enclosingBodyDecl();

	// Collect calls to BodyDecl, invert the callees collection
	coll SmallSet<CGNode> BodyDecl.calls() [SmallSet.mutable()] with add root TypeDecl;
	BodyDecl contributes this to BodyDecl.calls() for each callees();

	// Gather possible callees at method access nodes
	syn SmallSet<CGNode> MethodAccess.callees() = SmallSet.singleton((CGNode)decl());
	eq VirtualMethodAccess.callees() { 
		// Collect overriding methods
		SmallSet<CGNode> possibleCallees = SmallSet.empty();
		// Don't want to include decl() if the method is abstract 
		// (i.e. in an interface or abstract class)
		if (decl().isAbstract()) {
			possibleCallees = decl().overridingMethods();
		} else {
			possibleCallees = super.callees().union(decl().overridingMethods());
		}
		// Add local classes from the enclosing scope
		for (TypeDecl decl : localDeclsInScope()) {
			for (Iterator itr = decl.methodsIterator(); itr.hasNext();) {
				MethodDecl methodDecl = (MethodDecl)itr.next();
				if (applicable(methodDecl) && accessible(methodDecl)) {
					possibleCallees = possibleCallees.union(methodDecl);
				}
			}
		}
		// Divide callees into a set of subEq callees (i.e. in subclasses to the 
		// calling type or in the calling type) and the closest super callee to the
		// calling type
		TypeDecl callingType = isQualified() ? qualifier().type() : hostType();
		SmallSet<CGNode> subEqCallees = SmallSet.empty();
		MethodDecl superCallee = decl(); 
		for (CGNode callee : possibleCallees) {
			if (callee.hostType().instanceOf(callingType)) {
				subEqCallees = subEqCallees.union(callee);
			} else if (superCallee.overridingMethods().contains(callee)) {
				superCallee = (MethodDecl)callee;
			}
		}
		// This happens if the implementation is in a super class and there is no
		// overriding implementation in a class equal to or below the declared type
		SmallSet<CGNode> callees = SmallSet.empty();
		if (subEqCallees.size() == 0) {
			callees = callees.union(superCallee);
		} else {
			callees = callees.union(subEqCallees);
		}
		return callees;
	}

}

aspect SpecializeStaticVirtualCalls {
	// Guard attribute
	syn boolean MethodAccess.isExactMethodAccess() = true;
	eq StaticMethodAccess.isExactMethodAccess() = false;
	eq VirtualMethodAccess.isExactMethodAccess() = false;
	// Specialize MethodAccess nodes for static/virtual calls
	rewrite MethodAccess {
		when (isExactMethodAccess() && decl().isStatic()) to StaticMethodAccess {
			return new StaticMethodAccess(getID(), getArgList());
		}
		when (isExactMethodAccess() && !decl().isStatic()) to VirtualMethodAccess {
			return new VirtualMethodAccess(getID(), getArgList());
		}
	}
}

aspect Inheritance {
	
	// collect overriding methods by reversing the ancestorMethods collection
	coll SmallSet<CGNode> MethodDecl.overridingMethods()
		[SmallSet.mutable()] with add root CompilationUnit;
	MethodDecl contributes overridingMethods().union(this) 
		when !hostType().isLocalClass() && !hostType().isAnonymous()
		to MethodDecl.overridingMethods()
		for each hostType().ancestorMethods(signature());

	// Collect local and anonymous classes in BodyDecl
	coll SmallSet<TypeDecl> BodyDecl.localDecls() [SmallSet.mutable()] with add root BodyDecl;
	TypeDecl contributes this when (isLocalClass() || isAnonymous())
		to BodyDecl.localDecls() for enclosingBodyDecl();

	// Collect anonymous classes from fields in TypeDecl
	coll SmallSet<TypeDecl> TypeDecl.localDecls() [SmallSet.mutable()] with add root CompilationUnit;
	FieldDeclaration contributes localDecls() to TypeDecl.localDecls() for hostType();

	// Inherit the localDecls collections in MethodAccess and BodyDecl	
	inh SmallSet<TypeDecl> MethodAccess.localDeclsInScope();
	inh SmallSet<TypeDecl> BodyDecl.localDeclsInScope();
	eq Program.getChild(int i).localDeclsInScope() = SmallSet.empty();
	eq TypeDecl.getBodyDecl(int i).localDeclsInScope() = localDecls();
	eq InstanceInitializer.getBlock().localDeclsInScope() = localDecls().union(localDeclsInScope());
	eq StaticInitializer.getBlock().localDeclsInScope() = localDecls().union(localDeclsInScope());
	eq ConstructorDecl.getBlock().localDeclsInScope() = localDecls().union(localDeclsInScope());
	eq MethodDecl.getBlock().localDeclsInScope() = localDecls().union(localDeclsInScope());
}

// Intra type flow at class loading and instance initialization
aspect StaticIntraTypeFlow {

	// Interface
	interface FlowNode { }
	BodyDecl implements FlowNode;
	TypeDecl implements FlowNode;
	EnumConstant implements FlowNode;

	// Flow interface declarations -- static
	syn FlowNode TypeDecl.staticEntry();
	syn FlowNode EnumConstant.staticEntry();
	syn FlowNode TypeDecl.staticExit();
	syn FlowNode EnumConstant.staticExit();
	syn SmallSet<FlowNode> BodyDecl.staticSucc();
	coll SmallSet<FlowNode> FlowNode.staticPred() [SmallSet.mutable()] with add root TypeDecl;

	// Helpers declaration -- static
	syn boolean BodyDecl.includeInStaticFlow();
	inh SmallSet<FlowNode> BodyDecl.staticFollowing();

	// Flow interface declarations -- instance
	syn FlowNode TypeDecl.instanceEntry();
	syn FlowNode EnumConstant.instanceEntry();
	syn FlowNode TypeDecl.instanceExit();
	syn FlowNode EnumConstant.instanceExit();
	syn SmallSet<FlowNode> BodyDecl.instanceSucc();
	coll SmallSet<FlowNode> FlowNode.instancePred() [SmallSet.mutable()] with add root TypeDecl;

	// Helpers declaration -- instance
	syn boolean BodyDecl.includeInInstanceFlow();
	inh SmallSet<FlowNode> BodyDecl.instanceFollowing();

	// Implementation: FlowNode.staticPred();
	BodyDecl contributes this when includeInStaticFlow() 
		to FlowNode.staticPred() for each staticSucc();
	
	// Implementation: FlowNode TypeDecl.staticEntry()
	eq TypeDecl.staticEntry() {
		for (int i = 0; i < getNumBodyDecl(); i++) {
			BodyDecl decl = getBodyDecl(i);
			if (decl.includeInStaticFlow()) {
				return decl;
			}
		}
		return staticExit();
	}
	eq EnumConstant.staticEntry() {
		for (int i = 0; i < getNumBodyDecl(); i++) {
			BodyDecl decl = getBodyDecl(i);
			if (decl.includeInStaticFlow()) {
				return decl;
			}
		}
		return staticExit();
	}	

	// Implementation: FlowNode TypeDecl.staticExit()
	eq TypeDecl.staticExit() = this;
	eq EnumConstant.staticExit() = this;

	// Implementation: SmallSet<FlowNode> BodyDecl.staticFollowing()
	eq TypeDecl.getBodyDecl(int i).staticFollowing() {
		for (int j = i + 1; j < getNumBodyDecl(); j++) {
			BodyDecl decl = getBodyDecl(j);
			if (decl.includeInStaticFlow()) {
				return SmallSet.singleton((FlowNode)decl);
			}
		}
		return SmallSet.singleton((FlowNode)staticExit());
	}
	eq EnumConstant.getBodyDecl(int i).staticFollowing() {
		for (int j = i + 1; j < getNumBodyDecl(); j++) {
			BodyDecl decl = getBodyDecl(j);
			if (decl.includeInStaticFlow()) {
				return SmallSet.singleton((FlowNode)decl);
			}
		}
		return SmallSet.singleton((FlowNode)staticExit());
	}
	
	// Implementation: SmallSet<FlowNode> BodyDecl.staticSucc()
	eq BodyDecl.staticSucc() = staticFollowing();
	
	// Implementation: boolean BodyDecl.includeInStaticFlow()
	eq BodyDecl.includeInStaticFlow() = false;
	eq StaticInitializer.includeInStaticFlow() = true;
	eq FieldDeclaration.includeInStaticFlow() = isStatic();	



	// Implementation: FlowNode.instancePred();
	BodyDecl contributes this when includeInInstanceFlow() 
		to FlowNode.instancePred() for each staticSucc();
	
	// Implementation: FlowNode TypeDecl.instanceEntry()
	eq TypeDecl.instanceEntry() {
		for (int i = 0; i < getNumBodyDecl(); i++) {
			BodyDecl decl = getBodyDecl(i);
			if (decl.includeInInstanceFlow()) {
				return decl;
			}
		}
		return instanceExit();
	}
	eq EnumConstant.instanceEntry() {
		for (int i = 0; i < getNumBodyDecl(); i++) {
			BodyDecl decl = getBodyDecl(i);
			if (decl.includeInInstanceFlow()) {
				return decl;
			}
		}
		return instanceExit();
	}	

	// Implementation: FlowNode FlowDecl.instanceExit()
	eq TypeDecl.instanceExit() = this;
	eq EnumConstant.instanceExit() = this;

	// Implementation: SmallSet<FlowNode> BodyDecl.instanceFollowing()
	eq TypeDecl.getBodyDecl(int i).instanceFollowing() {
		for (int j = i + 1; j < getNumBodyDecl(); j++) {
			BodyDecl decl = getBodyDecl(j);
			if (decl.includeInInstanceFlow()) {
				return SmallSet.singleton((FlowNode)decl);
			}
		}
		return SmallSet.singleton((FlowNode)instanceExit());
	}
	eq EnumConstant.getBodyDecl(int i).instanceFollowing() {
		for (int j = i + 1; j < getNumBodyDecl(); j++) {
			BodyDecl decl = getBodyDecl(j);
			if (decl.includeInInstanceFlow()) {
				return SmallSet.singleton((FlowNode)decl);
			}
		}
		return SmallSet.singleton((FlowNode)instanceExit());
	}
	
	// Implementation: SmallSet<FlowNode> BodyDecl.instanceSucc()
	eq BodyDecl.instanceSucc() = instanceFollowing();
	
	// Implementation: boolean BodyDecl.includeInInstanceFlow()
	eq BodyDecl.includeInInstanceFlow() = false;
	eq InstanceInitializer.includeInInstanceFlow() = true;
	eq FieldDeclaration.includeInInstanceFlow() = !isStatic();	
}

aspect IntertypeMethodNameAnalysis {
  eq IntertypeMethodDecl.getTargetType().nameType() = NameType.TYPE_NAME;
  
  // hostAspect is the aspect the declares the intertype method decl
  syn TypeDecl IntertypeMethodDecl.hostAspect() = (TypeDecl)getParent().getParent();
  // introducedType is the type into which the intertype method decl is statically introduced
  syn TypeDecl IntertypeMethodDecl.introducedType() = getTargetType().type();

  // override ag-inherited attribute, this will cause calls bound to an
  // IntertypeMethodDecl to invoke a method in the introducedType instead of the hostAspect
  syn TypeDecl IntertypeMethodDecl.hostType() = introducedType();
  eq IntertypeMethodDecl.getBlock().hostType() = hostType();
  eq IntertypeMethodDecl.getParameter(int index).hostType() = hostType();
  eq IntertypeMethodDecl.getBlock().lookupMethod(String name) {
    MethodCollection c = introducedType().remoteLookupMethod(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }

  // override behavior to allow multiple methods with the same signature (but in different types)
  syn MethodCollection AspectDecl.localLookupMethod(MethodDecl signature) {
    String name = signature.name();
    MethodCollection maxSpecific = MethodCollection.emptyCollection();
    maxSpecific = maxSpecific.add(signature);
    return maxSpecific;
  }
  
  refine LookupMethod eq TypeDecl.localMethods(String name) {
    Collection methods = LookupMethod.TypeDecl.localMethods(name);
    if(!methods.isEmpty()) return methods;
    methods = new ArrayList();
    for(Iterator iter = introducedMethods().iterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(m.name().equals(name))
        methods.add(m);
    }
    return methods;
  }

  syn lazy Collection AspectDecl.localIntroductionMethods() {
    Collection c = new ArrayList(1);
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i) instanceof IntertypeMethodDecl) {
      	c.add(getBodyDecl(i));
      }
    }
    return c;
  }

  protected void IntertypeMethodDecl.collectIntertypeDecls(HashMap map) {
    super.collectIntertypeDecls(map);
    TypeDecl typeDecl = introducedType();
    if(!map.containsKey(typeDecl))
      map.put(typeDecl, new ArrayList());
    Collection c = (Collection)map.get(typeDecl);
    c.add(this);
  }

  syn lazy Collection TypeDecl.introducedMethods() {
    Collection c = new ArrayList();
    for(Iterator iter = intertypeDecls().iterator(); iter.hasNext(); ) {
      ASTNode node = (ASTNode)iter.next();
      if(node instanceof IntertypeMethodDecl)
        c.add(node);
    }
    return c;
  }
}

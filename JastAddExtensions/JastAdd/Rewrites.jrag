aspect Rewrite {
  eq RewriteDecl.getAccess().nameType() = NameType.TYPE_NAME;
  eq RewriteListDecl.getParentType().nameType() = NameType.TYPE_NAME;
  eq RewriteListDecl.getChildName().nameType() = NameType.METHOD_NAME;

  eq Rewrite.getAccess().nameType() = NameType.TYPE_NAME;
  
  // Satisfy reachability analysis for rewrite clauses
  eq RewriteDecl.getRewrite().reachable() = true;

  // Equation to bind expr to this hostbody declaration
  eq RewriteDecl.getRewrite().hostBodyDecl() = this;
  
  // Maps TypeDecl -> RewriteDecl
  syn lazy Map Program.rewritesMap() {
    Map map = new HashMap();
    collectRewrites(map);
    return map;
  }
  // Generic traversal that collects rewrites
  protected void ASTNode.collectRewrites(Map map) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectRewrites(map);
  }

  // Collect rewrites in AspectDecl
  syn lazy Map AspectDecl.rewritesMap() {
    Map map = new HashMap();
    collectRewrites(map);
    return map;
  }
  
  // Override and add self when rewrite
  protected void RewriteDecl.collectRewrites(Map map) {
    TypeDecl introducedType = getAccess().type();
    if(!map.containsKey(introducedType))
      map.put(introducedType, new ArrayList(1));
    Collection c = (Collection)map.get(introducedType);
    c.add(this);
  }

  // Set of rewrites for this ASTDecl
  syn lazy Collection ASTDecl.rewrites() = lookupRewrites(this);
  inh Collection ASTDecl.lookupRewrites(TypeDecl typeDecl);
  eq Program.getCompilationUnit(int i).lookupRewrites(TypeDecl typeDecl) = rewritesMap().containsKey(typeDecl) ? (Collection)rewritesMap().get(typeDecl) : new ArrayList(0);

  
  private FieldDeclaration AspectDecl.duringCounter = null; 
  syn lazy FieldDeclaration AspectDecl.duringCounter() {
    // protected static int duringAspectName = 0;
    if(duringCounter != null) return duringCounter;
    FieldDeclaration field =
      new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("protected")).add(new Modifier("static"))),
        new TypeAccess("int"),
        "during" + name(),
        new IntegerLiteral(0)
      );
    duringCounter = field;
    TypeDecl typeDecl = extractSingleType(lookupType("ASTNode"));
    typeDecl.addMemberField(field);
    typeDecl.addMemberMethod(
      // protected static boolean duringAspectName() {
      //   if(duringAspectName == 0)
      //     return false;
      //   else {
      //     state.pop();
      //     state.push(ASTNode.REWRITE_INTERRUPT);
      //     return true;
      //   }
      // }
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("protected")).add(new Modifier("static"))),
        new PrimitiveTypeAccess("boolean"),
        "during" + name(),
        new List(),
        new List(),
        new List(),
        new Opt(
          new Block(
            new List().add(
              new IfStmt(
                new EQExpr(
                  field.createBoundFieldAccess(),
                  new IntegerLiteral(0)
                ),
                new ReturnStmt(new BooleanLiteral(false)),
                new Block(
                  new List().add(
                    new ExprStmt(
                      new VarAccess("state").qualifiesAccess(
                        new MethodAccess(
                          "pop",
                          new List()
                        )
                      )
                    )
                  ).add(
                    new ExprStmt(
                      new VarAccess("state").qualifiesAccess(
                        new MethodAccess(
                          "push",
                          new List().add(
                            typeDecl.createQualifiedAccess().qualifiesAccess(
                              new VarAccess("REWRITE_INTERRUPT")
                            )
                          )
                        )
                      )
                    )
                  ).add(
                    new ReturnStmt(new BooleanLiteral(true))
                  )
                )
              )
            )
          )
        )
      )
    );
    return field;
  }

  inh FieldDeclaration Rewrite.duringCounter();
  eq AspectDecl.getBodyDecl(int i).duringCounter() = duringCounter();
  eq Program.getCompilationUnit(int i).duringCounter() { throw new Error("inherited attribute duringCounter does not have an equation"); }

  // Generate rewrite code for this ASTDecl
  public void ASTDecl.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    List statements = new List();
    for(Iterator iter = rewrites().iterator(); iter.hasNext(); ) {
      RewriteDecl r = (RewriteDecl)iter.next();
      for(int i = 0; i < r.getNumRewrite(); i++)
        r.getRewrite(i).addTestAndRewrite(statements);
    }
    addDelegationRewriteTo(statements);
    addRewriteMethodDecl(statements);

    addCloneNodeInit("inCircle", new BooleanLiteral(false));
    addCloneNodeInit("isFinal", new BooleanLiteral(false));

    addGetNumChild();
    addMayHaveRewrite();

    addFinalRootNode();

    addNTAGetChildNoTransform();
  }

  syn lazy boolean TypeDecl.mayHaveRewriteRule() = false;
  eq ClassDecl.mayHaveRewriteRule() = hasSuperclass() ? superclass().mayHaveRewriteRule() : false;
  eq ASTDecl.mayHaveRewriteRule() = !rewrites().isEmpty() || superclass().mayHaveRewriteRule();

  private void ASTDecl.addMayHaveRewrite() {
    addMemberMethod(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public"))),
        new TypeAccess("boolean"),
        "mayHaveRewrite",
        new List(),
        new List(),
        new List(),
        new Opt(
          new Block(
            new List().add(
              new ReturnStmt(new BooleanLiteral(mayHaveRewriteRule()))
            )
          )
        )
      )
    );
  }

  private void ASTDecl.addFinalRootNode() {
    if(isRootNode())
      addBodyDecl(
        new InstanceInitializer(
          new Block(
            new List().add(
              AssignExpr.asStmt(
                new VarAccess("isFinal"),
                new BooleanLiteral(true)
              )
            )
          )
        )
      );
  }

  private void ASTDecl.addGetNumChild() {
    int n = 0;
    for(Iterator iter = components().iterator(); iter.hasNext(); ) {
      ASTChild c = (ASTChild)iter.next();
      //if(!c.isNTA() && !(c instanceof ASTTokenChild))
      if(!(c instanceof ASTTokenChild))
        n++;
    }
    addMemberMethod(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public"))),
        new TypeAccess("int"),
        "getNumChild",
        new List(),
        new List(),
        new List(),
        new Opt(
          new Block(
            new List().add(
              new ReturnStmt(new IntegerLiteral(n))
            )
          )
        )
      )
    );
  }

  inh boolean Rewrite.isListRewrite();
  eq RewriteDecl.getRewrite(int i).isListRewrite() = false;
  eq RewriteListDecl.getRewrite(int i).isListRewrite() = true;
  
  inh TypeDecl Rewrite.parentNodeType();
  eq RewriteDecl.getRewrite(int i).parentNodeType() {
    throw new Error("parentNodeType not implemented for " + getClass().getName()); 
  }
  eq RewriteListDecl.getRewrite(int i).parentNodeType() = getParentType().type();
  
  inh MethodDecl Rewrite.childMethod();
  eq RewriteDecl.getRewrite(int i).childMethod() {
    throw new Error("childMethod not implemented for " + getClass().getName()); 
  }
  eq RewriteListDecl.getRewrite(int i).childMethod() = ((MethodAccess)getChildName()).decl();

  public abstract Expr Rewrite.createCondition();

  public Expr ConditionalRewrite.createCondition() {
    if(!isListRewrite()) {
      return (Expr)getExpr().fullCopy();
    }
    else {
      return new AndLogicalExpr(
        new AndLogicalExpr(
          // getParent().getParent() instanceof ParentType
          createCheckParentType(),
          // ((ParentType)getParent().getParent()).getChildNameListNoTransform() == getParent()
          createCheckCorrectChild()
        ),
        (Expr)getExpr().fullCopy()
      );
    }
  }
  public Expr UnconditionalRewrite.createCondition() {
    if(!isListRewrite()) {
      return new BooleanLiteral(true);
    }
    else {
      return new AndLogicalExpr(
        new AndLogicalExpr(
          // getParent().getParent() instanceof ParentType
          createCheckParentType(),
          // ((ParentType)getParent().getParent()).getChildNameListNoTransform() == getParent()
          createCheckCorrectChild()
        ),
        new BooleanLiteral(true)
      );
    }
  }
  
  public void Rewrite.addTestAndRewrite(List statements) {
    if(isListRewrite()) {
      // replace return x with getParent().insertList(x, getParent().getIndexOfChild(this))
      getBlock().replaceReturnStmts();
    }
    // if(expr) { ... return node; }
    FieldDeclaration field = duringCounter();
    statements.add(
      new IfStmt(
        createCondition(),
        new Block(
          new List().add(
            new ExprStmt(
              new PostIncExpr(
                field.createBoundFieldAccess()
              )
            )
          ).add(
            new TryStmt(
              (Block)getBlock().fullCopy(),
              new List(),
              new Opt(
                new Block(
                  new List().add(
                    new ExprStmt(
                      new PostDecExpr(
                        field.createBoundFieldAccess()
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
  }
  
  // getParent().getParent() instanceof ParentType
  protected Expr Rewrite.createCheckParentType() {
    return new InstanceOfExpr(
      new MethodAccess(
        "getParent",
        new List()
      ).qualifiesAccess(
        new MethodAccess(
          "getParent",
          new List()
        )
      ),
      parentNodeType().createQualifiedAccess()
    );
  }
  
  // ((ParentType)getParent().getParent()).getChildNameListNoTransform() == getParent()
  protected Expr Rewrite.createCheckCorrectChild() {
    return new EQExpr(
      new ParExpr(
        new CastExpr(
          parentNodeType().createQualifiedAccess(),
          new MethodAccess(
            "getParent",
            new List()
          ).qualifiesAccess(
            new MethodAccess(
              "getParent",
              new List()
            )
          )
        )
      ).qualifiesAccess(
        new MethodAccess(
          childMethod().name() + "ListNoTransform",
          new List()
        )
      ),
      new MethodAccess(
        "getParent",
        new List()
      )
    );
  }
  
  // replace return x with getParent().insertList(x, getParent().getIndexOfChild(this))
  protected void ASTNode.replaceReturnStmts() {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).replaceReturnStmts();
  }
  protected void ReturnStmt.replaceReturnStmts() {
    if(hasResult()) {
      setResult(
        new MethodAccess(
          "getParent",
          new List()
        ).qualifiesAccess(
          new MethodAccess(
            "insertList",
            new List().add(
              getResult()
            ).add(
              new MethodAccess(
                "getParent",
                new List()
              ).qualifiesAccess(
                new MethodAccess(
                  "getIndexOfChild",
                  new List().add(new ThisAccess("this"))
                )
              )
            )
          )
        )
      );
    }
  }
  
  private void ASTDecl.addDelegationRewriteTo(List statements) {
    // return super.rewriteTo();
    statements.add(
      new ReturnStmt(
        new SuperAccess(
          "super"
        ).qualifiesAccess(
          new MethodAccess(
            "rewriteTo",
            new List()
          )
        )
      )
    );
  }
  private void ASTDecl.addRewriteMethodDecl(List statements) {
    // public ASTNode rewriteTo() { statements }
    addMemberMethod(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public"))),
        new TypeAccess("ASTNode"),
        "rewriteTo",
        new List(),
        new List(),
        new List(),
        new Opt(
          new Block(
            statements
          )
        )
      )
    );
  }


  public void RewriteDecl.toString(StringBuffer s) {
    s.append(indent() + "rewrite ");
    getAccess().toString(s);
    s.append(" {\n");
    indent++;
    for(int i = 0; i < getNumRewrite(); i++)
      getRewrite(i).toString(s);
    indent--;
    s.append(indent() + "}\n");
  }

  public void UnconditionalRewrite.toString(StringBuffer s) {
    s.append(indent() + "to ");
    getAccess().toString(s);
    s.append(" ");
    getBlock().toString(s);
  }
  public void ConditionalRewrite.toString(StringBuffer s) {
    s.append(indent() + "when(");
    getExpr().toString(s);
    s.append(")\n");
    s.append(indent() + "to ");
    getAccess().toString(s);
    s.append(" ");
    getBlock().toString(s);
  }



  eq RewriteListDecl.getChildName().lookupMethod(String name) = 
    getParentType().type().memberMethods(name);

  eq RewriteDecl.getRewrite(int index).lookupMethod(String name) = 
    getAccess().type().memberMethods(name);

  eq RewriteDecl.getRewrite(int index).hostType() = getAccess().type();
}

aspect GenerateSynCode {

  // override behavior in IntertypeMethodCodegeneration
  refine Rewrites public void ASTDecl.generateIntertypeDecls() {
    Rewrites.ASTDecl.generateIntertypeDecls();
    // iterate over SynEq with a target interface that this classdecl implements
    for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)iter.next();
      if(!isObject() && !superclass().instanceOf(typeDecl)) {
        for(Iterator i2 = typeDecl.intertypeSynEqs().iterator(); i2.hasNext(); ) {
          SynEq synEq = (SynEq)i2.next();
          if(!hasEquation(synEq))
            synEq.generateSynEq(this);
        }
      }
    }
  }

  syn Collection TypeDecl.intertypeSynEqs() = Collections.EMPTY_LIST;
  syn lazy Collection InterfaceDecl.intertypeSynEqs() {
    Collection c = new ArrayList();
    for(Iterator iter = intertypeDecls().iterator(); iter.hasNext(); ) {
      ASTNode node = (ASTNode)iter.next();
      if(node instanceof SynEq)
        c.add(node);
    }
    for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)iter.next();
      c.addAll(typeDecl.intertypeSynEqs());
    }
    return c;
  }
  protected void SynEq.collectIntertypeDecls(HashMap map) {
    super.collectIntertypeDecls(map);
    TypeDecl typeDecl = introducedType();
    if(!map.containsKey(typeDecl))
      map.put(typeDecl, new ArrayList());
    Collection c = (Collection)map.get(typeDecl);
    c.add(this);
  }

  public void SynEq.generateIntertypeDecls() {
    if(!introducedType().isInterfaceDecl()) {
      generateSynEq(introducedType());
    }
  }
  public void SynEq.generateSynEq(TypeDecl introducedType) {
    SynDecl synDecl = decl();
    MethodDecl aspectMethod = aspectMethod();
    int lineNum = getParameterList().sourceLineNumber();
    synDecl.generateAttributeDecl(introducedType, aspectMethod, lineNum, shouldBeCached());
  }
  syn lazy MethodDecl SynEq.aspectMethod() {
    MethodDecl aspectMethod =
      new IntroducedMethodDecl(
          createModifiers(),
          type().createQualifiedAccess(),
          name(),
          createParameterList(),
          new List(),
          new List(),
          new Opt(
            getBlock().fullCopy()
            ),
          introducedType(),
          this
          );
    if(Program.hasOption("-weave_inline") && !introducedType().isInterfaceDecl())
      aspectMethod = introducedType().addMemberMethod(aspectMethod);
    else
      aspectMethod = hostType().addMemberMethod(aspectMethod);
    return aspectMethod;
  }

  /*
  rewrite TypeAccess {
    when(!duringSyntacticClassification() && !duringResolveAmbiguousNames() && getPackage().equals("") && !decl().isNestedType() && !decl().packageName().equals(""))
    to TypeAccess {
      System.out.println("Qualifying " + name() + " with " + decl().packageName());
      setPackage(decl().packageName());
      return this;
    }
  }
  */


  public void SynDecl.createIntertypeMethod(TypeDecl introducedType) {
    if(introducedType.isInterfaceDecl()) {
      introducedType/*()*/.addMemberMethod(
        new MethodDecl(
          new Modifiers(new List().add(new Modifier("public")).add(new Modifier("abstract"))),
          type().createQualifiedAccess(),
          name(),
          copyParameterList(getParameterList()),
          new List(),
          new List(),
          new Opt()
        )
      );
    }
    else {
  //public void SynDecl.generateIntertypeDecls() {
    if(hasEqBody()) {
      // public type name(p0, ..., PN-1) { ... }
      List modifierList = (List)getModifiers().getModifierList().fullCopy();
      MethodDecl aspectMethod =
          new IntroducedMethodDecl(
            createModifiers(),
            type().createQualifiedAccess(),
            name(),
            createParameterList(),
            new List(),
            new List(),
            new Opt(
              getBlock().fullCopy()
            ),
            introducedType/*()*/,
            this
          );
      if(Program.hasOption("-weave_inline") && !introducedType().isInterfaceDecl())
        aspectMethod = introducedType().addMemberMethod(aspectMethod);
      else
        aspectMethod = hostAspect().addMemberMethod(aspectMethod);
      int lineNum = getParameterList().sourceLineNumber();
      generateAttributeDecl(introducedType/*()*/, aspectMethod, lineNum, shouldBeCached());
    }
    else if(introducedType/*()*/ instanceof ASTDecl && !((ASTDecl)introducedType/*()*/).hasEquation(this) && introducedType == introducedType()) {
      // public abstract type name(p0, ..., PN-1);
      introducedType/*()*/.addMemberMethod(
        new MethodDecl(
          new Modifiers(new List().add(new Modifier("public")).add(new Modifier("abstract"))),
          type().createQualifiedAccess(),
          name(),
          copyParameterList(getParameterList()),
          new List(),
          new List(),
          new Opt()
        )
      );
    }
    }
  }

  public void InhDecl.createIntertypeMethod(TypeDecl introducedType) {
  //public void InhDecl.generateIntertypeDecls() {
    if(!Program.hasOption("-inh_in_astnode")) {
      addDefiningInterface();
    }
    addInterfaceTagging();
    int lineNum = getParameterList().sourceLineNumber();
    generateAttributeDecl(introducedType/*()*/, lineNum);
  }

  syn lazy TypeDecl SynEq.type() = decl().type();


  public Modifiers SynDecl.createModifiers() {
    List list = new List();
    if(Program.hasOption("-weave_inline") && !introducedType().isInterfaceDecl())
      list.add(new Modifier("static")).add(new Modifier("private"));
    else
      list.add(new Modifier("static")).add(new Modifier("public"));
    return new Modifiers(list);
  }

  public Modifiers SynEq.createModifiers() {
    List list = new List();
    if(Program.hasOption("-weave_inline") && !introducedType().isInterfaceDecl())
      list.add(new Modifier("static")).add(new Modifier("private"));
    else
      list.add(new Modifier("static")).add(new Modifier("public"));
    return new Modifiers(list);
  }

  public List AttributeDecl.createParameterList() {
    List list = new List();
    list.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).qualifiedCopy());
    return list;
  }

  public List SynEq.createParameterList() {
    List list = new List();
    list.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).qualifiedCopy());
    return list;
  }

  public List InhEq.createParameterList() {
    List list = new List();
    list.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).qualifiedCopy());
    if(hasChildParameter())
      list.add(createChildParameter());
    return list;
  }
  
  syn boolean InhEq.hasChildParameter() {
    if(getNumChildParameter() == 1) return true;
    ASTChild child = child();
    return child != null && child instanceof ASTListChild;
  }

  public ParameterDeclaration InhEq.createChildParameter() {
    if(getNumChildParameter() == 1)
      return getChildParameter(0).qualifiedCopy();
    return new ParameterDeclaration(new PrimitiveTypeAccess("int"), "childIndex");
  }

  public List InhEq.createArgumentList() {
    List args = new List();
    args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++)
      args.add(getParameter(i).createAccess());
    if(hasChildParameter()) {
      args.add(
        new VarAccess("caller").qualifiesAccess(
          new MethodAccess(
            "getIndexOfChild",
            new List().add(
              new VarAccess("child")
            )
          )
        )
      );
    }
    return args;
  }
  
  syn boolean AttributeDecl.isNTA() {
    if(!name().startsWith("get") || getNumParameter() != 0 || !(introducedType() instanceof ASTDecl))
      return false;
    String name = name().substring(3); // remove "get" prefix
    ASTDecl decl = (ASTDecl)introducedType();
    if(name.endsWith("List") && decl.lookupChild(name.substring(0, name.length() - 4)) instanceof ASTListChild)
      return true;
    if(name.endsWith("Opt") && decl.lookupChild(name.substring(0, name.length() - 3)) instanceof ASTOptionalChild)
      return true;
    boolean result = decl.lookupChild(name) != null;
    return result;
  }

  syn boolean AttributeDecl.bindsToTokenChild() = isNTA() && 
    ((ASTDecl)introducedType()).lookupChild(name().substring(3)) instanceof ASTTokenChild;
  
  // Add a possibly cached delegate in typeDecl that calls aspectMethod
  public void SynDecl.generateAttributeDecl(TypeDecl typeDecl, MethodDecl aspectMethod, int lineNum, boolean isLazy) {
    if(isLazy) {
      // Add re-init of attribute cache in node clone method
      nodeCopyClearCache(typeDecl);
    }
    
    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy || !Program.hasOption("-no_visit_check"))
      addParameterStructure(statements);
    if(isLazy)
      addComputedCheck(statements, typeDecl);
      
    if (!Program.hasOption("-no_component_check")) 
      addInterruptedCircleDeclaration(statements);
    
    if(!Program.hasOption("-no_visit_check")) {
      addCheckVisited(statements, typeDecl);
      addSetVisited(statements, typeDecl);
    }
    
    if (!Program.hasOption("-no_component_check"))
      addCheckInterruptCircle(statements);
    
    if(isLazy)
      addCacheComputeCall(statements, typeDecl, aspectMethod);
    else
      addComputeCall(statements, aspectMethod);

    if(isNTA()) {
      addStoreNTAValue(statements, typeDecl);
    }
    
    if(!Program.hasOption("-no_visit_check")) {
      addClearVisited(statements, typeDecl);
    }
    
    if (!Program.hasOption("-no_component_check"))
    	  addClearInterruptedCircle(statements);
    
    addReturnStmt(statements, typeDecl, isLazy);

    //statements.getChildNoTransform(0).setSourceLineNumber(lineNum);
    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);
    // public type name(p0, ... , pN-1) { ... }
    typeDecl.addMemberMethod(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public"))),
        type().createQualifiedAccess(),
        name(),
        copyParameterList(getParameterList()),
        new List(),
        new List(),
        new Opt(new Block(statements))
      )
    );
  }
  
  protected void AttributeDecl.addInterruptedCircleDeclaration(List list) {
    list.add(
      new VariableDeclaration(
        new TypeAccess("boolean"),
        "interruptedCircle",
        new BooleanLiteral(false)
      )
    );
  }
  
  protected void AttributeDecl.addCheckInterruptCircle(List list) {
  	List ifStatements = new List();
  	// interruptedCircle = true;
  	ifStatements.add(
  	  AssignExpr.asStmt(
  	      new VarAccess("interruptedCircle"),
  	      new BooleanLiteral(true)
  	  )
  	);
  	// IN_CIRCLE = FALSE;
  	ifStatements.add(
  	  AssignExpr.asStmt(
  	    new VarAccess("IN_CIRCLE"),
  	    new BooleanLiteral(false)
  	  )
  	);
  	// circularEvalState.push(new BOOLEAN(CHANGE)); 	
  	/*ifStatements.add(
  	  new ExprStmt(
  	    new VarAccess("circularEvalState").qualifiesAccess(
  	      new MethodAccess(
  	        "push",
  	         new List().add(
               new ClassInstanceExpr(
                 lookupType("java.lang", "Boolean").createQualifiedAccess(),
                 new List().add(
                   new VarAccess("CHANGE")
                 ),
                 new Opt()
               )
             )
  	      )
  	    )
  	  )
  	);*/
  	ifStatements.add(
  	  new ExprStmt(
  	    new MethodAccess(
  	      "pushEvalStack",
  	      new List()
  	    )
  	  )
  	);
  	
  	list.add(
  	  new IfStmt(
  	    new VarAccess("IN_CIRCLE"),
  	    new Block(
  	      ifStatements
  	    )
  	  )
  	);
  }
  
  protected void AttributeDecl.addClearInterruptedCircle(List list) {
    //if (interruptedCircle) { IN_CIRCLE = true; CHANGE = ((Boolean) circuralEvalStack().pop())booleanValue();}
  	List ifStatements = new List();
  	ifStatements.add(
      AssignExpr.asStmt(
  	    new VarAccess("IN_CIRCLE"),
  	    new BooleanLiteral(true)
  	  )
  	);
  	/*Expr popStack = 
  	  TypeDecl.createUnbox(lookupType("java.lang","Boolean"), "booleanValue", 
  	                      new VarAccess("circularEvalState").qualifiesAccess(
  	                        new MethodAccess(
  	                          "pop",
  	                          new List()
  	                        )
  	                      )
  	                    );
  	ifStatements.add(
  	  AssignExpr.asStmt(
  	    new VarAccess("CHANGE"),
  	    popStack
  	  )
  	);*/
  	ifStatements.add(
  	  new ExprStmt(
  	    new MethodAccess(
  	      "popEvalStack",
  	      new List()
  	    )
  	  )
  	);
  	list.add(
  	  new IfStmt(
  	    new VarAccess("interruptedCircle"),
  	    new Block(
  	      ifStatements
  	    )
  	  )
  	);
  }
  // createUnbox static
  //  ((Boolean)STACK.pop()).booleanValue()
  // TypeDecl.createUnbox(lookupType("java.lang", "Boolean"), "booleanValue", new VarAccess("STACK").qualifiesAccess(new MethodAccess...)


  // Add a possibly cached delegate in typeDecl that calls aspectMethod
  public void InhDecl.generateAttributeDecl(TypeDecl typeDecl, int lineNum) {
    if(isLazy()) {
      // Add re-init of attribute cache in node clone method
      nodeCopyClearCache(typeDecl);
    }
    
    // check cached value, compute new value, store in cache, return value
    List statements = new List();
    if(isLazy() || !Program.hasOption("-no_visit_check"))
      addParameterStructure(statements);
    if(isLazy())
      addComputedCheck(statements, typeDecl);
      
    if (!Program.hasOption("-no_component_check")) 
      addInterruptedCircleDeclaration(statements);
    
    if(!Program.hasOption("-no_visit_check")) {
      // if(visited) throw new RuntimeException("Circular definition...");
      addCheckVisited(statements, typeDecl);
      // visited = true;
      addSetVisited(statements, typeDecl);
    }
      
    if (!Program.hasOption("-no_component_check"))
      addCheckInterruptCircle(statements);
    
    if(isLazy())
      addCacheComputeCall(statements, typeDecl);
    else
      addComputeCall(statements);

    if(isNTA()) {
      addStoreNTAValue(statements, typeDecl);
    }
    
    if(!Program.hasOption("-no_visit_check"))
      // visited = false;
      addClearVisited(statements, typeDecl);
      
     if (!Program.hasOption("-no_component_check"))
    	  addClearInterruptedCircle(statements);
    
    addReturnStmt(statements, typeDecl, isLazy());

    //statements.getChildNoTransform(0).setSourceLineNumber(lineNum);
    statements.getChildNoTransform(statements.getNumChild()-1).setSourceLineNumber(lineNum);

    // public type name(p0, ... , pN-1) { ... }
    typeDecl.addMemberMethod(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public"))),
        type().createQualifiedAccess(),
        name(),
        copyParameterList(getParameterList()),
        new List(),
        new List(),
        new Opt(new Block(statements))
      )
    );
  }
  
  
  

  protected void AttributeDecl.addStoreNTAValue(List list, TypeDecl typeDecl) {
    // setNNN(computedValueName());
    list.add(
      new ExprStmt(
        new MethodAccess(
          "set" + name().substring(3), // replace initial get with set
          new List().add(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess()
          )
        )
      )
    );
  }
    
  protected void AttributeDecl.nodeCopyClearCache(TypeDecl type) {
    if(!(type instanceof ASTDecl))
      return;
    ASTDecl typeDecl = (ASTDecl)type;
    Access fieldAccess = null;
    Expr expr = null;
    if(getNumParameter() == 0) {
      // node.computed = false;
      fieldAccess = fieldComputedFlag(type).createQualifiedBoundAccess();
      expr = new BooleanLiteral(false);
    }
    else {
      // node.computed_value = new java.util.HashMap(4);
      fieldAccess = fieldComputedValue(type).createQualifiedBoundAccess();
      expr = new ClassInstanceExpr(
        lookupType("java.util", "HashMap").createQualifiedAccess(),
        new List().add(new IntegerLiteral(4))
      );
    }     
    typeDecl.addCloneNodeInit(fieldAccess, expr); 
  }

  inh lazy TypeDecl AttributeDecl.typeObject();
  inh lazy TypeDecl AttributeDecl.typeBoolean();

  private HashMap AttributeDecl.fieldVisitedFlagAdded = new HashMap();
  protected FieldDeclaration AttributeDecl.fieldVisitedFlag(TypeDecl typeDecl) {
    if(fieldVisitedFlagAdded.containsKey(typeDecl))
      return (FieldDeclaration)fieldVisitedFlagAdded.get(typeDecl);
    TypeDecl fieldType = getNumParameter() == 0 ?
      typeBoolean() : lookupType("java.util", "HashSet");
    Expr fieldInit;
    if(getNumParameter() == 0)
      fieldInit = new BooleanLiteral(false);
    else
      fieldInit = new ClassInstanceExpr(
        lookupType("java.util", "HashSet").createQualifiedAccess(),
        new List().add(new IntegerLiteral(4))
      );
    FieldDeclaration f = new FieldDeclaration(
      new Modifiers(new List().add(new Modifier("private"))),
      fieldType.createQualifiedAccess(),
      visitedFlagName(),
      fieldInit
    );
    typeDecl.addMemberField(f);
    fieldVisitedFlagAdded.put(typeDecl, f);
    return f;
  }

  private HashMap AttributeDecl.fieldComputedFlagAdded = new HashMap();
  protected FieldDeclaration AttributeDecl.fieldComputedFlag(TypeDecl typeDecl) {
    if(fieldComputedFlagAdded.containsKey(typeDecl))
      return (FieldDeclaration)fieldComputedFlagAdded.get(typeDecl);
    FieldDeclaration f;
    if(getNumParameter() == 0)
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        typeBoolean().createQualifiedAccess(),
        computedFlagName(),
        new BooleanLiteral(false)
      );
    else
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        lookupType("java.util", "HashSet").createQualifiedAccess(),
        computedFlagName(),
        new ClassInstanceExpr(
          lookupType("java.util", "HashSet").createQualifiedAccess(),
          new List().add(new IntegerLiteral(4))
        )
      );
    typeDecl.addMemberField(f);
    fieldComputedFlagAdded.put(typeDecl, f);
    return f;
  }
  
  private HashMap AttributeDecl.fieldComputedValueAdded = new HashMap();
  protected FieldDeclaration AttributeDecl.fieldComputedValue(TypeDecl typeDecl) {
    if(fieldComputedValueAdded.containsKey(typeDecl))
      return (FieldDeclaration)fieldComputedValueAdded.get(typeDecl);
    FieldDeclaration f;
    if(getNumParameter() == 0)
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        computedValueType().createQualifiedAccess(),
        computedValueName()
      );
    else
      f = new FieldDeclaration(
        new Modifiers(new List().add(new Modifier("private"))),
        computedValueType().createQualifiedAccess(),
        computedValueName(),
        new ClassInstanceExpr(
          lookupType("java.util", "HashMap").createQualifiedAccess(),
          new List().add(new IntegerLiteral(4))
        )
      );
    typeDecl.addMemberField(f);
    fieldComputedValueAdded.put(typeDecl, f);
    return f;
  }

  protected void AttributeDecl.addCheckVisited(List list, TypeDecl typeDecl) {
    if(getNumParameter() == 0) {
      // if(visited_flag) throw new RuntimeException("Circular definition of attr: signature in class: classname.");
      list.add(
        new IfStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess(),
          new ThrowStmt(
            new ClassInstanceExpr(
              lookupType("java.lang", "RuntimeException").createQualifiedAccess(),
              new List().add(
                new StringLiteral("Circular definition of attr: " + signature() + " in class: " + hostType().fullName())
              )
            )
          )
        )
      );
    }
    else {
      // if(visited_flag.contains("parameters$")) throw new RuntimeException("Circular definition of attr: signature in class: classname.");
      list.add(
        new IfStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "contains",
              new List().add(new VarAccess("parameters$"))
            )
          ),
          new ThrowStmt(
            new ClassInstanceExpr(
              lookupType("java.lang", "RuntimeException").createQualifiedAccess(),
              new List().add(
                new StringLiteral("Circular definition of attr: " + signature() + " in class: " + hostType().fullName())
              )
            )
          )
        )
      );
    }
  }

  protected void AttributeDecl.addSetVisited(List list, TypeDecl typeDecl) {
    if(getNumParameter() == 0) {
      // visited_flag = true; 
      list.add(
        AssignExpr.asStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess(),
          new BooleanLiteral(true)
        )
      );
    }
    else {
      // visited_flag.set(parameters$)
      list.add(
        new ExprStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "add",
              new List().add(new VarAccess("parameters$"))
            )
          )
        )
      );
    }
  }
  
  protected void AttributeDecl.addClearVisited(List list, TypeDecl typeDecl) {
    if(getNumParameter() == 0) {
      // visited_flag = true; 
      list.add(
        AssignExpr.asStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess(),
          new BooleanLiteral(false)
        )
      );
    }
    else {
      // visited_flag.set(parameters$)
      list.add(
        new ExprStmt(
          fieldVisitedFlag(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "remove",
              new List().add(new VarAccess("parameters$"))
            )
          )
        )
      );
    }
  }

  protected void AttributeDecl.addParameterStructure(List list) {
    if(getNumParameter() == 1) {
      // type parameters$ = parameter0;
      list.add(
        new VariableDeclaration(
          typeObject().createQualifiedAccess(),
          "parameters$",
          getParameter(0).type().box(getParameter(0).createAccess())
        )
      );
    }
    else if(getNumParameter() > 1) {
      // object[] parameters$ = {parameter0, .. , paramterN-1};
      List init = new List();
      for(int i = 0; i < getNumParameter(); i++)
        init.add(getParameter(i).type().box(getParameter(i).createAccess()));
      list.add(
        new VariableDeclaration(
          lookupType("java.util", "List").createQualifiedAccess(),
          "parameters$",
          new ClassInstanceExpr(
            lookupType("java.util", "ArrayList").createQualifiedAccess(),
            new List().add(new IntegerLiteral(getNumParameter()))
          )
        )
      );
      for(int i = 0; i < getNumParameter(); i++) {
        list.add(
          new ExprStmt(
            new VarAccess("parameters$").qualifiesAccess(
              new MethodAccess(
                "add",
                new List().add(
                  getParameter(i).type().box(getParameter(i).createAccess())
                )
              )
            )
          )
        );
      }
    }
  }
  
   
  protected void AttributeDecl.addComputedCheck(List list, TypeDecl typeDecl) {
    if(isNTA() && !bindsToTokenChild()) {
      list.add(
        new IfStmt(
          fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
          // return (List)ASTNode.getChild(this, getDynamicTypeListChildPosition());
          new ReturnStmt(
            new CastExpr(
              type().createQualifiedAccess(),
              astNode().createQualifiedAccess().qualifiesAccess(
                new MethodAccess(
                  "getChild",
                  new List().add(
                    new ThisAccess("this")
                  ).add(
                    new MethodAccess(name() + "ChildPosition", new List())
                  )
                )
              )
            )
          )
          /*
          // return (List)getChildNoTransform(getDynamicTypeListChildPosition());
          new ReturnStmt(
            new CastExpr(
              type().createQualifiedAccess(),
              new MethodAccess(
                "getChildNoTransform",
                new List().add(new MethodAccess(name() + "ChildPosition", new List()))
              )
            )
          )
          */
        )
      );
    }
    else if(getNumParameter() == 0) {
      // if(computed_flag) return computed_value;
      list.add(
        new IfStmt(
          fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
          //new VarAccess(computedFlagName()),
          new ReturnStmt(fieldComputedValue(typeDecl).createQualifiedBoundAccess()/*new VarAccess(computedValueName())*/)
        )
      );
    }
    else {
      // if(computed_value.containsKey(parameters$) return (type)computed_value.get(parameters$);
      list.add(
        new IfStmt(
          fieldComputedValue(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
            //new VarAccess(computedValueName()),
            new MethodAccess(
              "containsKey",
              new List().add(new VarAccess("parameters$"))
            )
          ),
          new ReturnStmt(
            type().unbox(
              fieldComputedValue(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
                //new VarAccess(computedValueName()),
                new MethodAccess(
                  "get",
                  new List().add(new VarAccess("parameters$"))
                )
              )
            )
          )
        )
      );
    }
  }
  
  /*
  public Access ParameterDeclaration.createAccess() {
    return new VarAccess(name());
  }
  */

  public Expr TypeDecl.box(Expr expr) {
    return expr;
  }

  protected Expr TypeDecl.createBox(TypeDecl typeDecl, Expr expr) {
    return new ClassInstanceExpr(
      typeDecl.createQualifiedAccess(),
      new List().add(expr)
    );
  }
  
  public Expr BooleanType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Boolean"), expr);
  }
  public Expr ByteType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Byte"), expr);
  }
  public Expr ShortType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Short"), expr);
  }
  public Expr IntType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Integer"), expr);
  }
  public Expr LongType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Long"), expr);
  }
  public Expr CharType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Char"), expr);
  }
  public Expr FloatType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Float"), expr);
  }
  public Expr DoubleType.box(Expr expr) {
    return createBox(lookupType("java.lang", "Double"), expr);
  }
  
  public Expr TypeDecl.unbox(Expr expr) {
    return new CastExpr(createQualifiedAccess(), expr);
  }

  protected  static Expr TypeDecl.createUnbox(TypeDecl typeDecl, String methodName, Expr expr) {
    return new ParExpr(
      new CastExpr(
        typeDecl.createQualifiedAccess(),
        expr
      )
    ).qualifiesAccess(
      new MethodAccess(methodName, new List())
    );
  }
    
  
  
  
    
    
  public Expr BooleanType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Boolean"), "booleanValue", expr);
  }
  public Expr ByteType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Byte"), "byteValue", expr);
  }
  public Expr ShortType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Short"), "shortValue", expr);
  }
  public Expr IntType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Integer"), "intValue", expr);
  }
  public Expr LongType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Long"), "longValue", expr);
  }
  public Expr CharType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Char"), "charValue", expr);
  }
  public Expr FloatType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Float"), "floatValue", expr);
  }
  public Expr DoubleType.unbox(Expr expr) {
    return createUnbox(lookupType("java.lang", "Double"), "doubleValue", expr);
  }

  protected void AttributeDecl.addComputeCall(List list, MethodDecl targetMethod) {
    List args = new List();
    args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    // type computed_value = name(arg0, ... , argN-1);
    list.add(
      new VariableDeclaration(
        type().createQualifiedAccess(),
        computedValueName(),
        //new ComputeMethodAccess(name(), args, hostAspect(), type())
        targetMethod.createBoundAccess(args)
      )
    );
  }
  
  protected void AttributeDecl.addCacheComputeCall(List list, TypeDecl typeDecl, MethodDecl targetMethod) {
    // int num$ = boundariesCrossed;
    list.add(
      new VariableDeclaration(
        new TypeAccess("int"),
        "num$",
        new VarAccess("boundariesCrossed")
      )
    );
    // boolean localFinal$ = this.isFinal
    list.add(
      new VariableDeclaration(
        new TypeAccess("boolean"),
        "localFinal$",
        new VarAccess("isFinal")
      )
    );
    // localFinal$ && num$ == boundariesCrossed
    Expr cond = new AndLogicalExpr(
      new VarAccess("localFinal$"),
      new EQExpr(
        new VarAccess("num$"),
        new VarAccess("boundariesCrossed")
      )
    );
    List args = new List();
    args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    if(getNumParameter() == 0) {
      // computed_value = name(arg0, .. , argN-1);
      list.add(
        AssignExpr.asStmt(
          fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
          //new VarAccess(computedValueName()),
          //new ComputeMethodAccess(name(), args, hostAspect(), type())
          targetMethod.createBoundAccess(args)
        )
      );
      // if(cond) computed_flag = true;
      list.add(
        new IfStmt(
          cond,
          AssignExpr.asStmt(
            fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
            //new VarAccess(computedFlagName()),
            new BooleanLiteral(true)
          )
        )
      );
    }
    else {
      // type computed_value = name(arg0, ... , argN-1);
      list.add(
          new VariableDeclaration(
            type().createQualifiedAccess(),
            computedValueName(),
            //new ComputeMethodAccess(name(), args, hostAspect(), type()))
            targetMethod.createBoundAccess(args)
          )
      );
      // if(cond) this.computed_value.put(parameters$, computed_value);
      list.add(
        new IfStmt(
          cond,
          new ExprStmt(
            fieldComputedValue(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
              new MethodAccess(
                "put",
                new List().add(
                  new VarAccess("parameters$")
                ).add(
                  type().box(new VarAccess(computedValueName()))
                )
              )
            )
          )
        )
      );
    }
  }

  syn lazy String InhDecl.definingInterfaceName() {
    StringBuffer s = new StringBuffer();
    s.append("Defines$" + name());
    for(int i = 0; i < getNumParameter(); i++)
      s.append("$" + getParameter(i).type().constantPoolName().replace('/', '$'));
    return s.toString();
  }


  private HashSet ClassDecl.addImplementedInterface = null;
  public void ClassDecl.addImplementedInterface(String name) {
    if(addImplementedInterface == null)
      addImplementedInterface = new HashSet();
    if(addImplementedInterface.contains(name))
      return;
    addImplementedInterface.add(name);
    addImplements(
      astNode().createQualifiedAccess().qualifiesAccess(
        new TypeAccess(name)
      )
    );
  }
  private HashMap TypeDecl.addMethod = null;
  public MethodDecl TypeDecl.addMethod(String name, MethodDecl m) {
    if(addMethod == null)
      addMethod = new HashMap();
    if(addMethod.containsKey(name))
      return (MethodDecl)addMethod.get(name);
    addMethod.put(name, m);
    addMemberMethod(m);
    return (MethodDecl)getBodyDecl(getNumBodyDecl()-1);
  }
  

  private boolean InhDecl.addInterfaceTagging = false;
  public void InhDecl.addInterfaceTagging() {
    if(addInterfaceTagging)
      return;
    addInterfaceTagging = true;
    
    Map map = new HashMap();
    for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
      InhEq inhEq = (InhEq)iter.next();
      if(!map.containsKey(inhEq.introducedType()))
        map.put(inhEq.introducedType(), new ArrayList(1));
      Collection c = (Collection)map.get(inhEq.introducedType());
      c.add(inhEq);
    }
    // Foreach class that has an introduced equation for this inh declaration
    for(Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)iter.next();
      if(typeDecl instanceof ClassDecl) {
        ClassDecl classDecl = (ClassDecl)typeDecl;

        if(!Program.hasOption("-inh_in_astnode")) {
          // Add implements tag
          classDecl.addImplementedInterface(definingInterfaceName());
        }

        // statements in delegation method
        List statements = new List(); 

        // Foreach inh equation in this type
        for(Iterator i2 = ((Collection)map.get(typeDecl)).iterator(); i2.hasNext(); ) {
          InhEq inhEq = (InhEq)i2.next();
          // add inh equation to aspect 
          MethodDecl methodDecl = inhEq.addEqToAspect(type());
          List modifierList = (List)getModifiers().getModifierList().fullCopy();
          modifierList.add(new Modifier("static"));
          methodDecl.setModifiers(new Modifiers(modifierList));

          // Add conditional delegation 
          statements.add(
            new IfStmt(
              inhEq.child().createFromCorrectChildCheck(),
              new ReturnStmt(
                methodDecl.createBoundAccess(inhEq.createArgumentList())
              )
            )
          );
          
        }


        MethodDecl m = classDecl.addMethod(definingInterfaceName(),
          new MethodDecl(
            new Modifiers(new List().add(new Modifier("public")).add(new Modifier("synthetic"))),
            type().createQualifiedAccess(),
            definingInterfaceName(),
            createDefiningInterfaceParameterList(),
            new List(),
            new List(),
            new Opt(
              new Block(
                statements
              )
            )
          )
        );

        // Add last statement
        // use the previously built MethodDecl as a template for the super method access
        // since it may not have been built yet
        boolean eqInSuperClass = false;
        TypeDecl searchType = typeDecl;
        while(!eqInSuperClass && searchType != null && searchType instanceof ASTDecl) {
          ASTDecl astDecl = (ASTDecl)searchType;
          if(astDecl.hasSuperclass())
            searchType = astDecl.superclass();
          if(map.containsKey(searchType) && !((Collection)map.get(searchType)).isEmpty())
            eqInSuperClass = true;
        }
        
        if(eqInSuperClass) {
          List args = new List();
          args.add(new VarAccess("caller"));
          args.add(new VarAccess("child"));
          for(int i = 0; i < getNumParameter(); i++)
            args.add(getParameter(i).createAccess());

          statements.add(
            new ReturnStmt(
              new SuperAccess(
                "super"
              ).qualifiesAccess(
                m.createBoundAccess(args)
                /*
                new MethodAccess(
                  definingInterfaceName(),
                  args
                )
                */
              )
            )
          );
        }
        else {
          addDelegateToAncestorDefinition(statements);
        }


      }
    }
  }

  syn lazy MethodDecl InhEq.addEqToAspect(TypeDecl returnType) {
          MethodDecl methodDecl =
            new IntroducedMethodDecl(
              new Modifiers(new List().add(new Modifier("static"))),
              returnType.createQualifiedAccess(),
              name() + "$" + childName(),
              createParameterList(),
              new List(),
              new List(),
              new Opt(
                getBlock().fullCopy()
              ),
              introducedType(),
              this
            );
          if(Program.hasOption("-weave_inline") && !introducedType().isInterfaceDecl())
            return introducedType().addMemberMethod(methodDecl);
          else
            return hostType().addMemberMethod(methodDecl);
  }

  Expr ASTChild.createFromCorrectChildCheck() {
    return new EQExpr(
      new VarAccess("caller"),
      new MethodAccess("get" + name() + "NoTransform", new List())
    );
  }
  Expr ASTOptionalChild.createFromCorrectChildCheck() {
    return new EQExpr(
      new VarAccess("caller"),
      new MethodAccess("get" + name() + "OptNoTransform", new List())
    );
  }
  Expr ASTListChild.createFromCorrectChildCheck() {
    return new EQExpr(
      new VarAccess("caller"),
      new MethodAccess("get" + name() + "ListNoTransform", new List())
    );
  }
  
  inh SimpleSet InhDecl.lookupType(String name);
  public List InhDecl.createDefiningInterfaceParameterList() {
    List list = new List();
    list.add(new ParameterDeclaration(astNode().createQualifiedAccess(), "caller"));
    list.add(new ParameterDeclaration(astNode().createQualifiedAccess(), "child"));
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).qualifiedCopy());
    return list;
  }
  

  private HashMap TypeDecl.inhEqDelegate;
  public MethodDecl TypeDecl.inhEqDelegate(String name) {
    return inhEqDelegate == null ? null : (MethodDecl)inhEqDelegate.get(name);
  }
  public void TypeDecl.addInhEqDelegate(String name, MethodDecl m) {
    if(inhEqDelegate == null)
      inhEqDelegate = new HashMap();
    inhEqDelegate.put(name, m);
  }
  public MethodDecl InhDecl.inhEqDelegate() {
    MethodDecl m = astNode().inhEqDelegate(definingInterfaceName());
    if(m == null) {
      List statements = new List();
      m = new MethodDecl(
        (Modifiers)getModifiers().fullCopy(),
        type().createQualifiedAccess(),
        definingInterfaceName(),
        createDefiningInterfaceParameterList(),
        new List(),
        new List(),
        new Opt(new Block(statements))
      );
      List args = new List();
      args.add(new ThisAccess("this"));
      args.add(new VarAccess("caller"));
      for(int i = 0; i < getNumParameter(); i++)
        args.add(new VarAccess(getParameter(i).name()));
      statements.add(
        new ReturnStmt(
          new MethodAccess("getParent", new List()).qualifiesAccess(
            new BoundMethodAccess(definingInterfaceName(), args, m)
          )
        )
      );
      m = astNode().addMemberMethod(m);
      astNode().addInhEqDelegate(definingInterfaceName(), m);
    }
    return m;
  }

  // TODO: currently needs to update remote attributes after this operation
  protected void InhDecl.addDefiningInterface() {
    if(astNode().firstDefiningInterfaceQuery(definingInterfaceName())) {
      astNode().addBodyDecl(
          new MemberInterfaceDecl(
            new InterfaceDecl(
              new Modifiers(new List().add(new Modifier("public"))),
              definingInterfaceName(),
              new List(),
              new List().add(
                new MethodDecl(
                  new Modifiers(new List().add(new Modifier("public"))),
                  type().createQualifiedAccess(),
                  definingInterfaceName(),
                  createDefiningInterfaceParameterList(),
                  new List(),
                  new List(),
                  new Opt()
                  )
                )
              )
            )
          );
    }
  }

  private HashSet TypeDecl.hasDefiningInterface = null;
  public boolean TypeDecl.firstDefiningInterfaceQuery(String name) {
    if(hasDefiningInterface == null)
      hasDefiningInterface = new HashSet();
    if(hasDefiningInterface.contains(name))
      return false;
    hasDefiningInterface.add(name);
    return true;
  }
    
  protected void InhDecl.addSearchAncestorForEquation(List list) {
    if(Program.hasOption("-inh_in_astnode")) {
      return;
    }
    // TODO: make this only call getParent() when other policy for inherited attributes
    // ASTNode n = getParent();
    // ASTNode caller = this;
    // ASTNode child = null;
    list.add(
      new VariableDeclaration(
        astNode().createQualifiedAccess(),
        "n",
        new MethodAccess("getParent", new List())
      )
    ).add(
      new VariableDeclaration(
        astNode().createQualifiedAccess(),
        "caller",
        new ThisAccess("this")
      )
    ).add(
      new VariableDeclaration(
        astNode().createQualifiedAccess(),
        "child",
        new NullLiteral("null")
      )
    );
    
    // while(!(n instanceof definingInterfaceName)) {
    //   child = caller;
    //   caller = n;
    //   n = n.getParent();
    list.add(
      new WhileStmt(
        new LogNotExpr(
          new ParExpr(
            new InstanceOfExpr(
              new VarAccess("n"),
              astNode().createQualifiedAccess().qualifiesAccess(
                new TypeAccess(definingInterfaceName())
              )
            )
          )
        ),
        new Block(
          new List().add(
            AssignExpr.asStmt(new VarAccess("child"), new VarAccess("caller"))
          ).add(
            AssignExpr.asStmt(new VarAccess("caller"), new VarAccess("n"))
          ).add(
            AssignExpr.asStmt(
              new VarAccess("n"),
              new VarAccess("n").qualifiesAccess(
                new MethodAccess("getParent", new List())
              )
            )
          )
        )
      )
    );
  }


  protected Expr AttributeDecl.createComputeCall(MethodDecl targetMethod) {
    throw new Error("createComputeCall(MethodDecl targetMethod) not implemented for " + getClass().getName());
  }
    
  protected Expr SynDecl.createComputeCall(MethodDecl targetMethod) {
    List args = new List();
    args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    // compute(this, p0, ... , pn-1)
    return targetMethod.createBoundAccess(args);
  }

  protected Expr AttributeDecl.createComputeCall() {
    throw new Error("createComputeCall() not implemented for " + getClass().getName());
  }
  
  protected Expr InhDecl.createComputeCall() {
    if(Program.hasOption("-inh_in_astnode")) {
      List args = new List();
      args.add(new ThisAccess("this"));
      args.add(new NullLiteral("null"));
      for(int i = 0; i < getNumParameter(); i++)
       args.add(getParameter(i).createAccess());
      return
        new MethodAccess("getParent", new List()).qualifiesAccess(
          new BoundMethodAccess(definingInterfaceName(), args, inhEqDelegate())
        );
    }
    
    // ((hostType.definingInterfaceName)n).definingInterfaceName(caller, child, arg0, ... argN-1)
    List args = new List();
    args.add(new VarAccess("caller"));
    args.add(new VarAccess("child"));
    for(int i = 0; i < getNumParameter(); i++)
     args.add(getParameter(i).createAccess());
    return 
      new ParExpr(
        new CastExpr(
          astNode().createQualifiedAccess().qualifiesAccess(
            new TypeAccess(definingInterfaceName())
          ),
          new VarAccess("n")
        )
      ).qualifiesAccess(
        new MethodAccess(definingInterfaceName(), args)
      );
  }

  protected void InhDecl.addDelegateToAncestorDefinition(List list) {
    addSearchAncestorForEquation(list);
    list.add(new ReturnStmt(createComputeCall()));
  }
  
  protected void InhDecl.addComputeCall(List list) {
    addSearchAncestorForEquation(list);
    list.add(
      new VariableDeclaration(
        type().createQualifiedAccess(),
        computedValueName(),
        createComputeCall()
      )
    );
  }

  protected void InhDecl.addCacheComputeCall(List list, TypeDecl typeDecl) {
    addSearchAncestorForEquation(list);
    Expr computeCall = createComputeCall();
      
    if(getNumParameter() == 0) {
      // computed_value = name(arg0, .. , argN-1);
      list.add(
        AssignExpr.asStmt(
          fieldComputedValue(typeDecl).createQualifiedBoundAccess(),
          //new VarAccess(computedValueName()),
          computeCall
        )
      );
      // computed_flag = true;
      list.add(
        AssignExpr.asStmt(
          fieldComputedFlag(typeDecl).createQualifiedBoundAccess(),
          //new VarAccess(computedFlagName()),
          new BooleanLiteral(true)
        )
      );
    }
    else {
      // type computed_value = name(arg0, ... , argN-1);
      list.add(
        new VariableDeclaration(
          type().createQualifiedAccess(),
          computedValueName(),
          computeCall
        )
      );
      // this.computed_value.put(parameters$, computed_value);
      list.add(
        new ExprStmt(
          fieldComputedValue(typeDecl).createQualifiedBoundAccess().qualifiesAccess(
            new MethodAccess(
              "put",
              new List().add(
                new VarAccess("parameters$")
              ).add(
                type().box(new VarAccess(computedValueName()))
              )
            )
          )
        )
      );
    }
  }

  protected void AttributeDecl.addReturnStmt(List list, TypeDecl typeDecl, boolean isLazy) {
    // return computed_value;
    if(isNTA() && !bindsToTokenChild()) {
      list.add(
        // return (List)ASTNode.getChild(this, getDynamicTypeListChildPosition());
        new ReturnStmt(
          new CastExpr(
            type().createQualifiedAccess(),
            astNode().createQualifiedAccess().qualifiesAccess(
              new MethodAccess(
                "getChild",
                new List().add(
                  new ThisAccess("this")
                ).add(
                  new MethodAccess(name() + "ChildPosition", new List())
                )
              )
            )
          )
        )
        /*
        // return (List)getChildNoTransform(getDynamicTypeListChildPosition());
        new ReturnStmt(
          new CastExpr(
            type().createQualifiedAccess(),
            new MethodAccess(
              "getChildNoTransform",
              new List().add(new MethodAccess(name() + "ChildPosition", new List()))
            )
          )
        )
        */
      );
    }
    else if(isLazy && getNumParameter() == 0)
      list.add(new ReturnStmt(fieldComputedValue(typeDecl).createQualifiedBoundAccess()));
    else
      list.add(new ReturnStmt(new VarAccess(computedValueName())));
  }

  syn lazy String AttributeDecl.uniqueSignatureName() {
    StringBuffer s = new StringBuffer();
    s.append(name());
    if(getNumParameter() > 0)
      s.append("_");
    for(int i = 0; i < getNumParameter(); i++) {
      ParameterDeclaration p = getParameter(i);
      s.append(p.type().fullName().replace('.', '$').replace('@', '_'));
    }
    return s.toString();
  }
  syn String AttributeDecl.visitedFlagName() = uniqueSignatureName() + "$visited";
  syn String AttributeDecl.computedFlagName() = uniqueSignatureName() + "$computed";
  syn String AttributeDecl.computedValueName() = uniqueSignatureName() + "$value";
  syn TypeDecl AttributeDecl.computedValueType() = getNumParameter() == 0 ? type() : lookupType("java.util", "Map");
}

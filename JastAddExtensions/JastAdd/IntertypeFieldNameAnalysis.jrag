aspect IntertypeFieldNameAnalysis {

  eq IntertypeFieldDeclaration.getTargetType().nameType() = NameType.TYPE_NAME;
  
  // hostAspect is the aspect the declares the intertype field decl
  syn TypeDecl IntertypeFieldDeclaration.hostAspect() = (TypeDecl)getParent().getParent();
  // introducedType is the type into which the intertype field decl is statically introduced
  syn TypeDecl IntertypeFieldDeclaration.introducedType() = getTargetType().type();

  // override ag-inherited attribute, this will cause an access bound to an
  // IntertypeFieldDeclaration to access a field in the introducedType instead of the hostAspect
  syn TypeDecl IntertypeFieldDeclaration.hostType() = introducedType();


  // TODO: Some problems when computing declare before use if the init thinks it is in a different host type
  // comment out works reasonably
  //eq IntertypeFieldDeclaration.getInit().hostType() = hostType();
  
  eq IntertypeFieldDeclaration.getInit().lookupVariable(String name) {
    SimpleSet set = introducedType().lookupMemberField(name);
    if(!set.isEmpty())
      return set;
    return lookupVariable(name);
  }

  refine LookupVariable eq TypeDecl.localFields(String name) {
    SimpleSet fields = LookupVariable.TypeDecl.localFields(name);
    for(Iterator iter = introducedFields().iterator(); iter.hasNext(); ) {
      FieldDeclaration f = (FieldDeclaration)iter.next();
      if(f.name().equals(name))
        fields = fields.add(f);
    }
    return fields;
  }

  protected void IntertypeFieldDeclaration.collectIntertypeDecls(HashMap map) {
    super.collectIntertypeDecls(map);
    TypeDecl typeDecl = introducedType();
    if(!map.containsKey(typeDecl))
      map.put(typeDecl, new ArrayList());
    Collection c = (Collection)map.get(typeDecl);
    c.add(this);
  }

  syn lazy Collection TypeDecl.introducedFields() {
    Collection c = new ArrayList();
    for(Iterator iter = intertypeDecls().iterator(); iter.hasNext(); ) {
      ASTNode node = (ASTNode)iter.next();
      if(node instanceof IntertypeFieldDeclaration)
        c.add(node);
    }
    return c;
  }

}

aspect IntertypeFieldCodegeneration {
  public void IntertypeFieldDeclaration.generateIntertypeDecls() {
    FieldDeclaration f = introducedType().addMemberField(
      new IntroducedFieldDeclaration(
        (Modifiers)getModifiers().fullCopy(),
        type().createQualifiedAccess(),
        name(),
        (Opt)getInitOpt().fullCopy(),
        hostAspect()
      )
    );
    ((IntroducedFieldDeclaration)f).originalField = this;
  }

  public FieldDeclaration IntroducedFieldDeclaration.originalField;
  eq IntroducedFieldDeclaration.accessorIndex() = originalField.accessorIndex();
  eq IntroducedFieldDeclaration.needsAccessor() = originalField.needsAccessor();
  // TODO: the same for write
  // TODO: the same for methods and constructors


  
  // change name binding to search for methods in introducedType in IntroducedMethodDecl body
  public IntroducedFieldDeclaration.IntroducedFieldDeclaration(Modifiers m, Access t, String d, Opt init, TypeDecl aspectType) {
    this(m, t, d, init);
    this.aspectType = aspectType;
  }
  private TypeDecl IntroducedFieldDeclaration.aspectType;
  syn TypeDecl IntroducedFieldDeclaration.aspectType() = aspectType;
  eq IntroducedFieldDeclaration.getInit().lookupVariable(String name) {
    SimpleSet set = lookupVariable(name);
    if(!set.isEmpty())
      return set;
    return aspectType().memberFields(name); // TODO: Does this work for fields in nested aspects/classes?
  }

  eq IntroducedFieldDeclaration.getInit().lookupType(String name) {
    SimpleSet set = hostType().memberTypes(name);
    if(!set.isEmpty()) return set;
    set = aspectType().memberTypes(name);
    if(!set.isEmpty()) return set;
    set = aspectType().lookupType(name);
    if(set.isEmpty())
      System.err.println("Could not find " + name + " from " + name() + " in neither " + hostType().typeName() + " nor " + aspectType().typeName());
    return set;
  }

  eq IntertypeFieldDeclaration.isBytecodeField() = false;
}

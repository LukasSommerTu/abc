aspect IntertypeFieldCodegeneration {
  public void IntertypeFieldDeclaration.generateIntertypeDecls() {
    introducedType().addMemberField(
      new IntroducedFieldDeclaration(
        (Modifiers)getModifiers().fullCopy(),
        type().createQualifiedAccess(),
        name(),
        (Opt)getInitOpt().fullCopy(),
        hostType()
      )
    );
  }

  
  // change name binding to search for methods in introducedType in IntroducedMethodDecl body
  public IntroducedFieldDeclaration.IntroducedFieldDeclaration(Modifiers m, Access t, String d, Opt init, TypeDecl aspectType) {
    this(m, t, d, init);
    this.aspectType = aspectType;
  }
  private TypeDecl IntroducedFieldDeclaration.aspectType;
  syn TypeDecl IntroducedFieldDeclaration.aspectType() = aspectType;
  eq IntroducedFieldDeclaration.getInit().lookupVariable(String name) {
    SimpleSet set = lookupVariable(name);
    if(!set.isEmpty())
      return set;
    return aspectType().memberFields(name); // TODO: Does this work for fields in nested aspects/classes?
  }

  eq IntertypeFieldDeclaration.isBytecodeField() = false;
}

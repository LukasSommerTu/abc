aspect IntertypeMethodCodegeneration {
  // Each IntertypeMethodDecl generates two methods
  //   IntroducedMethodDecl m1 in the aspect, holding the method body
  //   MethodDecl m2 in the introduced type, that delegates the call to m1 
  // the delegation methods are needed to give the desired semantics for instance methods
  // the IntroducedMethodDecl node type is used to specialize name analysis
  public void IntertypeMethodDecl.generateIntertypeDecls() {
    MethodDecl aspectMethod = createAspectMethod();
    MethodDecl delegateMethod = createDelegateMethod(aspectMethod);
    hostAspect().addBodyDecl(aspectMethod);
    introducedType().addBodyDecl(delegateMethod);
  }

  private MethodDecl IntertypeMethodDecl.createAspectMethod() {
    // make aspect method static
    List modifierList = (List)getModifiers().getModifierList().fullCopy();
    if(!isStatic())
      modifierList.add(new Modifier("static"));
    
    // add that for instance methods
    List parameterList = new List();
    if(!isStatic())
    	parameterList.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(getParameter(i).fullCopy());
      
    return new IntroducedMethodDecl(
      new Modifiers(modifierList),
      type().createQualifiedAccess(),
      new IdDecl(name()),
      parameterList,
      new List(),
      new List(),
      new Opt(
        getBlock().fullCopy()
      ),
      introducedType()
    );
  }
  
  private MethodDecl IntertypeMethodDecl.createDelegateMethod(MethodDecl aspectMethod) {
    // make arguments from this and method parameters
    List args = new List();
    if(!isStatic())
      args.add(new ThisAccess(new List(), new IdUse("this")));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    
    // delegate by calling the aspect method
    List statements = new List();
    if(type().isVoid())
    	statements.add(new ExprStmt(new BoundMethodAccess(name(), args, aspectMethod)));
    else
    	statements.add(new ReturnStmt(new BoundMethodAccess(name(), args, aspectMethod)));
      
    return new MethodDecl(
      (Modifiers)getModifiers().fullCopy(),
      type().createQualifiedAccess(),
      new IdDecl(name()),
      (List)getParameterList().fullCopy(),
      new List(),
      new List(),
      new Opt(
        new Block(
          statements
        )
      )
    );
  }
  
  // Do not generate bytecode for this node type even though it is a subtype of MethodDecl
  // the IntertypeMethodDecl is a placeholder used during error checking, but code
  // need only be emitted for the two generated methods
  eq IntertypeMethodDecl.isBytecodeMethod() = false; 
  
  // change name binding to search for methods in introducedType in IntroducedMethodDecl body
  syn TypeDecl IntroducedMethodDecl.introducedType() = getIntroducedType();
  eq IntroducedMethodDecl.getBlock().lookupMethod(String name) {
    MethodCollection c = introducedType().remoteLookupMethod(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }
  eq IntroducedMethodDecl.getBlock().hostType() = introducedType();
  eq IntroducedMethodDecl.getParameter(int index).hostType() = introducedType();
}

aspect IntertypeMethodCodegeneration {

  public void TypeDecl.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(m instanceof IntertypeMethodDecl) {
        IntertypeMethodDecl methodDecl = (IntertypeMethodDecl)m;
        methodDecl.createIntertypeMethod(this);
      }
    }
  }

  // Each IntertypeMethodDecl generates two methods
  //   IntroducedMethodDecl m1 in the aspect, holding the method body
  //   MethodDecl m2 in the introduced type, that delegates the call to m1 
  // the delegation methods are needed to give the desired semantics for instance methods
  // the IntroducedMethodDecl node type is used to specialize name analysis
  public void IntertypeMethodDecl.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    //MethodDecl aspectMethod = createAspectMethod();
    //MethodDecl delegateMethod = createDelegateMethod(aspectMethod);
    //introducedType().addMemberMethod(delegateMethod);
  }

  public void IntertypeMethodDecl.createIntertypeMethod(TypeDecl introducedType) {
    MethodDecl aspectMethod = createAspectMethod();
    MethodDecl delegateMethod = createDelegateMethod(aspectMethod);
    introducedType.addMemberMethod(delegateMethod);
  }

  syn lazy MethodDecl IntertypeMethodDecl.createAspectMethod() {
    if(!isFinal) throw new Error("IntertypeMethodDecl must be final when aspectMethod is created");
    // make aspect method static
    List modifierList = (List)getModifiers().getModifierList().fullCopy();
    if(!isStatic())
      modifierList.add(new Modifier("static"));
    
    // add that for instance methods
    List parameterList = new List();
    if(!isStatic())
    	parameterList.add(new ParameterDeclaration(introducedType().createQualifiedAccess(), "that"));
    for(int i = 0; i < getNumParameter(); i++)
      parameterList.add(getParameter(i).qualifiedCopy());
      
    MethodDecl aspectMethod = new IntroducedMethodDecl(
      new Modifiers(modifierList),
      type().createQualifiedAccess(),
      name(),
      parameterList,
      new List(),
      new List(),
      new Opt(
        getBlock().fullCopy()
      ),
      introducedType()
    );
    hostAspect().addMemberMethod(aspectMethod);
    return aspectMethod;
  }

  public ParameterDeclaration ParameterDeclaration.qualifiedCopy() {
    return new ParameterDeclaration(type().createQualifiedAccess(), name());
  }


  public void MethodAccess.generateIntertypeDecls() {
    super.generateIntertypeDecls();
    if(hasPrevExpr() && prevExpr().isSuperAccess() && enclosingBodyDecl() instanceof IntroducedMethodDecl) {
      SimpleSet maxSpecific = SimpleSet.emptySet;
      for(Iterator iter = hostType().memberMethods(name()).iterator(); iter.hasNext(); ) {
        MethodDecl decl = (MethodDecl)iter.next();
        if(applicable(decl) && accessible(decl)) {
          if(maxSpecific.isEmpty())
            maxSpecific = maxSpecific.add(decl);
          else {
            if(decl.moreSpecificThan((MethodDecl)maxSpecific.iterator().next()))
              maxSpecific = SimpleSet.emptySet.add(decl);
            else if(!((MethodDecl)maxSpecific.iterator().next()).moreSpecificThan(decl))
              maxSpecific = maxSpecific.add(decl);
          }
        }
      }
      if(maxSpecific.size() == 1) {
        MethodDecl m = (MethodDecl)maxSpecific.iterator().next();
        m.createSuperDispatchDelegate();
      }
    }
  }

  refine CreateBCode public void MethodAccess.createBCode(CodeGeneration gen) {
    if(hasPrevExpr() && prevExpr().isSuperAccess() && enclosingBodyDecl() instanceof IntroducedMethodDecl) {
      SimpleSet maxSpecific = SimpleSet.emptySet;
      for(Iterator iter = hostType().memberMethods(name()).iterator(); iter.hasNext(); ) {
        MethodDecl decl = (MethodDecl)iter.next();
        if(applicable(decl) && accessible(decl)) {
          if(maxSpecific.isEmpty())
            maxSpecific = maxSpecific.add(decl);
          else {
            if(decl.moreSpecificThan((MethodDecl)maxSpecific.iterator().next()))
              maxSpecific = SimpleSet.emptySet.add(decl);
            else if(!((MethodDecl)maxSpecific.iterator().next()).moreSpecificThan(decl))
              maxSpecific = maxSpecific.add(decl);
          }
        }
      }
      if(maxSpecific.size() == 1) {
        MethodDecl m = (MethodDecl)maxSpecific.iterator().next();
        m = m.createSuperDispatchDelegate();
        // invoke m virtually
        gen.emitLoadReference(0);
        for (int i = 0; i < getNumArg(); ++i) {
          getArg(i).createBCode(gen);
          getArg(i).type().emitCastTo(gen, m.getParameter(i).type()); // MethodInvocationConversion
        }
        m.emitInvokeMethod(gen, m.hostType());
      }
      else
        throw new Error("Used super." + name() + " in introduced method, hostType:" + hostType().typeName() + ", decl().hostType: " + decl().hostType().typeName());
    }
    else
      CreateBCode.MethodAccess.createBCode(gen);
  }

  protected static List ASTNode.copyParameterList(List l) {
    List list = new List();
    for(int i = 0; i < l.getNumChild(); i++) {
      ParameterDeclaration p = (ParameterDeclaration)l.getChild(i);
      list.add(new ParameterDeclaration(p.type().createQualifiedAccess(), p.name()));
    }
    return list;
  }
    
  syn lazy MethodDecl MethodDecl.createSuperDispatchDelegate() {
    String name = "superDispatch$" + name();
    List statements = new List();
    List args = new List();
    for(int i = 0; i < getNumParameter(); i++)
      args.add(getParameter(i).createAccess());
    // BUG: Expr e = new SuperAccess("super").qualifiesAccess(new MethodAccess(name(), args));
    Expr e = new SuperAccess("super").qualifiesAccess(this.createBoundAccess(args));
    if(type().isVoid())
      statements.add(new ExprStmt(e));
    else
      statements.add(new ReturnStmt(e));
    MethodDecl m = new MethodDecl(
      new Modifiers(new List().add(new Modifier("public"))),
      type().createQualifiedAccess(),
      name,
      copyParameterList(getParameterList()),
      new List(),
      (List)getExceptionList().fullCopy(),
      new Opt(new Block(statements))
    );
    hostType().addMemberMethod(m);
    hostType().getBodyDecl(hostType().getNumBodyDecl()-1);
    return m;
  }

  // decl().signature() -> method to call using invoke super
  // hostType() -> type to hold the new method
  // a new method called dispatchSuper$signature
  
  public MethodDecl IntertypeMethodDecl.createDelegateMethod(MethodDecl aspectMethod) {
    // make arguments from this and method parameters
    List args = new List();
    if(!isStatic())
      args.add(new ThisAccess("this"));
    for(int i = 0; i < getNumParameter(); i++) {
      args.add(getParameter(i).createAccess());
    }
    
    // delegate by calling the aspect method
    List statements = new List();
    if(type().isVoid())
    	statements.add(new ExprStmt(aspectMethod.createBoundAccess(args)));
    else
    	statements.add(new ReturnStmt(aspectMethod.createBoundAccess(args)));
      
    return new MethodDecl(
      (Modifiers)getModifiers().fullCopy(),
      type().createQualifiedAccess(),
      name(),
      copyParameterList(getParameterList()),
      new List(),
      new List(),
      new Opt(
        new Block(
          statements
        )
      )
    );
  }
  
  // Do not generate bytecode for this node type even though it is a subtype of MethodDecl
  // the IntertypeMethodDecl is a placeholder used during error checking, but code
  // need only be emitted for the two generated methods
  eq IntertypeMethodDecl.isBytecodeMethod() = false; 
  
  // change name binding to search for methods in introducedType in IntroducedMethodDecl body
  syn TypeDecl IntroducedMethodDecl.introducedType() = getIntroducedType();
  eq IntroducedMethodDecl.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }
  inh Collection BodyDecl.lookupMethod(String name);
  
  eq IntroducedMethodDecl.getBlock().lookupVariable(String name) {
    SimpleSet set = parameterDeclaration(name);
    if(!set.isEmpty()) return set;
    set = introducedType().memberFields(name);
    if(!set.isEmpty()) return set;
    return lookupVariable(name);
  }

  eq IntroducedMethodDecl.getBlock().hostType() = introducedType();
  eq IntroducedMethodDecl.getParameter(int index).hostType() = introducedType();

  // TODO: make this use the modifier prior to transformation instead of hardcoded false
  eq IntroducedMethodDecl.getBlock().inStaticContext() = false;
}

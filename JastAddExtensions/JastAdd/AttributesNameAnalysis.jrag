aspect JastAdd {
  
  eq AttributeDecl.isPublic() = true;

  eq AttributeDecl.getBlock().hostType() = getTargetType().type();
  eq AttributeDecl.getParameter().hostType() = getTargetType().type();
  
  eq SynEq.getBlock().hostType() = getTargetType().type();
  eq SynEq.getParameter().hostType() = getTargetType().type();

  eq InhEq.getBlock().hostType() = getTargetType().type();
  eq InhEq.getParameter().hostType() = getTargetType().type();
  eq InhEq.getChildParameter().hostType() = getTargetType().type();

  eq AttributeDecl.getTypeAccess().nameType() = NameType.TYPE_NAME;
  eq AttributeDecl.getTargetType().nameType() = NameType.TYPE_NAME;

  eq SynEq.getTargetType().nameType() = NameType.TYPE_NAME;
  eq SynEq.getParameter().nameType() = NameType.TYPE_NAME;

  eq InhEq.getTargetType().nameType() = NameType.TYPE_NAME;
  eq InhEq.getParameter().nameType() = NameType.TYPE_NAME;
  eq InhEq.getChildParameter().nameType() = NameType.TYPE_NAME;

  inh TypeDecl SynEq.unknownType();
  inh TypeDecl InhEq.unknownType();
  eq SynEq.getBlock().returnType() = decl() != null ? decl().type() : unknownType();
  // TODO: fixme
  eq InhEq.getBlock().returnType() = unknownType();

  syn boolean SynDecl.hasEqBody() = hasBlock() && !getBlock().isDummy();
  public boolean Block.isDummy() {
    return false;
  }
  // Add dummy body to please compiler
  rewrite SynDecl {
    when(!hasBlock())
    to SynDecl {
      setBlock(
        new Block(
          new List().add(
            new ThrowStmt(
              new ClassInstanceExpr(
                lookupType("java.lang", "Error").createQualifiedAccess(),
                new List(),
                new Opt()
              )
            )
          )
        ) {
          public boolean isDummy() {
            return true;
          }
        }
      );
      return this;
    }
  }
  

  syn lazy Map Program.inhEquationsMap() {
    Map map = new HashMap();
    collectInhEquations(map);
    return map;
  }
  protected void ASTNode.collectInhEquations(Map map) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectInhEquations(map);
  }
  protected void InhEq.collectInhEquations(Map map) {
    if(!map.containsKey(name()))
      map.put(name(), new ArrayList(1));
    Collection c = (Collection)map.get(name());
    c.add(this);
  }
  inh Collection AttributeDecl.lookupInhEq(String name);
  eq Program.getCompilationUnit(int i).lookupInhEq(String name) =
    inhEquationsMap().containsKey(name) ? (Collection)inhEquationsMap().get(name) : new ArrayList(0);

  syn Collection InhDecl.decls() {
    Collection c = new ArrayList(1);
    for(Iterator iter = lookupInhEq(name()).iterator(); iter.hasNext(); ) {
      InhEq inhEq = (InhEq)iter.next();
      if(inhEq.matches(this))
        c.add(inhEq);
    }
    return c;
  }

  public boolean InhEq.matches(InhDecl decl) {
    if(!name().equals(decl.name()))
      return false;
    if(getNumParameter() != decl.getNumParameter())
      return false;
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i).type() != decl.getParameter(i).type())
        return false;
    return true;
  }

  syn lazy Map Program.synEquationsMap() {
    Map map = new HashMap();
    collectSynEquations(map);
    return map;
  }
  protected void ASTNode.collectSynEquations(Map map) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectSynEquations(map);
  }
  protected void SynEq.collectSynEquations(Map map) {
    if(!map.containsKey(introducedType()))
      map.put(introducedType(), new ArrayList(1));
    Collection c = (Collection)map.get(introducedType());
    c.add(this);
  }
  inh Collection ASTDecl.synEquations(ASTDecl decl);
  eq Program.getCompilationUnit(int i).synEquations(ASTDecl decl) = synEquationsMap().containsKey(decl) ? 
    (Collection)synEquationsMap().get(decl) : new ArrayList(0);
  syn lazy Collection ASTDecl.synEquations() = synEquations(this);

  syn boolean ASTDecl.hasEquation(SynDecl decl) {
    for(Iterator iter = synEquations().iterator(); iter.hasNext(); ) {
      SynEq equation = (SynEq)iter.next();
      if(equation.matches(decl))
        return true;
    }
    return false;
  }
  syn boolean ASTDecl.hasEquation(SynEq synEq) {
    for(Iterator iter = synEquations().iterator(); iter.hasNext(); ) {
      SynEq equation = (SynEq)iter.next();
      if(equation.matches(synEq))
        return true;
    }
    return false;
  }

  public void SynEq.nameCheck() {
    super.nameCheck();
    if(decl() == null)
      error("Can not find declaration for attribute");
  }

  syn boolean SynEq.matches(SynDecl decl) {
    if(!name().equals(decl.name()) || getNumParameter() != decl.getNumParameter())
      return false;
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i).type() != decl.getParameter(i).type())
        return false;
    return true;
  }
  syn boolean SynEq.matches(SynEq synEq) {
    if(!name().equals(synEq.name()) || getNumParameter() != synEq.getNumParameter())
      return false;
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i).type() != synEq.getParameter(i).type())
        return false;
    return true;
  }


  syn SynDecl SynEq.decl() {
    TypeDecl typeDecl = introducedType();
    Collection c = typeDecl.memberMethods(name());
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(m instanceof SynDecl) {
        SynDecl decl = (SynDecl)m;
        if(matches(decl))
          return decl;
      }
    }
    return null;
    /*
    
    while(typeDecl != null) {
      for(Iterator iter = lookupSynDecl(typeDecl, name()).iterator(); iter.hasNext(); ) {
        SynDecl synDecl = (SynDecl)iter.next();
        if(this.matches(synDecl))
          return synDecl;
      }
      if(typeDecl instanceof ClassDecl) {
        ClassDecl classDecl = (ClassDecl)typeDecl;
        if(classDecl.hasSuperclass())
          typeDecl = classDecl.superclass();
        else
          typeDecl = null;
      }
      else
        typeDecl = null;
    }
    return null;
    */
  }
  /*
  eq Program.getCompilationUnit(int i).lookupSynDecl(TypeDecl typeDecl, String name) = null;
  eq AspectDecl.getBodyDecl(int i).lookupSynDecl(TypeDecl typeDecl, String name) {
    Collection c = new ArrayList(1);
    for(Iterator iter = localIntroductionMethods().iterator(); iter.hasNext(); ) {
      BodyDecl decl = (BodyDecl)iter.next();
      if(decl instanceof SynDecl) {
        SynDecl synDecl = (SynDecl)decl;
        if(synDecl.name().equals(name) && synDecl.introducedType() == typeDecl)
          c.add(synDecl);
      }
    }
    return c;
  }
  inh Collection SynEq.lookupSynDecl(TypeDecl typeDecl, String name);
  */

  syn TypeDecl SynEq.introducedType() = getTargetType().type();   // type in which this equation is valid
  syn String SynEq.name() = getID();           // attribute name
  
  syn TypeDecl InhEq.introducedType() = getTargetType().type();   // type in which this equation is valid
  syn String InhEq.name() = getAttributeName();           // attribute name
  syn String InhEq.childName() = getChildName().substring(3);          // name of the child of hostType that is the root for this equation

  syn lazy List AttributeDecl.getEmptyBracketList() = new List();
  syn lazy List AttributeDecl.getExceptionList() = new List();
  
  syn lazy Opt InhDecl.getBlockOpt() = new Opt(new Block(new List().add(new ThrowStmt(new NullLiteral()))));

  //syn lazy Opt AspectDecl.getSuperClassAccessOpt() = new Opt(typeObject().createQualifiedAccess());
  //syn lazy List AspectDecl.getImplementsList() = new List();

  syn lazy boolean AttributeDecl.isLazy() = getLazy();

  eq AttributeDecl.getModifiers().mayBePublic() = true;
  eq AttributeDecl.getModifiers().mayBeProtected() = true;
  eq AttributeDecl.getModifiers().mayBePrivate() = true;
  eq AttributeDecl.getModifiers().mayBeAbstract() = false;
  eq AttributeDecl.getModifiers().mayBeStatic() = false;
  eq AttributeDecl.getModifiers().mayBeFinal() = false;
  eq AttributeDecl.getModifiers().mayBeSynchronized() = false;
  eq AttributeDecl.getModifiers().mayBeNative() = false;
  eq AttributeDecl.getModifiers().mayBeStrictfp() = false;

  eq SynEq.getParameter().isMethodParameter() = true;
  eq SynEq.getParameter().isConstructorParameter() = false;
  eq SynEq.getParameter().isExceptionHandlerParameter() = false;
  eq SynEq.getBlock().reachable() = true;
  eq SynEq.getBlock().hostBodyDecl() = this;
  
  eq InhEq.getParameter().isMethodParameter() = true;
  eq InhEq.getParameter().isConstructorParameter() = false;
  eq InhEq.getParameter().isExceptionHandlerParameter() = false;
  eq InhEq.getBlock().reachable() = true;
  eq InhEq.getBlock().hostBodyDecl() = this;
  eq InhEq.getChildParameter().isMethodParameter() = true;
  eq InhEq.getChildParameter().isConstructorParameter() = false;
  eq InhEq.getChildParameter().isExceptionHandlerParameter() = false;

  eq SynEq.getBlock().lookupVariable(String name) = localLookupVariable(name);
  eq SynEq.getParameter().lookupVariable(String name) = localLookupVariable(name);

  eq InhEq.getBlock().lookupVariable(String name) = localLookupVariable(name);
  eq InhEq.getParameter().lookupVariable(String name) = localLookupVariable(name);
  eq InhEq.getChildParameter().lookupVariable(String name) = localLookupVariable(name);

  syn lazy SimpleSet SynEq.localLookupVariable(String name) {
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i) instanceof Variable) {
        Variable v = (Variable)getParameter(i);
        if(v.name().equals(name))
          return SimpleSet.emptySet.add(v);
      }
    return lookupVariable(name);
  }

  syn lazy SimpleSet InhEq.localLookupVariable(String name) {
    for(int i = 0; i < getNumChildParameter(); i++)
      if(getChildParameter(i) instanceof Variable) {
        Variable v = (Variable)getChildParameter(i);
        if(v.name().equals(name))
          return SimpleSet.emptySet.add(v);
      }
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i) instanceof Variable) {
        Variable v = (Variable)getParameter(i);
        if(v.name().equals(name))
          return SimpleSet.emptySet.add(v);
      }
    SimpleSet set = introducedType().memberFields(name);
    if(!set.isEmpty()) return set;
    return lookupVariable(name);
  }

  eq SynDecl.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }
  eq SynEq.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }
  eq InhEq.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }
}

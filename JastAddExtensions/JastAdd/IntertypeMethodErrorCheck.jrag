aspect IntertypeMethodErrorCheck {
  public void IntertypeMethodDecl.nameCheck() {
    // override behavior in MethodDecl, remove check for multiply declared signature
    if(isNative() && hasBlock())
      error("native methods must have an empty semicolon body");
    // 8.4.5
    if(isAbstract() && hasBlock())
      error("abstract methods must have an empty semicolon body");
    // 8.4.5
    if(!hasBlock() && !(isNative() || isAbstract()))
      error("only abstract and native methods may have an empty semicolon body");
  }

  // Do not include intertype methods in an aspect as local methods
  // override behavior in LookupMethod.jrag
  // signature -> method declaration
  eq AspectDecl.localMethodsSignatureMap() {
    HashMap map = new HashMap(getNumBodyDecl());
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i) instanceof MethodDecl && !(getBodyDecl(i) instanceof IntertypeMethodDecl)) {
        MethodDecl decl = (MethodDecl)getBodyDecl(i);
        map.put(decl.signature(), decl);
      }
    }
    return map;
  }

  // Override behavior and remove non abstract methods introduced through interfaces
  refine Modifiers eq ClassDecl.unimplementedMethods() {
    Collection c = Modifiers.ClassDecl.unimplementedMethods();
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(!m.isAbstract()) {
        iter.remove();
      }
    }
    return c;
  }

  // Override behavior to not make IntertypeMethodDecl abstract in interfaces
  eq IntertypeMethodDecl.isAbstract() = getModifiers().isAbstract();
}

import java.util.ArrayList;

aspect EnhancedFor {

	// some attributes for the parameter
	eq EnhancedForStmt.getParameter().isMethodParameter() = false;
	eq EnhancedForStmt.getParameter().isConstructorParameter() = false;
	eq EnhancedForStmt.getParameter().isExceptionHandlerParameter() = false;
	

	/** 
	 * Used by prettyPrint()
	 */
  public void EnhancedForStmt.toString(StringBuffer s) {
    s.append("for (");
    getParameter().toString(s);
    s.append(" : ");
    getExpr().toString(s);
    s.append(") ");
    getStmt().toString(s);
  }	
	
	/**
	 * Variable lookup
	 */
  inh ArrayList EnhancedForStmt.lookupVariable(IdUse idUse);
	eq EnhancedForStmt.getParameter().lookupVariable(IdUse idUse) = localLookupVariable(idUse);
	eq EnhancedForStmt.getExpr().lookupVariable(IdUse idUse) = localLookupVariable(idUse);
	eq EnhancedForStmt.getStmt().lookupVariable(IdUse idUse) = localLookupVariable(idUse);
  
  EnhancedForStmt implements VariableScope;
  eq EnhancedForStmt.getParameter().outerScope() = this;
  eq EnhancedForStmt.getExpr().outerScope() = this;
  eq EnhancedForStmt.getStmt().outerScope() = this;

	syn ArrayList EnhancedForStmt.localLookupVariable(IdUse idUse) {
		if(getParameter().getIdDecl().getID().equals(idUse.getID())) {
			ArrayList list = new ArrayList();
			list.add(getParameter());
			return list;
    }
 	  return lookupVariable(idUse);
	}
	
	/**
	 * True if type is java.lang.Iterable or subtype
	   As long as we use the 1.4 API we check for java.util.Collection instead.
	 */
	syn lazy boolean TypeDecl.isIterable() = instanceOf(lookupType("java.util", "Collection"));

/* 	Check that the return type of iterator().next()
	is a supertype to the access type in the parameter	
*/

/*
	syn TypeDecl TypeDecl.returnTypeOfMethod(String name) { 
		for (Iterator iter = methods().iterator(); iter.hasNext();) {
			MethodDecl md = (MethodDecl)iter.next();
			if (md.getIdDecl().getID().equals(name) &&
				md.getNumParameter() == 0) {
				return md.type();
			}
		}
		return lookupType("primitive", "null");
	}
*/
/*
  rewrite EnhancedForStmt {
    when (!duringResolveAmbiguousNames() && !hasComponent())
    to EnhancedForStmt {
      if (getExpr().type().isIterable()) {
        TypeDecl iterator = getExpr().type().returnTypeOfMethod("iterator");
        setComponent(iterator.returnTypeOfMethod("next").createQualifiedAccess());
      }	
      else if (getExpr().type().isArrayDecl()) {
        setComponent(getExpr().type().elementType().createQualifiedAccess());
      }
      else {
        setComponent(lookupType("primitive", "null").createQualifiedAccess());
      }
      return this;
    }
  }
  */
	
	inh TypeDecl Stmt.illegalType();
	
	//eq EnhancedForStmt.getComponent().inAssignmentContext(Expr e) =
	//	e == getComponent();
		
	//eq EnhancedForStmt.getComponent().expectedType() =
	//	getParameter().getTypeAccess().type();
	
	syn boolean EnhancedForStmt.legalEnhancedFor() = true; //compatibleTypes();
		
	//syn boolean EnhancedForStmt.compatibleTypes() = 
	//	getComponent().type() == getComponent().expectedType() &&
	//	getComponent().type() != illegalType();

	/**
	 * Type check. Errors are generated if the type of getExpr() is neither an
	 * array type nor an java.lang.Iterable. If the type is indeed 
	 * java.lang.Iterable, an error occurs if the type of the parameter is not
	 * exactly java.lang.Object.
	 */
	public void EnhancedForStmt.typeCheck() {
		if (!getExpr().type().isArrayDecl() && !getExpr().type().isIterable()) {
			error("*** Semantic error: type " + getExpr().type().name() + 
			      " of expression in foreach is neither array type nor java.lang.Iterable");
		}	
    /*
		else if (!compatibleTypes()) {
			error("*** Semantic error: elements in " + getExpr().type().fullName() +
				" are not assignable to " + getParameter().getTypeAccess().type().fullName());
		}
    */
	}
}

IdDecl type_variable =
		IDENTIFIER.id {: return new IdDecl(id); :}
	;

ClassDecl class_declaration =
		modifiers_opt.m CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new GenericClassDecl(m, new IdDecl(id), s, i, b, p, new List(), new Opt());  :}
	;
InterfaceDecl interface_declaration =
		modifiers_opt.m INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b 
		{:  return new GenericInterfaceDecl(m, new IdDecl(id), i, b, p, new List(), new Opt());  :}
	;

Access class_or_interface_type =
		class_or_interface.t LT type_argument_list_1.l {:  return new ParTypeAccess(t, l);  :}
	;
Access array_type =
    	class_or_interface.t LT type_argument_list_1.l DOT name.n dims.d 
    	{:  return new Dot(new TypeDot(new ParTypeAccess(t, l), n), new ArrayTypeName(d));  :}
	|	class_or_interface.t LT type_argument_list_1.l dims.d 
		{:  return new Dot(new ParTypeAccess(t, l), new ArrayTypeName(d));  :}
	;

List type_arguments =
		LT type_argument_list_1.l {:  return l;  :}
	;
      
Access wildcard =
		QUESTION                             {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type.t    {: return new WildcardExtends(t); :}
    |	QUESTION SUPER reference_type.t    {: return new WildcardSuper(t); :}
    ;
   
Access wildcard_1 =
		QUESTION GT                          {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_1.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_1.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_2 =
		QUESTION RSHIFT                      {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_2.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_2.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_3 =
		QUESTION URSHIFT                     {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_3.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_3.t    {: return new WildcardSuper(t); :}
	;

Expr class_instance_creation_expression =
	 	NEW type_arguments.a class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new ParClassInstanceExpr(t, l, b, a); :}
    /*
	|	primary.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(new IdUse(id)), a), l, b ); :}	
        */
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new Dot(n, new ParClassInstanceExpr(new ParseName(new IdUse(id)), l, b, ca)); :}
    /*
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(new IdUse(id)), ta), l, b, ca); :}
	|	name.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(new IdUse(id)), a), l, b);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParseName(new IdUse(id)), l, b, ca);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(new IdUse(id)), ta), l, b, ca);  :}
    */
	;

List type_argument_list =
		type_argument.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument.a {:  return l.add(a);  :}
	;
	
List type_argument_list_1 =
		type_argument_1.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_1.a {:  return l.add(a);  :}
	;
	
List type_argument_list_2 =
		type_argument_2.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_2.a {:  return l.add(a);  :}
	;
	
List type_argument_list_3 =
		type_argument_3.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_3.a {:  return l.add(a);  :}
	;
	
Access type_argument =
		reference_type.t {:  return t;  :}
	|	wildcard.w {: return w; :}
	;
	
Access type_argument_1 =
		reference_type_1.t {:  return t;  :}
	|	wildcard_1.w {: return w; :}
	;
	
Access type_argument_2 =
		reference_type_2.t {:  return t;  :}
	|	wildcard_2.w {: return w; :}
	;
	
Access type_argument_3 =
		reference_type_3.t {:  return t;  :}
	|	wildcard_3.w {: return w; :}
	;
Access class_or_interface =
		class_or_interface.t LT type_argument_list_1.l DOT name.n 
		{:  return new TypeDot(new ParTypeAccess(t, l), n);  :}
	;
Access reference_type_1 =
		reference_type.t GT {:  return t;  :}
	|	class_or_interface.t LT type_argument_list_2.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_2 =
		reference_type.t RSHIFT {:  return t;  :}
	|	class_or_interface.t LT type_argument_list_3.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_3 =
		reference_type.t URSHIFT {:  return t;  :}
	;
Expr cast_expression =
		LPAREN name.n LT type_argument_list_1.a RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new Dot(new ParTypeAccess(n, a), new ArrayTypeName(d)), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new Dot(new ParTypeAccess(n, a), t), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new Dot(new Dot(new ParTypeAccess(n, a), t), new ArrayTypeName(d)), e);  :};

List type_parameters =
		LT type_parameter_list_1.l {:  return l;  :}
	;
	
List type_parameter_list =
		type_parameter_list.l COMMA type_parameter.p {:  return l.add(p);  :}
	|	type_parameter.p {:  return new List().add(p);  :}
	;
	
List type_parameter_list_1 =
		type_parameter_1.p {:  return new List().add(p);  :}
	|	type_parameter_list.l COMMA type_parameter_1.p {:  return l.add(p);  :}
	;
	
TypeVariable type_parameter =
		type_variable.v {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
	|	type_variable.v type_bound.l {:  return new TypeVariable(new Modifiers(), v, new List(), l); :}
	;
	
TypeVariable type_parameter_1 =
		type_variable.v GT {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
|	type_variable.v type_bound_1.l {:  return new TypeVariable(new Modifiers(), v, new List(), l);  :}
	;
	
List type_bound =
		EXTENDS reference_type.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list.l {:  l.insertChild(t,0); return l; :}
    ;
    
List type_bound_1 =
		EXTENDS reference_type_1.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list_1.l {:  l.insertChild(t,0); return l; :}
    ;
    
List additional_bound_list =
		additional_bound.b additional_bound_list.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound.b {:  return new List().add(b);  :}
    ;
    
List additional_bound_list_1 =
		additional_bound.b additional_bound_list_1.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound_1.b {:  return new List().add(b);  :}
    ;
    
Access additional_bound =
		AND interface_type.t {:  return t;  :}
	;
	
Access additional_bound_1 =
		AND reference_type_1.t {:  return t;  :}
	;

BodyDecl class_member_declaration =
		modifiers_opt.m CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new MemberClass(new GenericClassDecl(m, new IdDecl(id), s, i, b, p, new List(), new Opt()));  :}
	;
	
Opt class_body_opt = {: return new Opt(); :}
    |  class_body.b {:  return new Opt(b);  :};

aspect GenericsCodegen {
    
   eq TypeVariable.typeDescriptor() = erasure().typeDescriptor();
   eq ParClassDecl.typeDescriptor() = erasure().typeDescriptor();
   eq ParInterfaceDecl.typeDescriptor() = erasure().typeDescriptor();

  syn FieldDeclaration FieldDeclaration.erasedField() =
    (FieldDeclaration)hostType().erasure().memberFields(name()).iterator().next();

  syn MethodDecl MethodDecl.erasedMethod() = this;
  eq MethodDeclSubstituted.erasedMethod() = getOriginal().erasedMethod();

  refine CodeGeneration public void VarAccess.emitStore(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessorWrite(gen, fieldQualifierType());
      else
        f.emitStoreField(gen, fieldQualifierType());
    }
    else
      CodeGeneration.VarAccess.emitStore(gen);
  }

  refine CreateBCode public void VarAccess.createAssignLoadDest(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      createLoadQualifier(gen);
      if(v.isInstanceVariable())
        gen.emitDup();
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessor(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
    }
    else
      CreateBCode.VarAccess.createAssignLoadDest(gen);
  }

  refine CreateBCode public void VarAccess.createBCode(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      createLoadQualifier(gen);
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessor(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
      if(f.type() != decl().type())
        gen.emitCheckCast(decl().type());
    }
    else
      CreateBCode.VarAccess.createBCode(gen);
  }

  refine CreateBCode public void MethodAccess.createBCode(CodeGeneration gen) {
    MethodDecl decl = decl().erasedMethod();
    createLoadQualifier(gen);
    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      getArg(i).type().emitCastTo(gen, decl.getParameter(i).type()); // MethodInvocationConversion
    }
    if(!decl.isStatic() && isQualified() && prevExpr().isSuperAccess()) {
      if(!hostType().instanceOf(prevExpr().type())) {
        TypeDecl typeDecl = superAccessorTarget();
        MethodDecl m = typeDecl.createSuperAccessor(decl);
        m.emitInvokeMethod(gen, typeDecl);
      }
      else
        decl.emitInvokeSpecialMethod(gen, methodQualifierType());
    }
    else
      decl.emitInvokeMethod(gen, methodQualifierType());

    if(decl.type() != decl().type())
      gen.emitCheckCast(decl().type());
  }

  public void ConstructorDeclSubstituted.emitInvokeConstructor(CodeGeneration gen) {
    erasedConstructor().emitInvokeConstructor(gen);
  }
  syn ConstructorDecl ConstructorDecl.erasedConstructor() = this;
  eq ConstructorDeclSubstituted.erasedConstructor() = getOriginal().erasedConstructor();


  eq TypeVariable.constantPoolName() = erasure().constantPoolName();
  eq ParClassDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq ParInterfaceDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq GenericClassDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq GenericInterfaceDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }



   syn boolean TypeVariable.isNestedType() = false;


   public Access RawClassDecl.createQualifiedAccess() {
     System.out.println("Creating qualified access to RawClassDecl" + name());
     List list = new List();
     for(int i = 0; i < getNumTypeParameter(); i++)
       list.add(getTypeParameter(i).erasure().createQualifiedAccess());
     if(isTopLevelType())
       return new RawTypeAccess(packageName(), name(), list);
     else
       return enclosingType().createQualifiedAccess().qualifiesAccess(new RawTypeAccess(name(), list));
   }

   public RawTypeAccess.RawTypeAccess(String typeName, List list) {
    this("", typeName, list);
  }
  
  public ParameterizedTypeAccess.ParameterizedTypeAccess(String typeName, List list) {
    this("", typeName, list);
  }

  // accessibility for members in generic classes
  // the accessibility for parameterized and raw versions of a generic class
  // should be the same as for the generic class, in other words the erasure of the 
  // paramterized version.
  eq ParClassDecl.accessibleFrom(TypeDecl type) =
    erasure().accessibleFrom(type);
  eq ParClassDecl.topLevelType() = erasure().topLevelType();


}

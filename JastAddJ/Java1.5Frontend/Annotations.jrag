aspect Annotations {
  // 7.4.1.1 Package Annotations

  /* Annotations may be used on package declarations, with the restriction that
  at most one annotated package declaration is permitted for a given package.
  The manner in which this restriction is enforced must, of necessity, vary
  from implementation to implementation. The following scheme is strongly
  recommended for file-system-based implementations: The sole annotated
  package declaration, if it exists, is placed in a source file called
  package-info.java in the directory containing the source files for the
  package. */
  public void AnnotatedCompilationUnit.nameCheck() {
    super.nameCheck();
    if(!relativeName().endsWith("package-info.java"))
      error("package annotations should be in a file package-info.java");
  }

  // 9.6 Annotation Types
  
  /* The Identifier in an annotation type declaration specifies the name of the
  annotation type. A compile-time error occurs if an annotation type has the same
  simple name as any of its enclosing classes or interfaces.
  Comment: This is common for all type declarations and need thus no specific
  implementation. */

  /* If an annotation a on an annotation declaration corresponds to an
  annotation type T, and T has a (meta-)annotation m that corresponds to
  annotation.Target, then m must have either an element whose matches the 
  annotated declaration, or a compile-time error occurs.*/
  public void Annotation.checkModifiers() {
    super.checkModifiers();
    if(getAccess().type() instanceof AnnotationDecl) {
      AnnotationDecl T = (AnnotationDecl)getAccess().type();
      Annotation m = T.annotationTarget();
      if(m != null && m.singleValueArgument() != null) {
        Expr e = m.singleValueArgument();
        if(e.varDecl() != null) {
          Variable v = e.varDecl();
          if(!v.hostType().fullName().equals("java.lang.annotation.ElementType") ||
            !mayUseAnnotationTarget(v.name()))
            error("annotation type " + T.typeName() + " is not applicable to this kind of declaration");
        }
      }
    }
  }
  syn Annotation AnnotationDecl.annotationTarget() {
    for(int i = 0; i < getModifiers().getNumModifier(); i++) {
      Modifier m = getModifiers().getModifier(i);
      if(m instanceof Annotation) {
        Annotation a = (Annotation)m;
        if(a.getAccess().type().fullName().equals("java.lang.annotation.Target"))
          return a;
      }
    }
    return null;
  }
  syn Expr Annotation.singleValueArgument() {
    if(getNumElementValuePair() != 1)
      return null;
    ElementValuePair pair = getElementValuePair(0);
    if(!pair.getName().equals("value"))
      return null;
    if(!(pair.getElementValue() instanceof ElementConstantValue))
      return null;
    return ((ElementConstantValue)pair.getElementValue()).getExpr();
  }
  inh boolean Annotation.mayUseAnnotationTarget(String name);
  // 7.4.1
  eq AnnotatedCompilationUnit.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("PACKAGE");
  // 8.1.1, 9.1.1
  eq TypeDecl.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("TYPE");
  // 9.6
  eq AnnotationDecl.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("ANNOTATION_TYPE") || name.equals("TYPE");
  // 8.3.1, 9.3, 8.9
  eq FieldDeclaration.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("FIELD");
  // 8.4.1
  eq ParameterDeclaration.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("PARAMETER");
  // 8.4.3, 9.4
  eq MethodDecl.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("METHOD");
  // 8.8.3
  eq ConstructorDecl.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("CONSTRUCTOR");
  // 14.4
  eq VariableDeclaration.getModifiers().mayUseAnnotationTarget(String name) =
    name.equals("LOCAL_VARIABLE");
  eq Program.getCompilationUnit().mayUseAnnotationTarget(String name) = false;

  /* The direct superinterface of an annotation type is always
  annotation.Annotation.*/
  syn List AnnotationDecl.getSuperInterfaceIdList() {
    List list = new List();
    TypeDecl typeDecl = lookupType("java.lang.annotation", "Annotation");
    if(typeDecl != null)
      list.add(typeDecl.createQualifiedAccess());
    return list;
  }

  public void AnnotationDecl.typeCheck() {
    super.typeCheck();
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i) instanceof MethodDecl) {
        MethodDecl m = (MethodDecl)getBodyDecl(i);
        if(!m.type().isValidAnnotationMethodReturnType())
          m.error("invalid type for annotation member");
        if(m.annotationMethodOverride())
          m.error("annotation method overrides " + m.signature());
      }
    }
    if(containsElementOf(this))
      error("cyclic annotation element type");
  }
  /* It is a compile-time error if the return type of a method declared in an
  annotation type is any type other than one of the following: one of the
  primitive types, String, Class and any invocation of Class, an enum type
  (§8.9), an annotation type, or an array (§10) of one of the preceding types.*/
  syn boolean TypeDecl.isValidAnnotationMethodReturnType() = false;
  eq PrimitiveType.isValidAnnotationMethodReturnType() = true;
  eq ReferenceType.isValidAnnotationMethodReturnType() {
    if(isString()) return true;
    if(fullName().equals("java.lang.Class"))
      return true;
    // TODO: include generic versions of Class
    return false;
  }
  eq EnumDecl.isValidAnnotationMethodReturnType() = true;
  eq ArrayDecl.isValidAnnotationMethodReturnType() = componentType().isValidAnnotationMethodReturnType();
  eq AnnotationDecl.isValidAnnotationMethodReturnType() = true;
 
  /* It is also a compile-time error if any method declared in an annotation type has a
  signature that is override-equivalent to that of any public or protected method
  declared in class Object or in the interface annotation.Annotation*/
  syn boolean MethodDecl.annotationMethodOverride() =
    !hostType().ancestorMethods(signature()).isEmpty();

  /* It is a compile-time error if an annotation type T contains an element of
  type T, either directly or indirectly.*/
  syn boolean AnnotationDecl.containsElementOf(TypeDecl typeDecl) circular [false] {
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i) instanceof MethodDecl) {
        MethodDecl m = (MethodDecl)getBodyDecl(i);
        if(m.type() == typeDecl)
          return true;
        if(m.type() instanceof AnnotationDecl && ((AnnotationDecl)m.type()).containsElementOf(typeDecl))
          return true;
      }
    }
    return false;
  }

  /* An ElementValue is used to specify a default value. It is a compile-time error
  if the type of the element is not commensurate (§9.7) with the default value
  specified. An ElementValue is always FP-strict (§15.4).*/
  public void AnnotationMethodDecl.typeCheck() {
    super.typeCheck();
    if(hasDefaultValue() && !type().commensurateWith(getDefaultValue()))
      error(type().typeName() + " is not commensurate with " + getDefaultValue().type().typeName());
  }

/*


// 9.6.1 Predefined Annotation Types

// 9.6.1.1 Target

// 9.6.1.2 Retention

// 9.6.1.3 Inherited

// 9.6.1.4 Override

// 9.6.1.5 SupressWarnings

// 9.6.1.6 Deprecated


*/
// 9.7 Annotations

  public void Annotation.typeCheck() {
    if(!(getAccess().type() instanceof AnnotationDecl)) {
      /* TypeName names the annotation type corresponding to the annotation. It is a
      compile-time error if TypeName does not name an annotation type.*/
      error(getAccess().type().typeName() + " is not an annotation type");
    } else {
      TypeDecl typeDecl = decl();
      /* It is a compile-time error if a declaration is annotated with more than one
      annotation for a given annotation type.*/
      if(lookupAnnotation(typeDecl) != this)
        error("duplicate annotation " + typeDecl.typeName());
      /* Annotations must contain an element-value pair for every element of the
      corresponding annotation type, except for those elements with default
      values, or a compile-time error occurs. Annotations may, but are not
      required to, contain element-value pairs for elements with default values.*/
      for(int i = 0; i < typeDecl.getNumBodyDecl(); i++) {
        if(typeDecl.getBodyDecl(i) instanceof AnnotationMethodDecl) {
          AnnotationMethodDecl decl = (AnnotationMethodDecl)typeDecl.getBodyDecl(i);
          if(!decl.hasDefaultValue() && elementValueFor(decl.name()) == null)
            error("missing value for " + decl.name());
        }
      }
      /* The Identifier in an ElementValuePair must be the simple name of one of the
      elements of the annotation type identified by TypeName in the containing
      annotation. Otherwise, a compile-time error occurs. (In other words, the
      identifier in an element-value pair must also be a method name in the interface
      identified by TypeName.) */
      for(int i = 0; i < getNumElementValuePair(); i++) {
        ElementValuePair pair = getElementValuePair(i);
        if(typeDecl.memberMethods(pair.getName()).isEmpty())
          error("can not find element named " + pair.getName() + " in " + typeDecl.typeName());
      }
    }
  }

  syn lazy TypeDecl Annotation.decl() = 
    getAccess().type() instanceof AnnotationDecl ? getAccess().type() : unknownType();
  inh TypeDecl Annotation.unknownType();


  inh Annotation Annotation.lookupAnnotation(TypeDecl typeDecl);
  eq Modifiers.getModifier(int index).lookupAnnotation(TypeDecl typeDecl) {
    for(int i = 0; i < getNumModifier(); i++) {
      if(getModifier(i) instanceof Annotation) {
        Annotation a = (Annotation)getModifier(i);
        if(a.getAccess().type() == typeDecl)
          return a;
      }
    }
    return null;
  }
  eq Program.getCompilationUnit(int i).lookupAnnotation(TypeDecl typeDecl) = null;

  syn ElementValue Annotation.elementValueFor(String name) {
    for(int i = 0; i < getNumElementValuePair(); i++) {
      ElementValuePair pair = getElementValuePair(i);
      if(pair.getName().equals(name))
        return pair.getElementValue();
    }
    return null;
  }

  /* The annotation type named by an annotation must be accessible (§6.6) at the
  point where the annotation is used, or a compile-time error occurs.
  Comment: This is done by the access control framework*/

  /* The return type of this method defines the element type of the element-value
  pair. An ElementValueArrayInitializer is similar to a normal array initializer
  (§10.6), except that annotations are permitted in place of expressions.*/
  syn TypeDecl ElementValuePair.type() {
    Annotation a = (Annotation)getParent().getParent(); // TODO: replace hack with inherited attribute
    Iterator iter = a.decl().memberMethods(getName()).iterator();
    if(iter.hasNext()) {
      MethodDecl m = (MethodDecl)iter.next();
      return m.type();
    }
    return unknownType();
  }
  inh TypeDecl ElementValuePair.unknownType();
    
  /* An element type T is commensurate with an element value V if and only if one of the following conditions is true:
    * T is an array type E[] and either:
          o V is an ElementValueArrayInitializer and each ElementValueInitializer (analogous to a variable initializer in an array initializer) in V is commensurate with E. Or
          o V is an ElementValue that is commensurate with T. 
    * The type of V is assignment compatible (§5.2) with T and, furthermore:
          o If T is a primitive type or String, V is a constant expression (§15.28).
          o V is not null.
          o if T is Class, or an invocation of Class, and V is a class literal (§15.8.2).
          o If T is an enum type, and V is an enum constant. */
  syn boolean TypeDecl.commensurateWith(ElementValue value) = value.commensurateWithTypeDecl(this);
  syn boolean ElementValue.commensurateWithTypeDecl(TypeDecl type) = false;
  eq ElementConstantValue.commensurateWithTypeDecl(TypeDecl type) {
    Expr v = getExpr();
    if(!v.type().assignConversionTo(type, v))
      return false;
    if((type.isPrimitive() || type.isString()) && !v.isConstant())
      return false;
    if(v.type().isNull())
      return false;
    if(type.fullName().equals("java.lang.Class") && !v.isClassAccess())
      return false;
    if(type.isEnumDecl() && (v.varDecl() == null || !(v.varDecl() instanceof EnumConstant)))
      return false;
    return true;
  }
  eq ArrayDecl.commensurateWith(ElementValue value) = value.commensurateWithArrayDecl(this);
  syn boolean ElementValue.commensurateWithArrayDecl(ArrayDecl type) = 
    type.componentType().commensurateWith(this);
  eq ElementArrayValue.commensurateWithArrayDecl(ArrayDecl type) {
    for(int i = 0; i < getNumElementValue(); i++)
      if(!type.componentType().commensurateWith(getElementValue(i)))
        return false;
    return true;
  }
  /* It is a compile-time error if the element type is not commensurate with the ElementValue.*/
  public void ElementValuePair.typeCheck() {
    if(!type().commensurateWith(getElementValue()))
      error(type().typeName() + " is not commensurate with " + getElementValue().type().typeName());
  }
  syn TypeDecl ElementValue.type() = unknownType();
  eq ElementConstantValue.type() = getExpr().type();
  inh TypeDecl ElementValue.unknownType();
/*
If the element type is not an annotation type or an array type, ElementValue
must be a ConditionalExpression (§15.25)

If the element type is an array type and the corresponding ElementValue is not
an ElementValueArrayInitializer, an array value whose sole element is the value
represented by the ElementValue is associated with the element. Otherwise, the
value represented by ElementValue is associated with the element.

An annotation on an annotation type declaration is known as a meta-annotation.
An annotation type may be used to annotate its own declaration. More generally,
circularities in the transitive closure of the "annotates" relation are
permitted. For example, it is legal to annotate an annotation type declaration
with another annotation type, and to annotate the latter type's declaration
with the former type. (The pre-defined meta-annotation types contain several
such circularities.)


*/
  // name binding
  eq Annotation.getAccess().nameType() = NameType.TYPE_NAME;
  eq ElementConstantValue.getExpr().nameType() = NameType.AMBIGUOUS_NAME;
  
  eq AnnotatedCompilationUnit.getModifiers().hostPackage() = packageName();
  eq AnnotatedCompilationUnit.getModifiers().lookupType(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for(Iterator iter = localLookupType(name).iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if(t.accessibleFromPackage(packageName()))
        set = set.add(t);
    }
    return set;
  }

} 

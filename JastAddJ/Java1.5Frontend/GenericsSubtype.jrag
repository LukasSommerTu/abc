aspect GenericsSubtype {
  // use of this in generic classes
  // all references to this are compatible with the raw counterpart
  eq GenericClassDecl.subtype(TypeDecl type) = type.supertypeGenericClassDecl(this);
  syn boolean TypeDecl.supertypeGenericClassDecl(GenericClassDecl type) circular [true] =
    supertypeClassDecl(type);
  eq RawClassDecl.supertypeGenericClassDecl(GenericClassDecl type) =
    erasure() == type;

  eq GenericInterfaceDecl.subtype(TypeDecl type) = type.supertypeGenericInterfaceDecl(this);
  syn boolean TypeDecl.supertypeGenericInterfaceDecl(GenericInterfaceDecl type) circular [true] =
    supertypeInterfaceDecl(type);
  eq RawInterfaceDecl.supertypeGenericInterfaceDecl(GenericInterfaceDecl type) =
    erasure() == type;

  // 5.1.9 Unchecked Conversion
  eq ParClassDecl.supertypeGenericClassDecl(GenericClassDecl type) {
    // TODO: How to generate warnings
    // For each RawTypeAccess that is being subject to unchecked conversion
    return type.subtype(genericTypeDecl());
  }
  eq ParInterfaceDecl.supertypeGenericClassDecl(GenericClassDecl type) {
    return type.subtype(genericTypeDecl());
  }
  eq ParInterfaceDecl.supertypeGenericInterfaceDecl(GenericInterfaceDecl type) {
    return type.subtype(genericTypeDecl());
  }


  // 5.1.10 Capture Conversion
  // TODO:

  eq WildcardType.subtype(TypeDecl type) = type.supertypeWildcard(this);
  public boolean TypeDecl.supertypeWildcard(WildcardType type) {
    return false;
  }
  public boolean TypeVariable.supertypeWildcard(WildcardType type) {
    return typeObject().subtype(this);
  }
  public boolean WildcardExtendsType.supertypeWildcard(WildcardType type) {
    return typeObject().subtype(this);
  }

  eq WildcardExtendsType.subtype(TypeDecl type) = type.supertypeWildcardExtends(this);
  public boolean TypeDecl.supertypeWildcardExtends(WildcardExtendsType type) {
    return false;
  }
  public boolean WildcardExtendsType.supertypeWildcardExtends(WildcardExtendsType type) {
    return type.extendsType().subtype(extendsType());
  }
  public boolean TypeVariable.supertypeWildcardExtends(WildcardExtendsType type) {
    return type.extendsType().subtype(this);
  }
  public boolean WildcardType.supertypeWildcardExtends(WildcardExtendsType type) {
    return true;
  }
  public boolean WildcardExtendsType.supertypeTypeVariable(TypeVariable type) {
    return type.subtype(extendsType());
  }

  public boolean ClassDecl.supertypeWildcardExtends(WildcardExtendsType type) {
    return type.extendsType() == this;
  }
  public boolean InterfaceDecl.supertypeWildcardExtends(WildcardExtendsType type) {
    return type.extendsType() == this;
  }

  eq WildcardSuperType.subtype(TypeDecl type) = type.supertypeWildcardSuper(this);
  public boolean TypeDecl.supertypeWildcardSuper(WildcardSuperType type) {
    return false;
  }
  public boolean WildcardSuperType.supertypeWildcardSuper(WildcardSuperType type) {
    return type.superType().subtype(superType());
  }
  public boolean TypeVariable.supertypeWildcardSuper(WildcardSuperType type) {
    return type.superType().subtype(this);
  }
  public boolean WildcardSuperType.supertypeTypeVariable(TypeVariable type) {
    return type.subtype(superType());
  }
  
  syn boolean TypeDecl.isWildcard() = false;
  eq AbstractWildcardType.isWildcard() = true;

  syn boolean TypeDecl.wildcardSubtype(TypeDecl typeDecl) circular [true] {
    if(typeDecl == this) return true;
    if(typeDecl instanceof WildcardExtendsType) {
      WildcardExtendsType other = (WildcardExtendsType)typeDecl;
      return subtype(other.extendsType());
    }
    else if(typeDecl instanceof WildcardSuperType) {
      WildcardSuperType other = (WildcardSuperType)typeDecl;
      return other.superType().subtype(this);
    }
    else if(typeDecl instanceof WildcardType) {
      return true;
    }
    return false;
  }
  eq WildcardType.wildcardSubtype(TypeDecl typeDecl) {
    if(typeDecl == this) return true;
    if(typeDecl instanceof WildcardType)
      return true;
    else if(typeDecl instanceof WildcardExtendsType) {
      WildcardExtendsType other = (WildcardExtendsType)typeDecl;
      return typeObject().subtype(other.extendsType());
    }
    else if(typeDecl instanceof WildcardSuperType) {
      WildcardSuperType other = (WildcardSuperType)typeDecl;
      return other.superType().subtype(typeObject());
    }
    return false;
  }
  eq WildcardExtendsType.wildcardSubtype(TypeDecl typeDecl) {
    if(typeDecl == this) return true;
    if(typeDecl instanceof WildcardExtendsType) {
      WildcardExtendsType other = (WildcardExtendsType)typeDecl;
      return extendsType().subtype(other.extendsType());
    }
    if(typeDecl instanceof WildcardType)
      return true;
    return false;
  }
  eq WildcardSuperType.wildcardSubtype(TypeDecl typeDecl) {
    if(typeDecl == this) return true;
    if(typeDecl instanceof WildcardSuperType) {
      WildcardSuperType other = (WildcardSuperType)typeDecl;
      return other.superType().subtype(superType());
    }
    if(typeDecl instanceof WildcardType)
      return true;
    return false;
  }

  eq ParClassDecl.supertypeClassDecl(ClassDecl type) {
    //System.out.println("Is ParClassDecl " + typeName() + " a supertype of ClassDecl " + type.typeName());
    if(!(type instanceof ParClassDecl))
      return super.supertypeClassDecl(type);
    ParClassDecl typeDecl = (ParClassDecl)type;
    if(typeDecl.genericDecl() == genericDecl()) {
      for(int i = 0; i < getNumArgument(); i++) {
        //System.out.println("Comparing argument " + typeDecl.getArgument(i).type().typeName() + " with " + getArgument(i).type().typeName());
        if(!typeDecl.getArgument(i).type().subtype(getArgument(i).type())) {
          //System.out.println("Argument " + i + " does not match");
          return false;
        }
      }
      return true;
    }
    else
      return false;
  }

  eq ParTypeDecl.subtype(TypeDecl type) {
    //System.out.println("Is ParTypeDecl " + typeName() + " a subtype of " + type.typeName());
    if(super.subtype(type))
      return true;
    if(isRawType() && !type.isRawType() && type instanceof ParTypeDecl)
      return false;
    if(type instanceof ParTypeDecl) {
      ParTypeDecl typeDecl = (ParTypeDecl)type;
      //System.err.println("Computing " + fullName() + " isSubtypeOf " + ((TypeDecl)typeDecl).fullName());
      TypeDecl g1 = genericDecl();
      TypeDecl g2 = typeDecl.genericDecl();
      if(g1 == g2 && (isRawType() || type.isRawType()))
        return true;
      if(g1.subtype(g2)) {
        //System.out.println("Checking type arguments");
        if(getNumArgument() == typeDecl.getNumArgument()) {
          for(int i = 0; i < getNumArgument(); i++) {
            if(typeDecl.getArgument(i).type().isTypeVariable()) {
              if(!getArgument(i).type().subtype(typeDecl.getArgument(i).type())) {
                //System.err.println("Argument " + getArgument(i).type().fullName() + " and " + typeDecl.getArgument(i).type().fullName() + " are not subtypes");
                return false;
              }
            }
            else if(!getArgument(i).type().wildcardSubtype(typeDecl.getArgument(i).type())) {
              //System.err.println("Argument " + getArgument(i).type().fullName() + " and " + typeDecl.getArgument(i).type().fullName() + " are not wildcard subtypes");
              return false;
            }
            else {
            }
          }
          return true;
        }
        else {
          //System.err.println("Number of type arguments does not match");
        }
      }
      else {
        //System.err.println("Generic type " + g1.fullName() + " is not an instanceof " + g2.fullName());
      }
    }
    if(type instanceof GenericClassDecl && genericTypeDecl() == type)
      return true;
    if(type instanceof GenericInterfaceDecl && genericTypeDecl() == type)
      return true;
    Object that = this;
    if(that instanceof ParClassDecl) {
      ParClassDecl p = (ParClassDecl)that;
      if(p.hasSuperclass() && p.superclass().subtype(type))
        return true;
      for(int i = 0; i < p.getNumImplements(); i++)
        if(p.getImplements(i).type().subtype(type))
          return true;
    }
    else if(that instanceof ParInterfaceDecl) {
      ParInterfaceDecl p = (ParInterfaceDecl)that;
      for(int i = 0; i < p.getNumSuperInterfaceId(); i++)
        if(p.getSuperInterfaceId(i).type().subtype(type))
          return true;
    }
    return false;
  }
  
  
  /*
  public boolean TypeVariable.supertypeInterfaceDecl(InterfaceDecl type) {
    return super.supertypeInterfaceDecl(type);
  }
  public boolean TypeVariable.supertypeArrayDecl(ArrayDecl type) {
    return super.supertypeArrayDecl(type);
  }
  */

  eq TypeVariable.supertypeArrayDecl(ArrayDecl type) {
    for(int i = 0; i < getNumTypeBound(); i++)
      if(type.subtype(getTypeBound(i).type())) {
        return true;
      }
    return false;
  }

  syn boolean TypeDecl.supertypeTypeVariable(TypeVariable type) circular [true] {
    //System.out.println("Is " + typeName() + " a supertype of TypeVariable " + type.typeName() + "?");
    if(type == this) {
      //System.err.println("  " + type.fullName() + " is a subtype of " + fullName() + "! ");
      return true;
    }
    for(int i = 0; i < type.getNumTypeBound(); i++)
      if(type.getTypeBound(i).type().subtype(this)) {
        //System.err.println("  " + type.fullName() + " is a subtype of " + fullName() + "! ");
        return true;
      }
    //System.err.println("  " + type.fullName() + " is not a subtype of " + fullName() + "! ");
    return false;
    //return type == this;
  }

  eq TypeVariable.subtype(TypeDecl type) = type.supertypeTypeVariable(this);

  //In addition to the above rules, a type variable is a direct supertype of its lower bound.
  eq TypeVariable.supertypeClassDecl(ClassDecl type) {
    //System.out.println("Is TypeVariable " + typeName() + " a supertype of ClassDecl " + type.typeName() + "?");
    for(int i = 0; i < getNumTypeBound(); i++) {
      //System.out.println("Is ClassDecl " + type.typeName() + " a subtype of " + getTypeBound(i).type().typeName());
      if(!type.subtype(getTypeBound(i).type())) {
        return false;
      }
    }
    return true;
  }
  eq TypeVariable.supertypeInterfaceDecl(InterfaceDecl type) {
    for(int i = 0; i < getNumTypeBound(); i++)
      if(!type.subtype(getTypeBound(i).type())) {
        return false;
      }
    return true;
  }

/* Let C be a type declaration with zero or more type parameters F1, ..., Fn which
have corresponding bounds B1, ..., Bn. That type declaration defines a set of
parameterized types C2 <T1,...,Tn>, where each argument type Ti ranges over all
types that are subtypes of all types listed in the corresponding bound. That
is, for each bound type Si in Bi, Ti is a subtype of Si[ F1 := T1, ..., Fn := Tn].

Comment: Take the bound Si and replace the type parameter F1 with T1, etc
*/

/*
Given a type declaration for C<F1,...,Fn>, the direct supertypes of the
parameterized type C<F1,...,Fn> are all of the following:

    * the direct superclasses of C.
    * the direct superinterfaces of C.
    * The type Object, if C is an interface type with no direct superinterfaces.
    * The raw type C. 

The direct supertypes of the type C<T1,...,Tn> , where Ti,1<=i<=n, is a type, are
D<U1 theta, ..., Uk theta>, where

    * D<U1,...,Uk> is a direct supertype of C<F1,...,Fn>, and theta is the 
      substitution [F1 := T1, ..., Fn := Tn].
    * C<S1,...,Sn> where Si contains Ti for 1<=i<=n. 

The direct supertypes of the type C<R1,...,Rn> , where at least one of the Ri,
1<=i<=n, is a wildcard type argument, are the direct supertypes of C<X1,...,Xn>,
where

C<X1,...,Xn> is the result of applying capture conversion to C<R1,...,Rn>.

The direct supertypes of an intersection type T1 & ... & Tn, are Ti, 1<=i<=n.

The direct supertypes of a type variable are the types listed in its bound.

The direct supertypes of the null type are all reference types other than the null type itself.

In addition to the above rules, a type variable is a direct supertype of its lower bound.
*/

/*
TypeDecl
ReferenceType : TypeDecl
ClassDecl : ReferenceType
ArrayDecl : ClassDecl
AnonymousDecl : ClassDecl
InterfaceDecl : ReferenceType
PrimitiveType : TypeDecl
NullType : TypeDecl
VoidType : TypeDecl
UnknownType : TypeDecl

GenericClassDecl : ClassDecl
GenericInterfaceDecl : InterfaceDecl
ParClassDecl : ClassDecl
RawClassDecl : ParClassDecl
ParInterfaceDecl : InterfaceDecl
RawInterfaceDecl : ParInterfaceDecl

TypeVariable : ReferenceType

WildcardType : TypeDecl
WildcardExtendsType : WildcardType
WildcardSuperType : WildcardType
*/
  refine TypeAnalysis eq TypeDecl.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq ClassDecl.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq InterfaceDecl.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq ArrayDecl.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq PrimitiveType.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq NullType.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq VoidType.instanceOf(TypeDecl type) = subtype(type);
  refine TypeAnalysis eq UnknownType.instanceOf(TypeDecl type) = subtype(type);
  eq GenericClassDecl.instanceOf(TypeDecl type) = subtype(type);
  eq GenericInterfaceDecl.instanceOf(TypeDecl type) = subtype(type);
  eq ParClassDecl.instanceOf(TypeDecl type) = subtype(type);
  eq RawClassDecl.instanceOf(TypeDecl type) = subtype(type);
  eq ParInterfaceDecl.instanceOf(TypeDecl type) = subtype(type);
  eq RawInterfaceDecl.instanceOf(TypeDecl type) = subtype(type);
  eq TypeVariable.instanceOf(TypeDecl type) = subtype(type);
  eq WildcardType.instanceOf(TypeDecl type) = subtype(type);
  eq WildcardExtendsType.instanceOf(TypeDecl type) = subtype(type);
  eq WildcardSuperType.instanceOf(TypeDecl type) = subtype(type);

  syn boolean TypeDecl.subtype(TypeDecl type) circular [true] =
    type == this;
  eq ClassDecl.subtype(TypeDecl type) = type.supertypeClassDecl(this);
  eq InterfaceDecl.subtype(TypeDecl type) = type.supertypeInterfaceDecl(this);
  eq ArrayDecl.subtype(TypeDecl type) = type.supertypeArrayDecl(this);
  eq PrimitiveType.subtype(TypeDecl type) = type.supertypePrimitiveType(this);
  eq NullType.subtype(TypeDecl type) = type.supertypeNullType(this);
  eq VoidType.subtype(TypeDecl type) = type.supertypeVoidType(this);

  eq UnknownType.subtype(TypeDecl type) = true;
  eq UnknownType.supertypeClassDecl(ClassDecl type) = true;
  eq UnknownType.supertypeInterfaceDecl(InterfaceDecl type) = true;
  eq UnknownType.supertypeArrayDecl(ArrayDecl type) = true;
  eq UnknownType.supertypePrimitiveType(PrimitiveType type) = true;
  eq UnknownType.supertypeNullType(NullType type) = true;
  
  syn boolean TypeDecl.supertypeClassDecl(ClassDecl type) circular [true] = type == this;
  eq ClassDecl.supertypeClassDecl(ClassDecl type) =
    super.supertypeClassDecl(type) || 
    type.hasSuperclass() && type.superclass() != null && type.superclass().subtype(this);

  eq InterfaceDecl.supertypeClassDecl(ClassDecl type) {
    if(super.supertypeClassDecl(type))
      return true;
    for(Iterator iter = type.interfacesIterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)iter.next();
      if(typeDecl.subtype(this))
        return true;
    }
    return type.hasSuperclass() && type.superclass() != null && type.superclass().subtype(this);
  }
  
  syn boolean TypeDecl.supertypeInterfaceDecl(InterfaceDecl type) circular [true] = type == this;
  eq ClassDecl.supertypeInterfaceDecl(InterfaceDecl type) = isObject();
  eq InterfaceDecl.supertypeInterfaceDecl(InterfaceDecl type) {
    if(super.supertypeInterfaceDecl(type))
      return true;
    for(Iterator iter = type.superinterfacesIterator(); iter.hasNext(); ) {
      TypeDecl superinterface = (TypeDecl)iter.next();
      if(superinterface.subtype(this))
        return true;
    }
    return false;
  }

  syn boolean TypeDecl.supertypeArrayDecl(ArrayDecl type) circular [true] = this == type;
  eq ClassDecl.supertypeArrayDecl(ArrayDecl type) {
    if(super.supertypeArrayDecl(type))
      return true;
    return type.hasSuperclass() && type.superclass() != null && type.superclass().subtype(this);
  }
  eq InterfaceDecl.supertypeArrayDecl(ArrayDecl type) {
    if(super.supertypeArrayDecl(type))
      return true;
    for(Iterator iter = type.interfacesIterator(); iter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)iter.next();
      if(typeDecl.subtype(this))
        return true;
    }
    return false;
  }  
  eq ArrayDecl.supertypeArrayDecl(ArrayDecl type) {
    if(type.elementType().isPrimitive() && elementType().isPrimitive())
      return type.dimension() == dimension() && type.elementType() == elementType();
    return type.componentType().subtype(componentType());
  }  

  syn boolean TypeDecl.supertypePrimitiveType(PrimitiveType type) circular [true] = type == this;
  eq PrimitiveType.supertypePrimitiveType(PrimitiveType type) {
    if(super.supertypePrimitiveType(type))
      return true;
    return type.hasSuperclass() && type.superclass().isPrimitive() && type.superclass().subtype(this);
  }
  
  syn boolean TypeDecl.supertypeNullType(NullType type) circular [true] = false;
  eq ReferenceType.supertypeNullType(NullType type) = true;
  eq NullType.supertypeNullType(NullType type) = true;
  
  syn boolean TypeDecl.supertypeVoidType(VoidType type) circular [true] = false;
  eq VoidType.supertypeVoidType(VoidType type) = true;

    


}

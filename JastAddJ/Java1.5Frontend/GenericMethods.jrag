aspect CovariantReturnTypes {
  refine TypeHierarchyCheck eq MethodDecl.mayOverrideReturn(MethodDecl m) = type().instanceOf(m.type());
}

aspect GenericMethods {

  inh lazy GenericMethodDecl ParMethodDecl.genericMethodDecl();
  eq GenericMethodDecl.getParMethodDecl(int i).genericMethodDecl() = this;
  eq Program.getCompilationUnit().genericMethodDecl() = null;
  inh lazy GenericConstructorDecl ParConstructorDecl.genericConstructorDecl();
  eq GenericConstructorDecl.getParConstructorDecl(int i).genericConstructorDecl() = this;
  eq Program.getCompilationUnit().genericConstructorDecl() = null;

  syn lazy MethodDecl GenericMethodDecl.lookupParMethodDecl(ArrayList typeArguments) {
    ParMethodDecl methodDecl = null;
    for(int i = 0; i < getNumParMethodDecl() && methodDecl == null; i++) {
      ParMethodDecl decl = getParMethodDecl(i);
      boolean match = true;
      if(decl.getNumTypeArgument() == typeArguments.size()) {
        for(int j = 0; j < decl.getNumTypeArgument(); j++) {
          if(decl.getTypeArgument(j).type() != typeArguments.get(j))
            match = false;
        }
      }
      else {
        match = false;
      }
      if(match)
        methodDecl = decl;
    }
    if(methodDecl == null) {
      methodDecl = p(typeArguments);
    }
    return methodDecl;
  }

  public ParMethodDecl GenericMethodDecl.p(ArrayList typeArguments) {
    ParMethodDecl methodDecl = new ParMethodDecl();
    addParMethodDecl(methodDecl);
    List list = new List();
    for(int i = 0; i < typeArguments.size(); i++) {
      TypeDecl arg = (TypeDecl)typeArguments.get(i);
      list.add(arg.createBoundAccess());
    }
    methodDecl.setTypeArgumentList(list);
    methodDecl.setTypeParameterList(original().getTypeParameterList().substitute(methodDecl));

    methodDecl.setModifiers((Modifiers)getModifiers().fullCopy());
    methodDecl.setTypeAccess(getTypeAccess().substituteReturnType(methodDecl));
    methodDecl.setID(getID());
    methodDecl.setParameterList(getParameterList().substitute(methodDecl));
    methodDecl.setExceptionList(getExceptionList().substitute(methodDecl));
    return methodDecl;
  }

  public Access Access.substitute(ParMethodDecl parMethodDecl) {
    return type().substitute(parMethodDecl);
  }
  public Access ParameterizedTypeAccess.substitute(ParMethodDecl parMethodDecl) {
    return new ParameterizedTypeAccess(getPackage(), getID(),
      getTypeArgumentList().substitute(parMethodDecl));
  }
  public Access Access.substituteReturnType(ParMethodDecl parMethodDecl) {
    return type().substituteReturnType(parMethodDecl);
  }
  public Access ParameterizedTypeAccess.substituteReturnType(ParMethodDecl parMethodDecl) {
    return new ParameterizedTypeAccess(getPackage(), getID(),
      getTypeArgumentList().substitute(parMethodDecl));
  }
  public Access Access.substituteParameterType(ParMethodDecl parMethodDecl) {
    return type().substituteParameterType(parMethodDecl);
  }
  public Access ParameterizedTypeAccess.substituteParameterType(ParMethodDecl parMethodDecl) {
    return new ParameterizedTypeAccess(getPackage(), getID(),
      getTypeArgumentList().substitute(parMethodDecl));
  }
  public List List.substitute(ParMethodDecl parMethodDecl) {
    List list = new List();
    for(int i = 0; i < getNumChild(); i++) {
      ASTNode node = getChild(i);
      if(node instanceof Access) {
        Access a = (Access)node;
        list.add(a.substitute(parMethodDecl));
      }
      else if(node instanceof VariableArityParameterDeclaration) {
        VariableArityParameterDeclaration p = (VariableArityParameterDeclaration)node;
        list.add(
          new VariableArityParameterDeclaration(
            (Modifiers)p.getModifiers().fullCopy(),
            p.getTypeAccess().substituteParameterType(parMethodDecl),
            p.getID(),
            new List()
          )
        );
      }
      else if(node instanceof ParameterDeclaration) {
        ParameterDeclaration p = (ParameterDeclaration)node;
        list.add(
          new ParameterDeclaration(
            (Modifiers)p.getModifiers().fullCopy(),
            p.getTypeAccess().substituteParameterType(parMethodDecl),
            p.getID()
          )
        );
      }
      else if(node instanceof TypeVariable) {
        TypeVariable tv = (TypeVariable)node;
        list.add(
          new TypeVariable(
            (Modifiers)tv.getModifiers().fullCopy(),
            tv.getID(),
            (List)tv.getBodyDeclList().fullCopy(),
            tv.getTypeBoundList().substitute(parMethodDecl)
          )
        );
      }
      else {
        throw new Error("Can only substitute lists of access nodes but node number " + i + " is of type " + node.getClass().getName());
      }
    }
    return list;
  }
  public Access TypeDecl.substitute(ParMethodDecl parMethodDecl) {
    return createBoundAccess();
  }
  public Access TypeVariable.substitute(ParMethodDecl parMethodDecl) {
    //System.err.println("Searching for substitution for variable " + name());
    TypeDecl typeDecl = this;
    GenericMethodDecl g = parMethodDecl.genericMethodDecl();
    String name = name();// + "'" + g.uniqueMethodIndex();
    for(int i = 0; i < g.getNumTypeParameter(); i++) {
      //System.err.println("TypeParameter candidate " + g.getTypeParameter(i).name());
      TypeDecl typeParameter = g.original().getTypeParameter(i);
      if(typeParameter == typeDecl || typeParameter.name().equals(typeDecl.name())) {
        typeDecl = parMethodDecl.getTypeArgument(i).type();
        return typeDecl.createBoundAccess();
      }
    }
    return typeDecl.createBoundAccess();
  }
  public Access WildcardType.substitute(ParMethodDecl parMethodDecl) {
    return new Wildcard();
  }
  public Access WildcardExtendsType.substitute(ParMethodDecl parMethodDecl) {
    return new WildcardExtends(getAccess().type().substitute(parMethodDecl));
  }
  public Access WildcardSuperType.substitute(ParMethodDecl parMethodDecl) {
    return new WildcardSuper(getAccess().type().substitute(parMethodDecl));
  }
  public Access ArrayDecl.substitute(ParMethodDecl parMethodDecl) {
    Access result = elementType().substitute(parMethodDecl);
    return new ArrayTypeAccess(result, dimension());
  }
  public Access ArrayDecl.substituteReturnType(ParMethodDecl parMethodDecl) {
    return new ArrayTypeAccess(componentType().substituteReturnType(parMethodDecl), 1);
  }
  public Access TypeDecl.substituteReturnType(ParMethodDecl parMethodDecl) {
    return createBoundAccess();
  }
  public Access TypeVariable.substituteReturnType(ParMethodDecl parMethodDecl) {
    TypeDecl typeDecl = this;
    GenericMethodDecl g = parMethodDecl.genericMethodDecl();
    for(int i = 0; i < g.getNumTypeParameter(); i++) {
      TypeDecl typeParameter = g.original().getTypeParameter(i);
      if(typeParameter == typeDecl || typeParameter.name().equals(typeDecl.name())) {
        typeDecl = parMethodDecl.getTypeArgument(i).type();
        if(typeDecl instanceof WildcardType) {
          return typeObject().createBoundAccess();
        }
        else if(typeDecl instanceof WildcardExtendsType) {
          WildcardExtendsType t = (WildcardExtendsType)typeDecl;
          return t.extendsType().createBoundAccess();
        }
        else if(typeDecl instanceof WildcardSuperType) {
          return typeObject().createBoundAccess();
        }
        return typeDecl.createBoundAccess();
      }
    }
    return typeDecl.createBoundAccess();
  }
  public Access TypeDecl.substituteParameterType(ParMethodDecl parMethodDecl) {
    return createBoundAccess();
  }
  public Access TypeVariable.substituteParameterType(ParMethodDecl parMethodDecl) {
    TypeDecl typeDecl = this;
    GenericMethodDecl g = parMethodDecl.genericMethodDecl();
    for(int i = 0; i < g.getNumTypeParameter(); i++) {
      TypeDecl typeParameter = g.original().getTypeParameter(i);
      if(typeParameter == typeDecl || typeParameter.name().equals(typeDecl.name())) {
        typeDecl = parMethodDecl.getTypeArgument(i).type();
        if(typeDecl instanceof WildcardType) {
          return typeNull().createBoundAccess();
        }
        else if(typeDecl instanceof WildcardExtendsType) {
          WildcardExtendsType t = (WildcardExtendsType)typeDecl;
          return typeNull().createQualifiedAccess();
        }
        else if(typeDecl instanceof WildcardSuperType) {
          WildcardSuperType t = (WildcardSuperType)typeDecl;
          return t.superType().createBoundAccess();
        }
        return typeDecl.createBoundAccess();
      }
    }
    return typeDecl.createBoundAccess();
  }




  public boolean GenericMethodDecl.compatible(MethodAccess m) {
    if(!name().equals(m.name()))
      return false;
    if(getNumParameter() != m.getNumArg())
      return false;
    if(!accessibleFrom(m.hostType()))
      return false;

    if(m instanceof ParMethodAccess) {
      //System.err.println("Is generic method " + signature() + " compatible with ParMethodAccess?");
      ParMethodAccess p = (ParMethodAccess)m;

      ArrayList typeArguments = new ArrayList();
      for(int i = 0; i < p.getNumTypeArgument(); i++)
        typeArguments.add(p.getTypeArgument(i).type());
      ParMethodDecl decl = (ParMethodDecl)lookupParMethodDecl(typeArguments);

      if(decl.getNumTypeParameter() != p.getNumTypeArgument())
        return false;
      for(int i = 0; i < decl.getNumTypeParameter(); i++) {
        for(int j = 0; j < decl.getTypeParameter(i).getNumTypeBound(); j++) {
          if(!p.getTypeArgument(i).type().instanceOf(decl.getTypeParameter(i).getTypeBound(j).type())) {
            //System.err.println("Type argument " + i + " is of type " + p.getTypeArgument(i).type().fullName() + " which is NOT a subtype of " + decl.getTypeParameter(i).getTypeBound(j).type().fullName());
            return false;
          }
        }
      }
      return decl.compatible(m);
    }
    return true; // Accept all non parameterized accesses to generic methods, these will be rewritten by type parameter inference 
    //return super.compatible(m);
  }

  public boolean ParMethodDecl.compatible(MethodAccess m) {
    //System.err.println("Computing compatible for " + signature());
    if(!name().equals(m.name()))
      return false;
    if(getNumParameter() != m.getNumArg())
      return false;
    for(int i = 0; i < getNumParameter(); i++) {
      if(!m.getArg(i).type().instanceOf(getParameter(i).type())) {
        //System.err.println("Argument " + i + " is of type " + m.getArg(i).type().fullName() + " which is NOT a subtype of " + getParameter(i).type().fullName());
        return false;
      }
      else {
        //System.err.println("Argument " + i + " is of type " + m.getArg(i).type().fullName() + " which is a subtype of " + getParameter(i).type().fullName());
      }
    }
    if(!accessibleFrom(m.hostType()))
      return false;
    return true;

  }


}

aspect TypeCheck {
  // Disable error checking in instantiated generic methods
  public void ParMethodDecl.collectErrors() {
  }
}

aspect GenericMethodsNameAnalysis {
  // Disable rewriting of ParMethodAccess into non paramterized VirtualMethodAccess
  protected boolean ParMethodAccess.isExactMethodAccess() { return false; }

  eq ParMethodAccess.getTypeArgument().nameType() = NameType.TYPE_NAME;
  eq ParMethodAccess.getTypeArgument().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq GenericMethodDecl.getTypeParameter().nameType() = NameType.TYPE_NAME;

  inh SimpleSet GenericMethodDecl.lookupType(String name);
  syn SimpleSet GenericMethodDecl.localLookupType(String name) {
    name = name + "'" + uniqueMethodIndex();
    SimpleSet c = SimpleSet.emptySet;
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(original().getTypeParameter(i).name().equals(name))
        c = c.add(original().getTypeParameter(i));
    }
    return c;
  }
  eq GenericMethodDecl.getTypeParameter().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);
  eq GenericMethodDecl.getTypeAccess().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);
  eq GenericMethodDecl.getParameter().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);
  eq GenericMethodDecl.getException().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);
  eq GenericMethodDecl.getBlock().lookupType(String name) = localLookupType(name).isEmpty() ? lookupType(name) : localLookupType(name);

  eq GenericMethodDecl.declaresType(String name) {
    for(int i = 0; i < getNumTypeParameter(); i++)
      if(original().getTypeParameter(i).name().equals(name))
        return true;
    return false;
  }
  eq GenericMethodDecl.type(String name) {
    for(int i = 0; i < getNumTypeParameter(); i++)
      if(original().getTypeParameter(i).name().equals(name))
        return original().getTypeParameter(i);
    return null;
  }

  inh lazy int GenericMethodDecl.uniqueMethodIndex();
  eq TypeDecl.getBodyDecl(int index).uniqueMethodIndex() = index;

  syn lazy boolean GenericMethodDecl.typeVariablesSuffix() {
    int index = uniqueMethodIndex();
    for(int i = 0; i < getNumTypeParameter(); i++)
      if(!getTypeParameter(i).name().endsWith("'" + index))
        return false;
    return true;
  }

  rewrite GenericMethodDecl {
    when(!typeVariablesSuffix())
    to GenericMethodDecl {
      int index = uniqueMethodIndex();
      for(int i = 0; i < getNumTypeParameter(); i++)
        getTypeParameter(i).setID(getTypeParameter(i).getID() + "'" + index);
      return this;
    }
  }
}

aspect GenericMethodsPrettyPrint {

  public void ParMethodAccess.toString(StringBuffer s) {
    s.append("<");
    for(int i = 0; i < getNumTypeArgument(); i++) {
      if(i != 0) s.append(", ");
      getTypeArgument(i).toString(s);
    }
    s.append(">");
    
    s.append(name());
    //s.append(getDecl().getID());
    s.append("(");
    if(getNumArg() > 0) {
      getArg(0).toString(s);
      for(int i = 1; i < getNumArg(); i++) {
        s.append(", ");
        getArg(i).toString(s);
      }
    }
    s.append(")");
  }

  public void GenericMethodDecl.toString(StringBuffer s) {
    s.append(indent());
    getModifiers().toString(s);
    
    s.append(" <");
    for(int i = 0; i < getNumTypeParameter(); i++) {
      if(i != 0) s.append(", ");
      original().getTypeParameter(i).toString(s);
    }
    s.append("> ");
    
    getTypeAccess().toString(s);
    s.append(" " + getID());
    s.append("(");
    if(getNumParameter() > 0) {
      getParameter(0).toString(s);
      for(int i = 1; i < getNumParameter(); i++) {
        s.append(", ");
        getParameter(i).toString(s);
      }
    }
    s.append(")");
    for(int i = 0; i < getNumEmptyBracket(); i++) {
      s.append("[]");
    }
    if(getNumException() > 0) {
      s.append(" throws ");
      getException(0).toString(s);
      for(int i = 1; i < getNumException(); i++) {
        s.append(", ");
        getException(i).toString(s);
      }
    }
    if(hasBlock()) {
      s.append(" ");
      getBlock().toString(s);
    }
    else {
      s.append(";\n");
    }
  }

}

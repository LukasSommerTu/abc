aspect ConstantPoolNames {

  syn lazy String TypeDecl.typeDescriptor() {
    throw new Error("Can not compute typeDescriptor for " + getClass().getName());
  }
  eq ClassDecl.typeDescriptor() = "L" + constantPoolName() + ";";
  eq InterfaceDecl.typeDescriptor() = "L" + constantPoolName() + ";";
  eq BooleanType.typeDescriptor() = "Z";
  eq    ByteType.typeDescriptor() = "B";
  eq   ShortType.typeDescriptor() = "S";
  eq     IntType.typeDescriptor() = "I";
  eq    LongType.typeDescriptor() = "J";
  eq    CharType.typeDescriptor() = "C";
  eq   FloatType.typeDescriptor() = "F";
  eq  DoubleType.typeDescriptor() = "D";
  eq    VoidType.typeDescriptor() = "V";
  eq   ArrayDecl.typeDescriptor() { 
    StringBuffer dim = new StringBuffer();
    for(int i = 0; i < getDimension(); i++)
      dim.append("[");
    return dim.toString() + elementType().typeDescriptor(); 
  }

  syn lazy String MethodDecl.descName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    for (int i=0; i<getNumParameter(); i++)
      b.append(getParameter(i).type().typeDescriptor());
    b.append(")");
    if(type().isUnknown()) {
      getTypeAccess().dumpTree(2);
      throw new Error("Error generating descName for " + signature() + ", did not expect unknown return type");
    }
    b.append(type().typeDescriptor());
    return b.toString();
  }

  syn lazy String FieldDeclaration.accessorDescName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    if(!isStatic())
      b.append(hostType().typeDescriptor());
    b.append(")");
    b.append(type().typeDescriptor());
    return b.toString();
  }
  
  syn lazy String FieldDeclaration.accessorWriteDescName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    if(!isStatic())
      b.append(hostType().typeDescriptor());
    b.append(type().typeDescriptor());
    b.append(")V");
    return b.toString();
  }
  
  syn lazy String MethodDecl.accessorDescName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    if(!isStatic())
      b.append(hostType().typeDescriptor());
    for (int i=0; i<getNumParameter(); i++)
      b.append(getParameter(i).type().typeDescriptor());
    b.append(")");
    b.append(type().typeDescriptor());
    return b.toString();
  }

  syn lazy String ConstructorDecl.descName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    // this$0
    TypeDecl typeDecl = hostType();
    if(typeDecl.needsEnclosing())
      b.append(typeDecl.enclosingType().typeDescriptor());
    if(typeDecl.needsSuperEnclosing()) {
      TypeDecl superClass = ((ClassDecl)typeDecl).superclass();
      b.append(superClass.enclosingType().typeDescriptor());
    }
    // args
    for (int i=0; i<getNumParameter(); i++)
      b.append(getParameter(i).type().typeDescriptor());
    // this$val
    for(Iterator iter = typeDecl.enclosingVariables().iterator(); iter.hasNext(); )
      b.append(((Variable)iter.next()).type().typeDescriptor());
    b.append(")V");
    return b.toString();
  }

  syn lazy String ConstructorDecl.accessorDescName() {
    StringBuffer b = new StringBuffer();
    b.append("(");
    // this$0
    TypeDecl typeDecl = hostType();
    if(typeDecl.needsEnclosing())
      b.append(typeDecl.enclosingType().typeDescriptor());
    if(typeDecl.needsSuperEnclosing()) {
      TypeDecl superClass = ((ClassDecl)typeDecl).superclass();
      b.append(superClass.enclosingType().typeDescriptor());
    }
    // args
    for (int i=0; i<getNumParameter(); i++)
      b.append(getParameter(i).type().typeDescriptor());
    // this$val
    for(Iterator iter = typeDecl.enclosingVariables().iterator(); iter.hasNext(); )
      b.append(((Variable)iter.next()).type().typeDescriptor());
    // anonymous class to handle private constructors
    b.append(anonymousJavaName);
    b.append(")");
    b.append("V");
    return b.toString();
  }


  inh lazy String TypeDecl.destinationPath();
  eq CompilationUnit.getTypeDecl(int index).destinationPath() = destinationPath();
  eq CompilationUnit.getImportDecl(int index).destinationPath() = destinationPath();

  syn lazy String CompilationUnit.destinationPath() {
    if(Program.hasValueForOption("-d")) {
      return Program.getValueForOption("-d");
    }
    else {
      if(fromSource()) {
        String sourceName = relativeName();         // ex AST/Defines_AST_hello
        // extract source path including package directories
        String sourcePath = null;
        if(sourceName.lastIndexOf(java.io.File.separator) == -1)
          sourcePath = ".";
        else
          sourcePath = sourceName.substring(0, sourceName.lastIndexOf(java.io.File.separator));
        //System.err.println("SourcePath: " + sourcePath);
        String[] parts = packageName().split("\\.");
        int k = parts.length - 1;
        while(k >= 0 && !sourcePath.endsWith(parts[k])) {
          //System.err.println(sourcePath + " does not end with " + parts[k]);
          k--;
        }
        if(k >= 0) {
          for(int i = k; i >= 0; i--) {
            sourcePath = sourcePath.substring(0, sourcePath.lastIndexOf(parts[i]));
            //System.err.println("new candidate is " + sourcePath);
          }
        }
        if(sourcePath.equals(""))
          sourcePath = ".";
        //System.err.println("SourcePath after: " + sourcePath);
        return sourcePath;
        /*
        // extract first part of package name
        String prefix;
        int pos = packageName().indexOf('.');       // AST
        if(pos != -1)
          prefix = packageName().substring(0, pos-1);
        else
          prefix = packageName();
        // add separator
        prefix = prefix + java.io.File.separator;
        // find last occurance
        pos = sourceName.lastIndexOf(prefix);
        if(pos > 0 && !packageName().equals(""))
          return sourceName.substring(0, pos-1);
        */
      }
      if(pathName != null)
        return pathName;
      else
        return ".";
    }
  }
}

aspect Java2Transformations {
  // generic traversal of the tree
  public void ASTNode.java2Transformation() {
    for(int i = 0; i < getNumChild(); i++) {
        getChild(i).java2Transformation();
    }
  }
  
  public void CompilationUnit.java2Transformation() {
    for(int i = 0; i < getNumTypeDecl(); i++) {
      getTypeDecl(i).java2Transformation();
    }
  }
  
  public void TypeDecl.java2Transformation() {
    super.java2Transformation();
    if(isNestedType())
      enclosingType().addNestedType(this);
  }

  public void TypeAccess.java2Transformation() {
    super.java2Transformation();
    if(type().isNestedType())
      hostType().addUsedNestedType(type());
  }
  
  public void MethodAccess.java2Transformation() {
    MethodDecl m = decl();
    
    if(m.isPrivate() && !hostType().hasMethod(name())) {
      addPrivateMethodAccessor();
      return;
    }
    else if(!m.isStatic() && isQualified() && prevExpr().isSuperAccess() && !hostType().instanceOf(prevExpr().type())) {
      superAccessorTarget().createSuperAccessor(m);
    }
    super.java2Transformation();
  }

  public void VarAccess.java2Transformation() {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      if(f.isPrivate() && !hostType().hasField(v.name())) {
        f.accessorIndex();
        f.accessorWriteIndex();
      }
    }
    super.java2Transformation();
  }

  public void ClassInstanceExpr.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && type() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void ConstructorAccess.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void SuperConstructorAccess.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void ClassAccess.java2Transformation() {
    super.java2Transformation();
    // touch static class method before any accessors to make it first in method
    if(isQualified() && qualifier().type().isReferenceType()) {
      hostType().createStaticClassMethod();
      FieldDeclaration f = hostType().createStaticClassField(prevExpr().type().referenceClassFieldName());
    }
    
  }
  
  // imperative transformation of the AST
  // syntax ASTNode.replace(sourcenode).with(destnode)
  // 
  protected static ASTNode ASTNode.replace(ASTNode node) {
    replacePos = node.getParent().getIndexOfChild(node);
    return node.getParent();
  }
  protected ASTNode ASTNode.with(ASTNode node) {
   setChild(node, replacePos);
   return node;
  }
  private static int ASTNode.replacePos = 0;
}

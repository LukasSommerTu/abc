aspect Java2Transformations {
  public void Program.java2Transformation(int length) {
    for(int i = 0; i < length; i++)
      getCompilationUnit(i).java2Transformation();
  }

  public void CompilationUnit.java2Transformation() {
    for(int i = 0; i < getNumTypeDecl(); i++) {
      getTypeDecl(i).java2Transformation();
    }
  }
  
  public void TypeDecl.java2Transformation() {
    if(nestedTypes() != null) {
      for(Iterator iter = nestedTypes().iterator(); iter.hasNext(); ) {
        TypeDecl typeDecl = (TypeDecl)iter.next();
        typeDecl.java2Transformation();
      }
    }
    super.java2Transformation();
  }

  // generic traversal of the tree but stop when a nested type is found
  public void ASTNode.java2Transformation() {
    for(int i = 0; i < getNumChild(); i++) {
      ASTNode node = getChild(i);
      if(!(node instanceof TypeDecl))
        getChild(i).java2Transformation();
    }
  }

  public void TypeAccess.java2Transformation() {
    super.java2Transformation();
    if(type().isNestedType())
      hostType().addUsedNestedType(type());
  }
  
  public void VarAccess.java2Transformation() {
    super.java2Transformation();
    Variable v = decl();
    if(!v.isInstanceVariable() && !v.isClassVariable() && v.hostType() != hostType()) {
      hostType().addUsedEnclosingVariable(v);
    }
  }

  public void MethodAccess.java2Transformation() {
    MethodDecl m = decl();
    
    if(m.isPrivate() && !hostType().hasMethod(name())) {
      addPrivateMethodAccessor();
      return;
    }
    else if(!m.isStatic() && isQualified() && prevExpr().isSuperAccess() && !hostType().instanceOf(prevExpr().type())) {
      superAccessorTarget().createSuperAccessor(m);
    }
    super.java2Transformation();
  }

  public void ClassInstanceExpr.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && type() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void ConstructorAccess.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void SuperConstructorAccess.java2Transformation() {
    super.java2Transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  public void ClassAccess.java2Transformation() {
    super.java2Transformation();
    // touch static class method before any accessors to make it first in method
    if(isQualified() && qualifier().type().isReferenceType()) {
      hostType().createStaticClassMethod();
      FieldDeclaration f = hostType().createStaticClassField(prevExpr().type().referenceClassFieldName());
    }
    
  }
  
  // imperative transformation of the AST
  // syntax ASTNode.replace(sourcenode).with(destnode)
  // 
  protected static ASTNode ASTNode.replace(ASTNode node) {
    replacePos = node.getParent().getIndexOfChild(node);
    return node.getParent();
  }
  protected ASTNode ASTNode.with(ASTNode node) {
   setChild(node, replacePos);
   return node;
  }
  private static int ASTNode.replacePos = 0;




  
}

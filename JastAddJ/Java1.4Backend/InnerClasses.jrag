aspect InnerClasses {
  int TypeDecl.constantPoolNameIndex = 1;

  syn lazy String TypeDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + name();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + name();
      }
      return prefix + "$" + name();
    }
  }

  syn lazy String ArrayDecl.constantPoolName() = typeDescriptor();

  syn lazy Collection TypeDecl.enclosingVariables() {
    HashSet set = new HashSet();
    for(TypeDecl e = this; e != null; e = e.enclosingType()) {
      if(e.isLocalClass() || e.isAnonymous()) {
        collectEnclosingVariables(set, e.enclosingType());
      }
    }
    if(isClassDecl()) {
      ClassDecl classDecl = (ClassDecl)this;
      if(classDecl.isNestedType() && classDecl.hasSuperclass())
        set.addAll(classDecl.superclass().enclosingVariables());
    }
    return set;
  }

  public void ASTNode.collectEnclosingVariables(HashSet set, TypeDecl typeDecl) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectEnclosingVariables(set, typeDecl);
  }
  public void VarAccess.collectEnclosingVariables(HashSet set, TypeDecl typeDecl) {
    Variable v = decl();
    if(!v.isInstanceVariable() && !v.isClassVariable() && v.hostType() == typeDecl) {
      //if(Program.verbose()) {
      //  System.out.println("Local variable " + v.name() + " in " + v.hostType().fullName() + " is used from " + hostType().fullName());
      //}
      set.add(v);
    }
    super.collectEnclosingVariables(set, typeDecl);
  }


  public int TypeDecl.accessorCounter = 0;

  syn boolean FieldDeclaration.needsAccessor() = accessorIndex != -1;
  syn lazy int FieldDeclaration.accessorIndex() = accessorIndex = hostType().accessorCounter++;
  private int FieldDeclaration.accessorIndex = -1;
  syn boolean FieldDeclaration.needsAccessorWrite() = accessorWriteIndex != -1;
  syn lazy int FieldDeclaration.accessorWriteIndex() = accessorWriteIndex = hostType().accessorCounter++;
  private int FieldDeclaration.accessorWriteIndex = -1;

  syn boolean MethodDecl.needsAccessor() = accessorIndex != -1;
  syn lazy int MethodDecl.accessorIndex() = accessorIndex = hostType().accessorCounter++;
  private int MethodDecl.accessorIndex = -1;

  syn boolean ConstructorDecl.needsAccessor() = accessorIndex != -1;
  private String ConstructorDecl.anonymousJavaName;

  private boolean ConstructorDecl.accessorIndexVisited = false;
  syn lazy int ConstructorDecl.accessorIndex() {
    // rework treebuilding, final
    if(accessorIndexVisited)
      return accessorIndex;
    accessorIndexVisited = true;

    ClassDecl classDecl =
      new ClassDecl(
          new Modifiers(new List().add(new Modifier("synthetic"))),
          new IdDecl("Dummy"),
          new Opt(),
          new List(),
          new List()
          );
    getBlock().addStmt(new LocalClassDeclStmt(classDecl)); 
    LocalClassDeclStmt stmt = (LocalClassDeclStmt)getBlock().getStmt(getBlock().getNumStmt()-1);
    classDecl = stmt.getClassDecl();
    classDecl.toString(new StringBuffer());

    accessorIndex = hostType().accessorCounter++;
    anonymousJavaName = classDecl.typeDescriptor();
    classDecl.generateClassfile();
    return accessorIndex;
  }
  private int ConstructorDecl.accessorIndex = -1;

  public int TypeDecl.numAccessorMethods(Collection c) {
    int num = 0;
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      Object o = iter.next();
      if(o instanceof MethodDecl) {
        MethodDecl m = (MethodDecl)o;
        if(m.needsAccessor())
          num++;
      }
      else if(o instanceof ConstructorDecl) {
        ConstructorDecl m = (ConstructorDecl)o;
        if(m.needsAccessor())
          num++;
      }
    }
    return num;
  }

  public int TypeDecl.numAccessorFields(Collection c) {
    int num = 0;
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      Object o = iter.next();
      if(o instanceof FieldDeclaration) {
        FieldDeclaration f = (FieldDeclaration)o;
        if(f.needsAccessor())
          num++;
        if(f.needsAccessorWrite())
          num++;
      }
    }
    return num;
  }

  public void FieldDeclaration.emitAccessor(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(Modifiers.ACC_STATIC);
    out.writeChar(cp.addUtf8("access$" + accessorIndex()));
    out.writeChar(cp.addUtf8(accessorDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }
  public void FieldDeclaration.emitAccessorWrite(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(Modifiers.ACC_STATIC);
    out.writeChar(cp.addUtf8("access$" + accessorWriteIndex()));
    out.writeChar(cp.addUtf8(accessorWriteDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorWriteAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }

  public ArrayList FieldDeclaration.accessorAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    if(!isStatic())
      gen.emitLoadReference(index++);
    emitLoadField(gen, hostType());
    type().emitReturn(gen);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  public ArrayList FieldDeclaration.accessorWriteAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    if(!isStatic())
      gen.emitLoadReference(index++);
    type().emitLoadLocal(gen, index);
    emitStoreField(gen, hostType());
    gen.emit(Bytecode.RETURN);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  public void MethodDecl.emitAccessor(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(Modifiers.ACC_STATIC);
    out.writeChar(cp.addUtf8("access$" + accessorIndex()));
    out.writeChar(cp.addUtf8(accessorDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }

  public void ConstructorDecl.emitAccessor(ConstantPool cp, DataOutputStream out) throws java.io.IOException {
    out.writeChar(0);
    out.writeChar(cp.addUtf8("<init>"));
    out.writeChar(cp.addUtf8(accessorDescName()));
    out.writeChar(accessorAttributes().size());
    for(Iterator iter = accessorAttributes().iterator(); iter.hasNext(); ) {
      ((Attribute)iter.next()).emit(out);
    }
  }

  public ArrayList MethodDecl.accessorAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    if(!isStatic())
      gen.emitLoadReference(index++);
    for(int i = 0; i < getNumParameter(); i++) {
      getParameter(i).type().emitLoadLocal(gen, index);
      index += getParameter(i).type().size();
    }
    emitInvokeMethod(gen, hostType());
    type().emitReturn(gen);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }


  syn boolean ConstructorDecl.needsEnclosing() = hostType().needsEnclosing();
  syn boolean ConstructorDecl.needsSuperEnclosing() = hostType().needsSuperEnclosing();
  
  syn boolean TypeDecl.isAnonymousInNonStaticContext() {
    return isAnonymous() && !((ClassInstanceExpr)getParent().getParent()).unqualifiedScope().inStaticContext();
  }
  
  syn boolean TypeDecl.needsEnclosing() {
    if(isAnonymous())
      return isAnonymousInNonStaticContext();
    else if(isLocalClass())
      return !inStaticContext();
    else if(isInnerType())
      return true;
    return false;
  }
  
  syn boolean TypeDecl.needsSuperEnclosing() {
    if(!isAnonymous())
      return false;
    TypeDecl superClass = ((ClassDecl)this).superclass();
    if(superClass.isLocalClass())
      return !superClass.inStaticContext();
    else if(superClass.isInnerType())
      return true;
    return false;
  }

  public ArrayList ConstructorDecl.accessorAttributes() {
    ConstantPool cp = hostType().constantPool();
    ArrayList list = new ArrayList();
    CodeGeneration gen = new CodeGeneration(cp);
    int index = 0;
    gen.emitLoadReference(index++);
    // this$0
    if(hostType().needsEnclosing())
      gen.emitLoadReference(index++);
    if(hostType().needsSuperEnclosing())
      gen.emitLoadReference(index++);

    // args
    for(int i = 0; i < getNumParameter(); i++) {
      getParameter(i).type().emitLoadLocal(gen, index);
      index += getParameter(i).type().size();
    }
    // this$val
    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
      Variable v = (Variable)iter.next();
      v.type().emitLoadLocal(gen, index);
      index += v.type().size();
    }
    gen.maxLocals++; // Increase max locals to include dummy constructor argument for private constructors
    emitInvokeConstructor(gen);
    gen.emit(Bytecode.RETURN);
    CodeAttribute a = new CodeAttribute(gen, null);
    list.add(a);
    list.add(new SyntheticAttribute(cp));
    return list;
  }

  public void ASTNode.collectInnerClasses(HashSet list, ConstantPool c, TypeDecl typeDecl) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectInnerClasses(list, c, typeDecl);
  }

  public void TypeAccess.collectInnerClasses(HashSet list, ConstantPool c, TypeDecl typeDecl) {
    super.collectInnerClasses(list, c, typeDecl);
    TypeDecl decl = type();
    if(decl.isNestedType()) {
      InnerClassesAttribute.Classes classes = new InnerClassesAttribute.Classes();
      classes.inner_class_info_index = c.addClass(decl.constantPoolName());
      classes.outer_class_info_index = !decl.isMemberType() ? 0 : c.addClass(decl.enclosingType().constantPoolName());
      classes.inner_name_index = decl.isAnonymous() ? 0 : c.addUtf8(decl.name());
      classes.inner_class_access_flags = decl.flags();
      if(decl.isInterfaceDecl())
        classes.inner_class_access_flags |= Modifiers.ACC_INTERFACE;
      list.add(classes);
    }
  }
  
  public void TypeDecl.collectInnerClasses(HashSet list, ConstantPool c, TypeDecl typeDecl) {
    if(isNestedType() && (typeDecl == this || typeDecl == enclosingType())) {
      InnerClassesAttribute.Classes classes = new InnerClassesAttribute.Classes();
      classes.inner_class_info_index = c.addClass(constantPoolName());
      classes.outer_class_info_index = !typeDecl.isMemberType() ? 0 : c.addClass(enclosingType().constantPoolName());
      classes.inner_name_index = isAnonymous() ? 0 : c.addUtf8(name());
      classes.inner_class_access_flags = flags();
      if(isInterfaceDecl())
        classes.inner_class_access_flags |= Modifiers.ACC_INTERFACE;
      list.add(classes);
    }
    if(typeDecl == this)
      super.collectInnerClasses(list, c, typeDecl);
  }



    public void MethodDecl.emitInvokeMethodAccessor(CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String      desc = accessorDescName();
    String      name = "access$" + accessorIndex();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int indexHi = index >> 8;
    int indexLo = index & 0xff;
    int size = type().size();
    if(!isStatic())
      size--;
    for(int i = 0; i < getNumParameter(); i++)
      size -= getParameter(i).type().size();
    gen.emit(Bytecode.INVOKESTATIC, size);
    gen.add(indexHi).add(indexLo);
  }

  public void ConstructorDecl.emitInvokeConstructorAccessor(CodeGeneration gen) {
    int size = -2; // take this and null (reference to anonymous class)
    for(int i = 0; i < getNumParameter(); i++)
      size -= getParameter(i).type().size();
    if(hostType().needsEnclosing())
      size--;
    if(hostType().needsSuperEnclosing())
      size--;
    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
      Variable v = (Variable)iter.next();
      size -= v.type().size();
    }
    gen.emit(Bytecode.INVOKESPECIAL, size);
    String classname = hostType().constantPoolName();
    String      desc = accessorDescName();
    String      name = "<init>";
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int indexHi = index >> 8;
    int indexLo = index & 0xff;
    gen.add(indexHi).add(indexLo);
  }
  public void FieldDeclaration.emitInvokeFieldAccessor(CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String      desc = accessorDescName();
    String      name = "access$" + accessorIndex();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int indexHi = index >> 8;
    int indexLo = index & 0xff;
    int size = type().size();
    if(!isStatic())
      size--;
    gen.emit(Bytecode.INVOKESTATIC, size);
    gen.add(indexHi).add(indexLo);
  }
  public void FieldDeclaration.emitInvokeFieldAccessorWrite(CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String      desc = accessorWriteDescName();
    String      name = "access$" + accessorWriteIndex();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int indexHi = index >> 8;
    int indexLo = index & 0xff;
    int size = 0;
    if(!isStatic())
      size--;
    size -= type().size();
    gen.emit(Bytecode.INVOKESTATIC, size);
    gen.add(indexHi).add(indexLo);
  }

}

aspect Transformations {
  // generic traversal of the tree
  public void ASTNode.transformation() {
    for(int i = 0; i < getNumChild(); i++) {
        getChild(i).transformation();
    }
  }
  
  public void CompilationUnit.transformation() {
    if(fromSource()) {
      for(int i = 0; i < getNumTypeDecl(); i++) {
        getTypeDecl(i).transformation();
      }
    }
  }
  
  // remote collection
  public void TypeDecl.transformation() {
    super.transformation();
    if(isNestedType())
      enclosingType().addNestedType(this);
  }

  /*
  public void Expr.transformation() {
    if(isConstant() && !(this instanceof Literal))
      replace(this).with(constant().buildLiteral());
    else
      super.transformation();
  }
  */

  // remote collection
  public void TypeAccess.transformation() {
    super.transformation();
    if(type().elementType().isNestedType())
      hostType().addUsedNestedType(type().elementType());
  }
  
  /*
  public void Dot.transformation() {
    if(leftSide().isTypeAccess() && rightSide() instanceof ThisAccess) {
      System.out.println("Replacing " + this);
      Access a = new ThisAccess("this");
      TypeDecl targetType = rightSide().type();
      TypeDecl typeDecl = hostType();
      while(typeDecl != null && typeDecl != targetType) {
        a = a.qualifiesAccess(new VarAccess("this$0"));
        typeDecl = typeDecl.enclosingType();
      }
      ASTNode result = replace(this).with(qualifyTailWith(a));
      result.transformation();
      return;
    }
    super.transformation();
  }*/

  // remote collection / demand driven creation of accessor
  public void MethodAccess.transformation() {
    MethodDecl m = decl();


    /*if(!isQualified() && !m.isStatic()) {
      TypeDecl typeDecl = hostType();
      while(typeDecl != null && !typeDecl.hasMethod(name()))
        typeDecl = typeDecl.enclosingType();
      ASTNode result = replace(this).with(typeDecl.createQualifiedAccess().qualifiesAccess(new ThisAccess("this")).qualifiesAccess(new MethodAccess(name(), getArgList())));
      result.transformation();
      return;
    }*/
    
    if(m.isPrivate() && m.hostType() != hostType()/*.hasMethod(name()*/) {
      /* Access to private methods in enclosing types:
      The original MethodAccess is replaced with an access to an accessor method
      built by createAccessor(). This method is built lazily and differs from
      normal MethodDeclarations in the following ways:
      1) The method in the class file should always be static and the signature
         is thus changed to include a possible this reference as the first argument. 
      2) The method is always invoked using INVOKESTATIC
      3) The flags must indicate that the method is static and package private
      */
      ASTNode result = replace(this).with(decl().createAccessor().createBoundAccess(getArgList()));
      //result.transformation();
      return;
    }
    else if(!m.isStatic() && isQualified() && prevExpr().isSuperAccess() && !hostType().instanceOf(prevExpr().type())) {
      superAccessorTarget().createSuperAccessor(m);
    }
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void VarAccess.transformation() {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      if(f.isPrivate() && !hostType().hasField(v.name())) {
        f.accessorIndex();
        f.accessorWriteIndex();
      }
    }
    super.transformation();
  }

  // remote collection / demand driven creation of accessor
  public void ClassInstanceExpr.transformation() {
    super.transformation();
    // touch accessorIndex to force creation of private constructorAccessor
    if(decl().isPrivate() && type() != hostType()) {
      decl().accessorIndex();
    }
  }

  // remote collection / demand driven creation of accessor
  public void ConstructorAccess.transformation() {
    super.transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  // remote collection / demand driven creation of accessor
  public void SuperConstructorAccess.transformation() {
    super.transformation();
    // touch accessorIndex go force creation of private constructorAccessor
    if(decl().isPrivate() && decl().hostType() != hostType()) {
      decl().accessorIndex();
    }
  }

  // remote collection / demand driven creation of accessor
  public void ClassAccess.transformation() {
    super.transformation();
    // touch static class method before any accessors to make it first in method
    if(isQualified() && qualifier().type().isReferenceType()) {
      hostType().createStaticClassMethod();
      FieldDeclaration f = hostType().createStaticClassField(prevExpr().type().referenceClassFieldName());
    }
    
  }

  public void AssertStmt.transformation() {
    super.transformation();
    // add field to hold cached result as a side-effect
    FieldDeclaration f = hostType().createStaticClassField(hostType().referenceClassFieldName());
    FieldDeclaration assertionsDisabled = hostType().createAssertionsDisabled();
    Expr condition = getfirst();
    List args = new List();
    if(hasExpr())
      args.add(getExpr());
    Stmt stmt = 
      new IfStmt(
        new LogNotExpr(
          new ParExpr(
            new OrLogicalExpr(
              new BoundFieldAccess(assertionsDisabled),
              condition
            )
          )
        ),
        new ThrowStmt(
          new ClassInstanceExpr(
            lookupType("java.lang", "AssertionError").createQualifiedAccess(),
            args,
            new Opt()
          )
        ),
        new Opt()
      );
     
    replace(this).with(stmt);
    stmt.transformation();
  }
  
  // imperative transformation of the AST
  // syntax ASTNode.replace(sourcenode).with(destnode)
  // 
  protected static ASTNode ASTNode.replace(ASTNode node) {
    replacePos = node.getParent().getIndexOfChild(node);
    return node.getParent();
  }
  protected ASTNode ASTNode.with(ASTNode node) {
   setChild(node, replacePos);
   return node;
  }
  private static int ASTNode.replacePos = 0;
}

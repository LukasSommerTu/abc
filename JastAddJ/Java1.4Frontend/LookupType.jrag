import java.util.*;
import java.util.zip.*;
import java.io.*;

aspect SpecialClasses {
  syn lazy TypeDecl Program.typeObject() = lookupType("java.lang", "Object");
  syn lazy TypeDecl Program.typeCloneable() = lookupType("java.lang", "Cloneable");
  syn lazy TypeDecl Program.typeSerializable() = lookupType("java.io", "Serializable");
  eq Program.getCompilationUnit().typeObject() = typeObject();
  eq Program.getCompilationUnit().typeCloneable() = typeCloneable();
  eq Program.getCompilationUnit().typeSerializable() = typeSerializable();
 
  syn lazy TypeDecl Program.typeString() = lookupType("java.lang", "String");
  eq Program.getCompilationUnit().typeString() = typeString();
  syn lazy TypeDecl Program.typeBoolean() = lookupType("primitive", "boolean");
  eq Program.getCompilationUnit().typeBoolean() = typeBoolean();
  syn lazy TypeDecl Program.typeVoid() = lookupType("primitive", "void");
  eq Program.getCompilationUnit().typeVoid() = typeVoid();
  syn lazy TypeDecl Program.typeInt() = lookupType("primitive" , "int");
  eq Program.getCompilationUnit().typeInt() = typeInt();
  syn lazy TypeDecl Program.typeLong() = lookupType("primitive" , "long");
  eq Program.getCompilationUnit().typeLong() = typeLong();
  
  inh TypeDecl Expr.typeString();
  inh TypeDecl Expr.typeBoolean();
  inh TypeDecl Expr.typeVoid();
  inh TypeDecl Expr.typeInt();
  inh lazy TypeDecl SwitchStmt.typeInt();
  inh TypeDecl TypeDecl.typeInt();
  inh TypeDecl Expr.typeLong();
  inh lazy TypeDecl SwitchStmt.typeLong();
  
  inh lazy TypeDecl TypeDecl.typeObject();

  inh lazy TypeDecl ThrowStmt.typeThrowable();
  inh lazy TypeDecl CatchClause.typeThrowable();
  
 
  eq Program.getCompilationUnit().typeNull() = lookupType("primitive", "null");
  inh lazy TypeDecl ThrowStmt.typeNull();
}

aspect LookupFullyQualifiedTypes {
  syn lazy boolean Program.hasPackage(String packageName) {
    return ClassFile.isPackage(packageName);
  }
  // The scope of a declaration of an observable top level package is all observable compilation units
  eq Program.getCompilationUnit().hasPackage(String packageName) = hasPackage(packageName);
  eq AbstractDot.getRight().hasPackage(String packageName) = getLeft().hasQualifiedPackage(packageName);
  syn boolean Expr.hasQualifiedPackage(String packageName) = false;
  eq PackageAccess.hasQualifiedPackage(String packageName) =
    hasPackage(packageName() + "." + packageName);
  inh boolean Expr.hasPackage(String packageName);
  eq MethodAccess.getArg().hasPackage(String packageName) = unqualifiedScope().hasPackage(packageName);
  eq ConstructorAccess.getArg().hasPackage(String packageName) = unqualifiedScope().hasPackage(packageName);
  eq SuperConstructorAccess.getArg().hasPackage(String packageName) = unqualifiedScope().hasPackage(packageName);
  eq ArrayAccess.getExpr().hasPackage(String packageName) = unqualifiedScope().hasPackage(packageName);
  eq ClassInstanceExpr.getArg().hasPackage(String packageName) = unqualifiedScope().hasPackage(packageName);

  
  inh TypeDecl Expr.lookupType(String packageName, String typeName);
  inh TypeDecl Stmt.lookupType(String packageName, String typeName);
  inh TypeDecl BodyDecl.lookupType(String packageName, String typeName);
  inh TypeDecl TypeDecl.lookupType(String packageName, String typeName);
  inh TypeDecl CompilationUnit.lookupType(String packageName, String typeName);

  eq Program.getCompilationUnit().lookupType(String packageName, String typeName) = lookupType(packageName, typeName);

  public int Program.classFileReadTime;
  
  syn lazy TypeDecl Program.lookupType(String packageName, String typeName) {
    addPrimitiveTypes();
    String fullName = packageName.equals("") ? typeName : packageName + "." + typeName;
    for(int i = 0; i < getNumCompilationUnit(); i++) {
      for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++) {
        TypeDecl type = getCompilationUnit(i).getTypeDecl(j);
        if(type.fullName().equals(fullName))
          return type;
      }
    }

    long startTime = System.currentTimeMillis();
    ClassFile classFile = new ClassFile(fullName);
    if(classFile.exists()) {
      try {
        CompilationUnit u = classFile.getCompilationUnit();
        addCompilationUnit(u);
        getCompilationUnit(getNumCompilationUnit()-1);
        classFileReadTime += (System.currentTimeMillis() - startTime);
        for(int j = 0; j < u.getNumTypeDecl(); j++) {
          if(u.getTypeDecl(j).name().equals(typeName))
            return u.getTypeDecl(j);
        }
        throw new Error("No type named " + typeName + " in file " + fullName);
      }
      catch (FileNotFoundException e) {
        //System.out.println("Classfile for type: " + fullName  + " not found");
      }
      catch (Exception e) {
        System.err.println("Error loading " + fullName + " on demand");
        e.printStackTrace();
      }
      catch (Error e) {
        System.err.println("Error loading " + fullName + " on demand");
        e.printStackTrace();
      }
    }
    return null;
  }
}

aspect TypeScopePropagation {
  inh TypeDecl Access.unknownType();

  syn lazy SimpleSet TypeAccess.decls() {
    if(packageName().equals(""))
      return lookupType(name());
    else {
      TypeDecl typeDecl = lookupType(packageName(), name());
      if(typeDecl != null)
        return SimpleSet.emptySet.add(typeDecl);
      return SimpleSet.emptySet;
    }
  }
  
  syn lazy TypeDecl TypeAccess.decl() {
    SimpleSet decls = decls();
    if(decls.size() == 1) {
      return (TypeDecl)decls.iterator().next();
    }
    return unknownType();
  }
  
  syn lazy TypeDecl ArrayTypeAccess.decl() {
    TypeDecl typeDecl = getAccess().type();
    for(int i = 0; i < getDimension(); i++)
      typeDecl = typeDecl.arrayType();
    return typeDecl;
  }
  
  syn SimpleSet ThisAccess.decls() = SimpleSet.emptySet;
  syn SimpleSet SuperAccess.decls() = SimpleSet.emptySet;
  syn lazy TypeDecl ThisAccess.decl() = isQualified() ? qualifier().type() : hostType();
  syn lazy TypeDecl SuperAccess.decl() {
    TypeDecl typeDecl = isQualified() ? qualifier().type() : hostType();
    if(!typeDecl.isClassDecl())
      return illegalType();
    ClassDecl classDecl = (ClassDecl)typeDecl;
    if(!classDecl.hasSuperclass())
      return illegalType();
    return classDecl.superclass();
  }
  
  eq MethodAccess.getArg().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq ConstructorAccess.getArg().lookupType(String name) = unqualifiedScope().lookupType(name);
  eq ArrayAccess.getExpr().lookupType(String name) = unqualifiedScope().lookupType(name);

  inh lazy SimpleSet CompilationUnit.lookupType(String name);
  inh lazy SimpleSet TypeDecl.lookupType(String name);
  inh lazy SimpleSet Block.lookupType(String name);
  inh SimpleSet Expr.lookupType(String name);

  eq Program.getCompilationUnit().lookupType(String name) = SimpleSet.emptySet;
  
  // The scope of a type import declaration is all the class and interface type declarations in
  // the compilation unit in which the import declaration appears.
  eq CompilationUnit.getTypeDecl().lookupType(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for(Iterator iter = localLookupType(name).iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if(t.accessibleFromPackage(packageName()))
        set = set.add(t);
    }
    return set;
  }
    
  eq CompilationUnit.getImportDecl().lookupType(String name) = lookupType(name);
  
  eq TypeDecl.getBodyDecl().lookupType(String name) {
    SimpleSet c = localLookupType(name);
    if(!c.isEmpty())
      return c;

    c = lookupType(name);
    // 8.5.2
    if(isClassDecl() && isStatic() && !isTopLevelType()) {
      SimpleSet newSet = SimpleSet.emptySet;
      for(Iterator iter = c.iterator(); iter.hasNext(); ) {
        TypeDecl d = (TypeDecl)iter.next();
        if(!(!d.isStatic() && d.enclosingType() != null && !instanceOf(d.enclosingType()))) {
          newSet = newSet.add(d);
        }
      }
      c = newSet;
    }
    if(!c.isEmpty())
      return c;
    return SimpleSet.emptySet;
    //return topLevelType().lookupType(name); // Fix to search imports
  }

  eq Block.getStmt(int index).lookupType(String name) {
    SimpleSet c = SimpleSet.emptySet;
    for(int i = 0; i < index; i++) {
      if(getStmt(i) instanceof LocalClassDeclStmt) {
        TypeDecl t = ((LocalClassDeclStmt)getStmt(i)).getClassDecl();
        if(t.name().equals(name)) {
          c = c.add(t);
        }
      }
    }
    if(!c.isEmpty())
      return c;
    return lookupType(name);
  }

  eq ClassInstanceExpr.getAccess().lookupType(String name) {
    SimpleSet c = lookupType(name);
    if(c.size() == 1) {
      if(isQualified())
        c = keepInnerClasses(c);
    }
    return c;
  }
  
  eq ClassInstanceExpr.getTypeDecl().lookupType(String name) {
    //System.err.println("Begin Delegation lookup for " + name + " from " + getTypeDecl().fullName());
    SimpleSet c = localLookupType(name);
    if(!c.isEmpty())
      return c;
    //System.err.println("Continue Delegation lookup from " + getTypeDecl().fullName());
    c = lookupType(name);
    if(!c.isEmpty())
      return c;
    c = unqualifiedScope().lookupType(name);
    //System.err.println("End Delegation lookup from " + getTypeDecl().fullName() + ", found " + c.size() + " types");
    return c;
  }

  public SimpleSet ClassInstanceExpr.keepInnerClasses(SimpleSet c) {
    SimpleSet newSet = SimpleSet.emptySet;
    for(Iterator iter = c.iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if(t.isInnerType() && t.isClassDecl()) {
        newSet = newSet.add(c);
      }
    }
    return newSet;
  }
  
  eq ParseName.qualifiedLookupType(String name) = SimpleSet.emptySet;
  eq PackageOrTypeAccess.qualifiedLookupType(String name) = SimpleSet.emptySet;
  eq AmbiguousAccess.qualifiedLookupType(String name) = SimpleSet.emptySet;

  eq AbstractDot.getRight().lookupType(String name) = getLeft().qualifiedLookupType(name);
  syn SimpleSet Expr.qualifiedLookupType(String name) =
    keepAccessibleTypes(type().remoteLookupType(name));

  eq PackageAccess.qualifiedLookupType(String name) {
    SimpleSet c = SimpleSet.emptySet;
    TypeDecl typeDecl = lookupType(packageName(), name);
    if(nextAccess() instanceof ClassInstanceExpr) {
      if(typeDecl != null && typeDecl.accessibleFrom(hostType()))
        c = c.add(typeDecl);
      return c;
    }
    else {
      if(typeDecl != null) {
        if(hostType() != null && typeDecl.accessibleFrom(hostType()))
          c = c.add(typeDecl);
        else if(hostType() == null && typeDecl.accessibleFromPackage(hostPackage()))
          c = c.add(typeDecl);
      }
      return c;
    }
  }
    
  public SimpleSet Expr.keepAccessibleTypes(SimpleSet oldSet) {
    SimpleSet newSet = SimpleSet.emptySet;
    TypeDecl hostType = hostType();
    for(Iterator iter = oldSet.iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if((hostType != null && t.accessibleFrom(hostType)) || (hostType == null && t.accessibleFromPackage(hostPackage())))
        newSet = newSet.add(t);
    }
    return newSet;
  }

  syn lazy SimpleSet ClassInstanceExpr.localLookupType(String name) {
    if(hasTypeDecl() && getTypeDecl().name().equals(name))
      return SimpleSet.emptySet.add(getTypeDecl());
    return SimpleSet.emptySet;
  }

  syn lazy SimpleSet TypeDecl.remoteLookupType(String name) = localLookupType(name);
  eq ClassDecl.remoteLookupType(String name) {
    // should really include all types (inherited from both superclasses and interfaces) and let the caller remove
    // not visible types using accesableFrom
    SimpleSet c = SimpleSet.emptySet;
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i).declaresType(name)) {
        c = c.add(getBodyDecl(i).type(name));
      }
    }
    if(!c.isEmpty()) return c;
    for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
      TypeDecl type = (TypeDecl)outerIter.next();
      for(Iterator iter = type.types(name).iterator(); iter.hasNext(); ) {
        TypeDecl decl = (TypeDecl)iter.next();
        if(!decl.isPrivate() && decl.accessibleFrom(this))
          c = c.add(decl);
      }
    }
    if(hasSuperclass()) {
      for(Iterator iter = superclass().types(name).iterator(); iter.hasNext(); ) {
        TypeDecl decl = (TypeDecl)iter.next();
        if(!decl.isPrivate() && decl.accessibleFrom(this)) {
          c = c.add(decl);
        }
      }
    }
    if(c.isEmpty() && name().equals(name))
      c = c.add(this);
    return c;
  }

  syn lazy SimpleSet TypeDecl.localLookupType(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for(Iterator iter = types(name).iterator(); iter.hasNext(); ) {
      TypeDecl t = (TypeDecl)iter.next();
      if(t.name().equals(name)) {
        set = set.add(t);
      }
    }
    if(set.isEmpty() && name().equals(name))
      set = set.add(this);
    return set;
  }

  syn boolean TypeDecl.hasType(String name) = !types(name).isEmpty();
  syn boolean BodyDecl.declaresType(String name) = false;
  eq MemberTypeDecl.declaresType(String name) = getTypeDecl().name().equals(name);
  syn TypeDecl BodyDecl.type(String name) = null;
  eq MemberTypeDecl.type(String name) = declaresType(name) ? getTypeDecl() : null;
  
  syn lazy SimpleSet TypeDecl.types(String name) = SimpleSet.emptySet;
  eq ClassDecl.types(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i).declaresType(name)) {
        set = set.add(getBodyDecl(i).type(name));
      }
    }
    if(!set.isEmpty()) return set;
    for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
      TypeDecl type = (TypeDecl)outerIter.next();
      for(Iterator iter = type.types(name).iterator(); iter.hasNext(); ) {
        TypeDecl decl = (TypeDecl)iter.next();
        if(!decl.isPrivate() && decl.accessibleFrom(this))
          set = set.add(decl);
      }
    }
    if(hasSuperclass()) {
      for(Iterator iter = superclass().types(name).iterator(); iter.hasNext(); ) {
        TypeDecl decl = (TypeDecl)iter.next();
        if(!decl.isPrivate() && decl.accessibleFrom(this)) {
          set = set.add(decl);
        }
      }
    }
    return set;
  }

  eq InterfaceDecl.types(String name) {
    SimpleSet set = SimpleSet.emptySet;
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i).declaresType(name)) {
        set = set.add(getBodyDecl(i).type(name));
      }
    }
    if(!set.isEmpty()) return set;
    for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
      TypeDecl typeDecl = (TypeDecl)outerIter.next();
      for(Iterator iter = typeDecl.types(name).iterator(); iter.hasNext(); ) {
        TypeDecl decl = (TypeDecl)iter.next();
        if(!decl.isPrivate())
          set = set.add(decl);
      }
    }
    return set;
  }

  eq PrimitiveType.localLookupType(String name) {
    SimpleSet set = super.localLookupType(name);
    if(set.isEmpty() && hasSuperclass()) {
      if(name.equals("super")) {
        set = set.add(superclass());
      }
      else 
        set = superclass().remoteLookupType(name);
    }
    return set;
  }


  syn lazy SimpleSet CompilationUnit.localLookupType(String name) {
    for(int i = 0; i < getNumTypeDecl(); i++) {
      if(getTypeDecl(i).name().equals(name))
        return SimpleSet.emptySet.add(getTypeDecl(i));
    }
  
    // The scope of a type imported by a single-type-import declaration
    for(int i = 0; i < getNumImportDecl(); i++) {
      if(getImportDecl(i) instanceof SingleTypeImportDecl) {
        SingleTypeImportDecl decl = (SingleTypeImportDecl)getImportDecl(i);
        TypeDecl type = decl.getAccess().type();
        if(type != null && type.name().equals(name))
          return SimpleSet.emptySet.add(type);
      }
    }
    
    TypeDecl result = lookupType(packageName(), name);
    if(result != null)
      return SimpleSet.emptySet.add(result);
    
    // The scope of a type imported by a type-import-on-demand declaration
    SimpleSet c = SimpleSet.emptySet;
    for(int i = 0; i < getNumImportDecl(); i++) {
      ImportDecl decl = getImportDecl(i);
      if(decl instanceof TypeImportOnDemandDecl) {
        if(decl.getAccess() instanceof PackageAccess) {
          PackageAccess pack = (PackageAccess)decl.getAccess();
          StringBuffer s = new StringBuffer();
          s.append(pack.getPackage(0).getID());
          for(int j = 1; j < pack.getNumPackage(); j++)
            s.append("." + pack.getPackage(j).getID());
          result = lookupType(s.toString(), name);
          if(result != null && result.accessibleFromPackage(packageName()) && 
                 result.fullName().equals(pack.packageName() + "." + name)) {
            c = c.add(result);
          }
        }
        else if(decl.getAccess().lastAccess().isTypeAccess()) {
          TypeDecl type = decl.getAccess().lastAccess().type();
          SimpleSet c_temp = type.remoteLookupType(name);
          if(c_temp.size() == 1) {
            result = (TypeDecl)c_temp.iterator().next();
            if(result != null && result.accessibleFromPackage(packageName()) &&
               result.fullName().equals(type.fullName() + "." + name)) {
              c = c.add(result);
            }
          }
        }
        else {
          //System.out.println("@@@@ demand import is not package access");
        }
      }
    }

    result = lookupType("primitive", name);
    if(result != null) {
      c = c.add(result);
      return c;
    }
    
    result = lookupType("java.lang", name);
    if(result != null) {
      c = c.add(result);
      return c;
    }
    return c;
  }

}

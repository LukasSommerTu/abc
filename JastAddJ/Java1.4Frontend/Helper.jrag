import java.util.*;

aspect Names {
  // simple names
  syn String ParseName.name() = getIdUse().getID();
  syn String PackageOrTypeAccess.name() = getIdUse().getID();
  syn String AmbiguousAccess.name() = getIdUse().getID();
  syn String VarAccess.name() = getIdUse().getID();
  syn String MethodAccess.name() = getIdUse().getID();
  syn String ConstructorAccess.name() = "this";
  syn String SuperConstructorAccess.name() = "super";
  syn String TypeAccess.name() = getIdUse().getID();
  
  syn String PackageAccess.name() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumPackage(); i++)
      s.append(getPackage(i).getID() + ".");
    return s.toString();
  }
  
  syn String TypeAccess.packageName() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumPackage(); i++) {
      if(i > 0) s.append(".");
      s.append(getPackage(i).getID());
    }
    return s.toString();
  }
  
  syn String PackageAccess.packageName() {
    StringBuffer s = new StringBuffer();
    if(hasPrevExpr() && prevExpr().isPackageAccess()) {
      s.append(((PackageAccess)prevExpr()).packageName());
      s.append(".");
    }
    for(int i = 0; i < getNumPackage(); i++) {
      if(i > 0) s.append(".");
      s.append(getPackage(i).getID());
    }
    return s.toString();
  }


  // human readable qualified names
  syn String TypeAccess.nameWithPackage() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumPackage(); i++)
      s.append(getPackage(i).getID() + ".");
    s.append(name());
    return s.toString();
  }

  syn String SingleTypeImportDecl.typeName() {
    Access a = getAccess().lastAccess();
    String name = a.isTypeAccess() ? ((TypeAccess)a).nameWithPackage() : "";
    while(a.hasPrevExpr() && a.prevExpr() instanceof Access) {
      Access pred = (Access)a.prevExpr();
      if(pred.isTypeAccess())
        name = ((TypeAccess)pred).nameWithPackage() + "." + name;
      a = pred;
    }
    return name;
  }
  syn String TypeImportOnDemandDecl.typeName() {
    Access a = getAccess().lastAccess();
    String name = a.isTypeAccess() ? ((TypeAccess)a).nameWithPackage() : "";
    while(a.hasPrevExpr() && a.prevExpr() instanceof Access) {
      Access pred = (Access)a.prevExpr();
      if(pred.isTypeAccess())
        name = ((TypeAccess)pred).nameWithPackage() + "." + name;
      a = pred;
    }
    return name;
  }

}

aspect TypeName {
  syn String TypeDecl.name() = getIdDecl().getID();

  syn lazy String TypeDecl.fullName() {
    String packageName = packageName();
    if(packageName.equals(""))
      return name();
    return packageName + "." + name();
  }

  syn lazy String TypeDecl.typeName() {
    String packageName = packageName();
    if(packageName.equals("") || packageName.equals("primitive"))
      return name();
    return packageName + "." + name();
  }
  eq ArrayDecl.typeName() = componentType().typeName() + "[]";

  inh lazy String TypeDecl.packageName();
  eq CompilationUnit.getTypeDecl().packageName() = packageName();
  eq CompilationUnit.getImportDecl().packageName() = packageName();

  eq TypeDecl.getBodyDecl().packageName() = packageName().equals("") ?
    name() : packageName() + "." + name();

  syn lazy String CompilationUnit.packageName() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumPackageDecl(); i++) {
      s.append(getPackageDecl(i).getID());
      if(i + 1 < getNumPackageDecl()) s.append(".");
    }
    return s.toString();
  }
}

aspect SuperClasses {

  public boolean ClassDecl.hasSuperclass() {
    return !isObject();
  }

  public ClassDecl ClassDecl.superclass() {
    if(isObject())
      return null;
    if(hasSuperClassAccess() && !isCircular() && getSuperClassAccess().type().isClassDecl())
      return (ClassDecl)getSuperClassAccess().type();
    return (ClassDecl)typeObject();
  }
  
  public boolean PrimitiveType.hasSuperclass() {
    return !isObject();
  }

  syn TypeDecl PrimitiveType.superclass() = getSuperClassAccess().type();
  

  public Iterator ClassDecl.interfacesIterator() {
    return new Iterator() {
      public boolean hasNext() {
        computeNextCurrent();
        return current != null;
      }
      public Object next() {
        return current;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
      private int index = 0;
      private TypeDecl current = null;
      private void computeNextCurrent() {
        current = null;
        if(isObject() || isCircular())
          return;
        while(index < getNumImplements()) {
          TypeDecl typeDecl = getImplements(index++).type();
          if(!typeDecl.isCircular() && typeDecl.isInterfaceDecl()) {
            current = typeDecl;
            return;
          }
        }
      }
    };
  }
  
  public Iterator InterfaceDecl.superinterfacesIterator() {
    return new Iterator() {
      public boolean hasNext() {
        computeNextCurrent();
        return current != null;
      }
      public Object next() {
        return current;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
      private int index = 0;
      private TypeDecl current = null;
      private void computeNextCurrent() {
        current = null;
        if(isCircular()) return;
        while(index < getNumSuperInterfaceId()) {
          TypeDecl typeDecl = getSuperInterfaceId(index++).type();
          if(!typeDecl.isCircular() && typeDecl.isInterfaceDecl()) {
            current = typeDecl;
            return;
          }
        }
      }
    };
  }
  
}

aspect Circularity {
  inh lazy TypeDecl TypeDecl.unknownType();
  syn lazy boolean TypeDecl.isCircular() circular [true] = false;
  eq ClassDecl.isCircular() {
    if(hasSuperClassAccess()) {
      Access a = getSuperClassAccess().lastAccess();
      while(a != null) {
        if(a.type().isCircular())
          return true;
        a = (a.isQualified() && a.qualifier().isTypeAccess()) ? (TypeAccess)a.qualifier() : null;
      }
    }
    for(int i = 0; i < getNumImplements(); i++) {
      Access a = getImplements(i).lastAccess();
      while(a != null) {
        if(a.type().isCircular())
          return true;
        a = (a.isQualified() && a.qualifier().isTypeAccess()) ? (TypeAccess)a.qualifier() : null;
      }
    }
    return false;
  }
  eq InterfaceDecl.isCircular() {
    for(int i = 0; i < getNumSuperInterfaceId(); i++) {
      Access a = getSuperInterfaceId(i).lastAccess();
      while(a != null) {
        if(a.type().isCircular())
          return true;
        a = (a.isQualified() && a.qualifier().isTypeAccess()) ? (TypeAccess)a.qualifier() : null;
      }
    }
    return false;
  }
}

aspect ImplicitConstructor {
  syn lazy boolean ClassDecl.noConstructor() {
    for(int i = 0; i < getNumBodyDecl(); i++)
      if(getBodyDecl(i) instanceof ConstructorDecl)
        return false;
    return true;
  }
  
  // 8.8.5
  rewrite ConstructorDecl {
    when(!hasConstructorInvocation() && !hostType().isObject())
    to ConstructorDecl {
      setConstructorInvocation(
        new ExprStmt(
          new SuperConstructorAccess(new List(), "super")
          )
        );
      return this;
    }
  }
}

aspect AnonymousClasses {

  eq ParameterDeclaration.getTypeAccess().hostType() = hostType().isAnonymous() ? ((ClassDecl)hostType()).superclass() : hostType();
  
  inh TypeDecl AnonymousDecl.superType();
  eq ClassInstanceExpr.getTypeDecl().superType() = getAccess().type();
  eq Program.getCompilationUnit().superType() = null;

  inh ConstructorDecl AnonymousDecl.constructorDecl();
  eq ClassInstanceExpr.getTypeDecl().constructorDecl() {
    Collection c = getAccess().type().constructors();
    SimpleSet maxSpecific = mostSpecificConstructor(c);
    if(maxSpecific.size() == 1)
      return (ConstructorDecl)maxSpecific.iterator().next();
    return unknownConstructor();
  }
  eq Program.getCompilationUnit().constructorDecl() = null;
  
  public Access TypeDecl.createQualifiedAccess() {
    if(isLocalClass() || isAnonymous()) {
      return new TypeAccess(name());
    }
    else if(!isTopLevelType()) {
      return enclosingType().createQualifiedAccess().qualifiesAccess(new TypeAccess(name()));
    }
    else {
      return new TypeAccess(packageName(), name());
    }
  }

  public Access PrimitiveType.createQualifiedAccess() {
    return new TypeAccess("primitive", name());
  }
  
  protected static int ASTNode.anonymousIndex = 0;

  syn lazy Opt AnonymousDecl.getSuperClassAccessOpt() {
    if(superType().isInterfaceDecl())
      return new Opt(typeObject().createQualifiedAccess());
    else
      return new Opt(superType().createQualifiedAccess());
  }
  syn lazy List AnonymousDecl.getImplementsList() {
    if(superType().isInterfaceDecl())
      return new List().add(superType().createQualifiedAccess());
    else
      return new List();
  }

  rewrite AnonymousDecl {
    when(noConstructor())
    to AnonymousDecl {
      setModifiers(new Modifiers(new List().add(new Modifier("final"))));
      
      ConstructorDecl constructor = (ConstructorDecl)constructorDecl().fullCopy();
      addBodyDecl(constructor);

      String name = "Anonymous" + anonymousIndex++;
      setIdDecl(new IdDecl(name));
      constructor.setIdDecl(new IdDecl(name));

      List parameterList = new List();
      for(int i = 0; i < constructorDecl().getNumParameter(); i++) {
        parameterList.add(
          new ParameterDeclaration(
            constructorDecl().getParameter(i).type().createQualifiedAccess(),
            constructorDecl().getParameter(i).name()
          )
        );
      }
      constructor.setParameterList(parameterList);
      
      List argList = new List();
      for(int i = 0; i < constructor.getNumParameter(); i++)
        argList.add(new VarAccess(constructor.getParameter(i).name()));
      constructor.setConstructorInvocation(
        new ExprStmt(
          new SuperConstructorAccess(argList, "super")
        )
      );
      constructor.setBlock(new Block());

      Set set = new HashSet();
      for(int i = 0; i < getNumBodyDecl(); i++) {
        if(getBodyDecl(i) instanceof InstanceInitializer) {
          InstanceInitializer init = (InstanceInitializer)getBodyDecl(i);
          set.addAll(init.exceptions());
        }
        else if(getBodyDecl(i) instanceof FieldDeclaration) {
          FieldDeclaration f = (FieldDeclaration)getBodyDecl(i);
          if(f.isInstanceVariable()) {
            set.addAll(f.exceptions());
          }
        }
      }
      List exceptionList = new List();
      for(Iterator iter = set.iterator(); iter.hasNext(); ) {
        TypeDecl exceptionType = (TypeDecl)iter.next();
        if(exceptionType.isNull())
          exceptionType = typeNullPointerException();
        exceptionList.add(exceptionType.createQualifiedAccess());
      }
      constructor.setExceptionList(exceptionList);
      return this;
    }
  }
  inh TypeDecl AnonymousDecl.typeNullPointerException();
}

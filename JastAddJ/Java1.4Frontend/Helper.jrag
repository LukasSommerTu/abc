import java.util.*;

aspect TypeName {
  syn String TypeDecl.name() = getIdDecl().getID();

  syn lazy String TypeDecl.fullName() {
    String packageName = packageName();
    if(packageName.equals(""))
      return name();
    return packageName + "." + name();
  }

  inh lazy String TypeDecl.packageName();
  eq CompilationUnit.getTypeDecl().packageName() = packageName();
  eq CompilationUnit.getImportDecl().packageName() = packageName();

  eq TypeDecl.getBodyDecl().packageName() = packageName().equals("") ?
    name() : packageName() + "." + name();

  syn lazy String CompilationUnit.packageName() {
    StringBuffer s = new StringBuffer();
    for(int i = 0; i < getNumPackageDecl(); i++) {
      s.append(getPackageDecl(i).getID());
      if(i + 1 < getNumPackageDecl()) s.append(".");
    }
    return s.toString();
  }
}

aspect SuperClasses {

  public boolean ClassDecl.hasSuperclass() {
    return !isObject();
  }

  public ClassDecl ClassDecl.superclass() {
    if(isObject())
      return null;
    if(hasSuperClassAccess() && !isCircular() && getSuperClassAccess().type().isClassDecl())
      return (ClassDecl)getSuperClassAccess().type();
    return (ClassDecl)typeObject();
  }
  
  public boolean PrimitiveType.hasSuperclass() {
    return !isObject();
  }

  syn TypeDecl PrimitiveType.superclass() = getSuperClassAccess().type();
  

  public Iterator ClassDecl.interfacesIterator() {
    return new Iterator() {
      public boolean hasNext() {
        computeNextCurrent();
        return current != null;
      }
      public Object next() {
        return current;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
      private int index = 0;
      private TypeDecl current = null;
      private void computeNextCurrent() {
        current = null;
        if(isObject())
          return;
        while(index < getNumImplements()) {
          TypeDecl typeDecl = getImplements(index++).type();
          if(!typeDecl.isCircular() && typeDecl.isInterfaceDecl()) {
            current = typeDecl;
            return;
          }
        }
      }
    };
  }
  
  public Iterator InterfaceDecl.superinterfacesIterator() {
    return new Iterator() {
      public boolean hasNext() {
        computeNextCurrent();
        return current != null;
      }
      public Object next() {
        return current;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
      private int index = 0;
      private TypeDecl current = null;
      private void computeNextCurrent() {
        current = null;
        while(index < getNumSuperInterfaceId()) {
          TypeDecl typeDecl = getSuperInterfaceId(index++).type();
          if(!typeDecl.isCircular() && typeDecl.isInterfaceDecl()) {
            current = typeDecl;
            return;
          }
        }
        if(getNumSuperInterfaceId() == 0 && index == 0) {
          current = typeObject();
          index++;
        }
      }
    };
  }
  
}

aspect Circularity {
  inh lazy TypeDecl TypeDecl.illegalType();
  syn lazy boolean TypeDecl.isCircular() circular [true] = false;
  eq ClassDecl.isCircular() {
    return hasSuperClassAccess() && getSuperClassAccess().type().isCircular();
  }
  eq InterfaceDecl.isCircular() {
    for(int i = 0; i < getNumSuperInterfaceId(); i++) {
      TypeDecl typeDecl = getSuperInterfaceId(i).type();
      if(typeDecl.isCircular())
        return true;
    }
    return false;
  }
}

aspect ImplicitConstructor {
  rewrite ClassDecl {
    when(noConstructor())
    to ClassDecl {
      Modifiers m = new Modifiers();
      if(isPublic()) m.addModifier(new Modifier("public"));
      if(isProtected()) m.addModifier(new Modifier("protected"));
      if(isPrivate()) m.addModifier(new Modifier("private"));
      addBodyDecl(
          new ConstructorDecl(
            m,
            new IdDecl(name()),
            new List(),
            new List(),
            new Opt(),
            new Block()
          )
      );
      return this;
    }
  }
  syn lazy boolean ClassDecl.noConstructor() {
    //for(int i = getNumBodyDecl()-1; i >= 0; i--) // Does not work since rewrite adds a list of nodes to the current position. Should use iterators instead
    for(int i = 0; i < getNumBodyDecl(); i++)
      if(getBodyDecl(i) instanceof ConstructorDecl)
        return false;
    return true;
  }
  
  // 8.8.5
  rewrite ConstructorDecl {
    when(!hasConstructorInvocation() && !hostType().isObject())
    to ConstructorDecl {
      setConstructorInvocation(
        new ExprStmt(
        new SuperConstructorAccess(new List(), new IdUse("super"))
        )
      );
      return this;
    }
  }
}

aspect AnonymousClasses {

  eq ParameterDeclaration.getTypeAccess().hostType() = hostType().isAnonymous() ? ((ClassDecl)hostType()).superclass() : hostType();
  
  inh TypeDecl AnonymousDecl.superType();
  eq ClassInstanceExpr.getTypeDecl().superType() = getAccess().type();
  eq Program.getCompilationUnit().superType() = null;

  inh ConstructorDecl AnonymousDecl.constructorDecl();
  eq ClassInstanceExpr.getTypeDecl().constructorDecl() {
    ArrayList list = getAccess().type().lookupConstructor(this);
    if(list.size() == 1)
      return (ConstructorDecl)list.get(0);
    return illegalConstructor();
  }
  eq Program.getCompilationUnit().constructorDecl() = null;
  
  public Access TypeDecl.createQualifiedAccess() {
    if(isLocalClass() || isAnonymous()) {
      return new TypeAccess(new List(), new IdUse(name()));
    }
    else if(!isTopLevelType()) {
      return enclosingType().createQualifiedAccess().qualifiesAccess(new TypeAccess(new List(), new IdUse(name())));
    }
    else {
      String[] strings = fullName().split("\\.");
      List list = new List();
      for(int i = 0; i < strings.length - 1; i++)
        list.add(new IdUse(strings[i]));
      return new TypeAccess(list, new IdUse(strings[strings.length-1]));
    }
  }

  public Access PrimitiveType.createQualifiedAccess() {
    return new TypeAccess(new List().add(new IdUse("primitive")), new IdUse(name()));
  }
  
  protected static int ASTNode.anonymousIndex = 0;

  syn lazy Opt AnonymousDecl.getSuperClassAccessOpt() {
    if(superType().isInterfaceDecl())
      return new Opt(typeObject().createQualifiedAccess());
    else
      return new Opt(superType().createQualifiedAccess());
  }
  syn lazy List AnonymousDecl.getImplementsList() {
    if(superType().isInterfaceDecl())
      return new List().add(superType().createQualifiedAccess());
    else
      return new List();
  }

  rewrite AnonymousDecl {
    //when(!duringResolveAmbiguousNames() && !duringVariableDeclaration() && !duringHelper() && noConstructor())
    when(noConstructor())
    to AnonymousDecl {
      setModifiers(new Modifiers(new List().add(new Modifier("final"))));
      
      ConstructorDecl constructor = (ConstructorDecl)constructorDecl().fullCopy();
      addBodyDecl(constructor);

      getIdDecl().setID("Anonymous" + anonymousIndex++);
      constructor.setIdDecl((IdDecl)getIdDecl().fullCopy());

      List parameterList = new List();
      for(int i = 0; i < constructorDecl().getNumParameter(); i++) {
        parameterList.add(
          new ParameterDeclaration(
            new Modifiers(new List()),
            constructorDecl().getParameter(i).type().createQualifiedAccess(),
            new IdDecl(constructorDecl().getParameter(i).getIdDecl().getID())
          )
        );
      }
      constructor.setParameterList(parameterList);
      
      List argList = new List();
      for(int i = 0; i < constructor.getNumParameter(); i++)
        argList.add(new VarAccess(new IdUse(constructor.getParameter(i).getIdDecl().getID())));
      constructor.setConstructorInvocation(
        new ExprStmt(
          new SuperConstructorAccess(
            argList, new IdUse("super")
          )
        )
      );
      constructor.setBlock(new Block());

      Set set = new HashSet();
      for(int i = 0; i < getNumBodyDecl(); i++) {
        if(getBodyDecl(i) instanceof InstanceInitializer) {
          InstanceInitializer init = (InstanceInitializer)getBodyDecl(i);
          set.addAll(init.exceptions());
        }
        else if(getBodyDecl(i) instanceof FieldDeclaration) {
          FieldDeclaration f = (FieldDeclaration)getBodyDecl(i);
          if(f.isInstanceVariable()) {
            //System.err.println(f.name() + " in anonymous class " + fullName() + " may throw exceptions");
            set.addAll(f.exceptions());
          }
        }
      }
      List exceptionList = new List();
      for(Iterator iter = set.iterator(); iter.hasNext(); ) {
        TypeDecl exceptionType = (TypeDecl)iter.next();
        if(exceptionType.isNull())
          exceptionType = typeNullPointerException();
        exceptionList.add(exceptionType.createQualifiedAccess());
      }
      constructor.setExceptionList(exceptionList);
      return this;
    }
  }
  inh TypeDecl AnonymousDecl.typeNullPointerException();
}

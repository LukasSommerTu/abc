/*
 * Translated to Beaver by CUP2Beaver 2004-07-07.
 */

/* Java 1.5 (JSR-14 + JSR-201) parser for CUP.
 * (Well, Java 1.5 as of 28 Jul 2003; it may change before official release)
 * Copyright (C) 2003 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JSR-201 Features added:
* varargs:
 formal_parameter ::= ...
	|	type ELLIPSIS IDENTIFIER
	|	FINAL type ELLIPSIS IDENTIFIER
	;
* enum:
  enum_declaration ::=
		modifiers_opt ENUM IDENTIFIER interfaces_opt enum_body
	;
  enum_body ::=
		LBRACE enum_constants_opt enum_body_declarations_opt RBRACE
	;
  enum_constants_opt ::=
	|	enum_constants
	;
  enum_constants ::=
		enum_constant
	|	enum_constants COMMA enum_constant
	;
  enum_constant ::=
		IDENTIFIER enum_arguments_opt
	|	IDENTIFIER enum_arguments_opt class_body
	;
  enum_arguments_opt ::=
	|	LPAREN argument_list_opt RPAREN
	;
  enum_body_declarations_opt ::=
	|	SEMICOLON class_body_declarations_opt
	;
*/



%package {parser}
%import {AST.*}
%class {JavaParser}
%embed {
  protected void syntaxError(beaver.core.Token token) {
    super.syntaxError(token);
    throw new RuntimeException(token.getLine() + ", " + token.getColumn() + ": Syntex Error");
  }
}

// These terminals are never used, but must be 
// declared for the scanner to compile
%type {Object} ENUM ASSERT ELLIPSIS GOTO CONST;  

// The following terminals and nonterminals are used in this file
%type {java.lang.String} IDENTIFIER;
%type {java.lang.String} INTEGER_LITERAL;
%type {java.lang.String} LONG_LITERAL;
%type {java.lang.String} FLOATING_POINT_LITERAL;
%type {java.lang.String} DOUBLE_LITERAL;
%type {java.lang.String} BOOLEAN_LITERAL;
%type {java.lang.Character} CHARACTER_LITERAL;
%type {java.lang.String} STRING_LITERAL;
%type {Program} goal;
%type {Expr} literal;
%type {Access} type;
%type {Access} primitive_type;
%type {Access} numeric_type;
%type {Access} integral_type;
%type {Access} floating_point_type;
%type {Access} reference_type;
%type {Access} class_or_interface_type;
%type {Access} class_type;
%type {Access} interface_type;
%type {Access} array_type;
%type {Access} name;
%type {Access} simple_name;
%type {Access} qualified_name;
%type {List} name_decl;
%type {List} simple_name_decl;
%type {List} qualified_name_decl;
%type {CompilationUnit} compilation_unit;
%type {List} package_declaration_opt;
%type {List} package_declaration;
%type {List} import_declarations_opt;
%type {List} import_declarations;
%type {List} type_declarations_opt;
%type {List} type_declarations;
%type {ImportDecl} import_declaration;
%type {ImportDecl} single_type_import_declaration;
%type {ImportDecl} type_import_on_demand_declaration;
%type {TypeDecl} type_declaration;
%type {Modifiers} modifiers_opt;
%type {List} modifiers;
%type {Modifier} modifier;
%type {ClassDecl} class_declaration;
%type {Access} super;
%type {Opt} super_opt;
%type {List} interfaces;
%type {List} interfaces_opt;
%type {List} interface_type_list;
%type {List} class_body;
%type {List} class_body_declarations;
%type {List} class_body_declarations_opt;
%type {BodyDecl} class_body_declaration;
%type {BodyDecl} class_member_declaration;
%type {BodyDecl} field_declaration;
%type {List} variable_declarators;
%type {VariableDecl} variable_declarator;
%type {VariableDecl} variable_declarator_id;
%type {AbstractVarInit} variable_initializer;
%type {MethodDecl} method_declaration;
%type {MethodDecl} method_header;
%type {MethodDecl} method_declarator;
%type {List} formal_parameter_list_opt;
%type {List} formal_parameter_list;
%type {Parameter} formal_parameter;
%type {List} throws_opt;
%type {List} throws;
%type {List} class_type_list;
%type {Opt} method_body;
%type {BodyDecl} static_initializer;
%type {BodyDecl} constructor_declaration;
%type {ConstructorDecl} constructor_declarator;
%type {ConstructorDecl} constructor_body;
%type {Stmt} explicit_constructor_invocation;
%type {Opt} explicit_constructor_invocation_opt;
%type {InterfaceDecl} interface_declaration;
%type {List} extends_interfaces_opt;
%type {List} extends_interfaces;
%type {List} interface_body;
%type {List} interface_member_declarations_opt;
%type {List} interface_member_declarations;
%type {BodyDecl} interface_member_declaration;
%type {BodyDecl} constant_declaration;
%type {BodyDecl} abstract_method_declaration;
%type {ArrayInit} array_initializer;
%type {List} variable_initializers;
%type {Block} block;
%type {List} block_statements_opt;
%type {List} block_statements;
%type {Stmt} block_statement;
%type {VarDeclStmt} local_variable_declaration_statement;
%type {VarDeclStmt} local_variable_declaration;
%type {Stmt} statement;
%type {Stmt} statement_no_short_if;
%type {Stmt} statement_without_trailing_substatement;
%type {EmptyStmt} empty_statement;
%type {LabelStmt} labeled_statement;
%type {LabelStmt} labeled_statement_no_short_if;
%type {ExprStmt} expression_statement;
%type {ExprStmt} statement_expression;
%type {IfStmt} if_then_statement;
%type {IfStmt} if_then_else_statement;
%type {IfStmt} if_then_else_statement_no_short_if;
%type {SwitchStmt} switch_statement;
%type {List} switch_block;
%type {List} switch_block_statement_groups;
%type {List} switch_block_statement_group;
%type {List} switch_labels;
%type {Case} switch_label;
%type {WhileStmt} while_statement;
%type {WhileStmt} while_statement_no_short_if;
%type {DoStmt} do_statement;
%type {ForStmt} for_statement;
%type {ForStmt} for_statement_no_short_if;
%type {List} for_init_opt;
%type {List} for_init;
%type {List} for_update_opt;
%type {List} for_update;
%type {List} statement_expression_list;
%type {Opt} identifier_opt;
%type {BreakStmt} break_statement;
%type {ContinueStmt} continue_statement;
%type {ReturnStmt} return_statement;
%type {ThrowStmt} throw_statement;
%type {SynchronizeStmt} synchronized_statement;
%type {TryStmt} try_statement;
%type {List} catches_opt;
%type {List} catches;
%type {Catch} catch_clause;
%type {Block} finally;
%type {AssertStmt} assert_statement;
%type {Expr} primary;
%type {Expr} primary_no_new_array;
%type {Expr} class_instance_creation_expression;
%type {Opt} subclass_body_opt;
%type {List} argument_list_opt;
%type {List} argument_list;
%type {ArrayInstanceExpr} array_creation_init;
%type {ArrayInstanceExpr} array_creation_uninit;
%type {List} dim_exprs;
%type {Dims} dim_expr;
%type {List} dims_opt;
%type {List} dims;
%type {Expr} field_access;
%type {Expr} method_invocation;
%type {Expr} array_access;
%type {Expr} postfix_expression;
%type {Expr} postincrement_expression;
%type {Expr} postdecrement_expression;
%type {Expr} unary_expression;
%type {Expr} unary_expression_not_plus_minus;
%type {Expr} preincrement_expression;
%type {Expr} predecrement_expression;
%type {Expr} cast_expression;
%type {Expr} multiplicative_expression;
%type {Expr} additive_expression;
%type {Expr} shift_expression;
%type {Expr} relational_expression;
%type {Expr} equality_expression;
%type {Expr} and_expression;
%type {Expr} exclusive_or_expression;
%type {Expr} inclusive_or_expression;
%type {Expr} conditional_and_expression;
%type {Expr} conditional_or_expression;
%type {Expr} conditional_expression;
%type {Expr} assignment_expression;
%type {AssignExpr} assignment;
%type {AssignExpr} assignment_operator;
%type {Opt} expression_opt;
%type {Expr} expression;
%type {Expr} constant_expression;
%type {Access} class_or_interface;
%type {Expr} instanceof_expression;
%type {Expr} postfix_expression_nn;
%type {Expr} unary_expression_nn;
%type {Expr} unary_expression_not_plus_minus_nn;
%type {Expr} multiplicative_expression_nn;
%type {Expr} additive_expression_nn;
%type {Expr} shift_expression_nn;
%type {Expr} relational_expression_nn;
%type {Expr} instanceof_expression_nn;
%type {Expr} equality_expression_nn;
%type {Expr} and_expression_nn;
%type {Expr} exclusive_or_expression_nn;
%type {Expr} inclusive_or_expression_nn;
%type {Expr} conditional_and_expression_nn;
%type {Expr} conditional_or_expression_nn;
%type {Expr} conditional_expression_nn;
%type {Expr} assignment_expression_nn;
%type {Expr} expression_nn;
goal.RESULT =
      compilation_unit.cu {  RESULT = new Program(new List().add(cu));  };
literal.RESULT =
      INTEGER_LITERAL.i {  RESULT = new IntegerLiteral(i);  }
    |  LONG_LITERAL.l {  RESULT = new LongLiteral(l);  }
    |  FLOATING_POINT_LITERAL.f {  RESULT = new FPLiteral(f);  }
    |  DOUBLE_LITERAL.d {  RESULT = new DoubleLiteral(d);  }
    |  BOOLEAN_LITERAL.b {  RESULT = new BooleanLiteral(b);  }
    |  CHARACTER_LITERAL.c {  RESULT = new CharLiteral(c.toString());  }
    |  STRING_LITERAL.s {  RESULT = new StringLiteralExpr(new StringLiteral(s));  }
    |  NULL_LITERAL {  RESULT = new NullLiteral("null");  };
type.RESULT =
      primitive_type.t {  RESULT = t;  }
    |  reference_type.t {  RESULT = t;  };
primitive_type.RESULT =
      numeric_type.t {  RESULT = t;  }
    |  BOOLEAN {  RESULT = new ParseName(new IdUse("boolean"));  };
numeric_type.RESULT =
      integral_type.t {  RESULT = t;  }
    |  floating_point_type.t {  RESULT = t;  };
integral_type.RESULT =
      BYTE {  RESULT = new ParseName(new IdUse("byte"));  }
    |  SHORT {  RESULT = new ParseName(new IdUse("short"));  }
    |  INT {  RESULT = new ParseName(new IdUse("int"));  }
    |  LONG {  RESULT = new ParseName(new IdUse("long"));  }
    |  CHAR {  RESULT = new ParseName(new IdUse("char"));  };
floating_point_type.RESULT =
      FLOAT {  RESULT = new ParseName(new IdUse("float"));  }
    |  DOUBLE {  RESULT = new ParseName(new IdUse("double"));  };
reference_type.RESULT =
      class_or_interface_type.t {  RESULT = t;  }
    |  array_type.t {  RESULT = t;  };
class_or_interface.RESULT =
      name.n {  RESULT = n;  };
class_or_interface_type.RESULT =
      class_or_interface.t {  RESULT = t;  };
class_type.RESULT =
      class_or_interface_type.c {  RESULT = c;  };
interface_type.RESULT =
      class_or_interface_type.c {  RESULT = c;  };
array_type.RESULT =
      primitive_type.t dims.d {  RESULT = new Dot(t, new ArrayTypeName(d));  }
    |  name.n dims.d {  RESULT = new Dot(n, new ArrayTypeName(d));  };
name.RESULT =
      simple_name.s {  RESULT = s;  }
    |  qualified_name.q {  RESULT = q;  };
simple_name.RESULT =
      IDENTIFIER.i {  RESULT = new ParseName(new IdUse(i));  };
qualified_name.RESULT =
      name.n DOT IDENTIFIER.i {  RESULT = new Dot(n, new ParseName(new IdUse(i)));  };
name_decl.RESULT =
      simple_name_decl.s {  RESULT = s;  }
    |  qualified_name_decl.q {  RESULT = q;  };
simple_name_decl.RESULT =
      IDENTIFIER.i {  RESULT = new List().add(new IdDecl(i));  };
qualified_name_decl.RESULT =
      name_decl.n DOT IDENTIFIER.i {  RESULT = n.add(new IdDecl(i));  };
compilation_unit.RESULT =
      package_declaration_opt.p import_declarations_opt.i type_declarations_opt.t {  RESULT = new CompilationUnit(p, i, t);  };
package_declaration_opt.RESULT =
      package_declaration.p {  RESULT = p;  }
    |  {  RESULT = new List();  };
import_declarations_opt.RESULT =
      import_declarations.i {  RESULT = i;  }
    |  {  RESULT = new List();  };
type_declarations_opt.RESULT =
      type_declarations.t {  RESULT = t;  }
    |  {  RESULT = new List();  };
import_declarations.RESULT =
      import_declaration.i {  RESULT = new List().add(i);  }
    |  import_declarations.l import_declaration.i {  RESULT = l.add(i);  };
type_declarations.RESULT =
      type_declaration.t {  RESULT = t != null ? new List().add(t) : new List() ;  }
    |  type_declarations.l type_declaration.t {  RESULT = t != null ? l.add(t) : l;  };
package_declaration.RESULT =
      PACKAGE name_decl.n SEMICOLON {  RESULT = n;  };
import_declaration.RESULT =
      single_type_import_declaration.s {  RESULT = s;  }
    |  type_import_on_demand_declaration.t {  RESULT = t;  };
single_type_import_declaration.RESULT =
      IMPORT name.n SEMICOLON {  RESULT = new SingleTypeImportDecl(n);  };
type_import_on_demand_declaration.RESULT =
      IMPORT name.n DOT MULT SEMICOLON {  RESULT = new TypeImportOnDemandDecl(n);  };
type_declaration.RESULT =
      class_declaration.c {  RESULT = c;  }
    |  interface_declaration.i {  RESULT = i;  }
    |  SEMICOLON {  RESULT = null;  };
modifiers_opt.RESULT =
      {  RESULT = new Modifiers(new List());  }
    |  modifiers.m {  RESULT = new Modifiers(m);  };
modifiers.RESULT =
      modifier.m {  RESULT = new List().add(m);  }
    |  modifiers.l modifier.m {  RESULT = l.add(m);  };
modifier.RESULT =
      PUBLIC {  RESULT = new Modifier("public");  }
    |  PROTECTED {  RESULT = new Modifier("protected");  }
    |  PRIVATE {  RESULT = new Modifier("private");  }
    |  STATIC {  RESULT = new Modifier("static");  }
    |  ABSTRACT {  RESULT = new Modifier("abstract");  }
    |  FINAL {  RESULT = new Modifier("final");  }
    |  NATIVE {  RESULT = new Modifier("native");  }
    |  SYNCHRONIZED {  RESULT = new Modifier("synchronized");  }
    |  TRANSIENT {  RESULT = new Modifier("transient");  }
    |  VOLATILE {  RESULT = new Modifier("volatile");  }
    |  STRICTFP {  RESULT = new Modifier("strictfp");  };
class_declaration.RESULT =
      modifiers_opt.m CLASS IDENTIFIER.id super_opt.s interfaces_opt.i class_body.b {  RESULT = new ClassDecl(m, new IdDecl(id), s, i, b);  };
super.RESULT =
      EXTENDS class_type.c {  RESULT = c;  };
super_opt.RESULT =
      {  RESULT = new Opt();  }
    |  super.s {  RESULT = new Opt(s);  };
interfaces.RESULT =
      IMPLEMENTS interface_type_list.i {  RESULT = i;  };
interfaces_opt.RESULT =
      {  RESULT = new List();  }
    |  interfaces.i {  RESULT = i;  };
interface_type_list.RESULT =
      interface_type.i {  RESULT = new List().add(i);  }
    |  interface_type_list.l COMMA interface_type.i {  RESULT = l.add(i);  };
class_body.RESULT =
      LBRACE class_body_declarations_opt.c RBRACE {  RESULT = c;  };
class_body_declarations_opt.RESULT =
      {  RESULT = new List();  }
    |  class_body_declarations.c {  RESULT = c;  };
class_body_declarations.RESULT =
      class_body_declaration.c {  RESULT = c != null ? new List().add(c) : new List();  }
    |  class_body_declarations.l class_body_declaration.c {  RESULT = c != null ? l.add(c) : l;  };
class_body_declaration.RESULT =
      class_member_declaration.c {  RESULT = c;  }
    |  static_initializer.si {  RESULT = si;  }
    |  constructor_declaration.c {  RESULT = c;  }
    |  block.b {  RESULT = new InstanceInitializer(b);  };
class_member_declaration.RESULT =
      field_declaration.f {  RESULT = f;  }
    |  method_declaration.m {  RESULT = m;  }
    |  modifiers_opt.m CLASS IDENTIFIER.id super_opt.s interfaces_opt.i class_body.b {  RESULT = new MemberClass(
                                                                       new ClassDecl(
                                                                         m, new IdDecl(id), s, i, b
                                                                       )
                                                                     );
                                                                   }
    |  interface_declaration.i {  RESULT = new MemberInterface(i);  }
    |  SEMICOLON;
field_declaration.RESULT =
      modifiers_opt.m type.t variable_declarators.v SEMICOLON {  RESULT = new FieldDecl(m, t, v);  };
variable_declarators.RESULT =
      variable_declarator.v {  RESULT = new List().add(v);  }
    |  variable_declarators.l COMMA variable_declarator.v {  RESULT = l.add(v);  };
variable_declarator.RESULT =
      variable_declarator_id.v {  RESULT = v;  }
    |  variable_declarator_id.v EQ variable_initializer.i {  v.setAbstractVarInit(i); RESULT = v;  };
variable_declarator_id.RESULT =
      IDENTIFIER.id {  RESULT = new VariableDecl(new IdDecl(id), new List(), new Opt());  }
    |  variable_declarator_id.v LBRACK RBRACK {  v.addEmptyBracket(new EmptyBracket()); RESULT = v;  };
variable_initializer.RESULT =
      expression.e {  RESULT = new VarInit(e);  }
    |  array_initializer.a {  RESULT = a;  };
method_declaration.RESULT =
      method_header.m method_body.b {  m.setBlockOpt(b); RESULT = m;  };
method_header.RESULT =
      modifiers_opt.m type.t method_declarator.d throws_opt.tl {  d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(tl); RESULT = d;  }
    |  modifiers_opt.m VOID method_declarator.d throws_opt.tl {  d.setModifiers(m);
                                                                  d.setTypeAccess(new ParseName(new IdUse("void")));
                                                                  d.setExceptionList(tl);
                                                                  RESULT = d;
                                                                };
method_declarator.RESULT =
      IDENTIFIER.id LPAREN formal_parameter_list_opt.p RPAREN {  RESULT = new MethodDecl(null, null, new IdDecl(id), p, new List(), null, new Opt());  }
    |  method_declarator.m LBRACK RBRACK {  m.addEmptyBracket(new EmptyBracket()); RESULT = m;  };
formal_parameter_list_opt.RESULT =
      {  RESULT = new List();  }
    |  formal_parameter_list.l {  RESULT = l;  };
formal_parameter_list.RESULT =
      formal_parameter.f {  RESULT = new List().add(f);  }
    |  formal_parameter_list.l COMMA formal_parameter.f {  RESULT = l.add(f);  };
formal_parameter.RESULT =
      type.t variable_declarator_id.v {  RESULT = new Parameter(new Modifiers(new List()), t, v.getIdDecl(), v.getEmptyBracketList());  }
    |  FINAL type.t variable_declarator_id.v {  RESULT = new Parameter(
                                                                   new Modifiers(new List().add(new Modifier("final"))),
                                                                   t,
                                                                   v.getIdDecl(),
                                                                   v.getEmptyBracketList()
                                                                 );
                                                               };
throws_opt.RESULT =
      {  RESULT = new List();  }
    |  throws.t {  RESULT = t;  };
throws.RESULT =
      THROWS class_type_list.l {  RESULT = l;  };
class_type_list.RESULT =
      class_type.c {  RESULT = new List().add(c);  }
    |  class_type_list.l COMMA class_type.c {  RESULT = l.add(c);  };
method_body.RESULT =
      block.b {  RESULT = new Opt(b);  }
    |  SEMICOLON {  RESULT = new Opt();  };
static_initializer.RESULT =
      STATIC block.b {  RESULT = new StaticInitializer(b);  };
constructor_declaration.RESULT =
      modifiers_opt.m IDENTIFIER.id LPAREN formal_parameter_list_opt.pl RPAREN
      throws_opt.tl constructor_body.b
      {
        RESULT = b;
        b.setModifiers(m);
        b.setIdDecl(new IdDecl(id));
        b.setParameterList(pl);
        b.setExceptionList(tl);
      };

constructor_body.RESULT =
		LBRACE explicit_constructor_invocation.c
			block_statements.l RBRACE                           { RESULT = new ConstructorDecl(null, null, null, null, new Opt(c), new Block(l)); }
	|	LBRACE explicit_constructor_invocation.c RBRACE       { RESULT = new ConstructorDecl(null, null, null, null, new Opt(c), new Block(new List())); }
	|	LBRACE block_statements.l RBRACE                      { RESULT = new ConstructorDecl(null, null, null, null, new Opt(), new Block(l)); }
	|	LBRACE RBRACE                                         { RESULT = new ConstructorDecl(null, null, null, null, new Opt(), new Block(new List())); }
	;
explicit_constructor_invocation.RESULT =
      THIS LPAREN argument_list_opt.l RPAREN SEMICOLON {  RESULT = new ExprStmt(new ConstructorAccess(l, new IdUse("this")));  }
    |  SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {  RESULT = new ExprStmt(new SuperConstructorAccess(l, new IdUse("super")));  }
    |  primary.p DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {  RESULT = new ExprStmt(new Dot(p, new SuperConstructorAccess(l, new IdUse("super"))));  }
    |  name.n DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {  RESULT = new ExprStmt(new Dot(n, new SuperConstructorAccess(l, new IdUse("super"))));  };
interface_declaration.RESULT =
      modifiers_opt.m INTERFACE IDENTIFIER.id extends_interfaces_opt.i interface_body.b {  RESULT = new InterfaceDecl(
                                                                     m, new IdDecl(id), i, b
                                                                   );
                                                               };
extends_interfaces_opt.RESULT =
      {  RESULT = new List();  }
    |  extends_interfaces.i {  RESULT = i;  };
extends_interfaces.RESULT =
      EXTENDS interface_type.i {  RESULT = new List().add(i);  }
    |  extends_interfaces.l COMMA interface_type.i {  RESULT = l.add(i);  };
interface_body.RESULT =
      LBRACE interface_member_declarations_opt.i RBRACE {  RESULT = i;  };
interface_member_declarations_opt.RESULT =
      {  RESULT = new List();  }
    |  interface_member_declarations.i {  RESULT = i;  };
interface_member_declarations.RESULT =
      interface_member_declaration.i {  RESULT = i != null ? new List().add(i) : new List() ;  }
    |  interface_member_declarations.l interface_member_declaration.i {  RESULT = i != null ? l.add(i) : l ;  };
interface_member_declaration.RESULT =
      constant_declaration.c {  RESULT = c;  }
    |  abstract_method_declaration.a {  RESULT = a;  }
    |  class_declaration.c {  RESULT = new MemberClass(c);  }
    |  interface_declaration.i {  RESULT = new MemberInterface(i);  }
    |  SEMICOLON {  RESULT = null;  };
constant_declaration.RESULT =
      field_declaration.f {  RESULT = f;  };
abstract_method_declaration.RESULT =
      method_header.m SEMICOLON {  RESULT = m;  };
array_initializer.RESULT =
      LBRACE variable_initializers.v COMMA RBRACE {  RESULT = new ArrayInit(v);  }
    |  LBRACE variable_initializers.v RBRACE {  RESULT = new ArrayInit(v);  }
    |  LBRACE COMMA RBRACE {  RESULT = new ArrayInit(new List());  }
    |  LBRACE RBRACE {  RESULT = new ArrayInit(new List());  };
variable_initializers.RESULT =
      variable_initializer.v {  RESULT = new List().add(v);  }
    |  variable_initializers.l COMMA variable_initializer.v {  RESULT = l.add(v);  };
block.RESULT =
      LBRACE block_statements_opt.l RBRACE {  RESULT = new Block(l);  };
block_statements_opt.RESULT =
      {  RESULT = new List();  }
    |  block_statements.l {  RESULT = l;  };
block_statements.RESULT =
      block_statement.b {  RESULT = new List().add(b);  }
    |  block_statements.l block_statement.b {  RESULT = l.add(b);  };
block_statement.RESULT =
      local_variable_declaration_statement.l {  RESULT = l;  }
    |  statement.s {  RESULT = s;  }
    |  class_declaration.c {  RESULT = new LocalClassDeclStmt(c);  };
local_variable_declaration_statement.RESULT =
      local_variable_declaration.l SEMICOLON {  RESULT = l;  };
local_variable_declaration.RESULT =
      type.t variable_declarators.l {  RESULT = new VarDeclStmt(new Modifiers(new List()), t, l);  }
    |  FINAL type.t variable_declarators.l {  RESULT = new VarDeclStmt(
                                                      new Modifiers(new List().add(new Modifier("final"))), t, l
                                                    );
                                                  };
statement.RESULT =
      statement_without_trailing_substatement.s {  RESULT = s;  }
    |  labeled_statement.l {  RESULT = l;  }
    |  if_then_statement.i {  RESULT = i;  }
    |  if_then_else_statement.i {  RESULT = i;  }
    |  while_statement.w {  RESULT = w;  }
    |  for_statement.f {  RESULT = f;  };
statement_no_short_if.RESULT =
      statement_without_trailing_substatement.s {  RESULT = s;  }
    |  labeled_statement_no_short_if.l {  RESULT = l;  }
    |  if_then_else_statement_no_short_if.i {  RESULT = i;  }
    |  while_statement_no_short_if.w {  RESULT = w;  }
    |  for_statement_no_short_if.f {  RESULT = f;  };
statement_without_trailing_substatement.RESULT =
      block.b {  RESULT = b;  }
    |  empty_statement.e {  RESULT = e;  }
    |  expression_statement.e {  RESULT = e;  }
    |  switch_statement.s {  RESULT = s;  }
    |  do_statement.d {  RESULT = d;  }
    |  break_statement.b {  RESULT = b;  }
    |  continue_statement.c {  RESULT = c;  }
    |  return_statement.r {  RESULT = r;  }
    |  synchronized_statement.s {  RESULT = s;  }
    |  throw_statement.t {  RESULT = t;  }
    |  try_statement.t {  RESULT = t;  }
    |  assert_statement.a {  RESULT = a;  };
empty_statement.RESULT =
      SEMICOLON {  RESULT = new EmptyStmt();  };
labeled_statement.RESULT =
      IDENTIFIER.id COLON statement.s {  RESULT = new LabelStmt(new IdDecl(id), s);  };
labeled_statement_no_short_if.RESULT =
      IDENTIFIER.id COLON statement_no_short_if.s {  RESULT = new LabelStmt(new IdDecl(id), s);  };
expression_statement.RESULT =
      statement_expression.e SEMICOLON {  RESULT = e;  };
statement_expression.RESULT =
      assignment.a {  RESULT = new ExprStmt(a);  }
    |  preincrement_expression.e {  RESULT = new ExprStmt(e);  }
    |  predecrement_expression.e {  RESULT = new ExprStmt(e);  }
    |  postincrement_expression.e {  RESULT = new ExprStmt(e);  }
    |  postdecrement_expression.e {  RESULT = new ExprStmt(e);  }
    |  method_invocation.i {  RESULT = new ExprStmt(i);  }
    |  class_instance_creation_expression.e {  RESULT = new ExprStmt(e);  };
if_then_statement.RESULT =
      IF LPAREN expression.e RPAREN statement.s {  RESULT = new IfStmt(e, s, new Opt());  };
if_then_else_statement.RESULT =
      IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement.els {  RESULT = new IfStmt(e, t, new Opt(els));  };
if_then_else_statement_no_short_if.RESULT =
      IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement_no_short_if.els {  RESULT = new IfStmt(e, t, new Opt(els));  };
switch_statement.RESULT =
      SWITCH LPAREN expression.e RPAREN switch_block.l {  RESULT = new SwitchStmt(e, l);  };
switch_block.RESULT =
      LBRACE switch_block_statement_groups.l switch_labels.s RBRACE {  for(int ii = 0; ii < s.getNumChild(); ii++) l.add(s.getChild(ii)); RESULT = l;  }
    |  LBRACE switch_block_statement_groups.l RBRACE {  RESULT = l;  }
    |  LBRACE switch_labels.l RBRACE {  RESULT = l;  }
    |  LBRACE RBRACE {  RESULT = new List();  };
switch_block_statement_groups.RESULT =
      switch_block_statement_group.g {  RESULT = g;  }
    |  switch_block_statement_groups.l switch_block_statement_group.g {  for(int ii = 0; ii < g.getNumChild(); ii++)
                                                 l.add(g.getChild(ii));
                                               RESULT = l;
                                             };
switch_block_statement_group.RESULT =
      switch_labels.l block_statements.bl {  ((Case)l.getChild(l.getNumChild()-1)).setStmtList(bl);
                                                 RESULT = l;
                                               };
switch_labels.RESULT =
      switch_label.s {  RESULT = new List().add(s);  }
    |  switch_labels.l switch_label.s {  RESULT = l.add(s);  };
switch_label.RESULT =
      CASE constant_expression.e COLON {  RESULT = new ConstCase(e, new List());  }
    |  DEFAULT COLON {  RESULT = new DefaultCase(new List());  };
while_statement.RESULT =
      WHILE LPAREN expression.e RPAREN statement.s {  RESULT = new WhileStmt(e, s);  };
while_statement_no_short_if.RESULT =
      WHILE LPAREN expression.e RPAREN statement_no_short_if.s {  RESULT = new WhileStmt(e, s);  };
do_statement.RESULT =
      DO statement.s WHILE LPAREN expression.e RPAREN SEMICOLON {  RESULT = new DoStmt(s, e);  };
for_statement.RESULT =
      FOR LPAREN for_init_opt.init SEMICOLON expression_opt.e SEMICOLON for_update_opt.upd RPAREN statement.s {  RESULT = new ForStmt(init, e, upd, s);  };
for_statement_no_short_if.RESULT =
      FOR LPAREN for_init_opt.init SEMICOLON expression_opt.e SEMICOLON for_update_opt.upd RPAREN statement_no_short_if.s {  RESULT = new ForStmt(init, e, upd, s);  };
for_init_opt.RESULT =
      {  RESULT = new List();  }
    |  for_init.f {  RESULT = f;  };
for_init.RESULT =
      statement_expression_list.l {  RESULT = l;  }
    |  local_variable_declaration.d {  RESULT = new List().add(d);  };
for_update_opt.RESULT =
      {  RESULT = new List();  }
    |  for_update.f {  RESULT = f;  };
for_update.RESULT =
      statement_expression_list.l {  RESULT = l;  };
statement_expression_list.RESULT =
      statement_expression.e {  RESULT = new List().add(e);  }
    |  statement_expression_list.l COMMA statement_expression.e {  RESULT = l.add(e);  };
identifier_opt.RESULT =
      {  RESULT = new Opt();  }
    |  IDENTIFIER.id {  RESULT = new Opt(new IdUse(id));  };
break_statement.RESULT =
      BREAK identifier_opt.i SEMICOLON {  RESULT = new BreakStmt(i);  };
continue_statement.RESULT =
      CONTINUE identifier_opt.i SEMICOLON {  RESULT = new ContinueStmt(i);  };
return_statement.RESULT =
      RETURN expression_opt.e SEMICOLON {  RESULT = new ReturnStmt(e);  };
throw_statement.RESULT =
      THROW expression.e SEMICOLON {  RESULT = new ThrowStmt(e);  };
synchronized_statement.RESULT =
      SYNCHRONIZED LPAREN expression.e RPAREN block.b {  RESULT = new SynchronizeStmt(e, b);  };
try_statement.RESULT =
      TRY block.b catches.c {  RESULT = new TryStmt(b, c, new Opt());  }
    |  TRY block.b catches_opt.c finally.f {  RESULT = new TryStmt(b, c, new Opt(f));  };
catches_opt.RESULT =
      {  RESULT = new List();  }
    |  catches.c {  RESULT = c;  };
catches.RESULT =
      catch_clause.c {  RESULT = new List().add(c);  }
    |  catches.l catch_clause.c {  RESULT = l.add(c);  };
catch_clause.RESULT =
      CATCH LPAREN formal_parameter.p RPAREN block.b {  RESULT = new Catch(p, b);  };
finally.RESULT =
      FINALLY block.b {  RESULT = b;  };
assert_statement.RESULT =
      ASSERT expression.e SEMICOLON {  RESULT = new AssertStmt(e, new Opt());  }
    |  ASSERT expression.e COLON expression.s SEMICOLON {  RESULT = new AssertStmt(e, new Opt(s));  };
primary.RESULT =
      primary_no_new_array.p {  RESULT = p;  }
    |  array_creation_init.a {  RESULT = a;  }
    |  array_creation_uninit.a {  RESULT = a;  };
primary_no_new_array.RESULT =
      literal.l {  RESULT = l;  }
    |  THIS {  RESULT = new ThisAccess(new List(), new IdUse("this"));  }
    |  LPAREN name.n RPAREN {  RESULT = new ParExpr(n);  }
    |  LPAREN expression_nn.e RPAREN {  RESULT = new ParExpr(e);  }
    |  class_instance_creation_expression.c {  RESULT = c;  }
    |  field_access.f {  RESULT = f;  }
    |  method_invocation.m {  RESULT = m;  }
    |  array_access.a {  RESULT = a;  }
    |  name.n DOT THIS {  RESULT = new ThisDot(n, new ThisAccess(new List(), new IdUse("this")));  }
    |  VOID DOT CLASS { RESULT = new ClassDot(new ParseName(new IdUse("void")), new ClassAccess()); }
    |  primitive_type.n DOT CLASS { RESULT = new ClassDot(n,  new ClassAccess()); }
    |  primitive_type.n dims.d DOT CLASS { RESULT = new ClassDot(new Dot(n, new ArrayTypeName(d)), new ClassAccess()); }
    |  name.n DOT CLASS {  RESULT = new ClassDot(n, new ClassAccess());  }
    |  name.n dims.d DOT CLASS {  RESULT = new ClassDot(new Dot(n, new ArrayTypeName(d)), new ClassAccess());  };
class_instance_creation_expression.RESULT =
       NEW class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body_opt.b 
        {  RESULT = new ClassInstanceExpr(t, l, b); }
    |  primary.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {  RESULT = new Dot(n, new ClassInstanceExpr(new ParseName(new IdUse(id)), l, b )); }
    |  name.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {  RESULT = new Dot(n, new ClassInstanceExpr(new ParseName(new IdUse(id)), l, b)); }
    ;
subclass_body_opt.RESULT =
        { RESULT = new Opt(); }
    |  class_body.b
        { RESULT = new Opt(new AnonymousDecl(new Modifiers(), new IdDecl("Anonymous"), b)); }
    ;
argument_list_opt.RESULT =
      {  RESULT = new List();  }
    |  argument_list.a {  RESULT = a;  };
argument_list.RESULT =
      expression.e {  RESULT = new List().add(e);  }
    |  argument_list.l COMMA expression.e {  RESULT = l.add(e);  };
array_creation_uninit.RESULT =
      NEW primitive_type.t dim_exprs.d dims_opt.ed {  RESULT = new ArrayInstanceExpr(t, d, new Opt());  }
    |  NEW class_or_interface_type.t dim_exprs.d dims_opt.ed {  RESULT = new ArrayInstanceExpr(t, d, new Opt());  };
array_creation_init.RESULT =
      NEW primitive_type.t dims.d array_initializer.i {  RESULT = new ArrayInstanceExpr(t, d, new Opt(i));  }
    |  NEW class_or_interface_type.t dims.d array_initializer.i {  RESULT = new ArrayInstanceExpr(t, d, new Opt(i));  };
dim_exprs.RESULT =
      dim_expr.e {  RESULT = new List().add(e);  }
    |  dim_exprs.l dim_expr.e {  RESULT = l.add(e);  };
dim_expr.RESULT =
      LBRACK expression.e RBRACK {  RESULT = new Dims(new Opt(e));  };
dims_opt.RESULT =
      {  RESULT = new List();  }
    |  dims.d {  RESULT = d;  };
dims.RESULT =
      LBRACK RBRACK {  RESULT = new List().add(new Dims(new Opt()));  }
    |  dims.l LBRACK RBRACK {  RESULT = l.add(new Dims(new Opt()));  };
field_access.RESULT =
      primary.p DOT IDENTIFIER.id {  RESULT = new Dot(p, new ParseName(new IdUse(id)));  }
    |  SUPER DOT IDENTIFIER.id {  RESULT = new Dot(
         new SuperAccess(new List(), new IdUse("super")),
         new ParseName(new IdUse(id))
       );
     }
    |  name.n DOT SUPER DOT IDENTIFIER.id {  RESULT = new Dot(
         new SuperDot(n, new SuperAccess(new List(), new IdUse("super"))),
         new ParseName(new IdUse(id))
       );
     };
method_invocation.RESULT =
      name.n LPAREN argument_list_opt.l RPAREN {  
                                                             if(n instanceof Dot) {    
                                                               Dot d = (Dot)n; 
                                                               ParseName pn = (ParseName)d.getRightNoTransform();
                                                               IdUse idUse = pn.getIdUseNoTransform();
                                                               d.setRight(new ParseMethodName(idUse, l));
                                                               RESULT = d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               IdUse idUse = pn.getIdUseNoTransform();
                                                               RESULT = new ParseMethodName(idUse, l);
                                                             }
                                                               
                                                                }
    |  primary.p DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {  RESULT = new Dot(p, new ParseMethodName(new IdUse(id), l));  }
    |  SUPER DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {  RESULT = new Dot(new SuperAccess(new List(), new IdUse("super")),
                                                                                           new ParseMethodName(new IdUse(id), l));  }
    |  name.n DOT SUPER DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {  RESULT = new Dot(new Dot(n, new SuperAccess(new List(), new IdUse("super"))),
                                                                                           new ParseMethodName(new IdUse(id), l));  };
array_access.RESULT =
      name.n LBRACK expression.e RBRACK {  RESULT = new Dot(n, new ParseArray(new List().add(new Dims(new Opt(e)))));  }
    |  primary_no_new_array.p LBRACK expression.e RBRACK {  RESULT = new Dot(p, new ParseArray(new List().add(new Dims(new Opt(e)))));  }
    |  array_creation_init.a LBRACK expression.e RBRACK {  RESULT = new Dot(a, new ParseArray(new List().add(new Dims(new Opt(e)))));  };
postfix_expression.RESULT =
      primary.p {  RESULT = p;  }
    |  name.n {  RESULT = n;  }
    |  postincrement_expression.e {  RESULT = e;  }
    |  postdecrement_expression.e {  RESULT = e;  };
postincrement_expression.RESULT =
      postfix_expression.e PLUSPLUS {  RESULT = new PostIncExpr(e);  };
postdecrement_expression.RESULT =
      postfix_expression.e MINUSMINUS {  RESULT = new PostDecExpr(e);  };
unary_expression.RESULT =
      preincrement_expression.e {  RESULT = e;  }
    |  predecrement_expression.e {  RESULT = e;  }
    |  PLUS unary_expression.e {  RESULT = new PlusExpr(e);  }
    |  MINUS unary_expression.e {  RESULT = new MinusExpr(e);  }
    |  unary_expression_not_plus_minus.e {  RESULT = e;  };
preincrement_expression.RESULT =
      PLUSPLUS unary_expression.e {  RESULT = new PreIncExpr(e);  };
predecrement_expression.RESULT =
      MINUSMINUS unary_expression.e {  RESULT = new PreDecExpr(e);  };
unary_expression_not_plus_minus.RESULT =
      postfix_expression.e {  RESULT = e;  }
    |  COMP unary_expression.e {  RESULT = new BitNotExpr(e);  }
    |  NOT unary_expression.e {  RESULT = new LogNotExpr(e);  }
    |  cast_expression.e {  RESULT = e;  };
cast_expression.RESULT =
      LPAREN primitive_type.t dims_opt.d RPAREN unary_expression.e {  RESULT = new CastExpr(new Dot(t, new ArrayTypeName(d)), e);  }
    |  LPAREN name.n RPAREN unary_expression_not_plus_minus.e {  RESULT = new CastExpr(n, e);  }
    |  LPAREN name.n dims.d RPAREN unary_expression_not_plus_minus.e {  RESULT = new CastExpr(new Dot(n, new ArrayTypeName(d)), e);  };
multiplicative_expression.RESULT =
      unary_expression.e {  RESULT = e;  }
    |  multiplicative_expression.e1 MULT unary_expression.e2 {  RESULT = new MulExpr(e1, e2);  }
    |  multiplicative_expression.e1 DIV unary_expression.e2 {  RESULT = new DivExpr(e1, e2);  }
    |  multiplicative_expression.e1 MOD unary_expression.e2 {  RESULT = new ModExpr(e1, e2);  };
additive_expression.RESULT =
      multiplicative_expression.e {  RESULT = e;  }
    |  additive_expression.e1 PLUS multiplicative_expression.e2 {  RESULT = new AddExpr(e1, e2);  }
    |  additive_expression.e1 MINUS multiplicative_expression.e2 {  RESULT = new SubExpr(e1, e2);  };
shift_expression.RESULT =
      additive_expression.e {  RESULT = e;  }
    |  shift_expression.e1 LSHIFT additive_expression.e2 {  RESULT = new LShiftExpr(e1, e2);  }
    |  shift_expression.e1 RSHIFT additive_expression.e2 {  RESULT = new RShiftExpr(e1, e2);  }
    |  shift_expression.e1 URSHIFT additive_expression.e2 {  RESULT = new URShiftExpr(e1, e2);  };
relational_expression.RESULT =
      shift_expression.e {  RESULT = e;  }
    |  relational_expression.e1 LT shift_expression.e2 {  RESULT = new LTExpr(e1, e2);  }
    |  relational_expression.e1 GT shift_expression.e2 {  RESULT = new GTExpr(e1, e2);  }
    |  relational_expression.e1 LTEQ shift_expression.e2 {  RESULT = new LEExpr(e1, e2);  }
    |  relational_expression.e1 GTEQ shift_expression.e2 {  RESULT = new GEExpr(e1, e2);  };
instanceof_expression.RESULT =
      relational_expression.e {  RESULT = e;  }
    |  instanceof_expression.e INSTANCEOF reference_type.t {  RESULT = new InstanceOfExpr(e, t);  };
equality_expression.RESULT =
      instanceof_expression.e {  RESULT = e;  }
    |  equality_expression.e1 EQEQ instanceof_expression.e2 {  RESULT = new EQExpr(e1, e2);  }
    |  equality_expression.e1 NOTEQ instanceof_expression.e2 {  RESULT = new NEExpr(e1, e2);  };
and_expression.RESULT =
      equality_expression.e {  RESULT = e;  }
    |  and_expression.e1 AND equality_expression.e2 {  RESULT = new AndBitwiseExpr(e1, e2);  };
exclusive_or_expression.RESULT =
      and_expression.e {  RESULT = e;  }
    |  exclusive_or_expression.e1 XOR and_expression.e2 {  RESULT = new XorBitwiseExpr(e1, e2);  };
inclusive_or_expression.RESULT =
      exclusive_or_expression.e {  RESULT = e;  }
    |  inclusive_or_expression.e1 OR exclusive_or_expression.e2 {  RESULT = new OrBitwiseExpr(e1, e2);  };
conditional_and_expression.RESULT =
      inclusive_or_expression.e {  RESULT = e;  }
    |  conditional_and_expression.e1 ANDAND inclusive_or_expression.e2 {  RESULT = new AndLogicalExpr(e1, e2);  };
conditional_or_expression.RESULT =
      conditional_and_expression.e {  RESULT = e;  }
    |  conditional_or_expression.e1 OROR conditional_and_expression.e2 {  RESULT = new OrLogicalExpr(e1, e2);  };
conditional_expression.RESULT =
      conditional_or_expression.c {  RESULT = c;  }
    |  conditional_or_expression.c QUESTION expression.e1 COLON conditional_expression.e2 {  RESULT = new QuestionColonExpr(c, e1, e2);  };
assignment_expression.RESULT =
      conditional_expression.c {  RESULT = c;  }
    |  assignment.a {  RESULT = a;  };
assignment.RESULT =
      postfix_expression.dest assignment_operator.e assignment_expression.source {  e.setDest(dest); e.setSource(source); RESULT = e;  };
assignment_operator.RESULT =
      EQ {  RESULT = new AssignSimpleExpr(null, null);  }
    |  MULTEQ {  RESULT = new AssignMulExpr(null, null);  }
    |  DIVEQ {  RESULT = new AssignDivExpr(null, null);  }
    |  MODEQ {  RESULT = new AssignModExpr(null, null);  }
    |  PLUSEQ {  RESULT = new AssignPlusExpr(null, null);  }
    |  MINUSEQ {  RESULT = new AssignMinusExpr(null, null);  }
    |  LSHIFTEQ {  RESULT = new AssignLShiftExpr(null, null);  }
    |  RSHIFTEQ {  RESULT = new AssignRShiftExpr(null, null);  }
    |  URSHIFTEQ {  RESULT = new AssignURShiftExpr(null, null);  }
    |  ANDEQ {  RESULT = new AssignAndExpr(null, null);  }
    |  XOREQ {  RESULT = new AssignXorExpr(null, null);  }
    |  OREQ {  RESULT = new AssignOrExpr(null, null);  };
expression_opt.RESULT =
      {  RESULT = new Opt();  }
    |  expression.e {  RESULT = new Opt(e);  };
expression.RESULT =
      assignment_expression.a {  RESULT = a;  };
constant_expression.RESULT =
      expression.e {  RESULT = e;  };
postfix_expression_nn.RESULT =
      primary.p {  RESULT = p;  }
    |  postincrement_expression.e {  RESULT = e;  }
    |  postdecrement_expression.e {  RESULT = e;  };
unary_expression_nn.RESULT =
      preincrement_expression.e {  RESULT = e;  }
    |  predecrement_expression.e {  RESULT = e;  }
    |  PLUS unary_expression.e {  RESULT = new PlusExpr(e);  }
    |  MINUS unary_expression.e {  RESULT = new MinusExpr(e);  }
    |  unary_expression_not_plus_minus_nn.e {  RESULT = e;  };
unary_expression_not_plus_minus_nn.RESULT =
      postfix_expression_nn.e {  RESULT = e;  }
    |  COMP unary_expression.e {  RESULT = new BitNotExpr(e);  }
    |  NOT unary_expression.e {  RESULT = new LogNotExpr(e);  }
    |  cast_expression.e {  RESULT = e;  };
multiplicative_expression_nn.RESULT =
      unary_expression_nn.e {  RESULT = e;  }
    |  name.e1 MULT unary_expression.e2 {  RESULT = new MulExpr(e1, e2);  }
    |  multiplicative_expression_nn.e1 MULT unary_expression.e2 {  RESULT = new MulExpr(e1, e2);  }
    |  name.e1 DIV unary_expression.e2 {  RESULT = new DivExpr(e1, e2);  }
    |  multiplicative_expression_nn.e1 DIV unary_expression.e2 {  RESULT = new DivExpr(e1, e2);  }
    |  name.e1 MOD unary_expression.e2 {  RESULT = new ModExpr(e1, e2);  }
    |  multiplicative_expression_nn.e1 MOD unary_expression.e2 {  RESULT = new ModExpr(e1, e2);  };
additive_expression_nn.RESULT =
      multiplicative_expression_nn.e {  RESULT = e;  }
    |  name.e1 PLUS multiplicative_expression.e2 {  RESULT = new AddExpr(e1, e2);  }
    |  additive_expression_nn.e1 PLUS multiplicative_expression.e2 {  RESULT = new AddExpr(e1, e2);  }
    |  name.e1 MINUS multiplicative_expression.e2 {  RESULT = new SubExpr(e1, e2);  }
    |  additive_expression_nn.e1 MINUS multiplicative_expression.e2 {  RESULT = new SubExpr(e1, e2);  };
shift_expression_nn.RESULT =
      additive_expression_nn.e {  RESULT = e;  }
    |  name.e1 LSHIFT additive_expression.e2 {  RESULT = new LShiftExpr(e1, e2);  }
    |  shift_expression_nn.e1 LSHIFT additive_expression.e2 {  RESULT = new LShiftExpr(e1, e2);  }
    |  name.e1 RSHIFT additive_expression.e2 {  RESULT = new RShiftExpr(e1, e2);  }
    |  shift_expression_nn.e1 RSHIFT additive_expression.e2 {  RESULT = new RShiftExpr(e1, e2);  }
    |  name.e1 URSHIFT additive_expression.e2 {  RESULT = new URShiftExpr(e1, e2);  }
    |  shift_expression_nn.e1 URSHIFT additive_expression.e2 {  RESULT = new URShiftExpr(e1, e2);  };
relational_expression_nn.RESULT =
      shift_expression_nn.e {  RESULT = e;  }
    |  name.e1 LT shift_expression.e2 {  RESULT = new LTExpr(e1, e2);  }
    |  shift_expression_nn.e1 LT shift_expression.e2 {  RESULT = new LTExpr(e1, e2);  }
    |  name.e1 GT shift_expression.e2 {  RESULT = new GTExpr(e1, e2);  }
    |  shift_expression_nn.e1 GT shift_expression.e2 {  RESULT = new GTExpr(e1, e2);  }
    |  name.e1 LTEQ shift_expression.e2 {  RESULT = new LEExpr(e1, e2);  }
    |  relational_expression_nn.e1 LTEQ shift_expression.e2 {  RESULT = new LEExpr(e1, e2);  }
    |  name.e1 GTEQ shift_expression.e2 {  RESULT = new GEExpr(e1, e2);  }
    |  relational_expression_nn.e1 GTEQ shift_expression.e2 {  RESULT = new GEExpr(e1, e2);  };
instanceof_expression_nn.RESULT =
      relational_expression_nn.e {  RESULT = e;  }
    |  name.e INSTANCEOF reference_type.t {  RESULT = new InstanceOfExpr(e, t);  }
    |  instanceof_expression_nn.e INSTANCEOF reference_type.t {  RESULT = new InstanceOfExpr(e, t);  };
equality_expression_nn.RESULT =
      instanceof_expression_nn.e {  RESULT = e;  }
    |  name.e1 EQEQ instanceof_expression.e2 {  RESULT = new EQExpr(e1, e2);  }
    |  equality_expression_nn.e1 EQEQ instanceof_expression.e2 {  RESULT = new EQExpr(e1, e2);  }
    |  name.e1 NOTEQ instanceof_expression.e2 {  RESULT = new NEExpr(e1, e2);  }
    |  equality_expression_nn.e1 NOTEQ instanceof_expression.e2 {  RESULT = new NEExpr(e1, e2);  };
and_expression_nn.RESULT =
      equality_expression_nn.e {  RESULT = e;  }
    |  name.e1 AND equality_expression.e2 {  RESULT = new AndBitwiseExpr(e1, e2);  }
    |  and_expression_nn.e1 AND equality_expression.e2 {  RESULT = new AndBitwiseExpr(e1, e2);  };
exclusive_or_expression_nn.RESULT =
      and_expression_nn.e {  RESULT = e;  }
    |  name.e1 XOR and_expression.e2 {  RESULT = new XorBitwiseExpr(e1, e2);  }
    |  exclusive_or_expression_nn.e1 XOR and_expression.e2 {  RESULT = new XorBitwiseExpr(e1, e2);  };
inclusive_or_expression_nn.RESULT =
      exclusive_or_expression_nn.e {  RESULT = e;  }
    |  name.e1 OR exclusive_or_expression.e2 {  RESULT = new OrBitwiseExpr(e1, e2);  }
    |  inclusive_or_expression_nn.e1 OR exclusive_or_expression.e2 {  RESULT = new OrBitwiseExpr(e1, e2);  };
conditional_and_expression_nn.RESULT =
      inclusive_or_expression_nn.e {  RESULT = e;  }
    |  name.e1 ANDAND inclusive_or_expression.e2 {  RESULT = new AndLogicalExpr(e1, e2);  }
    |  conditional_and_expression_nn.e1 ANDAND inclusive_or_expression.e2 {  RESULT = new AndLogicalExpr(e1, e2);  };
conditional_or_expression_nn.RESULT =
      conditional_and_expression_nn.e {  RESULT = e;  }
    |  name.e1 OROR conditional_and_expression.e2 {  RESULT = new OrLogicalExpr(e1, e2);  }
    |  conditional_or_expression_nn.e1 OROR conditional_and_expression.e2 {  RESULT = new OrLogicalExpr(e1, e2);  };
conditional_expression_nn.RESULT =
      conditional_or_expression_nn.e {  RESULT = e;  }
    |  name.c QUESTION expression.e1 COLON conditional_expression.e2 {  RESULT = new QuestionColonExpr(c, e1, e2);  }
    |  conditional_or_expression_nn.c QUESTION expression.e1 COLON conditional_expression.e2 {  RESULT = new QuestionColonExpr(c, e1, e2);  };
assignment_expression_nn.RESULT =
      conditional_expression_nn.c {  RESULT = c;  }
    |  assignment.a {  RESULT = a;  };
expression_nn.RESULT =
      assignment_expression_nn.e {  RESULT = e;  };

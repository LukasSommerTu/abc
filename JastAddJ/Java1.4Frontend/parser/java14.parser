%header {:
 package parser;
 import AST.*;
:};
%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
        super.syntaxError(token);
        throw new RuntimeException(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + ": Syntax Error");
    }
    public void scannerError(Scanner.Exception e) {
        super.scannerError(e);
        throw new RuntimeException("Unexpected token");
    }

  }

        {
            report = new Events(); // Use error handler in parser
        }
:};

Program goal =
      compilation_unit.cu {:  return new Program(new List().add(cu));  :}
      ;
Expr literal =
      INTEGER_LITERAL.i {:  return new IntegerLiteral(i);  :}
    |  LONG_LITERAL.l {:  return new LongLiteral(l);  :}
    |  FLOATING_POINT_LITERAL.f {:  return new FPLiteral(f);  :}
    |  DOUBLE_LITERAL.d {:  return new DoubleLiteral(d);  :}
    |  BOOLEAN_LITERAL.b {:  return new BooleanLiteral(b);  :}
    |  CHARACTER_LITERAL.c {:  return new CharLiteral(c.toString());  :}
    |  STRING_LITERAL.s {:  return new StringLiteralExpr(new StringLiteral(s));  :}
    |  NULL_LITERAL {:  return new NullLiteral("null");  :};
Access type =
      primitive_type.t {:  return t;  :}
    |  reference_type.t {:  return t;  :};
Access primitive_type =
      numeric_type.t {:  return t;  :}
    |  BOOLEAN {:  return new ParseName(new IdUse("boolean"));  :};
Access numeric_type =
      integral_type.t {:  return t;  :}
    |  floating_point_type.t {:  return t;  :};
Access integral_type =
      BYTE {:  return new ParseName(new IdUse("byte"));  :}
    |  SHORT {:  return new ParseName(new IdUse("short"));  :}
    |  INT {:  return new ParseName(new IdUse("int"));  :}
    |  LONG {:  return new ParseName(new IdUse("long"));  :}
    |  CHAR {:  return new ParseName(new IdUse("char"));  :};
Access floating_point_type =
      FLOAT {:  return new ParseName(new IdUse("float"));  :}
    |  DOUBLE {:  return new ParseName(new IdUse("double"));  :};
Access reference_type =
      class_or_interface_type.t {:  return t;  :}
    |  array_type.t {:  return t;  :};
Access class_or_interface =
      name.n {:  return n;  :};
Access class_or_interface_type =
      class_or_interface.t {:  return t;  :};
Access class_type =
      class_or_interface_type.c {:  return c;  :};
Access interface_type =
      class_or_interface_type.c {:  return c;  :};
Access array_type =
      primitive_type.t dims.d {:  return new Dot(t, new ArrayTypeName(d));  :}
    |  name.n dims.d {:  return new Dot(n, new ArrayTypeName(d));  :};
Access name =
      simple_name.s {:  return s;  :}
    |  qualified_name.q {:  return q;  :};
Access simple_name =
      IDENTIFIER.i {:  return new ParseName(new IdUse(i));  :};
Access qualified_name =
      name.n DOT IDENTIFIER.i {:  return new Dot(n, new ParseName(new IdUse(i)));  :};
List name_decl =
      simple_name_decl.s {:  return s;  :}
    |  qualified_name_decl.q {:  return q;  :};
List simple_name_decl =
      IDENTIFIER.i {:  return new List().add(new IdDecl(i));  :};
List qualified_name_decl =
      name_decl.n DOT IDENTIFIER.i {:  return n.add(new IdDecl(i));  :};
CompilationUnit compilation_unit =
      package_declaration_opt.p import_declarations_opt.i type_declarations_opt.t {:  return new CompilationUnit(p, i, t);  :};
List package_declaration_opt =
      package_declaration.p {:  return p;  :}
    |  {:  return new List();  :};
List import_declarations_opt =
      import_declarations.i {:  return i;  :}
    |  {:  return new List();  :};
List type_declarations_opt =
      type_declarations.t {:  return t;  :}
    |  {:  return new List();  :};
List import_declarations =
      import_declaration.i {:  return new List().add(i);  :}
    |  import_declarations.l import_declaration.i {:  return l.add(i);  :};
List type_declarations =
      type_declaration.t {:  return t != null ? new List().add(t) : new List() ;  :}
    |  type_declarations.l type_declaration.t {:  return t != null ? l.add(t) : l;  :};
List package_declaration =
      PACKAGE name_decl.n SEMICOLON {:  return n;  :};
ImportDecl import_declaration =
      single_type_import_declaration.s {:  return s;  :}
    |  type_import_on_demand_declaration.t {:  return t;  :};
ImportDecl single_type_import_declaration =
      IMPORT name.n SEMICOLON {:  return new SingleTypeImportDecl(n);  :};
ImportDecl type_import_on_demand_declaration =
      IMPORT name.n DOT MULT SEMICOLON {:  return new TypeImportOnDemandDecl(n);  :};
TypeDecl type_declaration =
      class_declaration.c {:  return c;  :}
    |  interface_declaration.i {:  return i;  :}
    |  SEMICOLON {:  return null;  :};
Modifiers modifiers_opt =
      {:  return new Modifiers(new List());  :}
    |  modifiers.m {:  return new Modifiers(m);  :};
List modifiers =
      modifier.m {:  return new List().add(m);  :}
    |  modifiers.l modifier.m {:  return l.add(m);  :};
Modifier modifier =
      PUBLIC {:  return new Modifier("public");  :}
    |  PROTECTED {:  return new Modifier("protected");  :}
    |  PRIVATE {:  return new Modifier("private");  :}
    |  STATIC {:  return new Modifier("static");  :}
    |  ABSTRACT {:  return new Modifier("abstract");  :}
    |  FINAL {:  return new Modifier("final");  :}
    |  NATIVE {:  return new Modifier("native");  :}
    |  SYNCHRONIZED {:  return new Modifier("synchronized");  :}
    |  TRANSIENT {:  return new Modifier("transient");  :}
    |  VOLATILE {:  return new Modifier("volatile");  :}
    |  STRICTFP {:  return new Modifier("strictfp");  :};
ClassDecl class_declaration =
      modifiers_opt.m CLASS IDENTIFIER.id super_opt.s interfaces_opt.i class_body.b {:  return new ClassDecl(m, new IdDecl(id), s, i, b);  :};
Access super =
      EXTENDS class_type.c {:  return c;  :};
Opt super_opt =
      {:  return new Opt();  :}
    |  super.s {:  return new Opt(s);  :};
List interfaces =
      IMPLEMENTS interface_type_list.i {:  return i;  :};
List interfaces_opt =
      {:  return new List();  :}
    |  interfaces.i {:  return i;  :};
List interface_type_list =
      interface_type.i {:  return new List().add(i);  :}
    |  interface_type_list.l COMMA interface_type.i {:  return l.add(i);  :};
List class_body =
      LBRACE class_body_declarations_opt.c RBRACE {:  return c;  :};
List class_body_declarations_opt =
      {:  return new List();  :}
    |  class_body_declarations.c {:  return c;  :};
List class_body_declarations =
      class_body_declaration.c {:  return c != null ? new List().add(c) : new List();  :}
    |  class_body_declarations.l class_body_declaration.c {:  return c != null ? l.add(c) : l;  :};
BodyDecl class_body_declaration =
      class_member_declaration.c {:  return c;  :}
    |  static_initializer.si {:  return si;  :}
    |  constructor_declaration.c {:  return c;  :}
    |  block.b {:  return new InstanceInitializer(b);  :};
BodyDecl class_member_declaration =
      field_declaration.f {:  return f;  :}
    |  method_declaration.m {:  return m;  :}
    |  modifiers_opt.m CLASS IDENTIFIER.id super_opt.s interfaces_opt.i class_body.b {:  return new MemberClass(
                                                                       new ClassDecl(
                                                                         m, new IdDecl(id), s, i, b
                                                                       )
                                                                     );
                                                                   :}
    |  interface_declaration.i {:  return new MemberInterface(i);  :}
    |  SEMICOLON {: return new InstanceInitializer(new Block()); :}
    ;
BodyDecl field_declaration =
      modifiers_opt.m type.t variable_declarators.v SEMICOLON {:  return new FieldDecl(m, t, v);  :};
List variable_declarators =
      variable_declarator.v {:  return new List().add(v);  :}
    |  variable_declarators.l COMMA variable_declarator.v {:  return l.add(v);  :};
VariableDecl variable_declarator =
      variable_declarator_id.v {:  return v;  :}
    |  variable_declarator_id.v EQ variable_initializer.i {:  v.setAbstractVarInit(i); return v;  :};
VariableDecl variable_declarator_id =
      IDENTIFIER.id {:  return new VariableDecl(new IdDecl(id), new List(), new Opt());  :}
    |  variable_declarator_id.v LBRACK RBRACK {:  v.addEmptyBracket(new EmptyBracket()); return v;  :};
AbstractVarInit variable_initializer =
      expression.e {:  return new VarInit(e);  :}
    |  array_initializer.a {:  return a;  :};
MethodDecl method_declaration =
      method_header.m method_body.b {:  m.setBlockOpt(b); return m;  :};
MethodDecl method_header =
      modifiers_opt.m type.t method_declarator.d throws_opt.tl {:  d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(tl); return d;  :}
    |  modifiers_opt.m VOID method_declarator.d throws_opt.tl {:  d.setModifiers(m);
                                                                  d.setTypeAccess(new ParseName(new IdUse("void")));
                                                                  d.setExceptionList(tl);
                                                                  return d;
                                                                :};
MethodDecl method_declarator =
      IDENTIFIER.id LPAREN formal_parameter_list_opt.p RPAREN {:  return new MethodDecl(null, null, new IdDecl(id), p, new List(), null, new Opt());  :}
    |  method_declarator.m LBRACK RBRACK {:  m.addEmptyBracket(new EmptyBracket()); return m;  :};
List formal_parameter_list_opt =
      {:  return new List();  :}
    |  formal_parameter_list.l {:  return l;  :};
List formal_parameter_list =
      formal_parameter.f {:  return new List().add(f);  :}
    |  formal_parameter_list.l COMMA formal_parameter.f {:  return l.add(f);  :};
Parameter formal_parameter =
      type.t variable_declarator_id.v {:  return new Parameter(new Modifiers(new List()), t, v.getIdDecl(), v.getEmptyBracketList());  :}
    |  FINAL type.t variable_declarator_id.v {:  return new Parameter(
                                                                   new Modifiers(new List().add(new Modifier("final"))),
                                                                   t,
                                                                   v.getIdDecl(),
                                                                   v.getEmptyBracketList()
                                                                 );
                                                               :};
List throws_opt =
      {:  return new List();  :}
    |  throws.t {:  return t;  :};
List throws =
      THROWS class_type_list.l {:  return l;  :};
List class_type_list =
      class_type.c {:  return new List().add(c);  :}
    |  class_type_list.l COMMA class_type.c {:  return l.add(c);  :};
Opt method_body =
      block.b {:  return new Opt(b);  :}
    |  SEMICOLON {:  return new Opt();  :};
StaticInitializer static_initializer =
      STATIC block.b {:  return new StaticInitializer(b);  :};
ConstructorDecl constructor_declaration =
      modifiers_opt.m IDENTIFIER.id LPAREN formal_parameter_list_opt.pl RPAREN
      throws_opt.tl constructor_body.b
      {:
        b.setModifiers(m);
        b.setIdDecl(new IdDecl(id));
        b.setParameterList(pl);
        b.setExceptionList(tl);
        return b;
      :};

ConstructorDecl constructor_body =
		LBRACE explicit_constructor_invocation.c
			block_statements.l RBRACE                           {: return new ConstructorDecl(null, null, null, null, new Opt(c), new Block(l)); :}
	|	LBRACE explicit_constructor_invocation.c RBRACE       {: return new ConstructorDecl(null, null, null, null, new Opt(c), new Block(new List())); :}
	|	LBRACE block_statements.l RBRACE                      {: return new ConstructorDecl(null, null, null, null, new Opt(), new Block(l)); :}
	|	LBRACE RBRACE                                         {: return new ConstructorDecl(null, null, null, null, new Opt(), new Block(new List())); :}
	;
ExprStmt explicit_constructor_invocation =
      THIS LPAREN argument_list_opt.l RPAREN SEMICOLON {:  return new ExprStmt(new ConstructorAccess(l, new IdUse("this")));  :}
    |  SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {:  return new ExprStmt(new SuperConstructorAccess(l, new IdUse("super")));  :}
    |  primary.p DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {:  return new ExprStmt(new Dot(p, new SuperConstructorAccess(l, new IdUse("super"))));  :}
    |  name.n DOT SUPER LPAREN argument_list_opt.l RPAREN SEMICOLON {:  return new ExprStmt(new Dot(n, new SuperConstructorAccess(l, new IdUse("super"))));  :};
InterfaceDecl interface_declaration =
      modifiers_opt.m INTERFACE IDENTIFIER.id extends_interfaces_opt.i interface_body.b {:  return new InterfaceDecl(
                                                                     m, new IdDecl(id), i, b
                                                                   );
                                                               :};
List extends_interfaces_opt =
      {:  return new List();  :}
    |  extends_interfaces.i {:  return i;  :};
List extends_interfaces =
      EXTENDS interface_type.i {:  return new List().add(i);  :}
    |  extends_interfaces.l COMMA interface_type.i {:  return l.add(i);  :};
List interface_body =
      LBRACE interface_member_declarations_opt.i RBRACE {:  return i;  :};
List interface_member_declarations_opt =
      {:  return new List();  :}
    |  interface_member_declarations.i {:  return i;  :};
List interface_member_declarations =
      interface_member_declaration.i {:  return i != null ? new List().add(i) : new List() ;  :}
    |  interface_member_declarations.l interface_member_declaration.i {:  return i != null ? l.add(i) : l ;  :};
BodyDecl interface_member_declaration =
      constant_declaration.c {:  return c;  :}
    |  abstract_method_declaration.a {:  return a;  :}
    |  class_declaration.c {:  return new MemberClass(c);  :}
    |  interface_declaration.i {:  return new MemberInterface(i);  :}
    |  SEMICOLON {:  return null;  :};
BodyDecl constant_declaration =
      field_declaration.f {:  return f;  :};
BodyDecl abstract_method_declaration =
      method_header.m SEMICOLON {:  return m;  :};
ArrayInit array_initializer =
      LBRACE variable_initializers.v COMMA RBRACE {:  return new ArrayInit(v);  :}
    |  LBRACE variable_initializers.v RBRACE {:  return new ArrayInit(v);  :}
    |  LBRACE COMMA RBRACE {:  return new ArrayInit(new List());  :}
    |  LBRACE RBRACE {:  return new ArrayInit(new List());  :};
List variable_initializers =
      variable_initializer.v {:  return new List().add(v);  :}
    |  variable_initializers.l COMMA variable_initializer.v {:  return l.add(v);  :};
Block block =
      LBRACE block_statements_opt.l RBRACE {:  return new Block(l);  :};
List block_statements_opt =
      {:  return new List();  :}
    |  block_statements.l {:  return l;  :};
List block_statements =
      block_statement.b {:  return new List().add(b);  :}
    |  block_statements.l block_statement.b {:  return l.add(b);  :};
Stmt block_statement =
      local_variable_declaration_statement.l {:  return l;  :}
    |  statement.s {:  return s;  :}
    |  class_declaration.c {:  return new LocalClassDeclStmt(c);  :};
VarDeclStmt local_variable_declaration_statement =
      local_variable_declaration.l SEMICOLON {:  return l;  :};
VarDeclStmt local_variable_declaration =
      type.t variable_declarators.l {:  return new VarDeclStmt(new Modifiers(new List()), t, l);  :}
    |  FINAL type.t variable_declarators.l {:  return new VarDeclStmt(
                                                      new Modifiers(new List().add(new Modifier("final"))), t, l
                                                    );
                                                  :};
Stmt statement =
      statement_without_trailing_substatement.s {:  return s;  :}
    |  labeled_statement.l {:  return l;  :}
    |  if_then_statement.i {:  return i;  :}
    |  if_then_else_statement.i {:  return i;  :}
    |  while_statement.w {:  return w;  :}
    |  for_statement.f {:  return f;  :};
Stmt statement_no_short_if =
      statement_without_trailing_substatement.s {:  return s;  :}
    |  labeled_statement_no_short_if.l {:  return l;  :}
    |  if_then_else_statement_no_short_if.i {:  return i;  :}
    |  while_statement_no_short_if.w {:  return w;  :}
    |  for_statement_no_short_if.f {:  return f;  :};
Stmt statement_without_trailing_substatement =
      block.b {:  return b;  :}
    |  empty_statement.e {:  return e;  :}
    |  expression_statement.e {:  return e;  :}
    |  switch_statement.s {:  return s;  :}
    |  do_statement.d {:  return d;  :}
    |  break_statement.b {:  return b;  :}
    |  continue_statement.c {:  return c;  :}
    |  return_statement.r {:  return r;  :}
    |  synchronized_statement.s {:  return s;  :}
    |  throw_statement.t {:  return t;  :}
    |  try_statement.t {:  return t;  :}
    |  assert_statement.a {:  return a;  :};
EmptyStmt empty_statement =
      SEMICOLON {:  return new EmptyStmt();  :};
LabelStmt labeled_statement =
      IDENTIFIER.id COLON statement.s {:  return new LabelStmt(new IdDecl(id), s);  :};
LabelStmt labeled_statement_no_short_if =
      IDENTIFIER.id COLON statement_no_short_if.s {:  return new LabelStmt(new IdDecl(id), s);  :};
ExprStmt expression_statement =
      statement_expression.e SEMICOLON {:  return e;  :};
ExprStmt statement_expression =
      assignment.a {:  return new ExprStmt(a);  :}
    |  preincrement_expression.e {:  return new ExprStmt(e);  :}
    |  predecrement_expression.e {:  return new ExprStmt(e);  :}
    |  postincrement_expression.e {:  return new ExprStmt(e);  :}
    |  postdecrement_expression.e {:  return new ExprStmt(e);  :}
    |  method_invocation.i {:  return new ExprStmt(i);  :}
    |  class_instance_creation_expression.e {:  return new ExprStmt(e);  :};
IfStmt if_then_statement =
      IF LPAREN expression.e RPAREN statement.s {:  return new IfStmt(e, s, new Opt());  :};
IfStmt if_then_else_statement =
      IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement.els {:  return new IfStmt(e, t, new Opt(els));  :};
IfStmt if_then_else_statement_no_short_if =
      IF LPAREN expression.e RPAREN statement_no_short_if.t ELSE statement_no_short_if.els {:  return new IfStmt(e, t, new Opt(els));  :};
SwitchStmt switch_statement =
      SWITCH LPAREN expression.e RPAREN switch_block.l {:  return new SwitchStmt(e, l);  :};
List switch_block =
      LBRACE switch_block_statement_groups.l switch_labels.s RBRACE {:  for(int ii = 0; ii < s.getNumChild(); ii++) l.add(s.getChild(ii)); return l;  :}
    |  LBRACE switch_block_statement_groups.l RBRACE {:  return l;  :}
    |  LBRACE switch_labels.l RBRACE {:  return l;  :}
    |  LBRACE RBRACE {:  return new List();  :};
List switch_block_statement_groups =
      switch_block_statement_group.g {:  return g;  :}
    |  switch_block_statement_groups.l switch_block_statement_group.g {:  for(int ii = 0; ii < g.getNumChild(); ii++)
                                                 l.add(g.getChild(ii));
                                               return l;
                                             :};
List switch_block_statement_group =
      switch_labels.l block_statements.bl {:  ((Case)l.getChild(l.getNumChild()-1)).setStmtList(bl);
                                                 return l;
                                               :};
List switch_labels =
      switch_label.s {:  return new List().add(s);  :}
    |  switch_labels.l switch_label.s {:  return l.add(s);  :};
Case switch_label =
      CASE constant_expression.e COLON {:  return new ConstCase(e, new List());  :}
    |  DEFAULT COLON {:  return new DefaultCase(new List());  :};
WhileStmt while_statement =
      WHILE LPAREN expression.e RPAREN statement.s {:  return new WhileStmt(e, s);  :};
WhileStmt while_statement_no_short_if =
      WHILE LPAREN expression.e RPAREN statement_no_short_if.s {:  return new WhileStmt(e, s);  :};
DoStmt do_statement =
      DO statement.s WHILE LPAREN expression.e RPAREN SEMICOLON {:  return new DoStmt(s, e);  :};
ForStmt for_statement =
      FOR LPAREN for_init_opt.init SEMICOLON.leftsemi expression_opt.e SEMICOLON.rightsemi for_update_opt.upd RPAREN statement.s {:  return new ForStmt(init, e, upd, s);  :};
ForStmt for_statement_no_short_if =
      FOR LPAREN for_init_opt.init SEMICOLON.leftsemi expression_opt.e SEMICOLON.rightsemi for_update_opt.upd RPAREN statement_no_short_if.s {:  return new ForStmt(init, e, upd, s);  :};
List for_init_opt =
      {:  return new List();  :}
    |  for_init.f {:  return f;  :};
List for_init =
      statement_expression_list.l {:  return l;  :}
    |  local_variable_declaration.d {:  return new List().add(d);  :};
List for_update_opt =
      {:  return new List();  :}
    |  for_update.f {:  return f;  :};
List for_update =
      statement_expression_list.l {:  return l;  :};
List statement_expression_list =
      statement_expression.e {:  return new List().add(e);  :}
    |  statement_expression_list.l COMMA statement_expression.e {:  return l.add(e);  :};
Opt identifier_opt =
      {:  return new Opt();  :}
    |  IDENTIFIER.id {:  return new Opt(new IdUse(id));  :};
BreakStmt break_statement =
      BREAK identifier_opt.i SEMICOLON {:  return new BreakStmt(i);  :};
ContinueStmt continue_statement =
      CONTINUE identifier_opt.i SEMICOLON {:  return new ContinueStmt(i);  :};
ReturnStmt return_statement =
      RETURN expression_opt.e SEMICOLON {:  return new ReturnStmt(e);  :};
ThrowStmt throw_statement =
      THROW expression.e SEMICOLON {:  return new ThrowStmt(e);  :};
SynchronizeStmt synchronized_statement =
      SYNCHRONIZED LPAREN expression.e RPAREN block.b {:  return new SynchronizeStmt(e, b);  :};
TryStmt try_statement =
      TRY block.b catches.c {:  return new TryStmt(b, c, new Opt());  :}
    |  TRY block.b catches_opt.c finally.f {:  return new TryStmt(b, c, new Opt(f));  :};
List catches_opt =
      {:  return new List();  :}
    |  catches.c {:  return c;  :};
List catches =
      catch_clause.c {:  return new List().add(c);  :}
    |  catches.l catch_clause.c {:  return l.add(c);  :};
Catch catch_clause =
      CATCH LPAREN formal_parameter.p RPAREN block.b {:  return new Catch(p, b);  :};
Block finally =
      FINALLY block.b {:  return b;  :};
AssertStmt assert_statement =
      ASSERT expression.e SEMICOLON {:  return new AssertStmt(e, new Opt());  :}
    |  ASSERT expression.e COLON expression.s SEMICOLON {:  return new AssertStmt(e, new Opt(s));  :};
Expr primary =
      primary_no_new_array.p {:  return p;  :}
    |  array_creation_init.a {:  return a;  :}
    |  array_creation_uninit.a {:  return a;  :};
Expr primary_no_new_array =
      literal.l {:  return l;  :}
    |  THIS {:  return new ThisAccess(new List(), new IdUse("this"));  :}
    |  LPAREN name.n RPAREN {:  return new ParExpr(n);  :}
    |  LPAREN expression_nn.e RPAREN {:  return new ParExpr(e);  :}
    |  class_instance_creation_expression.c {:  return c;  :}
    |  field_access.f {:  return f;  :}
    |  method_invocation.m {:  return m;  :}
    |  array_access.a {:  return a;  :}
    |  name.n DOT THIS {:  return new ThisDot(n, new ThisAccess(new List(), new IdUse("this")));  :}
    |  VOID DOT CLASS {: return new ClassDot(new ParseName(new IdUse("void")), new ClassAccess()); :}
    |  primitive_type.n DOT CLASS {: return new ClassDot(n,  new ClassAccess()); :}
    |  primitive_type.n dims.d DOT CLASS {: return new ClassDot(new Dot(n, new ArrayTypeName(d)), new ClassAccess()); :}
    |  name.n DOT CLASS {:  return new ClassDot(n, new ClassAccess());  :}
    |  name.n dims.d DOT CLASS {:  return new ClassDot(new Dot(n, new ArrayTypeName(d)), new ClassAccess());  :};
Expr class_instance_creation_expression =
       NEW class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body_opt.b 
        {:  return new ClassInstanceExpr(t, l, b); :}
    |  primary.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {:  return new Dot(n, new ClassInstanceExpr(new ParseName(new IdUse(id)), l, b )); :}
    |  name.n DOT NEW IDENTIFIER.id LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {:  return new Dot(n, new ClassInstanceExpr(new ParseName(new IdUse(id)), l, b)); :}
    ;
Opt subclass_body_opt =
        {: return new Opt(); :}
    |  class_body.b
        {: return new Opt(new AnonymousDecl(new Modifiers(), new IdDecl("Anonymous"), b)); :}
    ;
List argument_list_opt =
      {:  return new List();  :}
    |  argument_list.a {:  return a;  :};
List argument_list =
      expression.e {:  return new List().add(e);  :}
    |  argument_list.l COMMA expression.e {:  return l.add(e);  :};
Expr array_creation_uninit =
      NEW primitive_type.t dim_exprs.d dims_opt.ed {:  return new ArrayInstanceExpr(t, d, new Opt());  :}
    |  NEW class_or_interface_type.t dim_exprs.d dims_opt.ed {:  return new ArrayInstanceExpr(t, d, new Opt());  :};
Expr array_creation_init =
      NEW primitive_type.t dims.d array_initializer.i {:  return new ArrayInstanceExpr(t, d, new Opt(i));  :}
    |  NEW class_or_interface_type.t dims.d array_initializer.i {:  return new ArrayInstanceExpr(t, d, new Opt(i));  :};
List dim_exprs =
      dim_expr.e {:  return new List().add(e);  :}
    |  dim_exprs.l dim_expr.e {:  return l.add(e);  :};
Dims dim_expr =
      LBRACK expression.e RBRACK {:  return new Dims(new Opt(e));  :};
List dims_opt =
      {:  return new List();  :}
    |  dims.d {:  return d;  :};
List dims =
      LBRACK RBRACK {:  return new List().add(new Dims(new Opt()));  :}
    |  dims.l LBRACK RBRACK {:  return l.add(new Dims(new Opt()));  :};
Access field_access =
      primary.p DOT IDENTIFIER.id {:  return new Dot(p, new ParseName(new IdUse(id)));  :}
    |  SUPER DOT IDENTIFIER.id {:  return new Dot(
         new SuperAccess(new List(), new IdUse("super")),
         new ParseName(new IdUse(id))
       );
     :}
    |  name.n DOT.leftdot SUPER DOT.rightdot IDENTIFIER.id {:  return new Dot(
         new SuperDot(n, new SuperAccess(new List(), new IdUse("super"))),
         new ParseName(new IdUse(id))
       );
     :};
Access method_invocation =
      name.n LPAREN argument_list_opt.l RPAREN {:  
                                                             if(n instanceof Dot) {    
                                                               Dot d = (Dot)n; 
                                                               ParseName pn = (ParseName)d.getRightNoTransform();
                                                               IdUse idUse = pn.getIdUseNoTransform();
                                                               d.setRight(new ParseMethodName(idUse, l));
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               IdUse idUse = pn.getIdUseNoTransform();
                                                               return new ParseMethodName(idUse, l);
                                                             }
                                                               
                                                                :}
    |  primary.p DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {:  return new Dot(p, new ParseMethodName(new IdUse(id), l));  :}
    |  SUPER DOT IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {:  return new Dot(new SuperAccess(new List(), new IdUse("super")),
                                                                                           new ParseMethodName(new IdUse(id), l));  :}
    |  name.n DOT.leftdot SUPER DOT.rightdot IDENTIFIER.id LPAREN argument_list_opt.l RPAREN {:  return new Dot(new Dot(n, new SuperAccess(new List(), new IdUse("super"))),
                                                                                           new ParseMethodName(new IdUse(id), l));  :};
Access array_access =
      name.n LBRACK expression.e RBRACK {:  return new Dot(n, new ParseArray(new List().add(new Dims(new Opt(e)))));  :}
    |  primary_no_new_array.p LBRACK expression.e RBRACK {:  return new Dot(p, new ParseArray(new List().add(new Dims(new Opt(e)))));  :}
    |  array_creation_init.a LBRACK expression.e RBRACK {:  return new Dot(a, new ParseArray(new List().add(new Dims(new Opt(e)))));  :};
Expr postfix_expression =
      primary.p {:  return p;  :}
    |  name.n {:  return n;  :}
    |  postincrement_expression.e {:  return e;  :}
    |  postdecrement_expression.e {:  return e;  :};
Expr postincrement_expression =
      postfix_expression.e PLUSPLUS {:  return new PostIncExpr(e);  :};
Expr postdecrement_expression =
      postfix_expression.e MINUSMINUS {:  return new PostDecExpr(e);  :};
Expr unary_expression =
      preincrement_expression.e {:  return e;  :}
    |  predecrement_expression.e {:  return e;  :}
    |  PLUS unary_expression.e {:  return new PlusExpr(e);  :}
    |  MINUS unary_expression.e {:  return new MinusExpr(e);  :}
    |  unary_expression_not_plus_minus.e {:  return e;  :};
Expr preincrement_expression =
      PLUSPLUS unary_expression.e {:  return new PreIncExpr(e);  :};
Expr predecrement_expression =
      MINUSMINUS unary_expression.e {:  return new PreDecExpr(e);  :};
Expr unary_expression_not_plus_minus =
      postfix_expression.e {:  return e;  :}
    |  COMP unary_expression.e {:  return new BitNotExpr(e);  :}
    |  NOT unary_expression.e {:  return new LogNotExpr(e);  :}
    |  cast_expression.e {:  return e;  :};
Expr cast_expression =
      LPAREN primitive_type.t dims_opt.d RPAREN unary_expression.e {:  return new CastExpr(new Dot(t, new ArrayTypeName(d)), e);  :}
    |  LPAREN name.n RPAREN unary_expression_not_plus_minus.e {:  return new CastExpr(n, e);  :}
    |  LPAREN name.n dims.d RPAREN unary_expression_not_plus_minus.e {:  return new CastExpr(new Dot(n, new ArrayTypeName(d)), e);  :};
Expr multiplicative_expression =
      unary_expression.e {:  return e;  :}
    |  multiplicative_expression.e1 MULT unary_expression.e2 {:  return new MulExpr(e1, e2);  :}
    |  multiplicative_expression.e1 DIV unary_expression.e2 {:  return new DivExpr(e1, e2);  :}
    |  multiplicative_expression.e1 MOD unary_expression.e2 {:  return new ModExpr(e1, e2);  :};
Expr additive_expression =
      multiplicative_expression.e {:  return e;  :}
    |  additive_expression.e1 PLUS multiplicative_expression.e2 {:  return new AddExpr(e1, e2);  :}
    |  additive_expression.e1 MINUS multiplicative_expression.e2 {:  return new SubExpr(e1, e2);  :};
Expr shift_expression =
      additive_expression.e {:  return e;  :}
    |  shift_expression.e1 LSHIFT additive_expression.e2 {:  return new LShiftExpr(e1, e2);  :}
    |  shift_expression.e1 RSHIFT additive_expression.e2 {:  return new RShiftExpr(e1, e2);  :}
    |  shift_expression.e1 URSHIFT additive_expression.e2 {:  return new URShiftExpr(e1, e2);  :};
Expr relational_expression =
      shift_expression.e {:  return e;  :}
    |  relational_expression.e1 LT shift_expression.e2 {:  return new LTExpr(e1, e2);  :}
    |  relational_expression.e1 GT shift_expression.e2 {:  return new GTExpr(e1, e2);  :}
    |  relational_expression.e1 LTEQ shift_expression.e2 {:  return new LEExpr(e1, e2);  :}
    |  relational_expression.e1 GTEQ shift_expression.e2 {:  return new GEExpr(e1, e2);  :};
Expr instanceof_expression =
      relational_expression.e {:  return e;  :}
    |  instanceof_expression.e INSTANCEOF reference_type.t {:  return new InstanceOfExpr(e, t);  :};
Expr equality_expression =
      instanceof_expression.e {:  return e;  :}
    |  equality_expression.e1 EQEQ instanceof_expression.e2 {:  return new EQExpr(e1, e2);  :}
    |  equality_expression.e1 NOTEQ instanceof_expression.e2 {:  return new NEExpr(e1, e2);  :};
Expr and_expression =
      equality_expression.e {:  return e;  :}
    |  and_expression.e1 AND equality_expression.e2 {:  return new AndBitwiseExpr(e1, e2);  :};
Expr exclusive_or_expression =
      and_expression.e {:  return e;  :}
    |  exclusive_or_expression.e1 XOR and_expression.e2 {:  return new XorBitwiseExpr(e1, e2);  :};
Expr inclusive_or_expression =
      exclusive_or_expression.e {:  return e;  :}
    |  inclusive_or_expression.e1 OR exclusive_or_expression.e2 {:  return new OrBitwiseExpr(e1, e2);  :};
Expr conditional_and_expression =
      inclusive_or_expression.e {:  return e;  :}
    |  conditional_and_expression.e1 ANDAND inclusive_or_expression.e2 {:  return new AndLogicalExpr(e1, e2);  :};
Expr conditional_or_expression =
      conditional_and_expression.e {:  return e;  :}
    |  conditional_or_expression.e1 OROR conditional_and_expression.e2 {:  return new OrLogicalExpr(e1, e2);  :};
Expr conditional_expression =
      conditional_or_expression.c {:  return c;  :}
    |  conditional_or_expression.c QUESTION expression.e1 COLON conditional_expression.e2 {:  return new QuestionColonExpr(c, e1, e2);  :};
Expr assignment_expression =
      conditional_expression.c {:  return c;  :}
    |  assignment.a {:  return a;  :};
Expr assignment =
      postfix_expression.dest assignment_operator.e assignment_expression.source {:  e.setDest(dest); e.setSource(source); return e;  :};
AssignExpr assignment_operator =
      EQ {:  return new AssignSimpleExpr(null, null);  :}
    |  MULTEQ {:  return new AssignMulExpr(null, null);  :}
    |  DIVEQ {:  return new AssignDivExpr(null, null);  :}
    |  MODEQ {:  return new AssignModExpr(null, null);  :}
    |  PLUSEQ {:  return new AssignPlusExpr(null, null);  :}
    |  MINUSEQ {:  return new AssignMinusExpr(null, null);  :}
    |  LSHIFTEQ {:  return new AssignLShiftExpr(null, null);  :}
    |  RSHIFTEQ {:  return new AssignRShiftExpr(null, null);  :}
    |  URSHIFTEQ {:  return new AssignURShiftExpr(null, null);  :}
    |  ANDEQ {:  return new AssignAndExpr(null, null);  :}
    |  XOREQ {:  return new AssignXorExpr(null, null);  :}
    |  OREQ {:  return new AssignOrExpr(null, null);  :};
Opt expression_opt =
      {:  return new Opt();  :}
    |  expression.e {:  return new Opt(e);  :};
Expr expression =
      assignment_expression.a {:  return a;  :};
Expr constant_expression =
      expression.e {:  return e;  :};
Expr postfix_expression_nn =
      primary.p {:  return p;  :}
    |  postincrement_expression.e {:  return e;  :}
    |  postdecrement_expression.e {:  return e;  :};
Expr unary_expression_nn =
      preincrement_expression.e {:  return e;  :}
    |  predecrement_expression.e {:  return e;  :}
    |  PLUS unary_expression.e {:  return new PlusExpr(e);  :}
    |  MINUS unary_expression.e {:  return new MinusExpr(e);  :}
    |  unary_expression_not_plus_minus_nn.e {:  return e;  :};
Expr unary_expression_not_plus_minus_nn =
      postfix_expression_nn.e {:  return e;  :}
    |  COMP unary_expression.e {:  return new BitNotExpr(e);  :}
    |  NOT unary_expression.e {:  return new LogNotExpr(e);  :}
    |  cast_expression.e {:  return e;  :};
Expr multiplicative_expression_nn =
      unary_expression_nn.e {:  return e;  :}
    |  name.e1 MULT unary_expression.e2 {:  return new MulExpr(e1, e2);  :}
    |  multiplicative_expression_nn.e1 MULT unary_expression.e2 {:  return new MulExpr(e1, e2);  :}
    |  name.e1 DIV unary_expression.e2 {:  return new DivExpr(e1, e2);  :}
    |  multiplicative_expression_nn.e1 DIV unary_expression.e2 {:  return new DivExpr(e1, e2);  :}
    |  name.e1 MOD unary_expression.e2 {:  return new ModExpr(e1, e2);  :}
    |  multiplicative_expression_nn.e1 MOD unary_expression.e2 {:  return new ModExpr(e1, e2);  :};
Expr additive_expression_nn =
      multiplicative_expression_nn.e {:  return e;  :}
    |  name.e1 PLUS multiplicative_expression.e2 {:  return new AddExpr(e1, e2);  :}
    |  additive_expression_nn.e1 PLUS multiplicative_expression.e2 {:  return new AddExpr(e1, e2);  :}
    |  name.e1 MINUS multiplicative_expression.e2 {:  return new SubExpr(e1, e2);  :}
    |  additive_expression_nn.e1 MINUS multiplicative_expression.e2 {:  return new SubExpr(e1, e2);  :};
Expr shift_expression_nn =
      additive_expression_nn.e {:  return e;  :}
    |  name.e1 LSHIFT additive_expression.e2 {:  return new LShiftExpr(e1, e2);  :}
    |  shift_expression_nn.e1 LSHIFT additive_expression.e2 {:  return new LShiftExpr(e1, e2);  :}
    |  name.e1 RSHIFT additive_expression.e2 {:  return new RShiftExpr(e1, e2);  :}
    |  shift_expression_nn.e1 RSHIFT additive_expression.e2 {:  return new RShiftExpr(e1, e2);  :}
    |  name.e1 URSHIFT additive_expression.e2 {:  return new URShiftExpr(e1, e2);  :}
    |  shift_expression_nn.e1 URSHIFT additive_expression.e2 {:  return new URShiftExpr(e1, e2);  :};
Expr relational_expression_nn =
      shift_expression_nn.e {:  return e;  :}
    |  name.e1 LT shift_expression.e2 {:  return new LTExpr(e1, e2);  :}
    |  shift_expression_nn.e1 LT shift_expression.e2 {:  return new LTExpr(e1, e2);  :}
    |  name.e1 GT shift_expression.e2 {:  return new GTExpr(e1, e2);  :}
    |  shift_expression_nn.e1 GT shift_expression.e2 {:  return new GTExpr(e1, e2);  :}
    |  name.e1 LTEQ shift_expression.e2 {:  return new LEExpr(e1, e2);  :}
    |  relational_expression_nn.e1 LTEQ shift_expression.e2 {:  return new LEExpr(e1, e2);  :}
    |  name.e1 GTEQ shift_expression.e2 {:  return new GEExpr(e1, e2);  :}
    |  relational_expression_nn.e1 GTEQ shift_expression.e2 {:  return new GEExpr(e1, e2);  :};
Expr instanceof_expression_nn =
      relational_expression_nn.e {:  return e;  :}
    |  name.e INSTANCEOF reference_type.t {:  return new InstanceOfExpr(e, t);  :}
    |  instanceof_expression_nn.e INSTANCEOF reference_type.t {:  return new InstanceOfExpr(e, t);  :};
Expr equality_expression_nn =
      instanceof_expression_nn.e {:  return e;  :}
    |  name.e1 EQEQ instanceof_expression.e2 {:  return new EQExpr(e1, e2);  :}
    |  equality_expression_nn.e1 EQEQ instanceof_expression.e2 {:  return new EQExpr(e1, e2);  :}
    |  name.e1 NOTEQ instanceof_expression.e2 {:  return new NEExpr(e1, e2);  :}
    |  equality_expression_nn.e1 NOTEQ instanceof_expression.e2 {:  return new NEExpr(e1, e2);  :};
Expr and_expression_nn =
      equality_expression_nn.e {:  return e;  :}
    |  name.e1 AND equality_expression.e2 {:  return new AndBitwiseExpr(e1, e2);  :}
    |  and_expression_nn.e1 AND equality_expression.e2 {:  return new AndBitwiseExpr(e1, e2);  :};
Expr exclusive_or_expression_nn =
      and_expression_nn.e {:  return e;  :}
    |  name.e1 XOR and_expression.e2 {:  return new XorBitwiseExpr(e1, e2);  :}
    |  exclusive_or_expression_nn.e1 XOR and_expression.e2 {:  return new XorBitwiseExpr(e1, e2);  :};
Expr inclusive_or_expression_nn =
      exclusive_or_expression_nn.e {:  return e;  :}
    |  name.e1 OR exclusive_or_expression.e2 {:  return new OrBitwiseExpr(e1, e2);  :}
    |  inclusive_or_expression_nn.e1 OR exclusive_or_expression.e2 {:  return new OrBitwiseExpr(e1, e2);  :};
Expr conditional_and_expression_nn =
      inclusive_or_expression_nn.e {:  return e;  :}
    |  name.e1 ANDAND inclusive_or_expression.e2 {:  return new AndLogicalExpr(e1, e2);  :}
    |  conditional_and_expression_nn.e1 ANDAND inclusive_or_expression.e2 {:  return new AndLogicalExpr(e1, e2);  :};
Expr conditional_or_expression_nn =
      conditional_and_expression_nn.e {:  return e;  :}
    |  name.e1 OROR conditional_and_expression.e2 {:  return new OrLogicalExpr(e1, e2);  :}
    |  conditional_or_expression_nn.e1 OROR conditional_and_expression.e2 {:  return new OrLogicalExpr(e1, e2);  :};
Expr conditional_expression_nn =
      conditional_or_expression_nn.e {:  return e;  :}
    |  name.c QUESTION expression.e1 COLON conditional_expression.e2 {:  return new QuestionColonExpr(c, e1, e2);  :}
    |  conditional_or_expression_nn.c QUESTION expression.e1 COLON conditional_expression.e2 {:  return new QuestionColonExpr(c, e1, e2);  :};
Expr assignment_expression_nn =
      conditional_expression_nn.c {:  return c;  :}
    |  assignment.a {:  return a;  :};
Expr expression_nn =
      assignment_expression_nn.e {:  return e;  :};

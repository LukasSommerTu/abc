Program ::= CompilationUnit*;

// 7.3 Compilation Units
CompilationUnit ::= PackageDecl:IdDecl* ImportDecl* TypeDecl*;

// 7.5 Import Declarations
abstract ImportDecl ::= Access;
SingleTypeImportDecl : ImportDecl;
TypeImportOnDemandDecl : ImportDecl;

abstract Access : Expr;

AbstractDot : Access ::= Left:Expr Right:Access;
Dot : AbstractDot;

VarAccess : Access ::= IdUse;
MethodAccess : Access ::= Arg:Expr* IdUse;
ConstructorAccess : Access ::= Arg:Expr* IdUse;
SuperConstructorAccess : ConstructorAccess;
TypeAccess : Access ::= Package:IdUse* IdUse;
ArrayTypeAccess : TypeAccess ::= /Package:IdUse*/ /IdUse/ Access <Dimension:int>;
//ThisAccess : TypeAccess;
//SuperAccess : TypeAccess;
ThisAccess : Access ::= IdUse;
SuperAccess : Access ::= IdUse;
PackageAccess : Access ::= Package:IdUse*;

ArrayAccess : Access ::= Expr;

ParseName : Access ::= IdUse;
PackageOrTypeAccess : Access ::= IdUse;
AmbiguousAccess : Access ::= IdUse;

ClassInstanceExpr : Access ::= Access Arg:Expr* [TypeDecl];

ClassAccess : Access ::= ;
 
abstract TypeDecl ::= Modifiers IdDecl BodyDecl*;

// 4.1 The Kinds of Types and Values
abstract ReferenceType : TypeDecl;
PrimitiveType : TypeDecl ::= Modifiers IdDecl [SuperClassAccess:Access] BodyDecl*;
EmptyType : PrimitiveType; // placeholder for ; in compilation unit
NullType : TypeDecl;
VoidType : TypeDecl;

UnknownType : ClassDecl;
IllegalType : ClassDecl;

// 4.2 Primitive Types and Values
abstract NumericType : PrimitiveType;
BooleanType : PrimitiveType;
abstract IntegralType : NumericType;
ByteType : IntegralType;
ShortType : IntegralType;
IntType : IntegralType;
LongType : IntegralType;
CharType : IntegralType;
FloatingPointType : NumericType;
FloatType : FloatingPointType;
DoubleType : FloatingPointType;
// 4.3 Reference Types and Values
ClassDecl : ReferenceType ::= Modifiers IdDecl [SuperClassAccess:Access] Implements:Access* BodyDecl*;
InterfaceDecl : ReferenceType ::= Modifiers IdDecl SuperInterfaceId:Access* BodyDecl*;
ArrayDecl : ClassDecl ::= Modifiers IdDecl [SuperClassAccess:Access] Implements:Access* BodyDecl* <ElementType:TypeDecl> <Dimension:int>;

AnonymousDecl : ClassDecl ::= Modifiers IdDecl /[SuperClassAccess:Access]/ /Implements:Access*/ BodyDecl*;

abstract BodyDecl;
InstanceInitializer : BodyDecl ::= Block;
StaticInitializer : BodyDecl ::= Block;
ConstructorDecl : BodyDecl ::= Modifiers IdDecl Parameter* Exception:Access* [ConstructorInvocation:Stmt] Block;

abstract MemberDecl : BodyDecl;

FieldDecl : MemberDecl ::= Modifiers TypeAccess:Access VariableDecl*;
FieldDeclaration : MemberDecl ::= Modifiers TypeAccess:Access IdDecl [Init:Expr]; // Simplified FieldDecl

VarDeclStmt : Stmt ::= Modifiers TypeAccess:Access VariableDecl*;
VariableDeclaration : Stmt ::= Modifiers TypeAccess:Access IdDecl [Init:Expr]; // Simplified VarDeclStmt

VariableDecl ::= IdDecl EmptyBracket* [Init:Expr];

Parameter ::= Modifiers TypeAccess:Access IdDecl EmptyBracket*;
ParameterDeclaration : Parameter ::= Modifiers TypeAccess:Access IdDecl /EmptyBracket*/; // Simplified Parameter

EmptyBracket;

ArrayInit : Expr ::= Init:Expr*;

MethodDecl : MemberDecl ::= Modifiers TypeAccess:Access IdDecl Parameter* EmptyBracket* Exception:Access* [Block]; // Create simplified version

// 8.5 Member Type Declarations
abstract MemberTypeDecl : MemberDecl ::= TypeDecl;
MemberClassDecl : MemberTypeDecl ::= ClassDecl /TypeDecl/;
MemberInterfaceDecl : MemberTypeDecl ::= InterfaceDecl /TypeDecl/;

IdDecl ::= <ID>;
IdUse ::= <ID>;

abstract Expr;

abstract AssignExpr : Expr ::= Dest:Expr Source:Expr;

AssignSimpleExpr : AssignExpr ;
AssignMulExpr : AssignExpr ;
AssignDivExpr : AssignExpr ;
AssignModExpr : AssignExpr ;
AssignPlusExpr : AssignExpr ;
AssignMinusExpr : AssignExpr ;
AssignLShiftExpr : AssignExpr ;
AssignRShiftExpr : AssignExpr ;
AssignURShiftExpr : AssignExpr ;
AssignAndExpr : AssignExpr ;
AssignXorExpr : AssignExpr ;
AssignOrExpr : AssignExpr ;

abstract PrimaryExpr : Expr;

abstract Literal : PrimaryExpr ::= <LITERAL>;
IntegerLiteral : Literal ;
LongLiteral : Literal ;
FloatingPointLiteral : Literal ;
DoubleLiteral : Literal ;
BooleanLiteral : Literal ;
CharacterLiteral : Literal ;
StringLiteral : Literal ;
NullLiteral : Literal ;

ParExpr : PrimaryExpr ::= Expr;

ArrayCreationExpr : PrimaryExpr ::= TypeAccess:Access Dims* [ArrayInit];
Dims ::= [Expr];

abstract Unary : Expr ::= Operand:Expr;
PreIncExpr : Unary ;
PreDecExpr : Unary ;
MinusExpr : Unary ;
PlusExpr : Unary ;
BitNotExpr : Unary ;
LogNotExpr : Unary ;

CastExpr : Expr ::= TypeAccess:Access Expr;

abstract PostfixExpr : Unary;
PostIncExpr : PostfixExpr ;
PostDecExpr : PostfixExpr ;

abstract Binary : Expr ::= LeftOperand:Expr RightOperand:Expr;

abstract ArithmeticExpr : Binary;
MulExpr : ArithmeticExpr ;
DivExpr : ArithmeticExpr ;
ModExpr : ArithmeticExpr ;
AddExpr : ArithmeticExpr ;
SubExpr : ArithmeticExpr ;

abstract BitwiseExpr : Binary;
LShiftExpr : BitwiseExpr ;
RShiftExpr : BitwiseExpr ;
URShiftExpr : BitwiseExpr ;
AndBitwiseExpr : BitwiseExpr ;
OrBitwiseExpr : BitwiseExpr ;
XorBitwiseExpr : BitwiseExpr ;

abstract RelationalExpr : Binary;
LTExpr : RelationalExpr ;
GTExpr : RelationalExpr ;
LEExpr : RelationalExpr ;
GEExpr : RelationalExpr ;
EQExpr : RelationalExpr ;
NEExpr : RelationalExpr ;

InstanceOfExpr : Expr ::= Expr TypeAccess:Access;

abstract LogicalExpr : Binary;
AndLogicalExpr : LogicalExpr ;
OrLogicalExpr : LogicalExpr ;

ConditionalExpr : Expr ::= Condition:Expr TrueExpr:Expr FalseExpr:Expr;

Modifiers ::= Modifier*;
Modifier ::= <ID>;

// Statements

abstract Stmt;
abstract BranchTargetStmt : Stmt;  // a statement that can be reached by break or continue
Block : Stmt ::= Stmt*;
EmptyStmt : Stmt;
LabeledStmt : BranchTargetStmt ::= Label:IdDecl Stmt;
ExprStmt : Stmt ::= Expr;

SwitchStmt : BranchTargetStmt ::= Expr Case*;
abstract Case ::= Stmt*;
ConstCase : Case ::= Value:Expr Stmt*;
DefaultCase : Case ::= Stmt*;

IfStmt : Stmt ::= Condition:Expr Then:Stmt [Else:Stmt];
WhileStmt : BranchTargetStmt ::= Condition:Expr Stmt;
DoStmt : BranchTargetStmt ::= Stmt Condition:Expr;
ForStmt : BranchTargetStmt ::= InitStmt:Stmt* [Condition:Expr] UpdateStmt:Stmt* Stmt;

BreakStmt : Stmt ::= [Label:IdUse];
ContinueStmt : Stmt ::= [Label:IdUse];
ReturnStmt : Stmt ::= [Result:Expr];
ThrowStmt : Stmt ::= Expr;

SynchronizedStmt : Stmt ::= Expr Block;

TryStmt : Stmt ::= Block CatchClause* [Finally:Block];
CatchClause ::= Parameter Block;

AssertStmt : Stmt ::= first:Expr [Expr];

LocalClassDeclStmt : Stmt ::= ClassDecl;

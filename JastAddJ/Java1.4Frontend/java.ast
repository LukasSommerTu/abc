Program ::= CompilationUnit*;

// 7.3 Compilation Units
CompilationUnit ::= PackageDecl:IdDecl* ImportDecl* TypeDecl*;

// 7.5 Import Declarations
abstract ImportDecl ::= Access;
SingleTypeImportDecl : ImportDecl;
TypeImportOnDemandDecl : ImportDecl;

abstract Access : Expr;

AbstractDot : Access ::= Left:Expr Right:Access;
PackageDot : AbstractDot;
FieldDot : AbstractDot;
MethodDot : AbstractDot;
TypeDot : AbstractDot;
ThisDot : AbstractDot;
SuperDot : AbstractDot;
ArrayTypeDot : AbstractDot;
ArrayNameDot : AbstractDot;
ArrayDot : AbstractDot;
ClassDot : AbstractDot;
SuperConstructorDot : AbstractDot;

Dot : AbstractDot;

TypeAccess : Access ::= Package:IdUse* IdUse;
ArrayTypeAccess : TypeAccess ::= /Package:IdUse*/ /IdUse/ Access <Dimension:int>;
ThisAccess : TypeAccess;
SuperAccess : TypeAccess;

//abstract TypeAccess : Access ::= Package:IdUse* IdUse;
//RegularTypeAccess : TypeAccess ::= Package:IdUse* IdUse;
//ArrayTypeAccess : TypeAccess ::= Package:IdUse* IdUse <Dimension:int>;
//ThisAccess : RegularTypeAccess;
//SuperAccess : RegularTypeAccess;

ArrayAccess : Access ::= Expr;

VarAccess : Access ::= IdUse;
MethodAccess : Access ::= Arg:Expr* IdUse;
ConstructorAccess : Access ::= Arg:Expr* IdUse;
SuperConstructorAccess : ConstructorAccess;
PackageAccess : Access ::= Package:IdUse*;
PackageOrTypeAccess : Access ::= IdUse;
AmbiguousAccess : Access ::= IdUse;
//ArrayNameAccess : Access ::= <Dimension:int> <dummy:boolean>;

ClassInstanceExpr : Access ::= Access Arg:Expr* [TypeDecl];
ClassInstanceDot : AbstractDot;

ClassAccess : Access ::= ;

ParseName : Access ::= IdUse;
//ArrayTypeName : Access ::= EmptyBracket*;
ParseArray : Access ::= Dims*;
ParseMethodName : Access ::= IdUse Arg:Expr*;


 
abstract TypeDecl ::= Modifiers IdDecl BodyDecl*;

// 4.1 The Kinds of Types and Values
abstract ReferenceType : TypeDecl;
PrimitiveType : TypeDecl ::= Modifiers IdDecl [SuperClassAccess:Access] BodyDecl*;
NullType : TypeDecl;
VoidType : TypeDecl;

UnknownType : ClassDecl;
IllegalType : ClassDecl;

// 4.2 Primitive Types and Values
abstract NumericType : PrimitiveType;
BooleanType : PrimitiveType;
abstract IntegralType : NumericType;
ByteType : IntegralType;
ShortType : IntegralType;
IntType : IntegralType;
LongType : IntegralType;
CharType : IntegralType;
FloatingPointType : NumericType;
FloatType : FloatingPointType;
DoubleType : FloatingPointType;
// 4.3 Reference Types and Values
ClassDecl : ReferenceType ::= Modifiers IdDecl [SuperClassAccess:Access] Implements:Access* BodyDecl*;
InterfaceDecl : ReferenceType ::= Modifiers IdDecl SuperInterfaceId:Access* BodyDecl*;
ArrayDecl : ClassDecl ::= Modifiers IdDecl [SuperClassAccess:Access] Implements:Access* BodyDecl* <ElementType:TypeDecl> <Dimension:int>;

//AnonymousDecl : ReferenceType ::= BodyDecl*;
AnonymousDecl : ClassDecl ::= Modifiers IdDecl /[SuperClassAccess:Access]/ /Implements:Access*/ BodyDecl*;

abstract BodyDecl;
InstanceInitializer : BodyDecl ::= Block;
StaticInitializer : BodyDecl ::= Block;
//InitializerDecl : BodyDecl ::= Modifiers Block;
ConstructorDecl : BodyDecl ::= Modifiers IdDecl Parameter* Exception:Access* [ConstructorInvocation:Stmt] Block;

abstract MemberDecl : BodyDecl;

// TODO: 4.5.3 Kinds of Variables (interface hierarchy?)
// TODO: 4.5.4 final Variables (syn boolean isFinal && syn boolean isBlankFinal)
FieldDecl : MemberDecl ::= Modifiers TypeAccess:Access VariableDecl*;
FieldDeclaration : MemberDecl ::= Modifiers TypeAccess:Access IdDecl [AbstractVarInit]; // Simplified FieldDecl

VarDeclStmt : Stmt ::= Modifiers TypeAccess:Access VariableDecl*;
VariableDeclaration : Stmt ::= Modifiers TypeAccess:Access IdDecl [AbstractVarInit]; // Simplified VarDeclStmt

VariableDecl ::= IdDecl EmptyBracket* [AbstractVarInit];

Parameter ::= Modifiers TypeAccess:Access IdDecl EmptyBracket*;
ParameterDeclaration : Parameter ::= Modifiers TypeAccess:Access IdDecl /EmptyBracket*/; // Simplified Parameter

EmptyBracket;

abstract AbstractVarInit;
VarInit : AbstractVarInit ::= Expr;
ArrayInit : AbstractVarInit ::= AbstractVarInit*;

MethodDecl : MemberDecl ::= Modifiers TypeAccess:Access IdDecl Parameter* EmptyBracket* Exception:Access* [Block]; // Create simplified version

// 8.5 Member Type Declarations
abstract MemberType : MemberDecl ::= TypeDecl;
MemberClass : MemberType ::= ClassDecl /TypeDecl/;
MemberInterface : MemberType ::= InterfaceDecl /TypeDecl/;

IdDecl ::= <ID>;
IdUse ::= <ID>;

abstract Expr;

abstract AssignExpr : Expr ::= Dest:Expr Source:Expr;

AssignSimpleExpr : AssignExpr ;
AssignMulExpr : AssignExpr ;
AssignDivExpr : AssignExpr ;
AssignModExpr : AssignExpr ;
AssignPlusExpr : AssignExpr ;
AssignMinusExpr : AssignExpr ;
AssignLShiftExpr : AssignExpr ;
AssignRShiftExpr : AssignExpr ;
AssignURShiftExpr : AssignExpr ;
AssignAndExpr : AssignExpr ;
AssignXorExpr : AssignExpr ;
AssignOrExpr : AssignExpr ;

abstract PrimaryExpr : Expr;
abstract Literal : PrimaryExpr ::= <LITERAL>;
IntegerLiteral : Literal ;
LongLiteral : Literal ;
FPLiteral : Literal ;
DoubleLiteral : Literal ;
BooleanLiteral : Literal ;
CharLiteral : Literal ;
StringLiteral : Literal ;
NullLiteral : Literal ;

ParExpr : PrimaryExpr ::= Expr;

StringLiteralExpr : PrimaryExpr ::= StringLiteral; 

PrimTypeClassExpr : PrimaryExpr ::= <ID>; 

ArrayInstanceExpr : PrimaryExpr ::= TypeAccess:Access Dims* [ArrayInit];
Dims ::= [Expr];


abstract Unary : Expr ::= Operand:Expr;
PreIncExpr : Unary ;
PreDecExpr : Unary ;
MinusExpr : Unary ;
PlusExpr : Unary ;
BitNotExpr : Unary ;
LogNotExpr : Unary ;

//CastExpr : Unary ::= TypeAccess:Access Expr;
CastExpr : Expr ::= TypeAccess:Access Expr;

abstract PostfixExpr : Unary;
PostIncExpr : PostfixExpr ;
PostDecExpr : PostfixExpr ;

abstract Binary : Expr ::= LeftOperand:Expr RightOperand:Expr;

abstract ArithmeticExpr : Binary;
MulExpr : ArithmeticExpr ;
DivExpr : ArithmeticExpr ;
ModExpr : ArithmeticExpr ;
AddExpr : ArithmeticExpr ;
SubExpr : ArithmeticExpr ;

abstract BitwiseExpr : Binary;
LShiftExpr : BitwiseExpr ;
RShiftExpr : BitwiseExpr ;
URShiftExpr : BitwiseExpr ;
AndBitwiseExpr : BitwiseExpr ;
OrBitwiseExpr : BitwiseExpr ;
XorBitwiseExpr : BitwiseExpr ;

abstract RelationalExpr : Binary;
LTExpr : RelationalExpr ;
GTExpr : RelationalExpr ;
LEExpr : RelationalExpr ;
GEExpr : RelationalExpr ;
EQExpr : RelationalExpr ;
NEExpr : RelationalExpr ;

//InstanceOfExpr : RelationalExpr ::= Expr TypeAccess:Access;
InstanceOfExpr : Expr ::= Expr TypeAccess:Access;


abstract LogicalExpr : Binary;
AndLogicalExpr : LogicalExpr ;
OrLogicalExpr : LogicalExpr ;

QuestionColonExpr : Expr ::= Condition:Expr TrueExpr:Expr FalseExpr:Expr;

Modifiers ::= Modifier*;
Modifier ::= <ID>;

// Statements

abstract Stmt;
abstract BranchTargetStmt : Stmt;
Block : Stmt ::= Stmt*;
EmptyStmt : Stmt;
LabelStmt : BranchTargetStmt ::= Label:IdDecl Stmt;
ExprStmt : Stmt ::= Expr;

SwitchStmt : BranchTargetStmt ::= Expr Case*;
abstract Case ::= Stmt*;
ConstCase : Case ::= Value:Expr Stmt*;
DefaultCase : Case ::= Stmt*;

IfStmt : Stmt ::= Condition:Expr Then:Stmt [Else:Stmt];

WhileStmt : BranchTargetStmt ::= Condition:Expr Stmt;

DoStmt : BranchTargetStmt ::= Stmt Condition:Expr;

ForStmt : BranchTargetStmt ::= InitStmt:Stmt* [Condition:Expr] UpdateStmt:Stmt* Stmt;

BreakStmt : Stmt ::= [Label:IdUse];
ContinueStmt : Stmt ::= [Label:IdUse];

ReturnStmt : Stmt ::= [Result:Expr];

ThrowStmt : Stmt ::= Expr;

SynchronizeStmt : Stmt ::= Expr Block;

TryStmt : Stmt ::= Block Catch* [Finally:Block];
Catch ::= Parameter Block;

AssertStmt : Stmt ::= first:Expr [Expr];

LocalClassDeclStmt : Stmt ::= ClassDecl;

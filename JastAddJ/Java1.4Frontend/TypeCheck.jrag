
aspect TypeCheck {
  public void ASTNode.typeCheck() {
  }
  
  syn boolean Expr.isVariable() = false;
  eq AbstractDot.isVariable() = lastAccess().isVariable();
  eq VarAccess.isVariable() = true;
  eq ArrayAccess.isVariable() = true;
  eq ParExpr.isVariable() = getExpr().isVariable();
 
  public void VariableDeclaration.typeCheck() {
    if(hasInit()) {
      TypeDecl right = getInit().type();
      TypeDecl left = type();
      if(!right.assignConversionTo(left, getInit())) {
        StringBuffer s = new StringBuffer();
        toString(s);
        error("    " + s + "\n" + 
          "The type of the right sub-expression, \"" + 
          right.typeName() + "\", is not assignable to the variable" +
          ", of type \"" + left.typeName() + "\".\n");
      }
    }
  }

  public void FieldDeclaration.typeCheck() {
    if(hasInit()) {
      TypeDecl source = getInit().type();
      TypeDecl dest = type();
      if(source.assignConversionTo(dest, getInit()))
        return;
      StringBuffer s = new StringBuffer();
      toString(s);
      error("    " + s + "\n" +
        "The type of the right sub-expression, \"" + 
        source.typeName() + "\", is not assignable to the field" +
        ", of type \"" + dest.typeName() + "\".\n");
    }
  }

  // 5.2 Assignment Conversion
  public void AssignSimpleExpr.typeCheck() {
    if(!getDest().isVariable())
      error("left hand side is not a variable");
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    if(!source.isIllegal() && source.assignConversionTo(dest, getSource()))
      return;
    StringBuffer s = new StringBuffer();
    toString(s);
    error("    " + s + "\n" +
        "The type of the right sub-expression, \"" + 
        getSource().type().typeName() + "\", is not assignable to the variable" +
        ", of type \"" + getDest().type().typeName() + "\".\n");
  }
  
  public void AssignExpr.typeCheck() {
    if(!getDest().isVariable())
      error("left hand side is not a variable");
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    if(getSource().type().isPrimitive() && getDest().type().isPrimitive())
      return;
//    if(source != illegalType() && getsource.narrowingConversionTo(dest))
//      return;
       // TODO: getSource().representableIn(dest);
    StringBuffer s = new StringBuffer();
    toString(s);
    error("    " + s + "\n" +
        "The type of the right sub-expression, \"" + 
        getSource().type().typeName() + "\", is not assignable to the variable" +
        ", of type \"" + getDest().type().typeName() + "\".\n");
  }

  public void AssignMulExpr.typeCheck() {
    if(sourceType().isBoolean() || getDest().type().isBoolean()) {
      error("Operator * does not operate on boolean types");
    }
    super.typeCheck();
  }
  public void AssignDivExpr.typeCheck() {
    if(sourceType().isBoolean() || getDest().type().isBoolean()) {
      error("Operator / does not operate on boolean types");
    }
    super.typeCheck();
  }
  public void AssignModExpr.typeCheck() {
    if(sourceType().isBoolean() || getDest().type().isBoolean()) {
      error("Operator % does not operate on boolean types");
    }
    super.typeCheck();
  }
  public void AssignPlusExpr.typeCheck() {
    if(!getDest().isVariable())
      error("left hand side is not a variable");
    if(getDest().type().isString() && !(getSource().type().isVoid()))
      return;
    if(getSource().type().isBoolean() || getDest().type().isBoolean()) {
      error("Operator + does not operate on boolean types");
    }
    if(getSource().type().isPrimitive() && getDest().type().isPrimitive())
      return;
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    StringBuffer s = new StringBuffer();
    toString(s);
    error("    " + s + "\n" +
        "The type of the right sub-expression, \"" + 
        getSource().type().typeName() + "\", is not assignable to the variable" +
        ", of type \"" + getDest().type().typeName() + "\".\n");
  }
  public void AssignMinusExpr.typeCheck() {
    if(sourceType().isBoolean() || getDest().type().isBoolean()) {
      error("Operator - does not operate on boolean types");
    }
    super.typeCheck();
  }
  public void AssignLShiftExpr.typeCheck() {
    if(!sourceType().isIntegralType() || !getDest().type().isIntegralType()) {
      error("Operator << does only operate on integral types");
    }
    super.typeCheck();
  }
  public void AssignRShiftExpr.typeCheck() {
    if(!sourceType().isIntegralType() || !getDest().type().isIntegralType()) {
      error("Operator >> does only operate on integral types");
    }
    super.typeCheck();
  }
  public void AssignURShiftExpr.typeCheck() {
    if(!sourceType().isIntegralType() || !getDest().type().isIntegralType()) {
      error("Operator >>> does only operate on integral types");
    }
    super.typeCheck();
  }

  public void AssignAndExpr.typeCheck() {
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    if(source.isIntegralType() && dest.isIntegralType()) {
      super.typeCheck();
    }
    else if(source.isBoolean() && dest.isBoolean()) {
      super.typeCheck();
    }
    else {
      error("Operator & only operates on integral and boolean types");
    }
  }
  public void AssignOrExpr.typeCheck() {
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    if(source.isIntegralType() && dest.isIntegralType()) {
      super.typeCheck();
    }
    else if(source.isBoolean() && dest.isBoolean()) {
      super.typeCheck();
    }
    else {
      error("Operator | only operates on integral and boolean types");
      error("    not " + source.typeName() + " and " + dest.typeName());
    }
  }
  public void AssignXorExpr.typeCheck() {
    TypeDecl source = sourceType();
    TypeDecl dest = getDest().type();
    if(source.isIntegralType() && dest.isIntegralType()) {
      super.typeCheck();
    }
    else if(source.isBoolean() && dest.isBoolean()) {
      super.typeCheck();
    }
    else {
      error("Operator ^ only operates on integral and boolean types");
    }
  }

  syn TypeDecl AssignExpr.sourceType() {
    TypeDecl left = getDest().type();
    TypeDecl right = getSource().type();
    if(!right.isPrimitive())
      return illegalType();
    return right;
  }
  
  eq AssignPlusExpr.sourceType() {
    TypeDecl left = getDest().type();
    TypeDecl right = getSource().type();
    if(!left.isString() && !right.isString())
      return super.sourceType();
    if(left.isVoid() || right.isVoid())
      return illegalType();
    return left.isString() ? left : right;
  }
  
  syn TypeDecl AssignSimpleExpr.sourceType() = getSource().type();

  // 5.3 Method Invocation Conversion
  public void MethodAccess.typeCheck() {
    if(isQualified() && decl().isAbstract() && qualifier().isSuperAccess())
      error("may not access abstract methods in superclass");
    for(int i = 0; i < decl().getNumParameter(); i++) {
      TypeDecl exprType = getArg(i).type();
      TypeDecl parmType = decl().getParameter(i).type();
      if(!exprType.methodInvocationConversionTo(parmType) && !exprType.isUnknown() && !exprType.isIllegal() && !parmType.isUnknown() && !parmType.isIllegal()) {
        error("*The type " + exprType.typeName() + " of expr " +
            getArg(i) + " is not compatible with the method parameter " +
            decl().getParameter(i));
      }
    }
  }
          

  public void ArrayAccess.typeCheck() {
    if(isQualified() && !(qualifier().type().dimension() > 0) && !qualifier().type().isUnknown() && !qualifier().type().isIllegal())
      error("the type " + qualifier().type().name() + " of the indexed element is not an array");
    if(!getExpr().type().unaryNumericPromotion().isInt())
      error("array index must be int after unary numeric promotion which " + getExpr().type().typeName() + " is not");
  }

  public void ArrayInit.typeCheck() {
    TypeDecl initializerType = declType().componentType();
    if(initializerType.isIllegal())
      error("the dimension of the initializer is larger than the expected dimension");
    for(int i = 0; i < getNumInit(); i++) {
      Expr e = getInit(i);
      if(!e.type().assignConversionTo(initializerType, e))
        error("the type " + e.type().name() + " of the initializer is not compatible with " + initializerType.name()); 
    }
  }
  
  public void Binary.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(left.isNumericType() || right.isNumericType()) {
      if(left.binaryNumericPromotion(right).isIllegal() && !left.isUnknown() && !right.isUnknown())
        error(this + ", Left hand side " + left.typeName() + " is not compatible with right hand side " + right.typeName());
    }
    else if(!left.instanceOf(right) && !right.instanceOf(left) && !left.isUnknown() && !right.isUnknown()) {
      StringBuffer leftString = new StringBuffer();
      getLeftOperand().toString(leftString);
      StringBuffer rightString = new StringBuffer();
      getRightOperand().toString(rightString);
      StringBuffer thisString = new StringBuffer();
      toString(thisString);
      error("    " + thisString + "\n" + 
          "The type of the left hand side, \"" + 
          left.typeName() + "\", is not compatible with the type of the right hand side,\"" +
          right.typeName() + "\".\n");
    }
  }
  
  public void ArithmeticExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    TypeDecl type = left.binaryNumericPromotion(right);
    if(!left.isNumericType() && !left.isIllegal() && !left.isUnknown()) {
      error("The type " + left.typeName() + " of the left hand side is not numeric");
    }
    if(!right.isNumericType() && !right.isIllegal() && !right.isUnknown()) {
      error("The type " + right.typeName() + " of the right hand side is not numeric");
    }
    if(!type.isNumericType() && !left.isUnknown() && !right.isUnknown()) {
      StringBuffer leftString = new StringBuffer();
      getLeftOperand().toString(leftString);
      StringBuffer rightString = new StringBuffer();
      getRightOperand().toString(rightString);
      StringBuffer thisString = new StringBuffer();
      toString(thisString);
      error("    " + thisString + "\n" + 
          "The type of the left hand side, \"" + 
          left.typeName() + "\", is not compatible with the type of the right hand side,\"" +
          right.typeName() + "\".\n");
    }
  }

  public void RelationalExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(left.isNumericType() && !right.isNumericType()) {
      error("The type \"" + right.typeName() + "\" of the right hand side is not numeric");
    }
    else if(!left.isNumericType() && right.isNumericType()) {
      error("The type \"" + left.typeName() + "\" of the left hand side is not numeric");
    }
    else if(!left.isNumericType() && !right.isNumericType()) {
      error("Neither the type \"" + left.typeName() + "\" of the left hand side, nor the type \"" + 
            right.typeName() + "\" of the right hand side is numeric");
    }
  }

  public void LogicalExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(left.isBoolean() && !right.isBoolean()) {
      error("The type \"" + right.typeName() + "\" of the right hand side is not boolean");
    }
    else if(!left.isBoolean() && right.isBoolean()) {
      error("The type \"" + left.typeName() + "\" of the left hand side is not boolean");
    }
    else if(!left.isBoolean() && !right.isBoolean()) {
      error("Neither the type \"" + left.typeName() + "\" of the left hand side, nor the type \"" + 
            right.typeName() + "\" of the right hand side is boolean");
    }
  }

  public void EQExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(left.isNumericType() && right.isNumericType()) {
      return;
    }
    else if(left.isBoolean() && right.isBoolean()) {
      return;
    }
    else if((left.isReferenceType() || left.isNull()) && (right.isReferenceType() || right.isNull())) {
      if(left.castingConversionTo(right) || right.castingConversionTo(left))
        return;
    }
      StringBuffer leftString = new StringBuffer();
      getLeftOperand().toString(leftString);
      StringBuffer rightString = new StringBuffer();
      getRightOperand().toString(rightString);
      StringBuffer thisString = new StringBuffer();
      toString(thisString);
      error("    " + thisString + "\n" + 
          "The type of the left hand side, \"" + 
          left.typeName() + "\", is not compatible with the type of the right hand side,\"" +
          right.typeName() + "\".\n");
  }

  public void NEExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(left.isNumericType() && right.isNumericType()) {
      return;
    }
    else if(left.isBoolean() && right.isBoolean()) {
      return;
    }
    else if((left.isReferenceType() || left.isNull()) && (right.isReferenceType() || right.isNull())) {
      if(left.castingConversionTo(right) || right.castingConversionTo(left))
        return;
    }
      StringBuffer leftString = new StringBuffer();
      getLeftOperand().toString(leftString);
      StringBuffer rightString = new StringBuffer();
      getRightOperand().toString(rightString);
      StringBuffer thisString = new StringBuffer();
      toString(thisString);
      error("    " + thisString + "\n" + 
          "The type of the left hand side, \"" + 
          left.typeName() + "\", is not compatible with the type of the right hand side,\"" +
          right.typeName() + "\".\n");
  }



  // String add implicit cast conversion
  public void AddExpr.typeCheck() {
    TypeDecl left = getLeftOperand().type();
    TypeDecl right = getRightOperand().type();
    if(!left.isString() && !right.isString()) {
      super.typeCheck();
    }
    else if(left.isVoid()) {
      error("The type void of the left hand side is not numeric");
    }
    else if(right.isVoid()) {
      error("The type void of the right hand side is not numeric");
    }
  }     

  public void InstanceOfExpr.typeCheck() {
    TypeDecl relationalExpr = getExpr().type();
    TypeDecl referenceType = getTypeAccess().type();
    if(!relationalExpr.isReferenceType() && !relationalExpr.isNull())
      error("The relational expression in instance of must be reference or null type");
    if(!referenceType.isReferenceType())
      error("The reference expression in instance of must be reference type");
    if(!relationalExpr.castingConversionTo(referenceType))
      error("The type " + relationalExpr.typeName() + " of the relational expression " + 
        getExpr() +  " can not be cast into the type " + referenceType.typeName());
    if(getExpr().isTypeAccess())
      error("The relational expression " + getExpr() + " must not be a type name");
  }

  public void CastExpr.typeCheck() {
    TypeDecl expr = getExpr().type();
    TypeDecl type = getTypeAccess().type();
    if(!expr.castingConversionTo(type)) {
      StringBuffer s = new StringBuffer();
      toString(s);
      error("    " + s + "\n" +
          "An expression of type \"" + expr.typeName() + 
          "\" cannot be cast into type \"" + type.typeName() + "\".\n");
    }
    if(!getTypeAccess().isTypeAccess()) {
      error("" + getTypeAccess() + " is not a type access in cast expression");
    }
  }

  public void ParExpr.typeCheck() {
    if(getExpr().isTypeAccess())
      error("" + getExpr() + " is a type and may not be used in parenthesized expression");
  }

  public void PlusExpr.typeCheck() {
    if(!getOperand().type().isNumericType())
      error("unary plus only operates on numeric types");
  }
  public void MinusExpr.typeCheck() {
    if(!getOperand().type().isNumericType())
      error("unary minus only operates on numeric types");
  }

  public void BitNotExpr.typeCheck() {
    if(!getOperand().type().isIntegralType())
      error("unary ~ only operates on integral types");
  }

  public void LogNotExpr.typeCheck() {
    if(!getOperand().type().isBoolean())
      error("unary ! only operates on boolean types");
  }

  public void PostfixExpr.typeCheck() {
    if(!getOperand().isVariable())
      error("postfix expressions only work on variables");
    if(!getOperand().type().isNumericType())
      error("postfix expressions only operates on numeric types");
  }
  public void PreIncExpr.typeCheck() {
    if(!getOperand().isVariable())
      error("prefix increment expression only work on variables");
    if(!getOperand().type().isNumericType())
      error("unary increment only operates on numeric types");
  }
  public void PreDecExpr.typeCheck() {
    if(!getOperand().isVariable())
      error("prefix decrement expression only work on variables");
    if(!getOperand().type().isNumericType())
      error("unary decrement only operates on numeric types");
  }

  public void IfStmt.typeCheck() {
    TypeDecl cond = getCondition().type();
    if(!cond.isBoolean()) {
      error("the type of \"" + getCondition() + "\" is " + cond.name() + " which is not boolean");
    }
  }
  public void WhileStmt.typeCheck() {
    TypeDecl cond = getCondition().type();
    if(!cond.isBoolean()) {
      error("the type of \"" + getCondition() + "\" is " + cond.name() + " which is not boolean");
    }
  }
  public void DoStmt.typeCheck() {
    TypeDecl cond = getCondition().type();
    if(!cond.isBoolean()) {
      error("the type of \"" + getCondition() + "\" is " + cond.name() + " which is not boolean");
    }
  }

  public void SwitchStmt.typeCheck() {
    TypeDecl type = getExpr().type();
    if(!type.isIntegralType() || type.isLong())
      error("Switch expression must be of char, byte, short, or int");
  }

  public void ConstCase.typeCheck() {
    TypeDecl switchType = switchType();
    TypeDecl type = getValue().type();
    if(!type.assignConversionTo(switchType, getValue()))
      error("Constant expression must be assignable to Expression");
    if(!getValue().isConstant())
      error("Switch expression must be constant");
  }

  inh TypeDecl Case.switchType();
  eq SwitchStmt.getCase().switchType() = getExpr().type();

  public void SynchronizedStmt.typeCheck() {
    TypeDecl type = getExpr().type();
    if(!type.isReferenceType() || type.isNull())
      error("*** The type of the expression must be a reference");
  }

  public void CatchClause.typeCheck() {
    if(!getParameter().type().instanceOf(typeThrowable()))
      error("*** The catch variable must extend Throwable");
  }

  public void ThrowStmt.typeCheck() {
    if(!getExpr().type().instanceOf(typeThrowable()))
      error("*** The thrown expression must extend Throwable");
  }

  public void MethodDecl.typeCheck() {
    // Thrown vs super class method see MethodDecl.nameCheck
    // 8.4.4
    TypeDecl exceptionType = typeThrowable();
    for(int i = 0; i < getNumException(); i++) {
      TypeDecl typeDecl = getException(i).type();
      if(!typeDecl.instanceOf(exceptionType))
        error(signature() + " throws non throwable type " + typeDecl.fullName());
    }

    // check returns
    if(!isVoid() && hasBlock() && getBlock().canCompleteNormally())
      error("the body of a non void method may not complete normally");

  }
  // 14.16
  public void ReturnStmt.typeCheck() {
    if(hasResult() && !hostBodyDecl().isVoid() && hostBodyDecl() instanceof MethodDecl) {
      MethodDecl m = (MethodDecl)hostBodyDecl();
      if(!getResult().type().assignConversionTo(m.type(), getResult()))
        error("return value must be an instance of " + m.type().typeName() + " which " + getResult().type().typeName() + " is not");
    }
    // 8.4.5 8.8.5
    if(hostBodyDecl().isVoid() && hasResult())
      error("return stmt may not have an expression in void methods");
    // 8.4.5
    if(!hostBodyDecl().isVoid() && !hasResult())
      error("return stmt must have an expression in non void methods");
    if(hostBodyDecl() instanceof InstanceInitializer || hostBodyDecl() instanceof StaticInitializer)
      error("Initializers may not return");

  }

  public void ConstructorDecl.typeCheck() {
    // 8.8.4 (8.4.4)
    TypeDecl exceptionType = typeThrowable();
    for(int i = 0; i < getNumException(); i++) {
      TypeDecl typeDecl = getException(i).type();
      if(!typeDecl.instanceOf(exceptionType))
        error(signature() + " throws non throwable type " + typeDecl.fullName());
    }
  }

  inh TypeDecl SuperConstructorAccess.enclosingInstance();
  inh TypeDecl ClassInstanceExpr.enclosingInstance();
  inh TypeDecl TypeDecl.enclosingInstance();
  eq Program.getCompilationUnit().enclosingInstance() = null;
  eq StaticInitializer.getBlock().enclosingInstance() = null;
  //eq InstanceInitializer.getBlock().enclosingInstance() = null;
  eq TypeDecl.getBodyDecl().enclosingInstance() {
    if(getBodyDecl(childIndex) instanceof MemberTypeDecl && !((MemberTypeDecl)getBodyDecl(childIndex)).getTypeDecl().isInnerType())
      return null;
    if(getBodyDecl(childIndex) instanceof ConstructorDecl)
      return enclosingInstance();
    return this;
  }
  eq AbstractDot.getRight().enclosingInstance() = getLeft().type();

  inh TypeDecl ConstructorDecl.illegalType();
  eq ConstructorDecl.getConstructorInvocation().enclosingInstance() = illegalType();

  syn boolean ClassInstanceExpr.noEnclosingInstance() = isQualified() ? qualifier().staticContextQualifier() : inStaticContext();
  
  public void ClassInstanceExpr.typeCheck() {
    if(isQualified() && qualifier().isTypeAccess())
      error("*** The expression in a qualified class instance expr must not be a type name");
    // 15.9
    if(isQualified() && !type().isInnerClass() && !((ClassDecl)type()).superclass().isInnerClass()) {
      error("*** Qualified class instance creation can only instantiate inner classes and their anonymous subclasses");
    }
    if(!type().isClassDecl()) {
      error("*** Can only instantiate classes, which " + type().typeName() + " is not"); 
    }
    TypeDecl C = type();
    if(C.isInnerClass()) {
      TypeDecl enclosing = null;
      if(C.isAnonymous()) {
        if(noEnclosingInstance()) {
          enclosing = null;
        }
        else {
          enclosing = hostType();
        }
      }
      else if(C.isLocalClass()) {
        TypeDecl O = C.enclosingType();
        int n = 0;
        for(TypeDecl nest = hostType(); nest != O; nest = nest.enclosingType())
          n++;
        if(C.inStaticContext()) {
          enclosing = null;
        }
        else if(noEnclosingInstance()) {
          enclosing = illegalType();
        }
        else {
          enclosing = O;
        }
      }
      else if(C.isMemberType()) {
        if(!isQualified()) {
          if(noEnclosingInstance()) {
            System.err.println("ClassInstanceExpr: Non qualified MemberType " + C.typeName() + " is in a static context when instantiated in " + this);
            enclosing = illegalType();
          }
          else {
            TypeDecl nest = hostType();
            while(nest != null && !nest.instanceOf(C.enclosingType()))
              nest = nest.enclosingType();
            enclosing = nest == null ? illegalType() : nest;
          }
        }
        else {
          enclosing = enclosingInstance();
        }
      }
      if(enclosing != null && !enclosing.instanceOf(type().enclosingType())) {
        String msg = enclosing == null ? "None" : enclosing.typeName();
        error("*** Can not instantiate " + type().typeName() + " with the enclosing instance " + msg + " due to incorrect enclosing instance");
      }
      else if(!isQualified() && C.isMemberType() && inExplicitConstructorInvocation() && enclosing == hostType()) {
        error("*** The innermost enclosing instance of type " + enclosing.typeName() + " is this which is not yet initialized here.");
      }
      if(type().isAnonymous() && ((ClassDecl)type()).superclass().isInnerType()) {
        TypeDecl S = ((ClassDecl)type()).superclass();
        if(S.isLocalClass()) {
          if(S.inStaticContext()) {
          }
          else if(noEnclosingInstance()) {
            error("*** No enclosing instance to class " + type().typeName() + " due to static context");
          }
          else if(inExplicitConstructorInvocation())
            error("*** No enclosing instance to superclass " + S.typeName() + " of " + type().typeName() + " since this is not initialized yet");
        }
        else if(S.isMemberType()) {
          if(!isQualified()) {
            // 15.9.2 2nd paragraph
            if(noEnclosingInstance()) {
              error("*** No enclosing instance to class " + type().typeName() + " due to static context");
            }
            else {
              TypeDecl nest = hostType();
              while(nest != null && !nest.instanceOf(S.enclosingType()))
                nest = nest.enclosingType();
              if(nest == null) {
                error("*** No enclosing instance to superclass " + S.typeName() + " of " + type().typeName());
              }
              else if(inExplicitConstructorInvocation()) {
                error("*** No enclosing instance to superclass " + S.typeName() + " of " + type().typeName() + " since this is not initialized yet");
              }
            }
          }
        }
      }
      
    }
  }

  public void ArrayCreationExpr.typeCheck() {
    super.typeCheck();
    for(int i = 0; i < getNumDims(); i++) {
      if(getDims(i).hasExpr() && !getDims(i).getExpr().type().unaryNumericPromotion().isInt())
        error("The type of dimension " + i + " which is " + getDims(i).getExpr().type().typeName() +
              " is not int after unary numeric promotion");
    }
  }

  public void ConditionalExpr.typeCheck() {
    if(!getCondition().type().isBoolean())
      error("*** First expression must be a boolean in conditional operator");
    if(type().isIllegal()) {
      error("*** Operands in conditional operator does not match"); 
    }
  }

 public void IntegerLiteral.typeCheck() {
   if(constant().error)
     error("The value of an int literal must be a decimal value in the range -2147483648..2147483647 or a hexadecimal or octal literal that fits in 32 bits.");

 }
 public void LongLiteral.typeCheck() {
   if(constant().error)
     error("The value of the long literal " + getLITERAL() + " is not legal");

 }

 public void FloatingPointLiteral.typeCheck() {
   if(!isZero() && constant().floatValue() == 0.0f)
     error("It is an error for nonzero floating-point " + getLITERAL() + " to round to zero");
   if(constant().floatValue() == Float.NEGATIVE_INFINITY || constant().floatValue() == Float.POSITIVE_INFINITY)
     error("It is an error for floating-point " + getLITERAL() + " to round to an infinity");
     
 }
 public void DoubleLiteral.typeCheck() {
   if(!isZero() && constant().doubleValue() == 0.0f)
     error("It is an error for nonzero floating-point " + getLITERAL() + " to round to zero");
   if(constant().doubleValue() == Double.NEGATIVE_INFINITY || constant().doubleValue() == Double.POSITIVE_INFINITY)
     error("It is an error for floating-point " + getLITERAL() + " to round to an infinity");
 }
} 

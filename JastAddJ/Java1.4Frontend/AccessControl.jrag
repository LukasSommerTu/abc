aspect AccessControl {

  eq CompilationUnit.getTypeDecl().enclosingType() = null;
  eq CompilationUnit.getImportDecl().enclosingType() = null;
  
  eq TypeDecl.getBodyDecl().enclosingType() = this;

  inh TypeDecl TypeDecl.enclosingType();
  syn TypeDecl TypeDecl.topLevelType() {
    if(isTopLevelType())
      return this;
    return enclosingType().topLevelType();
  }

  // 8
  inh boolean TypeDecl.isNestedType();
  eq CompilationUnit.getTypeDecl().isNestedType() = false;
  eq CompilationUnit.getImportDecl().isNestedType() = false;
  eq TypeDecl.getBodyDecl().isNestedType() = true;

  // 8
  syn boolean TypeDecl.isTopLevelType() = !isNestedType();

  // 8.5
  inh boolean TypeDecl.isMemberType();
  eq MemberClassDecl.getClassDecl().isMemberType() = true;
  eq MemberInterfaceDecl.getInterfaceDecl().isMemberType() = true;
  eq CompilationUnit.getTypeDecl().isMemberType() = false;
  eq ClassInstanceExpr.getTypeDecl().isMemberType() = false;
  
  // 8.1.2
  syn boolean TypeDecl.isInnerClass() = false;
  eq ClassDecl.isInnerClass() = isNestedType() && !isStatic() && enclosingType().isClassDecl();
  syn boolean TypeDecl.isInnerType() = (isLocalClass() || isAnonymous() || (isMemberType() && !isStatic())) && !inStaticContext();

  syn boolean TypeDecl.isInnerTypeOf(TypeDecl typeDecl) = typeDecl == this || (isInnerType() && enclosingType().isInnerTypeOf(typeDecl));

  inh boolean TypeDecl.isLocalClass();
  eq CompilationUnit.getTypeDecl().isLocalClass() = false;
  eq CompilationUnit.getImportDecl().isLocalClass() = false;
  eq TypeDecl.getBodyDecl().isLocalClass() = false;
  eq LocalClassDeclStmt.getClassDecl().isLocalClass() = true;
  
  syn TypeDecl TypeDecl.withinBodyThatSubclasses(TypeDecl type) {
    if(instanceOf(type))
      return this;
    if(!isTopLevelType())
      return enclosingType().withinBodyThatSubclasses(type);
    return null;
  }
  
  syn boolean TypeDecl.encloses(TypeDecl type) = type.enclosedBy(this);

  syn boolean TypeDecl.enclosedBy(TypeDecl type) {
    if(this == type)
      return true;
    if(isTopLevelType())
      return false;
    return enclosingType().enclosedBy(type);
  }

  eq CompilationUnit.getTypeDecl().hostPackage() = packageName();
  eq CompilationUnit.getImportDecl().hostPackage() = packageName();

  inh String TypeDecl.hostPackage();
  inh String BodyDecl.hostPackage();
  inh String Expr.hostPackage();
  
  syn TypeDecl TypeDecl.hostType() = this;
  eq TypeDecl.getBodyDecl().hostType() = hostType();
  eq ClassInstanceExpr.getTypeDecl().hostType() = hostType();
  eq PrimitiveType.getSuperClassAccess().hostType() = hostType();
  eq ClassDecl.getSuperClassAccess().hostType() = hostType();
  eq ClassDecl.getImplements().hostType() = hostType();
  eq InterfaceDecl.getSuperInterfaceId().hostType() = hostType();
  
  eq Program.getCompilationUnit().hostType() = null;
  inh TypeDecl CompilationUnit.illegalType();
  eq CompilationUnit.getImportDecl().hostType() = null;
  
  inh TypeDecl BodyDecl.hostType();
  inh TypeDecl Expr.hostType();
  inh TypeDecl VariableDeclaration.hostType();
  inh TypeDecl ParameterDeclaration.hostType();

  inh BodyDecl Stmt.hostBodyDecl();
  eq Program.getCompilationUnit().hostBodyDecl() { throw new UnsupportedOperationException(); }
  eq InstanceInitializer.getBlock().hostBodyDecl() = this;
  eq StaticInitializer.getBlock().hostBodyDecl() = this;
  eq MethodDecl.getBlock().hostBodyDecl() = this;
  eq ConstructorDecl.getBlock().hostBodyDecl() = this;
  eq ConstructorDecl.getConstructorInvocation().hostBodyDecl() = this;
  eq FieldDeclaration.getInit().hostBodyDecl() = this;
 
  // 6.6 Access Control
  
  syn boolean ArrayDecl.accessibleFrom(TypeDecl type) = elementType().accessibleFrom(type);
 
  syn boolean TypeDecl.accessibleFromPackage(String packageName) =
    !isPrivate() && (isPublic() || hostPackage().equals(packageName));
  
  syn boolean TypeDecl.accessibleFromExtend(TypeDecl type) {
    if(type == this)
      return true;
    if(isInnerType()) { 
      if(!enclosingType().accessibleFrom(type)) {
        return false;
      }
    }
    if(isPublic()) 
      return true;
    else if(isProtected()) {
      // isProtected implies a nested type
      if(hostPackage().equals(type.hostPackage())) {
        return true;
      }
      if(type.isNestedType() && type.enclosingType().withinBodyThatSubclasses(enclosingType()) != null)
        return true;
      return false;
    }
    else if(isPrivate()) {
      return topLevelType() == type.topLevelType();
    }
    else
      return hostPackage().equals(type.hostPackage());
  }
 
  syn lazy boolean TypeDecl.accessibleFrom(TypeDecl type) {
    if(type == this)
      return true;
    if(isInnerType()) { 
      if(!enclosingType().accessibleFrom(type)) {
        return false;
      }
    }
    if(isPublic()) {  
      return true;
    }
    else if(isProtected()) {
      if(hostPackage().equals(type.hostPackage())) {
        return true;
      }
      if(isMemberType()) {
        TypeDecl typeDecl = type;
        while(typeDecl != null && !typeDecl.instanceOf(enclosingType()))
          typeDecl = typeDecl.enclosingType();
        if(typeDecl != null) {
          return true;
        }
      }
      return false;
    }
    else if(isPrivate()) {
      return topLevelType() == type.topLevelType();
    }
    else {
      return hostPackage().equals(type.hostPackage());
    }
  }

  syn lazy boolean MethodDecl.accessibleFrom(TypeDecl type) {
    if(isPublic()) {
      return true;
    }
    else if(isProtected()) {
      if(hostPackage().equals(type.hostPackage()))
        return true;
      if(type.withinBodyThatSubclasses(hostType()) != null)
        return true;
      return false;
    }
    else if(isPrivate())
      return hostType().topLevelType() == type.topLevelType();
    else
      return hostPackage().equals(type.hostPackage());
  }
  
  syn lazy boolean ConstructorDecl.accessibleFrom(TypeDecl type) {
    if(!hostType().accessibleFrom(type))
      return false;
    else if(isPublic())
      return true;
    else if(isProtected()) {
      return true;
    }
    else if(isPrivate()) {
      return hostType().topLevelType() == type.topLevelType();
    }
    else
      return hostPackage().equals(type.hostPackage());
  }
  
  syn lazy boolean FieldDeclaration.accessibleFrom(TypeDecl type, TypeDecl qualifierType) {
    if(isPublic())
      return true;
    else if(isProtected()) {
      if(hostPackage().equals(type.hostPackage()))
        return true;
      TypeDecl C = hostType();
      TypeDecl S = type.subclassWithinBody(C);
      TypeDecl Q = type();
      return S != null && (!isInstanceVariable() || Q.instanceOf(S));
    }
    else if(isPrivate())
      return hostType().topLevelType() == type.topLevelType();
    else
      return hostPackage().equals(type.hostPackage());
  }

  syn lazy boolean FieldDeclaration.accessibleFrom(TypeDecl type) {
    if(isPublic())
      return true;
    else if(isProtected()) {
      if(hostPackage().equals(type.hostPackage()))
        return true;
      if(type.withinBodyThatSubclasses(hostType()) != null)
        return true;
      return false;
    }
    else if(isPrivate())
      return hostType().topLevelType() == type.topLevelType();
    else
      return hostPackage().equals(type.hostPackage());
  }
    
  public void ASTNode.accessControl() {
  }
  
  public void TypeAccess.accessControl() {
    super.accessControl();
    TypeDecl hostType = hostType();
    if(hostType != null && !hostType.isIllegal() && !type().accessibleFrom(hostType)) {
      error("" + this + " in " + hostType().fullName() + " can not access type " + type().fullName());
    }
    else if((hostType == null || hostType.isIllegal())  && !type().accessibleFromPackage(hostPackage())) {
      error("" + this + " can not access type " + type().fullName());
    }
  }

  public void ClassInstanceExpr.accessControl() {
    super.accessControl();
    if(type().isAbstract())
      error("Can not instantiate abstract class " + type().fullName());
    if(!decl().accessibleFrom(hostType()))
      error("constructor " + decl().signature() + " is not accessible");
  }
  
  public void ClassDecl.accessControl() {
    super.accessControl();
    
    // 8.1.1.2 final Classes
    TypeDecl typeDecl = hasSuperclass() ? superclass() : null;
    if(typeDecl != null && typeDecl.isFinal()) {
      error("class " + fullName() + " may not extend final class " + typeDecl.fullName());
    }
    if(typeDecl != null && !typeDecl.accessibleFromExtend(this))
    //if(typeDecl != null && !isCircular() && !typeDecl.accessibleFrom(this))
      error("class " + fullName() + " may not extend non accessible type " + typeDecl.fullName());

    // 8.1.3
    if(isCircular())
      error("class " + fullName() + " depends on itself");

 
    // 8.1.4
    Set set = new HashSet();
    for(int i = 0; i < getNumImplements(); i++) {
      TypeDecl decl = getImplements(i).type();
      if(!decl.isInterfaceDecl())
        error("type " + fullName() + " tries no implement non interface type " + decl.fullName());
      if(!decl.isCircular() && !decl.accessibleFrom(this))
        error("class " + fullName() + " can not implement non accessible type " + decl.fullName());
      if(set.contains(decl))
        error("type " + decl.fullName() + " mentionened multiple times in implements clause");
      set.add(decl);
    }
  }

  public void InterfaceDecl.accessControl() {
    super.accessControl();
    
    // 8.1.3
    if(isCircular())
      error("interface " + fullName() + " depends on itself");
    else {
      // 9.1.2
      Set set = new HashSet();
      for(int i = 0; i < getNumSuperInterfaceId(); i++) {
        TypeDecl decl = getSuperInterfaceId(i).type();

        if(!decl.isInterfaceDecl())
          error("interface " + fullName() + " tries no extend non interface type " + decl.fullName());
        if(!decl.isCircular() && !decl.accessibleFrom(this))
          error("interface " + fullName() + " can not extend non accessible type " + decl.fullName());

        if(set.contains(decl))
          error("extended interface " + decl.fullName() + " mentionened multiple times in extends clause");
        set.add(decl);
      }
    }
  }
}

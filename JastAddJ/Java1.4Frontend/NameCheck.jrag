aspect NameCheck {
  public void ASTNode.nameCheck() {
  }

  public TypeDecl ASTNode.extractSingleType(TypeCollection c) {
    if(c.size() != 1)
      return null;
    return c.first();
  }

  public void SingleTypeImportDecl.nameCheck() {
    if(!getAccess().type().typeName().equals(typeName()) && !getAccess().type().isUnknown())
      error("Single-type import " + typeName() + " is not the canonical name of type " + getAccess().type().typeName());
  }
  public void TypeImportOnDemandDecl.nameCheck() {
    if(getAccess().lastAccess().isTypeAccess() && !getAccess().type().typeName().equals(typeName()))
      error("On demand type import " + typeName() + ".* is not the canonical name of type " + getAccess().type().typeName());
  }

  public void CompilationUnit.nameCheck() {
    for(int i = 0; i < getNumImportDecl(); i++) {
      ImportDecl decl = getImportDecl(i);
      if(decl instanceof SingleTypeImportDecl) {
        if(!localLookupType(decl.getAccess().type().name()).contains(decl.getAccess().type()))
          error("" + decl + " is conflicting with visible type");
      }
    }
  }

  public void PackageAccess.nameCheck() {
    if(!hasPackage(packageName())) {
      error("package " + packageName() + " does not exist but is used in " + enclosingStmt());
    }
  }

  public void AmbiguousAccess.nameCheck() {
    error("ambiguous name " + name() + " is used in " + enclosingStmt());
  }
  
  public void PackageOrTypeAccess.nameCheck() {
    error("packageortype name " + name() + " is used in " + enclosingStmt());
  }

  inh String MethodAccess.methodHost();
  eq TypeDecl.getBodyDecl().methodHost() = typeName();
  eq AbstractDot.getRight().methodHost() = getLeft().type().typeName();
  eq Program.getCompilationUnit().methodHost() {
    throw new Error("Needs extra equation for methodHost()");
  }
  
  syn boolean Expr.isUnknown() = type().isUnknown();
  eq PackageAccess.isUnknown() = !hasPackage(packageName());
  
  public void MethodAccess.nameCheck() {
    if(isQualified() && qualifier().isPackageAccess() && !qualifier().isUnknown())
      error("The method " + decl().signature() + 
          " can not be qualified by a package name.");
    if(isQualified() && qualifier().isSuperAccess() && decl().isAbstract())
      error("Invoking an abstract method through super.method() is invalid");
    if(decl() == unknownMethod() && decls().size() <= 1 && (!isQualified() || !qualifier().isUnknown())) {
      StringBuffer s = new StringBuffer();
      s.append("no method named " + name());
      s.append("(");
      for(int i = 0; i < getNumArg(); i++) {
        if(i != 0)
          s.append(", ");
        s.append(getArg(i).type().typeName());
      }
      s.append(")" + " in " + methodHost() + " matches " + this);
      error(s.toString());
    }
    if(decls().size() > 1) {
      boolean allAbstract = true;
      for(MethodCollection.MethodIterator iter = decls().iterator(); iter.hasNext() && allAbstract; ) {
        if(!((MethodDecl)iter.next()).isAbstract())
          allAbstract = false;
      }
      if(!allAbstract) {
        StringBuffer s = new StringBuffer();
        s.append("several most specific methods for " + this + "\n");
        for(MethodCollection.MethodIterator iter = decls().iterator(); iter.hasNext(); ) {
          MethodDecl m = (MethodDecl)iter.next();
          s.append("    " + m.signature() + " in " + m.hostType().typeName() + "\n");
        }
        error(s.toString());
      }
       
    }
  }


  public void ConstructorDecl.nameCheck() {
    super.nameCheck();
    // 8.8
    if(!hostType().name().equals(name()))
      error("constructor " + name() +" does not have the same name as the simple name of the host class " + hostType().name());
    
    // 8.8.2
    if(hostType().lookupConstructor(this) != this)
      error("constructor with signature " + signature() + " is multiply declared in type " + hostType().typeName());

    if(circularThisInvocation(this))
      error("The constructor " + signature() + " may not directly or indirectly invoke itself");
  }

  // 8.8.5
  syn boolean ConstructorDecl.circularThisInvocation(ConstructorDecl decl) {
    if(hasConstructorInvocation()) {
      Expr e = ((ExprStmt)getConstructorInvocation()).getExpr();
      if(e instanceof ConstructorAccess) {
        ConstructorDecl constructorDecl = ((ConstructorAccess)e).decl();
        if(constructorDecl == decl)
          return true;
        return constructorDecl.circularThisInvocation(decl);
      }
    }
    return false;
  }

  public void MethodDecl.nameCheck() {
    // 8.4
    // 8.4.2
    if(!hostType().localLookupMethod(this).contains(this))
      error("method with signature " + signature() + " is multiply declared in type " + hostType().typeName());
    // 8.4.3.4
    if(isNative() && hasBlock())
      error("native methods must have an empty semicolon body");
    // 8.4.5
    if(isAbstract() && hasBlock())
      error("abstract methods must have an empty semicolon body");
    // 8.4.5
    if(!hasBlock() && !(isNative() || isAbstract()))
      error("only abstract and native methods may have an empty semicolon body");
  }

  public void ConstructorAccess.nameCheck() {
    super.nameCheck();
    if(decl() == illegalConstructor() && decls().size() <= 1)
      error("no constructor named " + name());
    if(decls().size() > 1) {
      error("several most specific constructors for " + this);
      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
        error("         " + ((ConstructorDecl)iter.next()).signature());
      }
    }
  }

  public void ClassInstanceExpr.nameCheck() {
    super.nameCheck();
    if(decl() == illegalConstructor() && decls().size() <= 1)
      error("can not instantiate " + type().typeName() + " no matching constructor found in " + type().typeName());
    else if(decls().size() > 1) {
      error("several most specific constructors found");
      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
        error("         " + ((ConstructorDecl)iter.next()).signature());
      }
    }
  }
    
  
  public void SuperConstructorAccess.nameCheck() {
    super.nameCheck();
    // 8.8.5.1
    TypeDecl c = hostType();
    TypeDecl s = c.isClassDecl() && ((ClassDecl)c).hasSuperclass() ? ((ClassDecl)c).superclass() : illegalType();
    if(isQualified()) {
      if(!s.isInnerType() || s.inStaticContext())
        error("the super type " + s.typeName() + " of " + c.typeName() +
           " is not an inner class");
    
      else if(!qualifier().type().instanceOf(s.enclosingType()))
        error("The type of this primary expression, " +
                qualifier().type().typeName() + " is not enclosing the super type, " + 
                s.typeName() + ", of " + c.typeName());
    }
    if(!isQualified() && s.isInnerType()) {
      if(!c.isInnerType()) {
        error("" + s.typeName() + " isStatic: " + s.isStatic() + ", enclosingType: " + s.enclosingType().typeName());

        error("no enclosing instance for " + s.typeName() + " when accessed in " + this);
      }
    }
  }

  // 8.8.5.1
  inh boolean VarAccess.inExplicitConstructorInvocation();
  inh boolean MethodAccess.inExplicitConstructorInvocation();
  inh boolean SuperAccess.inExplicitConstructorInvocation();
  inh boolean ThisAccess.inExplicitConstructorInvocation();
  inh boolean ClassInstanceExpr.inExplicitConstructorInvocation();
  inh lazy boolean TypeDecl.inExplicitConstructorInvocation();
  eq Program.getCompilationUnit().inExplicitConstructorInvocation() = false;

  eq ConstructorAccess.getArg().inExplicitConstructorInvocation() = true;
  eq SuperConstructorAccess.getArg().inExplicitConstructorInvocation() = true;


  inh boolean Expr.inStaticContext(); // SuperAccess, ThisAccess, ClassInstanceExpr, MethodAccess
  inh lazy boolean TypeDecl.inStaticContext();
  
  eq Program.getCompilationUnit().inStaticContext() = false;
  eq TypeDecl.getBodyDecl().inStaticContext() = isStatic() || inStaticContext();
  eq StaticInitializer.getBlock().inStaticContext() = true;
  eq InstanceInitializer.getBlock().inStaticContext() = false;
  eq FieldDeclaration.getInit().inStaticContext() = isStatic() || hostType().isInterfaceDecl();
  eq MethodDecl.getBlock().inStaticContext() = isStatic();
  eq ConstructorDecl.getBlock().inStaticContext() = false;
  eq MemberClassDecl.getClassDecl().inStaticContext() = false;
  
  eq ClassInstanceExpr.getTypeDecl().inStaticContext() = isQualified() ?
    qualifier().staticContextQualifier() : inStaticContext();

  syn boolean Expr.staticContextQualifier() = false;
  eq ParExpr.staticContextQualifier() = getExpr().staticContextQualifier();
  eq CastExpr.staticContextQualifier() = getExpr().staticContextQualifier();
  eq AbstractDot.staticContextQualifier() = lastAccess().staticContextQualifier();
  eq TypeAccess.staticContextQualifier() = true;
  
  public void ArrayTypeAccess.nameCheck() {
    if(decl().elementType() == unknownType())
      error("no type named " + name());
  }
  
  public void TypeAccess.nameCheck() {
    if(isQualified() && !qualifier().isTypeAccess() && !qualifier().isPackageAccess())
      error("can not access the type named " + decl().typeName() + " in this context");
    if(decl() == unknownType() && decls().size() <= 1)
      error("no type named " + name());
    if(decls().size() > 1) {
      error("several types named " + name());
      for(TypeCollection.TypeIterator iter = decls().iterator(); iter.hasNext(); ) {
        TypeDecl t = (TypeDecl)iter.next();
        error("    " + t.typeName());
      }
    }
  }

  public void SuperAccess.nameCheck() {
    if(isQualified()) {
      if(!hostType().isInnerTypeOf(qualifier().type()) && hostType() != qualifier().type())
        error("qualified super must name an enclosing type");
      if(inStaticContext()) {
        error("*** Qualified super may not occur in static context");
      }
    }
    // 8.8.5.1
    if(inExplicitConstructorInvocation() && hostType().instanceOf(decl().hostType()) )
      error("super may not be accessed in an explicit constructor invocation");
    // 8.4.3.2
    if(inStaticContext())
      error("super may not be accessed in a static context");
  }

  public void ThisAccess.nameCheck() {
    if(isQualified()) {
      // 15.8.4
      if(!hostType().isInnerTypeOf(qualifier().type()) && hostType() != qualifier().type())
        error("qualified this must name an enclosing type: " + getParent());
      if(inStaticContext()) {
        error("*** Qualified this may not occur in static context");
      }
    }
    // 8.8.5.1
    if(inExplicitConstructorInvocation() && hostType() == type())
      error("this may not be accessed in an explicit constructor invocation");
    // 8.4.3.2
    if(inStaticContext())
      error("this may not be accessed in static context: " + enclosingStmt());
  }
  

  public void ClassAccess.nameCheck() {
    if(isQualified() && !qualifier().isTypeAccess())
      error("class literal may only contain type names");
  }

  public void VarAccess.nameCheck() {
    if(decl() == unknownField() && decls().size() <= 1)
      error("no field named " + name());
    if(decls().size() > 1) {
      error("several fields named " + name());
      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
        Variable v = (Variable)iter.next();
        error("    " + v.type().typeName() + "." + v.name() + " declared in " + v.hostType().typeName());
      }
       
    }
      
    // 8.8.5.1
    if(inExplicitConstructorInvocation() && !isQualified() && decl().isInstanceVariable() && hostType() ==  decl().hostType())
      error("instance variable " + name() + " may not be accessed in an explicit constructor invocation");

    Variable v = decl();
    if(!v.isFinal() && !v.isClassVariable() && !v.isInstanceVariable() && v.hostType() != hostType())
      error("A parameter/variable used but not declared in an inner class must be declared final");

    // 8.3.2.3
    if((decl().isInstanceVariable() || decl().isClassVariable()) && !isQualified()) {
      if(!hostType().declaredBeforeUse(decl(), this)) {
        if(inSameInitializer() && !simpleAssignment() && inDeclaringClass()) {
          BodyDecl b = closestBodyDecl(hostType());
          error("variable " + decl().name() + " is used in " + b + " before it is declared");
        }
      }
    }

  }

  // find the bodydecl declared in t in which this construct is nested
  public BodyDecl VarAccess.closestBodyDecl(TypeDecl t) {
    ASTNode node = this;
    while(!(node.getParent().getParent() instanceof Program) && node.getParent().getParent() != t) {
      node = node.getParent();
    }
    if(node instanceof BodyDecl)
      return (BodyDecl)node;
    return null;
  }

  syn boolean VarAccess.inSameInitializer() {
    BodyDecl b = closestBodyDecl(decl().hostType());
    if(b == null) return false;
    if(b instanceof FieldDeclaration && ((FieldDeclaration)b).isStatic() == decl().isStatic())
      return true;
    if(b instanceof InstanceInitializer && !decl().isStatic())
      return true;
    if(b instanceof StaticInitializer && decl().isStatic())
      return true;
    return false;
  }

  syn boolean VarAccess.simpleAssignment() = isDest() && getParent() instanceof AssignSimpleExpr;

  syn boolean VarAccess.inDeclaringClass() = hostType() == decl().hostType();

  inh boolean TypeDecl.hasPackage(String packageName);
  inh boolean PackageAccess.hasPackage(String packageName);

  inh ASTNode TypeDecl.enclosingBlock();
  eq MethodDecl.getBlock().enclosingBlock() = this;
  eq ConstructorDecl.getBlock().enclosingBlock() = this;
  eq InstanceInitializer.getBlock().enclosingBlock() = this;
  eq Program.getCompilationUnit().enclosingBlock() = null;

  public void TypeDecl.nameCheck() {
    if(isTopLevelType() && lookupType(packageName(), name()) != this)
      error("duplicate member " + name() + " in compilation unit");
  
    if(!isTopLevelType() && !isAnonymous() && !isLocalClass() && extractSingleType(enclosingType().remoteLookupType(name())) != this)
      error("duplicate member type " + name() + " in type " + enclosingType().typeName());

    // 14.3
    if(isLocalClass()) {
      TypeDecl typeDecl = extractSingleType(lookupType(name()));
      if(typeDecl != null && typeDecl != this && typeDecl.isLocalClass() && enclosingBlock() == typeDecl.enclosingBlock())
        error("local class named " + name() + " may not be redeclared as a local class in the same block");
    }

    if(!packageName().equals("") && hasPackage(typeName()))
      error("duplicate member class and package " + name());
    
    // 8.1 & 9.1
    if(hasEnclosingTypeDecl(name())) {
      error("type may not have the same simple name as an enclosing type declaration");
    }

    // 8.4.6.4 & 9.4.1
    for(Iterator iter = methods().iterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();

      for(Iterator i2 = overrides(m).iterator(); i2.hasNext(); ) {
        MethodDecl decl = (MethodDecl)i2.next();
        // 8.4.6.1
        if(!m.isStatic() && decl.isStatic())
          error("an instance method may not override a static method");
        // 8.4.6.3
        if(m.type() != decl.type())
          error("the return type of method " + m.signature() + " in " + m.hostType().typeName() + " does not match the return type of method " + decl.signature() + " in " + decl.hostType().typeName() + " and may thus not be overriden");
        // 8.4.4
        for(int i = 0; i < m.getNumException(); i++) {
          Access e = m.getException(i);
          boolean found = false;
          for(int j = 0; !found && j < decl.getNumException(); j++) {
            if(e.type().instanceOf(decl.getException(j).type()))
              found = true;
          }
          if(!found && e.type().isUncheckedException())
            error(m.signature() + " in " + m.hostType().typeName() + " may not throw more checked exceptions than overridden method " +
             decl.signature() + " in " + decl.hostType().typeName());
        }
        // 8.4.6.3
        if(decl.isPublic() && !m.isPublic())
          error("overriding access modifier error");
        // 8.4.6.3
        if(decl.isProtected() && !(m.isPublic() || m.isProtected()))
          error("overriding access modifier error");
        // 8.4.6.3
        if((!decl.isPrivate() && !decl.isProtected() && !decl.isPublic()) && m.isPrivate())
          error("overriding access modifier error");
        if(decl.isFinal())
          error("method " + m.signature() + " in " + hostType().typeName() + " can not override final method " + decl.signature() + " in " + decl.hostType().typeName());
        
      }
      
      for(Iterator i2 = hides(m).iterator(); i2.hasNext(); ) {
        MethodDecl decl = (MethodDecl)i2.next();
        // 8.4.6.2
        if(m.isStatic() && !decl.isStatic())
          error("a static method may not hide an instance method");
        // 8.4.6.3
        if(m.type() != decl.type())
          error("can not hide a method with a different return type");
        // 8.4.4
        for(int i = 0; i < m.getNumException(); i++) {
          Access e = m.getException(i);
          boolean found = false;
          for(int j = 0; !found && j < decl.getNumException(); j++) {
            if(e.type().instanceOf(decl.getException(j).type()))
              found = true;
          }
          if(!found)
            error("may not throw more checked exceptions than hidden method");
        }
        // 8.4.6.3
        if(decl.isPublic() && !m.isPublic())
          error("hiding access modifier error: public method " + decl.signature() + " in " + decl.hostType().typeName() + " is hidden by non public method " + m.signature() + " in " + m.hostType().typeName());
        // 8.4.6.3
        if(decl.isProtected() && !(m.isPublic() || m.isProtected()))
          error("hiding access modifier error: protected method " + decl.signature() + " in " + decl.hostType().typeName() + " is hidden by non (public|protected) method " + m.signature() + " in " + m.hostType().typeName());
        // 8.4.6.3
        if((!decl.isPrivate() && !decl.isProtected() && !decl.isPublic()) && m.isPrivate())
          error("hiding access modifier error: default method " + decl.signature() + " in " + decl.hostType().typeName() + " is hidden by private method " + m.signature() + " in " + m.hostType().typeName());
        if(decl.isFinal())
          error("method " + m.signature() + " in " + hostType().typeName() + " can not hide final method " + decl.signature() + " in " + decl.hostType().typeName());
      }

      if(m.hostType() != this) {
        MethodCollection list = localLookupMethod(m);
        for(MethodCollection.MethodIterator i2 = list.iterator(); i2.hasNext(); ) {
          MethodDecl n = (MethodDecl)i2.next();
          if(n != m) {
            if(n.hostType() != this && m.type() != n.type())
              error("multiply inherited methods with the same signature must have the same return type");
            if(n.hostType() != this && !m.isAbstract() && m.isStatic()) {
              error("abstract instance methods may not be implemented by a static method " + m.signature());
            }
          }
        }
      }
    }
  }

  public void ClassDecl.nameCheck() {
    super.nameCheck();
    if(hasSuperClassAccess() && !getSuperClassAccess().type().isClassDecl())
      error("class may only inherit a class and not " + getSuperClassAccess().type().typeName());
    if(isObject() && hasSuperClassAccess())
      error("class Object may not have superclass");
    if(isObject() && getNumImplements() != 0)
      error("class Object may not implement interfaces");
    if(hasSuperclass() && !superclass().accessibleFrom(this))
      error("a superclass must be accessible which " + superclass().name() + " is not");
    
    if(isCircular())
      error("circular inheritance dependency in " + typeName()); 

  }

  public void InterfaceDecl.nameCheck() {
    super.nameCheck();
    for(int i = 0; i < getNumSuperInterfaceId(); i++) {
      TypeDecl typeDecl = getSuperInterfaceId(i).type();
      if(typeDecl.isCircular())
        error("circular inheritance dependency in " + typeName()); 
    }
  }

  syn boolean TypeDecl.hasEnclosingTypeDecl(String name) {
    TypeDecl enclosingType = enclosingType();
    if(enclosingType != null) {
      return enclosingType.name().equals(name) || enclosingType.hasEnclosingTypeDecl(name);
    }
    return false;
  }

  public void FieldDeclaration.nameCheck() {
    super.nameCheck();
    // 8.3
    Collection list = hostType().lookupMemberField(name());
    for(Iterator iter = list.iterator(); iter.hasNext(); ) {
      Variable v = (Variable)iter.next();
      if(v != this && v.hostType() == hostType())
        error("field named " + name() + " is multiply declared in type " + hostType().typeName());
    }

    if(isBlank() && isFinal() && isClassVariable()) {
      boolean found = false;
      TypeDecl typeDecl = hostType();
      for(int i = 0; i < typeDecl.getNumBodyDecl(); i++) {
        if(typeDecl.getBodyDecl(i) instanceof StaticInitializer) {
          StaticInitializer s = (StaticInitializer)typeDecl.getBodyDecl(i);
          if(s.isDAafter(this))
            found = true;
        }
        
        else if(typeDecl.getBodyDecl(i) instanceof FieldDeclaration) {
          FieldDeclaration f = (FieldDeclaration)typeDecl.getBodyDecl(i);
          if(f.isStatic() && f.isDAafter(this))
            found = true;
        }
        
      }
      if(!found)
        error("blank final class variable " + name() + " in " + hostType().typeName() + " is not definitely assigned in static initializer");

    }
    if(isBlank() && isFinal() && isInstanceVariable()) {
      TypeDecl typeDecl = hostType();
      boolean found = false;
      for(int i = 0; !found && i < typeDecl.getNumBodyDecl(); i++) {
        if(typeDecl.getBodyDecl(i) instanceof FieldDeclaration) {
          FieldDeclaration f = (FieldDeclaration)typeDecl.getBodyDecl(i);
          if(!f.isStatic() && f.isDAafter(this))
            found = true;
        }
        else if(typeDecl.getBodyDecl(i) instanceof InstanceInitializer) {
          InstanceInitializer ii = (InstanceInitializer)typeDecl.getBodyDecl(i);
          if(ii.getBlock().isDAafter(this))
            found = true;
        }
      }
      for(int i = 0; !found && i < typeDecl.getNumBodyDecl(); i++) {
        if(typeDecl.getBodyDecl(i) instanceof ConstructorDecl) {
          ConstructorDecl c = (ConstructorDecl)typeDecl.getBodyDecl(i);
          if(!c.isDAafter(this)) {
            error("blank final instance variable " + name() + " in " + hostType().typeName() + " is not definitely assigned after " + c.signature());
          }
        }
      }
    }
    if(isBlank() && hostType().isInterfaceDecl()) {
            error("variable  " + name() + " in " + hostType().typeName() + " which is an interface must have an initializer");
    }
  }

  
  public void VariableDeclaration.nameCheck() {
    Collection decls = outerScope().lookupVariable(name());
    for(Iterator iter = decls.iterator(); iter.hasNext(); ) {
      Variable var = (Variable)iter.next();
      if(var instanceof VariableDeclaration) {
        VariableDeclaration decl = (VariableDeclaration)var;
        if(decl.enclosingBodyDecl() == enclosingBodyDecl())
  	      error("duplicate declaration of local variable " + name() + " in enclosing scope");
      }
      // 8.4.1
      else if(var instanceof ParameterDeclaration) {
        ParameterDeclaration decl = (ParameterDeclaration)var;
	      if(decl.enclosingBodyDecl() == enclosingBodyDecl())
  	      error("duplicate declaration of local variable and parameter " + name());
      }
    }
    if(getParent().getParent() instanceof Block) {
      Block block = (Block)getParent().getParent();
      for(int i = 0; i < block.getNumStmt(); i++) {
        if(block.getStmt(i) instanceof Variable) {
          Variable v = (Variable)block.getStmt(i);
          if(v.name().equals(name()) && v != this) {
     	    error("duplicate declaration of local variable " + name());
          }
	}
      }
    }
  }
  
  public void ParameterDeclaration.nameCheck() {
    Collection decls = outerScope().lookupVariable(name());
    for(Iterator iter = decls.iterator(); iter.hasNext(); ) {
      Variable var = (Variable)iter.next();
      if(var instanceof VariableDeclaration) {
        VariableDeclaration decl = (VariableDeclaration)var;
	      if(decl.enclosingBodyDecl() == enclosingBodyDecl())
  	      error("duplicate declaration of local variable " + name());
      }
      else if(var instanceof ParameterDeclaration) {
        ParameterDeclaration decl = (ParameterDeclaration)var;
	      if(decl.enclosingBodyDecl() == enclosingBodyDecl())
          error("duplicate declaration of local variable " + name());
      }
    }

    // 8.4.1  
    if(!lookupVariable(name()).contains(this)) {
      error("duplicate declaration of parameter " + name());
    }
  }
  
  public void LabeledStmt.nameCheck() {
    LabeledStmt stmt = lookupLabel(getLabel().getID());
    if(stmt != null) {
      if(stmt.enclosingBodyDecl() == enclosingBodyDecl()) {
        error("Labels can not shadow labels in the same member");
      }
    }
  }
  
  inh boolean BreakStmt.insideLoop();
  inh boolean ContinueStmt.insideLoop();

  eq TypeDecl.getBodyDecl(int i).insideLoop() = false;
  eq ForStmt.getStmt().insideLoop() = true;
  eq WhileStmt.getStmt().insideLoop() = true;
  eq DoStmt.getStmt().insideLoop() = true;
  
  inh boolean BreakStmt.insideSwitch();
  eq TypeDecl.getBodyDecl(int i).insideSwitch() = false;
  eq SwitchStmt.getCase(int i).insideSwitch() = true;

  public void BreakStmt.nameCheck() {
    if(!hasLabel() && !insideLoop() && !insideSwitch())
      error("break outside switch or loop");
    else if(hasLabel()) {
      LabeledStmt label = lookupLabel(getLabel().getID());
      if(label == null)
        error("labeled break must have visible matching label");
    }
  }
  
  public void ContinueStmt.nameCheck() {
    if(!insideLoop())
      error("continue outside loop");
    else if(hasLabel()) {
      LabeledStmt label = lookupLabel(getLabel().getID());
      if(label == null)
        error("labeled continue must have visible matching label");
      else if(!label.getStmt().continueLabel())
        error(getLabel().getID() + " is not a loop label");
    }
  }

  syn boolean Stmt.continueLabel() = false;
  eq ForStmt.continueLabel() = true;
  eq WhileStmt.continueLabel() = true;
  eq DoStmt.continueLabel() = true;
  
  public void ConstCase.nameCheck() {
    if(getValue().isConstant() && bind(this) != this) {
      error("constant expression " + getValue() + " is multiply declared in two case statements");
    }
  }
  public void DefaultCase.nameCheck() {
    if(bind(this) != this) {
      error("only one default case statement allowed");
    }
  }

  inh lazy Case Case.bind(Case c);
  eq SwitchStmt.getCase().bind(Case c) {
    for(int i = 0; i < getNumCase(); i++)
      if(getCase(i).constValue(c))
        return getCase(i);
    return null;
  }

  syn boolean TypeDecl.assignableToInt() = false;
  eq IntegralType.assignableToInt() = true;
  eq LongType.assignableToInt() = false;

  syn boolean Case.constValue(Case c);
  eq ConstCase.constValue(Case c) {
    if(!(c instanceof ConstCase) || !getValue().isConstant())
      return false;
    if(!getValue().type().assignableToInt() || !((ConstCase)c).getValue().type().assignableToInt())
      return false;
    return getValue().constant().intValue() == ((ConstCase)c).getValue().constant().intValue();
  }
  eq DefaultCase.constValue(Case c) = c instanceof DefaultCase;
}

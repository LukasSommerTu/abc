aspect ErrorCheck {

  protected String ASTNode.sourceFile() {
    ASTNode node = this;
    while(node != null && !(node instanceof CompilationUnit))
      node = node.getParent();
    if(node == null)
      return "Unknown file";
    CompilationUnit u = (CompilationUnit)node;
    return u.relativeName();
  }

  syn int ASTNode.lineNumber() {
    ASTNode n = this;
    while(n.getParent() != null && n.getStart() == 0) {
      n = n.getParent();
    }
    return getLine(n.getStart());
  }

  eq ClassDecl.lineNumber() = getSuperClassAccessOpt().lineNumber();
  eq MethodDecl.lineNumber() {
    for(int i = 0; i < getNumChild(); i++)
      if(getChild(i).getStart() != 0)
        return getChild(i).lineNumber();
    return super.lineNumber();
  }

  public ASTNode ASTNode.setStart(int i) {
    start = i;
    return this;
  }
  public int ASTNode.start() {
    return start;
  }
  public ASTNode ASTNode.setEnd(int i) {
    end = i;
    return this;
  }
  public int ASTNode.end() {
    return end;
  }

  public String ASTNode.location() {
    return "" + lineNumber();
  }
  public String ASTNode.errorPrefix() {
    return sourceFile() + ":" + location() + ":\n" + "  *** Semantic Error: ";
  }
  public String ASTNode.warningPrefix() {
    return sourceFile() + ":" + location() + ":\n" + "  *** WARNING: ";
  }

  protected java.util.ArrayList CompilationUnit.errors = new java.util.ArrayList();
  protected java.util.ArrayList CompilationUnit.warnings = new java.util.ArrayList();

  protected void ASTNode.error(String s) {
    ASTNode node = this;
    while(node != null && !(node instanceof CompilationUnit))
      node = node.getParent();
    CompilationUnit cu = (CompilationUnit)node;
    cu.errors.add(errorPrefix() + s);
  }
  protected void ASTNode.warning(String s) {
    ASTNode node = this;
    while(node != null && !(node instanceof CompilationUnit))
      node = node.getParent();
    CompilationUnit cu = (CompilationUnit)node;
    cu.warnings.add(warningPrefix() + s);
  }
  
  public void ASTNode.collectErrors() {
    nameCheck();
    typeCheck();
    accessControl();
    exceptionHandling();
    checkUnreachableStmt();
    definiteAssignment();
    checkModifiers();
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collectErrors();
    }
  }

  public void Program.errorCheck(Collection collection) {
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit cu = (CompilationUnit)iter.next();
      if(cu.fromSource()) {
        cu.collectErrors();
        collection.addAll(cu.errors);
      }
    }
  }

  public void CompilationUnit.errorCheck(Collection collection) {
    collectErrors();
    collection.addAll(errors);
  }
  public void CompilationUnit.errorCheck(Collection err, Collection warn) {
    collectErrors();
    err.addAll(errors);
    warn.addAll(warnings);
  }
  
  public boolean Program.errorCheck() {
    Collection collection = new LinkedList();
    errorCheck(collection);
    if(collection.isEmpty())
      return false;
    System.out.println("Errors:");
    for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
      String s = (String)iter.next();
      System.out.println(s);
    }
    return true;
  }
}

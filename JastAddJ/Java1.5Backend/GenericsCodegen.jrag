aspect GenericsCodegen {
    
   eq TypeVariable.typeDescriptor() = erasure().typeDescriptor();
   eq ParClassDecl.typeDescriptor() = erasure().typeDescriptor();
   eq ParInterfaceDecl.typeDescriptor() = erasure().typeDescriptor();
   //eq WildcardType.typeDescriptor() = erasure().typeDescriptor();

  syn FieldDeclaration FieldDeclaration.erasedField() = this;
  eq FieldDeclarationSubstituted.erasedField() = getOriginal().erasedField();

  syn MethodDecl MethodDecl.erasedMethod() = this;
  eq MethodDeclSubstituted.erasedMethod() = getOriginal().erasedMethod();
  eq ParMethodDecl.erasedMethod() = genericMethodDecl().erasedMethod();

  refine CodeGeneration public void VarAccess.emitStore(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessorWrite(gen, fieldQualifierType());
      else
        f.emitStoreField(gen, fieldQualifierType());
    }
    else
      CodeGeneration.VarAccess.emitStore(gen);
  }

  refine CreateBCode public void VarAccess.createAssignLoadDest(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      createLoadQualifier(gen);
      if(v.isInstanceVariable())
        gen.emitDup();
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessor(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
    }
    else
      CreateBCode.VarAccess.createAssignLoadDest(gen);
  }

  refine CreateBCode public void VarAccess.createBCode(CodeGeneration gen) {
    Variable v = decl();
    if(v instanceof FieldDeclaration) {
      FieldDeclaration f = (FieldDeclaration)v;
      f = f.erasedField();
      createLoadQualifier(gen);
      if(f.isPrivate() && !hostType().hasField(v.name()))
        f.emitInvokeFieldAccessor(gen, fieldQualifierType());
      else
        f.emitLoadField(gen, fieldQualifierType());
      if(f.type() != decl().type())
        gen.emitCheckCast(decl().type());
    }
    else
      CreateBCode.VarAccess.createBCode(gen);
  }

  refine CreateBCode public void MethodAccess.createBCode(CodeGeneration gen) {
    MethodDecl decl = decl().erasedMethod();
    createLoadQualifier(gen);

    if(decl.type().isUnknown()) {
      System.err.println("Could not bind " + this);
      for (int i = 0; i < getNumArg(); ++i) {
        System.err.println("Argument " + getArg(i) + " is of type " + getArg(i).type().typeName());
        if(getArg(i).varDecl() != null) System.err.println(getArg(i).varDecl() + " in " + getArg(i).varDecl().hostType().typeName());
      }
      if(isQualified())
        System.err.println("Qualifier " + qualifier() + " is of type " + qualifier().type().typeName());
      throw new Error("Could not bind " + this);
    }
    if(decl.getNumParameter() != getNumArg()) {
      System.out.println(this + " does not have the same number of arguments as " + decl);
    }

    for (int i = 0; i < getNumArg(); ++i) {
      getArg(i).createBCode(gen);
      // the cast or boxing/unboxing operation must know the bound rather than the erased type
      getArg(i).type().emitCastTo(gen, decl().getParameter(i).type()); // MethodInvocationConversion
    }
    if(!decl.isStatic() && isQualified() && prevExpr().isSuperAccess()) {
      if(!hostType().instanceOf(prevExpr().type())) {
        TypeDecl typeDecl = superAccessorTarget();
        MethodDecl m = typeDecl.createSuperAccessor(decl);
        m.emitInvokeMethod(gen, typeDecl);
      }
      else
        decl.emitInvokeSpecialMethod(gen, methodQualifierType());
    }
    else
      decl.emitInvokeMethod(gen, methodQualifierType());

    if(decl.type() != decl().type())
      gen.emitCheckCast(decl().type());
  }

  public void ConstructorDeclSubstituted.emitInvokeConstructor(CodeGeneration gen) {
    erasedConstructor().emitInvokeConstructor(gen);
  }
  syn ConstructorDecl ConstructorDecl.erasedConstructor() = this;
  eq ConstructorDeclSubstituted.erasedConstructor() = getOriginal().erasedConstructor();


  eq TypeVariable.constantPoolName() = erasure().constantPoolName();
  eq ParClassDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq ParInterfaceDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq GenericClassDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }
  eq GenericInterfaceDecl.constantPoolName() {
    if(!isNestedType()) {
      String packageName = packageName();
      if(!packageName.equals("")) {
        packageName = packageName.replace('.', '/') + "/";
      }
      return packageName + getID();
    }
    else {
      String prefix = enclosingType().constantPoolName();
      if(isAnonymous()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index;
      }
      else if(isLocalClass()) {
        int index = topLevelType().constantPoolNameIndex++;
        return prefix + "$" + index + getID();
      }
      return prefix + "$" + getID();
    }
  }



   syn boolean TypeVariable.isNestedType() = false;

  // accessibility for members in generic classes
  // the accessibility for parameterized and raw versions of a generic class
  // should be the same as for the generic class, in other words the erasure of the 
  // paramterized version.
  eq ParClassDecl.topLevelType() = erasure().topLevelType();

  public void BridgeMethodDecl.java2Transformation() { }

  public void MethodDecl.java2Transformation() {
    super.java2Transformation();
    for(Iterator iter = hostType().ancestorMethods(signature()).iterator(); iter.hasNext(); ) {
      MethodDecl m = (MethodDecl)iter.next();
      if(this.overrides(m)) {
        MethodDecl erased = m.erasedMethod();
        if(!erased.signature().equals(signature()) || erased.type().erasure() != type().erasure()) {
          List args = new List();
          List parameters = new List();
          for(int i = 0; i < getNumParameter(); i++) {
            args.add(new CastExpr(getParameter(i).type().erasure().createBoundAccess(), new VarAccess("p" + i)));
            parameters.add(new ParameterDeclaration(erased.getParameter(i).type().erasure(), "p" + i));
          }
          Stmt stmt;
          if(type().isVoid()) {
            stmt = new ExprStmt(
              createBoundAccess(
                args
              )
            );
          }
          else {
            stmt = new ReturnStmt(
              createBoundAccess(
                args
              )
            );
          }
          MethodDecl bridge = new BridgeMethodDecl(
            (Modifiers)getModifiers().fullCopy(),
            erased.type().erasure().createBoundAccess(),
            erased.name(),
            parameters,
            new List(),
            (List)getExceptionList().fullCopy(),
            new Opt(
              new Block(
                new List().add(stmt)
              )
            )
          );
          hostType().addBodyDecl(bridge);
          
        }
      }
    }
  }

  public void ParTypeDecl.java2Transformation() {
  }


}

Executing test 1 (base/test100): static and non-static before methods -- one file
================================================
Breakdown of abc phases  (total: 9046 millisec.)
------------------------------------------------
[ 00.420% ] Init. of Soot:  38
[ 00.033% ] Loading Jars:  3
[ 70.352% ] Polyglot phases:  6364
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.619% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.420% ] Intertype Adjuster:  38
[ 06.091% ] Retrieving bodies:  551
[ 00.000% ] Weave Initializers:  0
[ 00.243% ] Load shadow types:  22
[ 10.756% ] Compute advice lists:  973
[ 00.033% ] Intertype weave:  3
[ 00.553% ] Add aspect code:  50
[ 00.509% ] Weaving advice:  46
[ 00.000% ] Validate jimple:  0
[ 05.815% ] Soot Packs:  526
[ 04.112% ] Soot Writing Output:  372
================================================
Abc started on Thu Jun 24 08:01:58 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Pos p1 = new Pos();
        Pos p2 = new Pos();
        Pos p3 = new Pos();
        Foo f1 = Foo.aspectOf(p1);
        Foo f2 = Foo.aspectOf(p2);
        Foo f3 = Foo.aspectOf(p3);
        p1.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p1.getX(), 1, "p1.x");
        org.aspectj.testing.Tester.checkEqual(p1.getY(), 2, "p1.y");
        p2.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p2.getX(), 1, "p2.x");
        org.aspectj.testing.Tester.checkEqual(p2.getY(), 2, "p2.y");
        p3.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p3.getX(), 1, "p3.x");
        org.aspectj.testing.Tester.checkEqual(p3.getY(), 2, "p3.y");
        org.aspectj.testing.Tester.checkEqual(f1/*null*/.count,
                                              3,
                                              "f1.count");
        org.aspectj.testing.Tester.checkEqual(f2/*null*/.count,
                                              3,
                                              "f2.count");
        org.aspectj.testing.Tester.checkEqual(f3/*null*/.count,
                                              3,
                                              "f3.count");
        org.aspectj.testing.Tester.checkEqual(Bar/*Bar*/.countx,
                                              9,
                                              "Bar.countx");
    }
    
    public Driver() { super(); }
}
class Pos {
    int x = 0;
    
    int y = 0;
    
    int getX() { return this/*null*/.x; }
    
    int getY() { return this/*null*/.y; }
    
    void move(int newX, int newY) {
        this/*null*/.x = newX;
        this/*null*/.y = newY;
    }
    
    public Pos() { super(); }
}
aspect Foo {
    int count = 0;
    
    before():
    call(* (*).getX(..)) || call(* (*).getY(..)) ||
      call(* (*).move(..)) {
        this/*null*/.count++;
    }
    
    public static Foo aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Foo() { super(); }
}
aspect Bar {
    static int countx = 0;
    
    before():
    target(Pos) &&
      (call(* (*).getX(..)) || call(* (*).getY(..)) ||
         call(* (*).move(..))) {
        Bar/*Bar*/.countx++;
    }
    
    public static Bar aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Bar() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Pos: int getX()> from Pos
retrieve <Pos: int getY()> from Pos
retrieve <Pos: void move(int,int)> from Pos
retrieve <Pos: void <init>()> from Pos
retrieve <Foo: boolean hasAspect(java.lang.Object)> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void before$0()> from Foo
retrieve <Foo: Foo aspectOf(java.lang.Object)> from Foo
retrieve <Bar: Bar aspectOf()> from Bar
retrieve <Bar: boolean hasAspect()> from Bar
retrieve <Bar: void <clinit>()> from Bar
retrieve <Bar: void <init>()> from Bar
retrieve <Bar: void before$1()> from Bar
Transforming Pos... 
Transforming Bar... 
Transforming Driver... 
Transforming Foo... 
Transforming Foo$abc$PerTarget... 
Abc finished on Thu Jun 24 08:02:07 BST 2004. ( 0 min. 9 sec. )
PASS: static and non-static before methods -- one file()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 0 failed (check: 0), 1 passed (check: 0), 0 skipped.
Executing test 2 (base/test101): static and non-static before methods -- many files
================================================
Breakdown of abc phases  (total: 8725 millisec.)
------------------------------------------------
[ 00.447% ] Init. of Soot:  39
[ 00.034% ] Loading Jars:  3
[ 68.894% ] Polyglot phases:  6011
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.607% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.436% ] Intertype Adjuster:  38
[ 06.487% ] Retrieving bodies:  566
[ 00.000% ] Weave Initializers:  0
[ 00.252% ] Load shadow types:  22
[ 11.152% ] Compute advice lists:  973
[ 00.034% ] Intertype weave:  3
[ 00.619% ] Add aspect code:  54
[ 00.665% ] Weaving advice:  58
[ 00.000% ] Validate jimple:  0
[ 05.926% ] Soot Packs:  517
[ 04.401% ] Soot Writing Output:  384
================================================
Abc started on Thu Jun 24 08:02:10 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Pos p1 = new Pos();
        Pos p2 = new Pos();
        Pos p3 = new Pos();
        Foo f1 = Foo.aspectOf(p1);
        Foo f2 = Foo.aspectOf(p2);
        Foo f3 = Foo.aspectOf(p3);
        p1.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p1.getX(), 1, "p1.x");
        org.aspectj.testing.Tester.checkEqual(p1.getY(), 2, "p1.y");
        p2.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p2.getX(), 1, "p2.x");
        org.aspectj.testing.Tester.checkEqual(p2.getY(), 2, "p2.y");
        p3.move(1, 2);
        org.aspectj.testing.Tester.checkEqual(p3.getX(), 1, "p3.x");
        org.aspectj.testing.Tester.checkEqual(p3.getY(), 2, "p3.y");
        org.aspectj.testing.Tester.checkEqual(f1/*null*/.count,
                                              3,
                                              "f1.count");
        org.aspectj.testing.Tester.checkEqual(f2/*null*/.count,
                                              3,
                                              "f2.count");
        org.aspectj.testing.Tester.checkEqual(f3/*null*/.count,
                                              3,
                                              "f3.count");
        org.aspectj.testing.Tester.checkEqual(Bar/*Bar*/.count,
                                              9,
                                              "Bar.count");
    }
    
    public Driver() { super(); }
}
<<<< Bar.java >>>>
aspect Bar {
    static int count = 0;
    
    before():
    target(Pos) &&
      (call(* (*).getX(..)) || call(* (*).getY(..)) ||
         call(* (*).move(..))) {
        Bar/*Bar*/.count++;
    }
    
    public static Bar aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Bar() { super(); }
}
<<<< Pos.java >>>>
class Pos {
    int x = 0;
    
    int y = 0;
    
    int getX() { return this/*null*/.x; }
    
    int getY() { return this/*null*/.y; }
    
    void move(int newX, int newY) {
        this/*null*/.x = newX;
        this/*null*/.y = newY;
    }
    
    public Pos() { super(); }
}
<<<< Foo.java >>>>
aspect Foo {
    int count = 0;
    
    before():
    call(* (*).getX(..)) || call(* (*).getY(..)) ||
      call(* (*).move(..)) {
        this/*null*/.count++;
    }
    
    public static Foo aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Foo() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Bar: boolean hasAspect()> from Bar
retrieve <Bar: void <clinit>()> from Bar
retrieve <Bar: void <init>()> from Bar
retrieve <Bar: void before$0()> from Bar
retrieve <Bar: Bar aspectOf()> from Bar
retrieve <Pos: int getX()> from Pos
retrieve <Pos: int getY()> from Pos
retrieve <Pos: void move(int,int)> from Pos
retrieve <Pos: void <init>()> from Pos
retrieve <Foo: void before$1()> from Foo
retrieve <Foo: Foo aspectOf(java.lang.Object)> from Foo
retrieve <Foo: boolean hasAspect(java.lang.Object)> from Foo
retrieve <Foo: void <init>()> from Foo
Transforming Pos... 
Transforming Foo... 
Transforming Bar... 
Transforming Driver... 
Transforming Foo$abc$PerTarget... 
Abc finished on Thu Jun 24 08:02:19 BST 2004. ( 0 min. 8 sec. )
PASS: static and non-static before methods -- many files()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 0 failed (check: 0), 2 passed (check: 0), 0 skipped.
Executing test 3 (base/test102): this redirection in non-static before methods
================================================
Breakdown of abc phases  (total: 8032 millisec.)
------------------------------------------------
[ 00.461% ] Init. of Soot:  37
[ 00.037% ] Loading Jars:  3
[ 73.220% ] Polyglot phases:  5881
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.436% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.772% ] Intertype Adjuster:  62
[ 06.524% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.286% ] Load shadow types:  23
[ 09.923% ] Compute advice lists:  797
[ 00.037% ] Intertype weave:  3
[ 00.560% ] Add aspect code:  45
[ 00.336% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 03.972% ] Soot Packs:  319
[ 03.386% ] Soot Writing Output:  272
================================================
Abc started on Thu Jun 24 08:02:21 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    static java.lang.Object objectFromClass;
    
    static java.lang.Object objectFromAspect;
    
    static java.lang.String stringFromClass;
    
    static java.lang.String stringFromAspect;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Driver obj = new Driver();
        obj.doit();
        org.aspectj.testing.Tester.check(Driver/*Driver*/.objectFromClass ==
                                         Driver/*Driver*/.objectFromAspect,
                                         "this matches this");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.stringFromClass.equals(Driver/*Driver*/.stringFromAspect),
                                         "this.toString() matches this.toString()");
    }
    
    void doit() {
        Driver/*Driver*/.objectFromClass = this;
        Driver/*Driver*/.stringFromClass = this.toString();
    }
    
    public Driver() { super(); }
}
aspect DriverAspect {
    before(Driver d):
    target(d) &&
      call(* (*).doit(..)) {
        d/*null*/.objectFromAspect = d;
        d/*null*/.stringFromAspect = d.toString();
    }
    
    public static DriverAspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public DriverAspect() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void doit()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <DriverAspect: void before$0(Driver)> from DriverAspect
retrieve <DriverAspect: DriverAspect aspectOf(java.lang.Object)> from DriverAspect
retrieve <DriverAspect: boolean hasAspect(java.lang.Object)> from DriverAspect
retrieve <DriverAspect: void <init>()> from DriverAspect
Transforming DriverAspect... 
Transforming Driver... 
Transforming DriverAspect$abc$PerTarget... 
Abc finished on Thu Jun 24 08:02:30 BST 2004. ( 0 min. 8 sec. )
PASS: this redirection in non-static before methods()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 3 passed (check: 0), 0 skipped.
Executing test 4 (base/test103): DEPRECATED: introductions
================================================
Breakdown of abc phases  (total: 7829 millisec.)
------------------------------------------------
[ 00.498% ] Init. of Soot:  39
[ 00.038% ] Loading Jars:  3
[ 74.773% ] Polyglot phases:  5854
[ 00.038% ] Resolve class names:  3
[ 00.026% ] Declare Parents:  2
[ 00.536% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 02.210% ] Intertype Adjuster:  173
[ 05.096% ] Retrieving bodies:  399
[ 00.128% ] Weave Initializers:  10
[ 00.294% ] Load shadow types:  23
[ 02.120% ] Compute advice lists:  166
[ 00.038% ] Intertype weave:  3
[ 00.447% ] Add aspect code:  35
[ 00.166% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 10.436% ] Soot Packs:  817
[ 03.155% ] Soot Writing Output:  247
================================================
Abc started on Thu Jun 24 08:02:32 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        MagicKey key = new MagicKey();
        Pos p1 = new Pos(key);
        org.aspectj.testing.Tester.checkEqual(p1.getOther(),
                                              1,
                                              "introduced value");
    }
    
    public Driver() { super(); }
}
class Pos {
    int _x = 0;
    
    int _y = 0;
    
    public int getX() { return this/*null*/._x; }
    
    public int getY() { return this/*null*/._y; }
    
    public void move(int x, int y) {
        this/*null*/._x = x;
        this/*null*/._y = y;
    }
    
    public Pos() { super(); }
}
aspect Foo {
    public int Pos.id = 1;
    
    public int Pos.other;
    
    intertype int Pos.getOther() { return hostPosthis/*null*/.other; }
    
    Pos.new(MagicKey key) {
        super();
        hostPosthis/*null*/.other = hostPosthis/*null*/.id;
        hostPosthis/*null*/.id = getOther();
    }
    
    public static Foo aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Foo() { super(); }
}
class MagicKey {
    public MagicKey() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Pos: int getX()> from Pos
retrieve <Pos: int getY()> from Pos
retrieve <Pos: void move(int,int)> from Pos
retrieve <Pos: void <init>()> from Pos
retrieve <Pos: int Foo$getOther$6()> from Pos
retrieve <Pos: void <init>(MagicKey,Foo)> from Pos
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: int Foo$getOther$6(Pos)> from Foo
retrieve <Foo: Foo aspectOf()> from Foo
retrieve <Foo: boolean hasAspect()> from Foo
retrieve <Foo: int init$id$9(Pos)> from Foo
retrieve <Foo: void new$Pos$11(Pos,MagicKey,Foo)> from Foo
retrieve <MagicKey: void <init>()> from MagicKey
Transforming Pos... 
Transforming Driver... 
Transforming MagicKey... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:02:40 BST 2004. ( 0 min. 7 sec. )
PASS: DEPRECATED: introductions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 4 passed (check: 0), 0 skipped.
Executing test 5 (base/test104): before constructors -- one file
================================================
Breakdown of abc phases  (total: 8293 millisec.)
------------------------------------------------
[ 00.458% ] Init. of Soot:  38
[ 00.036% ] Loading Jars:  3
[ 71.783% ] Polyglot phases:  5953
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.531% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.784% ] Intertype Adjuster:  65
[ 07.295% ] Retrieving bodies:  605
[ 00.000% ] Weave Initializers:  0
[ 00.398% ] Load shadow types:  33
[ 02.544% ] Compute advice lists:  211
[ 05.535% ] Intertype weave:  459
[ 00.724% ] Add aspect code:  60
[ 00.398% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 06.041% ] Soot Packs:  501
[ 03.425% ] Soot Writing Output:  284
================================================
Abc started on Thu Jun 24 08:02:43 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public aspect Driver {
    static boolean point;
    
    static boolean line;
    
    static boolean circle;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Point p = new Point();
        Line l = new Line();
        Circle c = new Circle();
        org.aspectj.testing.Tester.check(Driver/*Driver*/.point,
                                         "point");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.line,
                                         "line");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.circle,
                                         "circle");
    }
    
    before():
    target(Point) &&
      execution ((*).new(..)) {
        Driver/*Driver*/.point = true;
    }
    
    before():
    target(Line) &&
      execution ((*).new(..)) {
        Driver/*Driver*/.line = true;
    }
    
    before():
    target() && target(Circle) &&
      execution ((*).new()) {
        Driver/*Driver*/.circle = true;
    }
    
    public static Driver aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Driver() { super(); }
}
class Point {
    int _x = 0;
    
    int _y = 0;
    
    Point() { super(); }
    
    void set(int x, int y) {
        this/*null*/._x = x;
        this/*null*/._y = y;
    }
    
    void setX(int x) { this/*null*/._x = x; }
    
    void setY(int y) { this/*null*/._y = y; }
    
    int getX() { return this/*null*/._x; }
    
    int getY() { return this/*null*/._y; }
}
class Line {
    int _x1;
    
    int _y1;
    
    int _x2;
    
    int _y2;
    
    Line() { super(); }
    
    void set(int x1, int y1, int x2, int y2) {
        this/*null*/._x1 = x1;
        this/*null*/._y1 = y1;
        this/*null*/._x2 = x2;
        this/*null*/._y2 = y2;
    }
    
    void setX1(int x1) { this/*null*/._x1 = x1; }
    
    void setY1(int y1) { this/*null*/._y1 = y1; }
    
    void setX2(int x2) { this/*null*/._x2 = x2; }
    
    void setY2(int y2) { this/*null*/._y2 = y2; }
    
    int getX1() { return this/*null*/._x1; }
    
    int getY1() { return this/*null*/._y1; }
    
    int getX2() { return this/*null*/._x2; }
    
    int getY2() { return this/*null*/._y2; }
}
class Circle {
    int _x = 0;
    
    int _y = 0;
    
    int _r = 0;
    
    Circle() { super(); }
    
    void set(int x, int y, int r) {
        this/*null*/._x = x;
        this/*null*/._y = y;
        this/*null*/._r = r;
    }
    
    void setX(int x) { this/*null*/._x = x; }
    
    void setY(int y) { this/*null*/._y = y; }
    
    void setR(int r) { this/*null*/._r = r; }
    
    int getX() { return this/*null*/._x; }
    
    int getY() { return this/*null*/._y; }
    
    int getR() { return this/*null*/._r; }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void before$0()> from Driver
retrieve <Driver: void before$1()> from Driver
retrieve <Driver: void before$2()> from Driver
retrieve <Driver: Driver aspectOf()> from Driver
retrieve <Driver: boolean hasAspect()> from Driver
retrieve <Point: void setY(int)> from Point
retrieve <Point: void <init>()> from Point
retrieve <Point: int getX()> from Point
retrieve <Point: int getY()> from Point
retrieve <Point: void set(int,int)> from Point
retrieve <Point: void setX(int)> from Point
retrieve <Line: void <init>()> from Line
retrieve <Line: void set(int,int,int,int)> from Line
retrieve <Line: void setX1(int)> from Line
retrieve <Line: void setY1(int)> from Line
retrieve <Line: void setX2(int)> from Line
retrieve <Line: void setY2(int)> from Line
retrieve <Line: int getX1()> from Line
retrieve <Line: int getY1()> from Line
retrieve <Line: int getX2()> from Line
retrieve <Line: int getY2()> from Line
retrieve <Circle: void setY(int)> from Circle
retrieve <Circle: void <init>()> from Circle
retrieve <Circle: void setR(int)> from Circle
retrieve <Circle: int getX()> from Circle
retrieve <Circle: int getY()> from Circle
retrieve <Circle: int getR()> from Circle
retrieve <Circle: void set(int,int,int)> from Circle
retrieve <Circle: void setX(int)> from Circle
Transforming Line... 
Transforming Circle... 
Transforming Point... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:02:51 BST 2004. ( 0 min. 8 sec. )
PASS: before constructors -- one file()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 5 passed (check: 0), 0 skipped.
Executing test 6 (base/test105): advise weaves find methods typed to builtins or non-woven classes
================================================
Breakdown of abc phases  (total: 8349 millisec.)
------------------------------------------------
[ 00.455% ] Init. of Soot:  38
[ 00.036% ] Loading Jars:  3
[ 71.074% ] Polyglot phases:  5934
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.683% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.455% ] Intertype Adjuster:  38
[ 12.804% ] Retrieving bodies:  1069
[ 00.000% ] Weave Initializers:  0
[ 00.455% ] Load shadow types:  38
[ 05.941% ] Compute advice lists:  496
[ 00.036% ] Intertype weave:  3
[ 00.467% ] Add aspect code:  39
[ 00.359% ] Weaving advice:  30
[ 00.000% ] Validate jimple:  0
[ 04.276% ] Soot Packs:  357
[ 02.911% ] Soot Writing Output:  243
================================================
Abc started on Thu Jun 24 08:02:54 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public aspect Driver {
    static boolean t1;
    
    static boolean t2;
    
    static boolean t3;
    
    static boolean t4;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo f1 = new Foo();
        f1.m1("foo");
        f1.m2(1);
        f1.m3("foo");
        f1.m3(1);
        org.aspectj.testing.Tester.check(Driver/*Driver*/.t1,
                                         "finding m1(String)");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.t2,
                                         "finding m2(int)");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.t3,
                                         "finding m3(String)");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.t4,
                                         "finding m3(int)");
    }
    
    before(String x):
    target(Foo) && call(void (*).m1(String)) &&
      args(x) {
        Driver/*Driver*/.t1 = true;
    }
    
    before(int x):
    target(Foo) && call(void (*).m2(int)) &&
      args(x) {
        Driver/*Driver*/.t2 = true;
    }
    
    before(String x):
    target(Foo) && call(void (*).m3(String)) &&
      args(x) {
        Driver/*Driver*/.t3 = true;
    }
    
    before(int x):
    target(Foo) && call(void (*).m3(int)) &&
      args(x) {
        Driver/*Driver*/.t4 = true;
    }
    
    public static Driver aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Driver() { super(); }
}
class Foo {
    void m1(java.lang.String x) {  }
    
    void m2(int x) {  }
    
    void m3(java.lang.String x) {  }
    
    void m3(int x) {  }
    
    public Foo() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void before$0(java.lang.String)> from Driver
retrieve <Driver: void before$1(int)> from Driver
retrieve <Driver: void before$2(java.lang.String)> from Driver
retrieve <Driver: void before$3(int)> from Driver
retrieve <Driver: Driver aspectOf()> from Driver
retrieve <Driver: boolean hasAspect()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Foo: void m1(java.lang.String)> from Foo
retrieve <Foo: void m2(int)> from Foo
retrieve <Foo: void m3(java.lang.String)> from Foo
retrieve <Foo: void m3(int)> from Foo
retrieve <Foo: void <init>()> from Foo
Transforming Foo... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:03:02 BST 2004. ( 0 min. 8 sec. )
PASS: advise weaves find methods typed to builtins or non-woven classes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 6 passed (check: 0), 0 skipped.
Executing test 7 (base/test106): make sure new weaves work inside of packages
================================================
Breakdown of abc phases  (total: 7725 millisec.)
------------------------------------------------
[ 00.466% ] Init. of Soot:  36
[ 00.052% ] Loading Jars:  4
[ 74.369% ] Polyglot phases:  5745
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.583% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.816% ] Intertype Adjuster:  63
[ 06.356% ] Retrieving bodies:  491
[ 00.000% ] Weave Initializers:  0
[ 00.311% ] Load shadow types:  24
[ 02.045% ] Compute advice lists:  158
[ 00.039% ] Intertype weave:  3
[ 00.595% ] Add aspect code:  46
[ 01.036% ] Weaving advice:  80
[ 00.000% ] Validate jimple:  0
[ 09.877% ] Soot Packs:  763
[ 03.405% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 08:03:05 BST 2004
<<<< Driver.java >>>>
import pkg.*;
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        pkg.Obj obj = new pkg.Obj();
        org.aspectj.testing.Tester.checkEqual(obj.m(), 3, "obj.m()");
    }
    
    public Driver() { super(); }
}
<<<< Obj.java >>>>
package pkg;

public class Obj {
    public int m() { return 2; }
    
    public Obj() { super(); }
}
aspect Asp {
    int around ():
    target(pkg.Obj) &&
      execution (int (*).m()) {
        return 3;
    }
    
    public static pkg.Asp aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Asp() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <pkg.Obj: void <init>()> from pkg.Obj
retrieve <pkg.Obj: int m()> from pkg.Obj
retrieve <pkg.Asp: int around$0()> from pkg.Asp
retrieve <pkg.Asp: pkg.Asp aspectOf()> from pkg.Asp
retrieve <pkg.Asp: boolean hasAspect()> from pkg.Asp
retrieve <pkg.Asp: void <init>()> from pkg.Asp
retrieve <pkg.Asp: int proceed$1()> from pkg.Asp
Transforming Driver... 
Transforming pkg.Obj... 
Transforming pkg.Asp... 
Transforming abc$access$pkg_d_Asp$around$0... 
Abc finished on Thu Jun 24 08:03:12 BST 2004. ( 0 min. 7 sec. )
PASS: make sure new weaves work inside of packages()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 7 passed (check: 0), 0 skipped.
Executing test 8 (base/test107): make sure new weaves work inside of packages (again)
================================================
Breakdown of abc phases  (total: 7825 millisec.)
------------------------------------------------
[ 00.486% ] Init. of Soot:  38
[ 00.051% ] Loading Jars:  4
[ 76.524% ] Polyglot phases:  5988
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.422% ] Recompute name pattern matches:  33
[ 00.013% ] Compute precedence relation:  1
[ 00.780% ] Intertype Adjuster:  61
[ 06.812% ] Retrieving bodies:  533
[ 00.000% ] Weave Initializers:  0
[ 00.281% ] Load shadow types:  22
[ 03.438% ] Compute advice lists:  269
[ 00.038% ] Intertype weave:  3
[ 00.422% ] Add aspect code:  33
[ 01.355% ] Weaving advice:  106
[ 00.000% ] Validate jimple:  0
[ 05.406% ] Soot Packs:  423
[ 03.923% ] Soot Writing Output:  307
================================================
Abc started on Thu Jun 24 08:03:15 BST 2004
<<<< Driver.java >>>>
import pack3.Foo;
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C1 c1 = new C1();
        C2 c2 = new C2();
        C3 c3 = new C3();
        org.aspectj.testing.Tester.checkEqual(c1.m(), 3, "c1.m()");
        org.aspectj.testing.Tester.checkEqual(c2.m(), 3, "c2.m()");
        org.aspectj.testing.Tester.checkEqual(c3.m(), 3, "c3.m()");
    }
    
    public Driver() { super(); }
}
class C3 {
    int m() {
        pack3.Foo f = new pack3.Foo();
        return f.hello();
    }
    
    public C3() { super(); }
}
aspect Test {
    int around ():
    (target(C1) || target(C2)) &&
      call(int (*).m()) {
        pack3.Foo f = new pack3.Foo();
        return f.hello();
    }
    
    public static Test aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Test() { super(); }
}
<<<< C2.java >>>>
import pack2.Foo;

public class C2 {
    int m() { return 998; }
    
    public C2() { super(); }
}
<<<< Foo.java >>>>
package pack2;

public class Foo {
    public int hello() { return 2; }
    
    public Foo() { super(); }
}
<<<< Foo.java >>>>
package pack3;

public class Foo {
    public int hello() { return 3; }
    
    public Foo() { super(); }
}
<<<< Foo.java >>>>
package pack1;

public class Foo {
    public int hello() { return 1; }
    
    public Foo() { super(); }
}
<<<< C1.java >>>>
import pack1.Foo;

public class C1 {
    int m() { return 999; }
    
    public C1() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <C3: int m()> from C3
retrieve <C3: void <init>()> from C3
retrieve <Test: int around$0()> from Test
retrieve <Test: Test aspectOf()> from Test
retrieve <Test: boolean hasAspect()> from Test
retrieve <Test: void <init>()> from Test
retrieve <Test: int proceed$1()> from Test
retrieve <C2: int m()> from C2
retrieve <C2: void <init>()> from C2
retrieve <pack2.Foo: int hello()> from pack2.Foo
retrieve <pack2.Foo: void <init>()> from pack2.Foo
retrieve <pack3.Foo: int hello()> from pack3.Foo
retrieve <pack3.Foo: void <init>()> from pack3.Foo
retrieve <pack1.Foo: int hello()> from pack1.Foo
retrieve <pack1.Foo: void <init>()> from pack1.Foo
retrieve <C1: int m()> from C1
retrieve <C1: void <init>()> from C1
Transforming C2... 
Transforming pack2.Foo... 
Transforming Test... 
Transforming C3... 
Transforming Driver... 
Transforming pack3.Foo... 
Transforming C1... 
Transforming pack1.Foo... 
Transforming abc$access$Test$around$0... 
Abc finished on Thu Jun 24 08:03:23 BST 2004. ( 0 min. 7 sec. )
PASS: make sure new weaves work inside of packages (again)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 8 passed (check: 0), 0 skipped.
Executing test 9 (base/test108): Inheritance of class and aspect vars in weaves
================================================
Breakdown of abc phases  (total: 7995 millisec.)
------------------------------------------------
[ 00.463% ] Init. of Soot:  37
[ 00.050% ] Loading Jars:  4
[ 74.071% ] Polyglot phases:  5922
[ 00.038% ] Resolve class names:  3
[ 00.025% ] Declare Parents:  2
[ 00.650% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.463% ] Intertype Adjuster:  37
[ 06.617% ] Retrieving bodies:  529
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  22
[ 02.789% ] Compute advice lists:  223
[ 00.038% ] Intertype weave:  3
[ 00.475% ] Add aspect code:  38
[ 00.363% ] Weaving advice:  29
[ 00.013% ] Validate jimple:  1
[ 10.494% ] Soot Packs:  839
[ 03.177% ] Soot Writing Output:  254
================================================
Abc started on Thu Jun 24 08:03:25 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Bar().m(),
                                              10,
                                              "Bar.m");
    }
    
    public Driver() { super(); }
}
class Foo {
    int fooVar = 1;
    
    public int getFooVar() { return this/*null*/.fooVar; }
    
    public Foo() { super(); }
}
class Bar extends Foo {
    int barVar = 2;
    
    int ans = 0;
    
    public int getBarVar() { return this/*null*/.barVar; }
    
    public void setAns(int newAns) { this/*null*/.ans = newAns; }
    
    int m() { return this/*null*/.ans; }
    
    public Bar() { super(); }
}
abstract aspect A {
    static int aVar = 3;
    
    public A() { super(); }
}
aspect B extends A {
    static int bVar = 4;
    
    before(Bar b):
    target(b) &&
      call(* (*).m(..)) {
        b.setAns(b.getFooVar() + b.getBarVar() + A/*A*/.aVar +
                 B/*B*/.bVar);
    }
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Foo: int getFooVar()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <Bar: void <init>()> from Bar
retrieve <Bar: int getBarVar()> from Bar
retrieve <Bar: void setAns(int)> from Bar
retrieve <Bar: int m()> from Bar
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <B: boolean hasAspect()> from B
retrieve <B: void <init>()> from B
retrieve <B: void <clinit>()> from B
retrieve <B: void before$0(Bar)> from B
retrieve <B: B aspectOf()> from B
Transforming A... 
Transforming Driver... 
Transforming Foo... 
Transforming B... 
Transforming Bar... 
Abc finished on Thu Jun 24 08:03:33 BST 2004. ( 0 min. 8 sec. )
PASS: Inheritance of class and aspect vars in weaves()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 9 passed (check: 0), 0 skipped.
Executing test 10 (base/test109): Accessibility of class and aspect members from inside weaves
================================================
Breakdown of abc phases  (total: 8047 millisec.)
------------------------------------------------
[ 00.460% ] Init. of Soot:  37
[ 00.050% ] Loading Jars:  4
[ 70.971% ] Polyglot phases:  5711
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.510% ] Recompute name pattern matches:  41
[ 00.000% ] Compute precedence relation:  0
[ 00.783% ] Intertype Adjuster:  63
[ 06.499% ] Retrieving bodies:  523
[ 00.000% ] Weave Initializers:  0
[ 00.273% ] Load shadow types:  22
[ 10.252% ] Compute advice lists:  825
[ 00.075% ] Intertype weave:  6
[ 00.559% ] Add aspect code:  45
[ 00.410% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 05.045% ] Soot Packs:  406
[ 04.064% ] Soot Writing Output:  327
================================================
Abc started on Thu Jun 24 08:03:36 BST 2004
<<<< Driver.java >>>>
public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo f = new Foo();
        f.foo();
    }
    
    public Driver() { super(); }
}
<<<< Foo.java >>>>
public class Foo {
    private java.lang.String _name;
    
    private static final int PRIVATECONST = 1;
    
    private static int privateClassVar = 2;
    
    private int privateInstanceVar = 3;
    
    protected static int protectedClassVar = 4;
    
    protected int protectedInstanceVar = 5;
    
    public static int publicClassVar = 6;
    
    public int publicInstanceVar = 7;
    
    public static int ClassVar = 8;
    
    public int InstanceVar = 9;
    
    public void foo() {  }
    
    private static void privateClassMethod() {  }
    
    private void privateInstanceMethod() {  }
    
    protected static void protectedClassMethod() {  }
    
    protected void protectedInstanceMethod() {  }
    
    public static void publicClassMethod() {  }
    
    public void publicInstanceMethod() {  }
    
    static void ClassMethod() {  }
    
    void InstanceMethod() {  }
    
    public Foo() { super(); }
}
<<<< Aspect.java >>>>
aspect Aspect {
    public java.lang.String toString() { return "The Aspect"; }
    
    before(Foo f):
    target(f) &&
      call(* (*).foo(..)) {
        f/*null*/.protectedClassVar++;
        f/*null*/.protectedInstanceVar++;
        f/*null*/.publicClassVar++;
        f/*null*/.publicInstanceVar++;
        f/*null*/.ClassVar++;
        f/*null*/.InstanceVar++;
        f.protectedClassMethod();
        f.protectedInstanceMethod();
        f.publicClassMethod();
        f.publicInstanceMethod();
        f.ClassMethod();
        f.InstanceMethod();
    }
    
    public static Aspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Aspect() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void <clinit>()> from Foo
retrieve <Foo: void foo()> from Foo
retrieve <Foo: void privateClassMethod()> from Foo
retrieve <Foo: void privateInstanceMethod()> from Foo
retrieve <Foo: void protectedClassMethod()> from Foo
retrieve <Foo: void protectedInstanceMethod()> from Foo
retrieve <Foo: void publicClassMethod()> from Foo
retrieve <Foo: void publicInstanceMethod()> from Foo
retrieve <Foo: void ClassMethod()> from Foo
retrieve <Foo: void InstanceMethod()> from Foo
retrieve <Aspect: java.lang.String toString()> from Aspect
retrieve <Aspect: void before$0(Foo)> from Aspect
retrieve <Aspect: Aspect aspectOf(java.lang.Object)> from Aspect
retrieve <Aspect: boolean hasAspect(java.lang.Object)> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming Aspect... 
Transforming Foo... 
Transforming Driver... 
Transforming Aspect$abc$PerTarget... 
Abc finished on Thu Jun 24 08:03:44 BST 2004. ( 0 min. 8 sec. )
PASS: Accessibility of class and aspect members from inside weaves()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 10 passed (check: 0), 0 skipped.
Executing test 11 (base/test110): Packaged aspects referring to packaged classes
================================================
Breakdown of abc phases  (total: 7583 millisec.)
------------------------------------------------
[ 00.488% ] Init. of Soot:  37
[ 00.053% ] Loading Jars:  4
[ 73.757% ] Polyglot phases:  5593
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.725% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.501% ] Intertype Adjuster:  38
[ 06.646% ] Retrieving bodies:  504
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  23
[ 08.400% ] Compute advice lists:  637
[ 00.053% ] Intertype weave:  4
[ 00.462% ] Add aspect code:  35
[ 00.356% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 05.143% ] Soot Packs:  390
[ 03.059% ] Soot Writing Output:  232
================================================
Abc started on Thu Jun 24 08:03:47 BST 2004
<<<< Driver.java >>>>
import pClass.Class;
import pAspect.Aspect;
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        pClass.Class f = new pClass.Class();
        f.foo();
        org.aspectj.testing.Tester.check(pAspect.Aspect/*pAspect.Aspect*/.ranAdvice,
                                         "advice on class in different package");
    }
    
    public Driver() { super(); }
}
<<<< Aspect.java >>>>
package pAspect;

public aspect Aspect {
    public static boolean ranAdvice = false;
    
    before():
    target(pClass.Class) &&
      call(* (*).foo(..)) {
        pAspect.Aspect/*pAspect.Aspect*/.ranAdvice = true;
    }
    
    public static pAspect.Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
<<<< Class.java >>>>
package pClass;

public class Class {
    public void foo() {  }
    
    public Class() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <pAspect.Aspect: void before$0()> from pAspect.Aspect
retrieve <pAspect.Aspect: pAspect.Aspect aspectOf()> from pAspect.Aspect
retrieve <pAspect.Aspect: boolean hasAspect()> from pAspect.Aspect
retrieve <pAspect.Aspect: void <init>()> from pAspect.Aspect
retrieve <pAspect.Aspect: void <clinit>()> from pAspect.Aspect
retrieve <pClass.Class: void foo()> from pClass.Class
retrieve <pClass.Class: void <init>()> from pClass.Class
Transforming pClass.Class... 
Transforming pAspect.Aspect... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:03:54 BST 2004. ( 0 min. 7 sec. )
PASS: Packaged aspects referring to packaged classes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 0 failed (check: 0), 11 passed (check: 0), 0 skipped.
Executing test 12 (base/test111): Inheritance of methods advised by aspects
================================================
Breakdown of abc phases  (total: 8270 millisec.)
------------------------------------------------
[ 00.472% ] Init. of Soot:  39
[ 00.036% ] Loading Jars:  3
[ 74.172% ] Polyglot phases:  6134
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.689% ] Recompute name pattern matches:  57
[ 00.012% ] Compute precedence relation:  1
[ 00.447% ] Intertype Adjuster:  37
[ 06.288% ] Retrieving bodies:  520
[ 00.000% ] Weave Initializers:  0
[ 00.266% ] Load shadow types:  22
[ 08.573% ] Compute advice lists:  709
[ 00.036% ] Intertype weave:  3
[ 00.472% ] Add aspect code:  39
[ 01.076% ] Weaving advice:  89
[ 00.000% ] Validate jimple:  0
[ 04.353% ] Soot Packs:  360
[ 03.059% ] Soot Writing Output:  253
================================================
Abc started on Thu Jun 24 08:03:57 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        SubClass sub = new SubClass(3);
        org.aspectj.testing.Tester.checkEqual(sub.getX(),
                                              3 +
                                              42,
                                              "x value");
    }
    
    public Driver() { super(); }
}
<<<< SuperAspect.java >>>>
import org.aspectj.testing.Tester;

public aspect SuperAspect {
    before(SuperClass s):
    target(s) &&
      call(* (*).getX(..)) {
        org.aspectj.testing.Tester.checkEqual(thisJoinPoint.getSignature().getName(),
                                              "getX",
                                              "method name");
        s.setX(s.checkX() + 42);
    }
    
    public static SuperAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public SuperAspect() { super(); }
}
<<<< SuperClass.java >>>>
public class SuperClass {
    int x;
    
    public SuperClass(int _x) {
        super();
        this/*null*/.x = _x;
    }
    
    public int getX() { return this/*null*/.x; }
    
    public int checkX() { return this/*null*/.x; }
    
    public void setX(int newX) { this/*null*/.x = newX; }
}
<<<< SubClass.java >>>>
public class SubClass extends SuperClass {
    public SubClass(int _x) { super(_x); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <SuperAspect: void before$0(SuperClass,org.aspectj.lang.JoinPoint)> from SuperAspect
retrieve <SuperAspect: SuperAspect aspectOf()> from SuperAspect
retrieve <SuperAspect: boolean hasAspect()> from SuperAspect
retrieve <SuperAspect: void <init>()> from SuperAspect
retrieve <SuperClass: void setX(int)> from SuperClass
retrieve <SuperClass: void <init>(int)> from SuperClass
retrieve <SuperClass: int getX()> from SuperClass
retrieve <SuperClass: int checkX()> from SuperClass
retrieve <SubClass: void <init>(int)> from SubClass
Transforming SuperAspect... 
Transforming SuperClass... 
Transforming Driver... 
Transforming SubClass... 
Abc finished on Thu Jun 24 08:04:05 BST 2004. ( 0 min. 8 sec. )
PASS: Inheritance of methods advised by aspects()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 12 passed (check: 0), 0 skipped.
Executing test 13 (base/test112): Inherited weaves on constructor
================================================
Breakdown of abc phases  (total: 7646 millisec.)
------------------------------------------------
[ 00.523% ] Init. of Soot:  40
[ 00.052% ] Loading Jars:  4
[ 74.170% ] Polyglot phases:  5671
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.667% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.811% ] Intertype Adjuster:  62
[ 06.343% ] Retrieving bodies:  485
[ 00.000% ] Weave Initializers:  0
[ 00.353% ] Load shadow types:  27
[ 01.857% ] Compute advice lists:  142
[ 00.039% ] Intertype weave:  3
[ 00.419% ] Add aspect code:  32
[ 00.340% ] Weaving advice:  26
[ 00.000% ] Validate jimple:  0
[ 09.901% ] Soot Packs:  757
[ 04.473% ] Soot Writing Output:  342
================================================
Abc started on Thu Jun 24 08:04:08 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static int constructorCount = 0;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        SubClass sub1 = new SubClass();
        org.aspectj.testing.Tester.checkEqual(Driver/*Driver*/.constructorCount,
                                              1,
                                              "constructor called");
    }
    
    public Driver() { super(); }
}
class SuperClass {
    public SuperClass() { super(); }
}
class SubClass extends SuperClass {
    public SubClass() { super(); }
}
aspect SuperAspect {
    after() returning:
    call((SuperClass+).new(..)) {
        Driver/*Driver*/.constructorCount += 1;
    }
    
    public static SuperAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public SuperAspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
retrieve <SuperClass: void <init>()> from SuperClass
retrieve <SubClass: void <init>()> from SubClass
retrieve <SuperAspect: void afterReturning$0()> from SuperAspect
retrieve <SuperAspect: SuperAspect aspectOf()> from SuperAspect
retrieve <SuperAspect: boolean hasAspect()> from SuperAspect
retrieve <SuperAspect: void <init>()> from SuperAspect
Transforming SuperAspect... 
Transforming SuperClass... 
Transforming SubClass... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:04:15 BST 2004. ( 0 min. 7 sec. )
PASS: Inherited weaves on constructor()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 13 passed (check: 0), 0 skipped.
Executing test 14 (base/test113): Initializers in Aspect and Class Bodies
================================================
Breakdown of abc phases  (total: 7848 millisec.)
------------------------------------------------
[ 00.510% ] Init. of Soot:  40
[ 00.038% ] Loading Jars:  3
[ 74.656% ] Polyglot phases:  5859
[ 00.025% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.586% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.459% ] Intertype Adjuster:  36
[ 06.651% ] Retrieving bodies:  522
[ 00.000% ] Weave Initializers:  0
[ 00.293% ] Load shadow types:  23
[ 02.370% ] Compute advice lists:  186
[ 00.038% ] Intertype weave:  3
[ 00.586% ] Add aspect code:  46
[ 06.397% ] Weaving advice:  502
[ 00.000% ] Validate jimple:  0
[ 04.205% ] Soot Packs:  330
[ 03.173% ] Soot Writing Output:  249
================================================
Abc started on Thu Jun 24 08:04:18 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static boolean classStaticInitRan;
    
    public static boolean classInitRan;
    
    public static boolean aspectStaticInitRan;
    
    public static boolean aspectInitRan;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Class c = new Class();
        org.aspectj.testing.Tester.check(Driver/*Driver*/.classStaticInitRan,
                                         "ran class\'s static initializer");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.classInitRan,
                                         "ran class\'s initializer");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.aspectStaticInitRan,
                                         "ran aspect\'s static initializer");
        org.aspectj.testing.Tester.check(Driver/*Driver*/.aspectInitRan,
                                         "ran aspect\'s initializer");
    }
    
    public Driver() { super(); }
}
class Class {
    static { Driver/*Driver*/.classStaticInitRan = true; }
    
    { Driver/*Driver*/.classInitRan = true; }
    
    public Class() { super(); }
}
aspect Aspect {
    static { Driver/*Driver*/.aspectStaticInitRan = true; }
    
    { Driver/*Driver*/.aspectInitRan = true; }
    
    public static Aspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Aspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Class: void <init>()> from Class
retrieve <Class: void <clinit>()> from Class
retrieve <Aspect: Aspect aspectOf(java.lang.Object)> from Aspect
retrieve <Aspect: boolean hasAspect(java.lang.Object)> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
Transforming Aspect... 
Transforming Driver... 
Transforming Class... 
Transforming Aspect$abc$PerTarget... 
Abc finished on Thu Jun 24 08:04:26 BST 2004. ( 0 min. 7 sec. )
PASS: Initializers in Aspect and Class Bodies()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 14 passed (check: 0), 0 skipped.
Executing test 15 (base/test114): Weaver Resolution of method names in method calls passed as args
================================================
Breakdown of abc phases  (total: 8249 millisec.)
------------------------------------------------
[ 00.473% ] Init. of Soot:  39
[ 00.048% ] Loading Jars:  4
[ 72.045% ] Polyglot phases:  5943
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.546% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.739% ] Intertype Adjuster:  61
[ 06.292% ] Retrieving bodies:  519
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  23
[ 10.195% ] Compute advice lists:  841
[ 00.036% ] Intertype weave:  3
[ 00.388% ] Add aspect code:  32
[ 00.509% ] Weaving advice:  42
[ 00.000% ] Validate jimple:  0
[ 04.958% ] Soot Packs:  409
[ 03.443% ] Soot Writing Output:  284
================================================
Abc started on Thu Jun 24 08:04:29 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Class c = new Class();
        c.foo(5);
    }
    
    public Driver() { super(); }
}
class Class {
    void foo(int x) {  }
    
    int baz(int y) { return 2; }
    
    public Class() { super(); }
}
aspect Aspect {
    int bar(int x) { return 5; }
    
    after(Class c, int z):
    target(c) && call(* (*).foo(int)) &&
      args(z) {
        org.aspectj.testing.Tester.check(c.baz(bar(6)) ==
                                         2,
                                         "didn\'t run class method");
        org.aspectj.testing.Tester.check(bar(c.baz(4)) ==
                                         5,
                                         "Didn\'t run aspect method");
    }
    
    public static Aspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Aspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Class: void foo(int)> from Class
retrieve <Class: int baz(int)> from Class
retrieve <Class: void <init>()> from Class
retrieve <Aspect: int bar(int)> from Aspect
retrieve <Aspect: void after$0(Class,int)> from Aspect
retrieve <Aspect: Aspect aspectOf(java.lang.Object)> from Aspect
retrieve <Aspect: boolean hasAspect(java.lang.Object)> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming Aspect... 
Transforming Driver... 
Transforming Class... 
Transforming Aspect$abc$PerTarget... 
Abc finished on Thu Jun 24 08:04:37 BST 2004. ( 0 min. 8 sec. )
PASS: Weaver Resolution of method names in method calls passed as args()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 15 passed (check: 0), 0 skipped.
Executing test 16 (base/test115): DEPRECATED: Introduce constructor with class inheritance
================================================
Breakdown of abc phases  (total: 7626 millisec.)
------------------------------------------------
[ 00.498% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 73.551% ] Polyglot phases:  5609
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.603% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 02.203% ] Intertype Adjuster:  168
[ 05.167% ] Retrieving bodies:  394
[ 00.000% ] Weave Initializers:  0
[ 00.328% ] Load shadow types:  25
[ 07.933% ] Compute advice lists:  605
[ 00.052% ] Intertype weave:  4
[ 00.420% ] Add aspect code:  32
[ 00.170% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 05.665% ] Soot Packs:  432
[ 03.318% ] Soot Writing Output:  253
================================================
Abc started on Thu Jun 24 08:04:39 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        SubClass s = new SubClass(0);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.count,
                                              2,
                                              "introduced constructors");
    }
    
    public Driver() { super(); }
}
class Class {
    public Class() { super(); }
}
class SubClass extends Class {
    public SubClass() { super(); }
}
aspect Aspect {
    static int count = 0;
    
    Class.new(int i) {
        super();
        Aspect/*Aspect*/.count++;
    }
    
    SubClass.new(int i) {
        super(2);
        Aspect/*Aspect*/.count++;
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Class: void <init>(int,Aspect)> from Class
retrieve <Class: void <init>()> from Class
retrieve <SubClass: void <init>(int,Aspect)> from SubClass
retrieve <SubClass: void <init>()> from SubClass
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void new$Class$5(Class,int,Aspect)> from Aspect
retrieve <Aspect: int arg$SubClass$7(int,Aspect)> from Aspect
retrieve <Aspect: Aspect arg$SubClass$8(int,Aspect)> from Aspect
retrieve <Aspect: void new$SubClass$9(SubClass,int,Aspect)> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
Transforming Aspect... 
Transforming Class... 
Transforming SubClass... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:04:47 BST 2004. ( 0 min. 7 sec. )
PASS: DEPRECATED: Introduce constructor with class inheritance()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 16 passed (check: 0), 0 skipped.
Executing test 17 (base/test116): empty and singular patterns on modifiers and throws
================================================
Breakdown of abc phases  (total: 8147 millisec.)
------------------------------------------------
[ 00.466% ] Init. of Soot:  38
[ 00.049% ] Loading Jars:  4
[ 72.910% ] Polyglot phases:  5940
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.466% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.761% ] Intertype Adjuster:  62
[ 06.420% ] Retrieving bodies:  523
[ 00.000% ] Weave Initializers:  0
[ 00.282% ] Load shadow types:  23
[ 08.948% ] Compute advice lists:  729
[ 00.061% ] Intertype weave:  5
[ 00.393% ] Add aspect code:  32
[ 00.331% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 05.794% ] Soot Packs:  472
[ 03.069% ] Soot Writing Output:  250
================================================
Abc started on Thu Jun 24 08:04:50 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Class c = new Class();
        c.l();
        c.l(2);
        c.m(3);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.c1,
                                              3,
                                              "Aspect.c1");
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.c2,
                                              2,
                                              "Aspect.c2");
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.c3,
                                              1,
                                              "Aspect.c3");
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.c4,
                                              2,
                                              "Aspect.c4");
    }
    
    public Driver() { super(); }
}
class Class {
    public void l() throws java.lang.Error {  }
    
    void l(int x) {  }
    
    public void m(int x) throws java.lang.Error {  }
    
    public Class() { super(); }
}
aspect Aspect {
    static int c1;
    
    static int c2;
    
    static int c3;
    
    static int c4 = 0;
    
    before():
    target(Class) &&
      call(void (*).*(..)) {
        Aspect/*Aspect*/.c1++;
    }
    
    before(int x):
    target(Class) && call(void (*).*(int)) &&
      args(x) {
        Aspect/*Aspect*/.c2++;
    }
    
    before(int x):
    target(Class) && call(public void (*).*(int)) &&
      args(x) {
        Aspect/*Aspect*/.c3++;
    }
    
    before():
    target(Class) &&
      call(void (*).*(..) throws Error) {
        Aspect/*Aspect*/.c4++;
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Class: void l()> from Class
retrieve <Class: void l(int)> from Class
retrieve <Class: void m(int)> from Class
retrieve <Class: void <init>()> from Class
retrieve <Aspect: void before$0()> from Aspect
retrieve <Aspect: void before$1(int)> from Aspect
retrieve <Aspect: void before$2(int)> from Aspect
retrieve <Aspect: void before$3()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
Transforming Aspect... 
Transforming Driver... 
Transforming Class... 
Abc finished on Thu Jun 24 08:04:58 BST 2004. ( 0 min. 8 sec. )
PASS: empty and singular patterns on modifiers and throws()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 0 failed (check: 0), 17 passed (check: 0), 0 skipped.
Executing test 18 (base/test117): DEPRECATED: introduce of variables
Failed. Current status: 1 failed (check: 0), 17 passed (check: 0), 0 skipped.
Executing test 19 (base/test118): DEPRECATED: Introduce of constructors
================================================
Breakdown of abc phases  (total: 8645 millisec.)
------------------------------------------------
[ 00.463% ] Init. of Soot:  40
[ 00.046% ] Loading Jars:  4
[ 73.603% ] Polyglot phases:  6363
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.671% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 01.862% ] Intertype Adjuster:  161
[ 10.630% ] Retrieving bodies:  919
[ 00.000% ] Weave Initializers:  0
[ 00.266% ] Load shadow types:  23
[ 02.984% ] Compute advice lists:  258
[ 00.035% ] Intertype weave:  3
[ 00.382% ] Add aspect code:  33
[ 00.416% ] Weaving advice:  36
[ 00.000% ] Validate jimple:  0
[ 04.881% ] Soot Packs:  422
[ 03.713% ] Soot Writing Output:  321
================================================
Failed. Current status: 2 failed (check: 0), 17 passed (check: 0), 0 skipped.
Executing test 20 (base/test119): Local declarations in advise bodies
================================================
Breakdown of abc phases  (total: 10293 millisec.)
------------------------------------------------
[ 00.379% ] Init. of Soot:  39
[ 00.039% ] Loading Jars:  4
[ 68.687% ] Polyglot phases:  7070
[ 00.019% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  2
[ 00.563% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.389% ] Intertype Adjuster:  40
[ 05.237% ] Retrieving bodies:  539
[ 00.000% ] Weave Initializers:  0
[ 00.262% ] Load shadow types:  27
[ 09.871% ] Compute advice lists:  1016
[ 00.029% ] Intertype weave:  3
[ 00.340% ] Add aspect code:  35
[ 01.341% ] Weaving advice:  138
[ 00.000% ] Validate jimple:  0
[ 07.044% ] Soot Packs:  725
[ 05.781% ] Soot Writing Output:  595
================================================
Abc started on Thu Jun 24 08:05:20 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo foo = new Foo();
        foo.m();
    }
    
    public Driver() { super(); }
}
aspect A {
    void around ():
    target(Foo) &&
      call(void (*).m(..)) {
        class Internal {
            int val() { return 1; }
            
            public Internal() { super(); }
        }
        ;
        int i = 1;
        Internal j = new Internal();
        this.proceed();
        org.aspectj.testing.Tester.checkEqual(i, 1, "i");
        org.aspectj.testing.Tester.checkEqual(j.val(), 1, "j.val()");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class Foo {
    Foo() { super(); }
    
    void m() {  }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <A: void around$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void proceed$1()> from A
retrieve <A$1Internal: void <init>(A)> from A$1Internal
retrieve <A$1Internal: int val()> from A$1Internal
retrieve <Foo: void m()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <A$1Internal: void <init>(A)> from A$1Internal
retrieve <A$1Internal: int val()> from A$1Internal
Transforming A... 
Transforming A$1Internal... 
Transforming Foo... 
Transforming Driver... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 08:05:30 BST 2004. ( 0 min. 10 sec. )
PASS: Local declarations in advise bodies()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 2 failed (check: 0), 18 passed (check: 0), 0 skipped.
Executing test 21 (base/test120): unicodes and literals
================================================
Breakdown of abc phases  (total: 11066 millisec.)
------------------------------------------------
[ 01.247% ] Init. of Soot:  138
[ 00.027% ] Loading Jars:  3
[ 75.764% ] Polyglot phases:  8384
[ 00.000% ] Resolve class names:  0
[ 00.018% ] Declare Parents:  2
[ 00.271% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 00.361% ] Intertype Adjuster:  40
[ 14.332% ] Retrieving bodies:  1586
[ 00.000% ] Weave Initializers:  0
[ 00.605% ] Load shadow types:  67
[ 01.392% ] Compute advice lists:  154
[ 00.027% ] Intertype weave:  3
[ 00.090% ] Add aspect code:  10
[ 00.127% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.091% ] Soot Packs:  342
[ 02.648% ] Soot Writing Output:  293
================================================
Abc started on Thu Jun 24 08:05:35 BST 2004
<<<< Driver.java >>>>
public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        int dec = 5;
        long longDec = 5;
        long longDecL = 5L;
        int hex = 703710;
        long longHex = 703710;
        long longHexL = 703710L;
        int oct = 498;
        long longOct = 498;
        long longOctL = 498L;
        boolean btrue = true;
        boolean bfalse = false;
        float f1 = 10.0F;
        float f2 = 2.0F;
        float f3 = 0.3F;
        float f4 = 3.14F;
        float f5 = 6.023E23F;
        char c2 = 'c';
        java.lang.String c = "c";
        java.lang.String s1 = "";
        java.lang.String s2 = "c";
        java.lang.String bs = "\b";
        java.lang.String ht = "\t";
        java.lang.String lf = "\n";
        java.lang.String cr = "\r";
        java.lang.String dq = "\"";
        java.lang.String sq = "\'";
        java.lang.String backslash = "\\";
        java.lang.String oes = "\000";
        java.lang.String oeb = "\377";
        java.lang.String ctrlg = "\007";
        java.lang.String random = "?";
    }
    
    public Driver() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
Transforming Driver... 
Abc finished on Thu Jun 24 08:05:46 BST 2004. ( 0 min. 11 sec. )
PASS: unicodes and literals()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 2 failed (check: 0), 19 passed (check: 0), 0 skipped.
Executing test 22 (base/test121): advises on introduced methods and constructors
================================================
Breakdown of abc phases  (total: 9023 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  38
[ 00.033% ] Loading Jars:  3
[ 68.813% ] Polyglot phases:  6209
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.720% ] Recompute name pattern matches:  65
[ 00.000% ] Compute precedence relation:  0
[ 01.651% ] Intertype Adjuster:  149
[ 05.209% ] Retrieving bodies:  470
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  26
[ 05.807% ] Compute advice lists:  524
[ 00.033% ] Intertype weave:  3
[ 00.598% ] Add aspect code:  54
[ 01.275% ] Weaving advice:  115
[ 00.000% ] Validate jimple:  0
[ 10.917% ] Soot Packs:  985
[ 04.189% ] Soot Writing Output:  378
================================================
creating: A@84433d
Failed. Current status: 3 failed (check: 0), 19 passed (check: 0), 0 skipped.
Executing test 23 (base/test122): DEPRECATED: Method introduction into interface implemented by abstract class
================================================
Breakdown of abc phases  (total: 7760 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  39
[ 00.039% ] Loading Jars:  3
[ 75.941% ] Polyglot phases:  5893
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.670% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 07.564% ] Intertype Adjuster:  587
[ 04.948% ] Retrieving bodies:  384
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  24
[ 01.933% ] Compute advice lists:  150
[ 00.052% ] Intertype weave:  4
[ 00.438% ] Add aspect code:  34
[ 00.180% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.905% ] Soot Packs:  303
[ 03.466% ] Soot Writing Output:  269
================================================
Abc started on Thu Jun 24 08:06:01 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        I i = new C4();
        org.aspectj.testing.Tester.checkEqual(i.m(), 42, "i.m()");
    }
    
    public Driver() { super(); }
}
interface I {}
abstract class C1 implements I {
    public C1() { super(); }
}
class C2 extends C1 implements I {
    public C2() { super(); }
}
class C3 extends C1 {
    public C3() { super(); }
}
class C4 extends C2 {
    public C4() { super(); }
}
aspect Aspect {
    public intertype int I.m() { return 42; }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C1: void <init>()> from C1
retrieve <C1: int m()> from C1
retrieve <C2: void <init>()> from C2
retrieve <C3: void <init>()> from C3
retrieve <C4: void <init>()> from C4
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: int m(I)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
Transforming C2... 
Transforming C1... 
Transforming C3... 
Transforming C4... 
Transforming Aspect... 
Transforming Driver... 
Transforming I... 
Abc finished on Thu Jun 24 08:06:09 BST 2004. ( 0 min. 7 sec. )
PASS: DEPRECATED: Method introduction into interface implemented by abstract c...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 20 passed (check: 0), 0 skipped.
Executing test 24 (base/test123): Crossing super calls in constructors
================================================
Breakdown of abc phases  (total: 7951 millisec.)
------------------------------------------------
[ 00.478% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 74.205% ] Polyglot phases:  5900
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.478% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.742% ] Intertype Adjuster:  59
[ 12.250% ] Retrieving bodies:  974
[ 00.000% ] Weave Initializers:  0
[ 00.289% ] Load shadow types:  23
[ 02.717% ] Compute advice lists:  216
[ 00.038% ] Intertype weave:  3
[ 00.453% ] Add aspect code:  36
[ 00.478% ] Weaving advice:  38
[ 00.000% ] Validate jimple:  0
[ 04.515% ] Soot Packs:  359
[ 03.270% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 08:06:11 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C1 c1 = new C1(333);
        org.aspectj.testing.Tester.checkEqual(c1/*null*/.afterAdvises,
                                              0,
                                              "C1(int)");
        c1 = new C1("asdfasdf");
        org.aspectj.testing.Tester.checkEqual(c1/*null*/.afterAdvises,
                                              1,
                                              "C1(String)");
        C2 c2 = new C2(333);
        org.aspectj.testing.Tester.checkEqual(c2/*null*/.afterAdvises,
                                              0,
                                              "C2(int) -> C1(String)");
        c2 = new C2("foo");
        org.aspectj.testing.Tester.checkEqual(c2/*null*/.afterAdvises,
                                              1,
                                              "C2(String) -> C1(int)");
        c2 = new C2("foo", 42);
        org.aspectj.testing.Tester.checkEqual(c2/*null*/.afterAdvises,
                                              1,
                                              "C2(String,int) -> C1(String)");
    }
    
    public Driver() { super(); }
}
class C1 {
    public int afterAdvises = 0;
    
    C1() { super(); }
    
    C1(int i) { super(); }
    
    C1(java.lang.String s) { super(); }
}
class C2 extends C1 {
    C2(int i) { super("asdf"); }
    
    C2(java.lang.String s) { super(42); }
    
    C2(java.lang.String s, int i) { super(s); }
}
aspect A {
    after() returning(C1 c1):
    call((*).new(String, ..)) {
        c1/*null*/.afterAdvises += 1;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C1: void <init>(int)> from C1
retrieve <C1: void <init>(java.lang.String)> from C1
retrieve <C1: void <init>()> from C1
retrieve <C2: void <init>(int)> from C2
retrieve <C2: void <init>(java.lang.String)> from C2
retrieve <C2: void <init>(java.lang.String,int)> from C2
retrieve <A: void afterReturning$0(C1)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming C2... 
Transforming A... 
Transforming Driver... 
Transforming C1... 
Abc finished on Thu Jun 24 08:06:19 BST 2004. ( 0 min. 8 sec. )
PASS: Crossing super calls in constructors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 21 passed (check: 0), 0 skipped.
Executing test 25 (base/test124): empty modifier pattern
================================================
Breakdown of abc phases  (total: 7748 millisec.)
------------------------------------------------
[ 00.478% ] Init. of Soot:  37
[ 00.052% ] Loading Jars:  4
[ 75.065% ] Polyglot phases:  5816
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.710% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.478% ] Intertype Adjuster:  37
[ 06.440% ] Retrieving bodies:  499
[ 00.000% ] Weave Initializers:  0
[ 00.284% ] Load shadow types:  22
[ 02.375% ] Compute advice lists:  184
[ 00.052% ] Intertype weave:  4
[ 00.594% ] Add aspect code:  46
[ 00.413% ] Weaving advice:  32
[ 00.000% ] Validate jimple:  0
[ 03.665% ] Soot Packs:  284
[ 09.344% ] Soot Writing Output:  724
================================================
Abc started on Thu Jun 24 08:06:22 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Driver.m(4);
        org.aspectj.testing.Tester.checkEqual(Trace/*Trace*/.enterCount,
                                              2,
                                              "befores");
        org.aspectj.testing.Tester.checkEqual(Trace/*Trace*/.exitCount,
                                              1,
                                              "afters");
    }
    
    static int m(int x) { return 0; }
    
    public Driver() { super(); }
}
aspect Trace {
    public static int enterCount;
    
    public static int exitCount;
    
    before():
    within(Driver) &&
      (execution (void (*).test()) || execution (* (*).m(..))) {
        Trace/*Trace*/.enterCount++;
    }
    
    after():
    within(Driver) &&
      (execution (void (*).test()) || execution (* (*).m(..))) {
        Trace/*Trace*/.exitCount++;
    }
    
    public static Trace aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Trace() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: int m(int)> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Trace: void before$0()> from Trace
retrieve <Trace: void after$1()> from Trace
retrieve <Trace: Trace aspectOf()> from Trace
retrieve <Trace: boolean hasAspect()> from Trace
retrieve <Trace: void <init>()> from Trace
Transforming Trace... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:06:30 BST 2004. ( 0 min. 7 sec. )
PASS: empty modifier pattern()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 22 passed (check: 0), 0 skipped.
Executing test 26 (base/test125): Alpha conversion of argument names in designators
================================================
Breakdown of abc phases  (total: 8102 millisec.)
------------------------------------------------
[ 00.469% ] Init. of Soot:  38
[ 00.037% ] Loading Jars:  3
[ 73.081% ] Polyglot phases:  5921
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.555% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.728% ] Intertype Adjuster:  59
[ 06.393% ] Retrieving bodies:  518
[ 00.000% ] Weave Initializers:  0
[ 00.284% ] Load shadow types:  23
[ 09.849% ] Compute advice lists:  798
[ 00.074% ] Intertype weave:  6
[ 00.407% ] Add aspect code:  33
[ 00.457% ] Weaving advice:  37
[ 00.000% ] Validate jimple:  0
[ 04.567% ] Soot Packs:  370
[ 03.049% ] Soot Writing Output:  247
================================================
Abc started on Thu Jun 24 08:06:32 BST 2004
<<<< Driver.java >>>>
import java.io.*;
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Point p = new Point();
        p.setX(3);
    }
    
    public Driver() { super(); }
}
class Point {
    int _x = 0;
    
    int _y = 0;
    
    Point() { super(); }
    
    void set(int x, int y) {
        this/*null*/._x = x;
        this/*null*/._y = y;
    }
    
    void setX(int x) { this/*null*/._x = x; }
    
    void setY(int y) { this/*null*/._y = y; }
    
    int getX() { return this/*null*/._x; }
    
    int getY() { return this/*null*/._y; }
}
aspect Trace {
    static int oldvalue;
    
    before(Point p, int newvalue):
    target(p) && args(newvalue) &&
      (call(void (*).setX(int)) || call(void (*).setY(int))) {
        Trace/*Trace*/.oldvalue = p.getX();
    }
    
    after(Point p, int newvalue):
    target(p) && args(newvalue) &&
      (call(void (*).setX(int)) || call(void (*).setY(int))) {
        org.aspectj.testing.Tester.checkEqual(Trace/*Trace*/.oldvalue,
                                              0,
                                              "oldvalue");
        org.aspectj.testing.Tester.checkEqual(newvalue,
                                              3,
                                              "newvalue");
    }
    
    public static Trace aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Trace() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Point: void <init>()> from Point
retrieve <Point: void set(int,int)> from Point
retrieve <Point: void setX(int)> from Point
retrieve <Point: void setY(int)> from Point
retrieve <Point: int getX()> from Point
retrieve <Point: int getY()> from Point
retrieve <Trace: void before$0(Point,int)> from Trace
retrieve <Trace: void after$1(Point,int)> from Trace
retrieve <Trace: Trace aspectOf()> from Trace
retrieve <Trace: boolean hasAspect()> from Trace
retrieve <Trace: void <init>()> from Trace
Transforming Point... 
Transforming Driver... 
Transforming Trace... 
Abc finished on Thu Jun 24 08:06:40 BST 2004. ( 0 min. 8 sec. )
PASS: Alpha conversion of argument names in designators()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 23 passed (check: 0), 0 skipped.
Executing test 27 (base/test126): For Statement
================================================
Breakdown of abc phases  (total: 7032 millisec.)
------------------------------------------------
[ 00.540% ] Init. of Soot:  38
[ 00.043% ] Loading Jars:  3
[ 77.844% ] Polyglot phases:  5474
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.484% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 06.485% ] Intertype Adjuster:  456
[ 06.925% ] Retrieving bodies:  487
[ 00.000% ] Weave Initializers:  0
[ 00.327% ] Load shadow types:  23
[ 01.564% ] Compute advice lists:  110
[ 00.043% ] Intertype weave:  3
[ 00.114% ] Add aspect code:  8
[ 00.185% ] Weaving advice:  13
[ 00.014% ] Validate jimple:  1
[ 02.645% ] Soot Packs:  186
[ 02.759% ] Soot Writing Output:  194
================================================
Abc started on Thu Jun 24 08:06:43 BST 2004
<<<< Driver.java >>>>
public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        for (int i = 0, j = 0; j < 10; i++, j++) { j++; }
        int m;
        int n;
        int j = 0;
        for (m = 0, n = 0; j < 10; m++, n++) {
            j++;
            m++;
        }
    }
    
    public Driver() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
Transforming Driver... 
Abc finished on Thu Jun 24 08:06:50 BST 2004. ( 0 min. 7 sec. )
PASS: For Statement()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 3 failed (check: 0), 24 passed (check: 0), 0 skipped.
Executing test 28 (base/test127): advice uses its own formals to get actuals
================================================
Breakdown of abc phases  (total: 7571 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  3
[ 74.614% ] Polyglot phases:  5649
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.740% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.475% ] Intertype Adjuster:  36
[ 06.723% ] Retrieving bodies:  509
[ 00.000% ] Weave Initializers:  0
[ 00.317% ] Load shadow types:  24
[ 02.338% ] Compute advice lists:  177
[ 00.040% ] Intertype weave:  3
[ 00.449% ] Add aspect code:  34
[ 00.542% ] Weaving advice:  41
[ 00.000% ] Validate jimple:  0
[ 03.778% ] Soot Packs:  286
[ 09.391% ] Soot Writing Output:  711
================================================
Abc started on Thu Jun 24 08:06:53 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() { new C().foo("hello"); }
    
    public Driver() { super(); }
}
class C {
    void foo(java.lang.String s) {
        org.aspectj.testing.Tester.checkEqual(s,
                                              "hello",
                                              "in method body");
    }
    
    public C() { super(); }
}
aspect A {
    before(String str):
    target(C) && call(void (*).foo(String)) &&
      args(str) {
        org.aspectj.testing.Tester.checkEqual(str,
                                              "hello",
                                              "in advice body");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C: void foo(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <A: void before$0(java.lang.String)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Driver... 
Transforming C... 
Abc finished on Thu Jun 24 08:07:00 BST 2004. ( 0 min. 7 sec. )
PASS: advice uses its own formals to get actuals()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 3 failed (check: 0), 25 passed (check: 0), 0 skipped.
Executing test 29 (base/test128): DEPRECATED:  introduce weaves can use this
================================================
Breakdown of abc phases  (total: 7529 millisec.)
------------------------------------------------
[ 00.505% ] Init. of Soot:  38
[ 00.053% ] Loading Jars:  4
[ 74.233% ] Polyglot phases:  5589
[ 00.040% ] Resolve class names:  3
[ 00.027% ] Declare Parents:  2
[ 00.664% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 02.152% ] Intertype Adjuster:  162
[ 05.207% ] Retrieving bodies:  392
[ 00.000% ] Weave Initializers:  0
[ 00.398% ] Load shadow types:  30
[ 01.939% ] Compute advice lists:  146
[ 00.040% ] Intertype weave:  3
[ 00.239% ] Add aspect code:  18
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 11.422% ] Soot Packs:  860
[ 02.909% ] Soot Writing Output:  219
================================================
Abc started on Thu Jun 24 08:07:03 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C c = new C();
        org.aspectj.testing.Tester.check(c ==
                                         c.foo(),
                                         "this wasn\'t this");
    }
    
    public Driver() { super(); }
}
class C {
    public C() { super(); }
}
aspect A {
    intertype C C.foo() { return hostCthis; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <C: void <init>()> from C
retrieve <C: C A$foo$1()> from C
retrieve <A: C A$foo$1(C)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Driver... 
Transforming C... 
Abc finished on Thu Jun 24 08:07:11 BST 2004. ( 0 min. 7 sec. )
PASS: DEPRECATED:  introduce weaves can use this()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 3 failed (check: 0), 26 passed (check: 0), 0 skipped.
Executing test 30 (base/test129): DEPRECATED: introduce of abstract methods works
================================================
Breakdown of abc phases  (total: 7069 millisec.)
------------------------------------------------
[ 00.538% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  3
[ 79.601% ] Polyglot phases:  5627
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.679% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 02.334% ] Intertype Adjuster:  165
[ 05.517% ] Retrieving bodies:  390
[ 00.000% ] Weave Initializers:  0
[ 00.325% ] Load shadow types:  23
[ 02.518% ] Compute advice lists:  178
[ 00.057% ] Intertype weave:  4
[ 00.481% ] Add aspect code:  34
[ 00.184% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.300% ] Soot Packs:  304
[ 03.367% ] Soot Writing Output:  238
================================================
Abc started on Thu Jun 24 08:07:13 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        AbstractC aC = new C();
        org.aspectj.testing.Tester.checkEqual(aC.foo(),
                                              42,
                                              "introduced abstract");
        org.aspectj.testing.Tester.checkEqual(((I) aC).bar(),
                                              12,
                                              "introduced on interface");
    }
    
    public Driver() { super(); }
}
interface I {}
abstract class AbstractC implements I {
    public AbstractC() { super(); }
}
class C extends AbstractC {
    public C() { super(); }
}
aspect A {
    abstract intertype int AbstractC.foo();
    
    intertype int C.foo() { return 42; }
    
    public intertype int I.bar() { return 12; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <AbstractC: int bar()> from AbstractC
retrieve <AbstractC: void <init>()> from AbstractC
retrieve <C: int A$foo$3()> from C
retrieve <C: void <init>()> from C
retrieve <A: int A$foo$3(C)> from A
retrieve <A: int bar(I)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming I... 
Transforming Driver... 
Transforming C... 
Transforming AbstractC... 
Transforming A... 
Abc finished on Thu Jun 24 08:07:21 BST 2004. ( 0 min. 7 sec. )
PASS: DEPRECATED: introduce of abstract methods works()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 3 failed (check: 0), 27 passed (check: 0), 0 skipped.
Executing test 31 (base/test130): multiple arounds successfully intercept and return own values
================================================
Breakdown of abc phases  (total: 7685 millisec.)
------------------------------------------------
[ 00.494% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 72.843% ] Polyglot phases:  5598
[ 00.039% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.599% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.755% ] Intertype Adjuster:  58
[ 06.584% ] Retrieving bodies:  506
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  23
[ 02.472% ] Compute advice lists:  190
[ 00.039% ] Intertype weave:  3
[ 00.442% ] Add aspect code:  34
[ 01.327% ] Weaving advice:  102
[ 00.000% ] Validate jimple:  0
[ 10.397% ] Soot Packs:  799
[ 03.656% ] Soot Writing Output:  281
================================================
Abc started on Thu Jun 24 08:07:23 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C c = new C();
        org.aspectj.testing.Tester.checkEqual(c.basic(),
                                              4,
                                              "basic()");
        org.aspectj.testing.Tester.checkEqual(c.exceptional(),
                                              3,
                                              "exceptional()");
    }
    
    public Driver() { super(); }
}
class C {
    public int basic() { return 1; }
    
    public int exceptional() { return 1; }
    
    public C() { super(); }
}
aspect B {
    int around (): target(C) && call(int (*).basic()) { return 4; }
    
    int around ():
    target(C) &&
      call(int (*).exceptional()) {
        return 3;
    }
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C: int basic()> from C
retrieve <C: int exceptional()> from C
retrieve <C: void <init>()> from C
retrieve <B: void <init>()> from B
retrieve <B: int around$0()> from B
retrieve <B: int around$1()> from B
retrieve <B: B aspectOf()> from B
retrieve <B: boolean hasAspect()> from B
retrieve <B: int proceed$2()> from B
retrieve <B: int proceed$3()> from B
Transforming C... 
Transforming B... 
Transforming Driver... 
Transforming abc$access$B$around$0... 
Transforming abc$access$B$around$1... 
Abc finished on Thu Jun 24 08:07:31 BST 2004. ( 0 min. 7 sec. )
PASS: multiple arounds successfully intercept and return own values()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 28 passed (check: 0), 0 skipped.
Executing test 32 (base/test132): proper matching of overloaded constructors
================================================
Breakdown of abc phases  (total: 7813 millisec.)
------------------------------------------------
[ 00.486% ] Init. of Soot:  38
[ 00.051% ] Loading Jars:  4
[ 73.378% ] Polyglot phases:  5733
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.640% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.486% ] Intertype Adjuster:  38
[ 06.668% ] Retrieving bodies:  521
[ 00.000% ] Weave Initializers:  0
[ 00.294% ] Load shadow types:  23
[ 10.060% ] Compute advice lists:  786
[ 00.051% ] Intertype weave:  4
[ 00.525% ] Add aspect code:  41
[ 00.384% ] Weaving advice:  30
[ 00.000% ] Validate jimple:  0
[ 03.840% ] Soot Packs:  300
[ 03.085% ] Soot Writing Output:  241
================================================
Abc started on Thu Jun 24 08:07:33 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public aspect Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    after(String aspectName) returning(Foo f):
    call((*).new(String)) &&
      args(aspectName) {
        f/*null*/.name = aspectName + "-ADVISED";
    }
    
    public static void test() {
        Foo foo = new Foo("NAME");
        org.aspectj.testing.Tester.checkEqual(foo/*null*/.name,
                                              "NAME-ADVISED",
                                              "new Foo(name)");
        foo = new Foo();
        org.aspectj.testing.Tester.checkEqual(foo/*null*/.name,
                                              "NONE",
                                              "new Foo()");
    }
    
    public static Driver aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Driver() { super(); }
}
class Foo {
    public java.lang.String name = "NONE";
    
    public Foo() { super(); }
    
    public Foo(java.lang.String name) {
        super();
        this/*<unknown>*/.name = name;
    }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void afterReturning$0(java.lang.String,Foo)> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: Driver aspectOf()> from Driver
retrieve <Driver: boolean hasAspect()> from Driver
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void <init>(java.lang.String)> from Foo
Transforming Foo... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:07:41 BST 2004. ( 0 min. 7 sec. )
PASS: proper matching of overloaded constructors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 29 passed (check: 0), 0 skipped.
Executing test 33 (base/test133): correct super call lookup for method().name()
================================================
Breakdown of abc phases  (total: 7357 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 76.893% ] Polyglot phases:  5657
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.462% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.856% ] Intertype Adjuster:  63
[ 12.559% ] Retrieving bodies:  924
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 02.406% ] Compute advice lists:  177
[ 00.041% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  9
[ 00.177% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.882% ] Soot Packs:  212
[ 02.718% ] Soot Writing Output:  200
================================================
Abc started on Thu Jun 24 08:07:44 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    private Foo foo = new Foo();
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Foo getFoo() { return this/*null*/.foo; }
    
    public java.lang.String bar() { return getFoo().bar(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Driver().bar(),
                                              "Foo",
                                              "getFoo().bar()");
    }
    
    public Driver() { super(); }
}
class Foo {
    public java.lang.String bar() { return "Foo"; }
    
    public Foo() { super(); }
}
retrieve <Driver: java.lang.String bar()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: Foo getFoo()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Foo: java.lang.String bar()> from Foo
retrieve <Foo: void <init>()> from Foo
Transforming Foo... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:07:51 BST 2004. ( 0 min. 7 sec. )
PASS: correct super call lookup for method().name()()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 3 failed (check: 0), 30 passed (check: 0), 0 skipped.
Executing test 34 (base/test134): proper handling of formals in catch advice
================================================
Breakdown of abc phases  (total: 8283 millisec.)
------------------------------------------------
[ 00.459% ] Init. of Soot:  38
[ 00.048% ] Loading Jars:  4
[ 69.516% ] Polyglot phases:  5758
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.555% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.749% ] Intertype Adjuster:  62
[ 06.700% ] Retrieving bodies:  555
[ 00.000% ] Weave Initializers:  0
[ 00.266% ] Load shadow types:  22
[ 10.226% ] Compute advice lists:  847
[ 00.072% ] Intertype weave:  6
[ 00.278% ] Add aspect code:  23
[ 02.994% ] Weaving advice:  248
[ 00.000% ] Validate jimple:  0
[ 04.334% ] Soot Packs:  359
[ 03.755% ] Soot Writing Output:  311
================================================
Abc started on Thu Jun 24 08:07:54 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public int divide(int x, int y) { return x / y; }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Driver().divide(6,
                                                                  3),
                                              2,
                                              "divide(6, 3)");
        org.aspectj.testing.Tester.checkEqual(new Driver().divide(6,
                                                                  0),
                                              -1,
                                              "divide(6, 0)");
    }
    
    public Driver() { super(); }
}
aspect CatchArithmetic {
    int around ():
    target() &&
      call(int (*).*(..)) {
        int x;
        try {
            x = this.proceed();
        }
        catch (java.lang.ArithmeticException e) { return -1; }
        return x;
    }
    
    public static CatchArithmetic aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public CatchArithmetic() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: int divide(int,int)> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <CatchArithmetic: int around$0()> from CatchArithmetic
retrieve <CatchArithmetic: CatchArithmetic aspectOf()> from CatchArithmetic
retrieve <CatchArithmetic: boolean hasAspect()> from CatchArithmetic
retrieve <CatchArithmetic: void <init>()> from CatchArithmetic
retrieve <CatchArithmetic: int proceed$1()> from CatchArithmetic
Transforming CatchArithmetic... 
Transforming Driver... 
Transforming abc$access$CatchArithmetic$around$0... 
Abc finished on Thu Jun 24 08:08:02 BST 2004. ( 0 min. 8 sec. )
PASS: proper handling of formals in catch advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 3 failed (check: 0), 31 passed (check: 0), 0 skipped.
Executing test 35 (base/test135): proper values for thisJoinPoint attributes
Failed. Current status: 4 failed (check: 0), 31 passed (check: 0), 0 skipped.
Executing test 36 (base/test136): supers, supers, supers
================================================
Breakdown of abc phases  (total: 10517 millisec.)
------------------------------------------------
[ 00.371% ] Init. of Soot:  39
[ 00.038% ] Loading Jars:  4
[ 72.530% ] Polyglot phases:  7628
[ 00.029% ] Resolve class names:  3
[ 00.010% ] Declare Parents:  1
[ 00.551% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.361% ] Intertype Adjuster:  38
[ 12.513% ] Retrieving bodies:  1316
[ 00.010% ] Weave Initializers:  1
[ 00.219% ] Load shadow types:  23
[ 04.878% ] Compute advice lists:  513
[ 00.067% ] Intertype weave:  7
[ 00.523% ] Add aspect code:  55
[ 00.352% ] Weaving advice:  37
[ 00.000% ] Validate jimple:  0
[ 04.574% ] Soot Packs:  481
[ 02.976% ] Soot Writing Output:  313
================================================
Abc started on Thu Jun 24 08:08:12 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C0 c = new C2();
        c.m1(2, 2);
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C0_m1_calls,
                                              1,
                                              "C2.m1 -- C0 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C2_m1_calls,
                                              1,
                                              "C2.m1 -- C2 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.m1_afters,
                                              1,
                                              "C2.m1 -- after advice");
        A.clearCounts();
        c.m2(c);
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C0_m1_calls,
                                              1,
                                              "C2.m2 -- C0.m1 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C2_m1_calls,
                                              0,
                                              "C2.m2 -- C2.m1 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.m1_afters,
                                              0,
                                              "C2.m2 -- after m1 advice");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C0_m2_calls,
                                              1,
                                              "C2.m2 -- C0.m2 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C2_m2_calls,
                                              1,
                                              "C2.m2 -- C2.m2 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.m2_afters,
                                              1,
                                              "C2.m2 -- after m2 advice");
        c.m3("hi");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C0_m3_calls,
                                              1,
                                              "C2.m3 -- C0 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C1_m3_calls,
                                              1,
                                              "C2.m3 -- C1 calls");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.C2_m3_calls,
                                              1,
                                              "C2.m3 -- C2 calls");
    }
    
    public Driver() { super(); }
}
class C0 {
    public C0() { super(); }
    
    void m1(int x, double y) { A/*A*/.C0_m1_calls += 1; }
    
    void m2(C0 c0) { A/*A*/.C0_m2_calls += 1; }
    
    void m3(java.lang.String s) { A/*A*/.C0_m3_calls += 1; }
}
class C1 extends C0 {
    void m3(java.lang.String s) {
        super.m3(s);
        A/*A*/.C1_m3_calls += 1;
    }
    
    public C1() { super(); }
}
class C2 extends C1 {
    public boolean C2_after_called = false;
    
    public void setC2_after_called(boolean newVal) {
        this/*null*/.C2_after_called = newVal;
    }
    
    public C2() { super(); }
    
    void m1(int x, double y) {
        A/*A*/.C2_m1_calls += 1;
        super.m1(x * 2, x + y);
    }
    
    void m2(C0 c0) {
        A/*A*/.C2_m2_calls += 1;
        super.m1(2, 2);
        super.m2(this);
    }
    
    void m3(java.lang.String s) {
        super.m3(s);
        A/*A*/.C2_m3_calls += 1;
    }
}
aspect A {
    public static int C0_m1_calls = 0;
    
    public static int C2_m1_calls = 0;
    
    public static int C0_m2_calls = 0;
    
    public static int C2_m2_calls = 0;
    
    public static int C0_m3_calls = 0;
    
    public static int C1_m3_calls = 0;
    
    public static int C2_m3_calls = 0;
    
    public static int m1_afters = 0;
    
    public static int m2_afters = 0;
    
    public static void clearCounts() {
        A/*A*/.C0_m1_calls = 0;
        A/*A*/.C2_m1_calls = 0;
        A/*A*/.C0_m2_calls = 0;
        A/*A*/.C2_m2_calls = 0;
        A/*A*/.C0_m3_calls = 0;
        A/*A*/.C1_m3_calls = 0;
        A/*A*/.C2_m3_calls = 0;
        A/*A*/.m1_afters = 0;
        A/*A*/.m2_afters = 0;
    }
    
    after():
    target(C0) &&
      call(void (*).m1(int, double)) {
        A/*A*/.m1_afters += 1;
    }
    
    after():
    target(C0) &&
      call(* (*).m2(..)) {
        A/*A*/.m2_afters += 1;
    }
    
    after(): target(C0) && call(* (*).m3(..)) { int x = 22; }
    
    after(C2 c2) returning:
    target(c2) &&
      call((*).new()) {
        c2.setC2_after_called(true);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C0: void <init>()> from C0
retrieve <C0: void m1(int,double)> from C0
retrieve <C0: void m2(C0)> from C0
retrieve <C0: void m3(java.lang.String)> from C0
retrieve <C1: void <init>()> from C1
retrieve <C1: void m3(java.lang.String)> from C1
retrieve <C2: void setC2_after_called(boolean)> from C2
retrieve <C2: void <init>()> from C2
retrieve <C2: void m1(int,double)> from C2
retrieve <C2: void m2(C0)> from C2
retrieve <C2: void m3(java.lang.String)> from C2
retrieve <A: void <init>()> from A
retrieve <A: void clearCounts()> from A
retrieve <A: void after$0()> from A
retrieve <A: void after$1()> from A
retrieve <A: void after$2()> from A
retrieve <A: void afterReturning$3(C2)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <clinit>()> from A
Transforming C2... 
Transforming C1... 
Transforming A... 
Transforming C0... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:08:23 BST 2004. ( 0 min. 10 sec. )
PASS: supers, supers, supers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 12 seconds
Passed. Current status: 4 failed (check: 0), 32 passed (check: 0), 0 skipped.
Executing test 37 (base/test137): operations on private and protected aspect members (++, -- in partciular)
================================================
Breakdown of abc phases  (total: 9329 millisec.)
------------------------------------------------
[ 00.418% ] Init. of Soot:  39
[ 00.043% ] Loading Jars:  4
[ 70.115% ] Polyglot phases:  6541
[ 00.021% ] Resolve class names:  2
[ 00.021% ] Declare Parents:  2
[ 00.600% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.418% ] Intertype Adjuster:  39
[ 12.370% ] Retrieving bodies:  1154
[ 00.000% ] Weave Initializers:  0
[ 00.268% ] Load shadow types:  25
[ 07.396% ] Compute advice lists:  690
[ 00.032% ] Intertype weave:  3
[ 00.386% ] Add aspect code:  36
[ 00.268% ] Weaving advice:  25
[ 00.000% ] Validate jimple:  0
[ 04.298% ] Soot Packs:  401
[ 03.344% ] Soot Writing Output:  312
================================================
Abc started on Thu Jun 24 08:08:25 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo foo = new Foo();
        foo.foo();
        org.aspectj.testing.Tester.checkEqual(Aspect.getPrivateAspectVar(),
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect.aspectOf().getPrivateAspectInstanceVar(),
                                              23);
    }
    
    public Driver() { super(); }
}
class Foo {
    public void foo() {  }
    
    public Foo() { super(); }
}
aspect Aspect {
    private static final int PRIVATEASPECTCONST = 10;
    
    private static int privateAspectVar = 20;
    
    protected static int protectedAspectVar = 40;
    
    public static int getPrivateAspectVar() {
        return Aspect/*Aspect*/.privateAspectVar;
    }
    
    private int privateAspectInstanceVar = 30;
    
    protected int protectedAspectInstanceVar = 50;
    
    public int getPrivateAspectInstanceVar() {
        return this/*null*/.privateAspectInstanceVar;
    }
    
    pointcut onFoo() : target(Foo) && call(void (*).foo());
    
    before():
    onFoo() {
        Aspect/*Aspect*/.privateAspectVar = 21;
        Aspect/*Aspect*/.privateAspectVar =
          1 + Aspect/*Aspect*/.privateAspectVar;
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              22);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar +=
                                                1,
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar++,
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar--,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              23);
        org.aspectj.testing.Tester.checkEqual(++Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(--Aspect/*Aspect*/.privateAspectVar,
                                              23);
    }
    
    before():
    onFoo() {
        Aspect/*Aspect*/.privateAspectVar = 21;
        Aspect/*Aspect*/.privateAspectVar =
          1 + Aspect/*Aspect*/.privateAspectVar;
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              22);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar +=
                                                1,
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar++,
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar--,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              23);
        org.aspectj.testing.Tester.checkEqual(++Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(--Aspect/*Aspect*/.privateAspectVar,
                                              23);
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.privateAspectVar,
                                              23);
        this/*null*/.privateAspectInstanceVar = 21;
        this/*null*/.privateAspectInstanceVar =
          1 + this/*null*/.privateAspectInstanceVar;
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar,
                                              22);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar +=
                                                1,
                                              23);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar++,
                                              23);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar--,
                                              24);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar,
                                              23);
        org.aspectj.testing.Tester.checkEqual(++this/*null*/.privateAspectInstanceVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar,
                                              24);
        org.aspectj.testing.Tester.checkEqual(--this/*null*/.privateAspectInstanceVar,
                                              23);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.privateAspectInstanceVar,
                                              23);
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Foo: void foo()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <Aspect: int getPrivateAspectVar()> from Aspect
retrieve <Aspect: int getPrivateAspectInstanceVar()> from Aspect
retrieve <Aspect: void before$0()> from Aspect
retrieve <Aspect: void before$1()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
Transforming Aspect... 
Transforming Foo... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:08:35 BST 2004. ( 0 min. 9 sec. )
PASS: operations on private and protected aspect members (++, -- in partciular)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 4 failed (check: 0), 33 passed (check: 0), 0 skipped.
Executing test 38 (base/test138): only register things once
================================================
Breakdown of abc phases  (total: 8394 millisec.)
------------------------------------------------
[ 00.453% ] Init. of Soot:  38
[ 00.048% ] Loading Jars:  4
[ 74.172% ] Polyglot phases:  6226
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.619% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.453% ] Intertype Adjuster:  38
[ 06.433% ] Retrieving bodies:  540
[ 00.000% ] Weave Initializers:  0
[ 00.429% ] Load shadow types:  36
[ 07.577% ] Compute advice lists:  636
[ 00.048% ] Intertype weave:  4
[ 00.429% ] Add aspect code:  36
[ 00.393% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 06.052% ] Soot Packs:  508
[ 02.847% ] Soot Writing Output:  239
================================================
Abc started on Thu Jun 24 08:08:37 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void test() {
        A a = new A();
        B b = new B();
        org.aspectj.testing.Tester.checkEqual(Aspect/*Aspect*/.count,
                                              2,
                                              "instance count");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Driver() { super(); }
}
class A {
    public A() { super(); }
    
    public void foo() {  }
}
class B extends A {
    public B() { super(); }
    
    public void bar() {  }
}
aspect Aspect {
    public static int count = 0;
    
    after() returning: call((*).new()) { Aspect/*Aspect*/.count++; }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <A: void foo()> from A
retrieve <A: void <init>()> from A
retrieve <B: void bar()> from B
retrieve <B: void <init>()> from B
retrieve <Aspect: void afterReturning$0()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
Transforming Aspect... 
Transforming Driver... 
Transforming B... 
Transforming A... 
Abc finished on Thu Jun 24 08:08:46 BST 2004. ( 0 min. 8 sec. )
PASS: only register things once()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 4 failed (check: 0), 34 passed (check: 0), 0 skipped.
Executing test 39 (base/test139): inner aspects and around
================================================
Breakdown of abc phases  (total: 8412 millisec.)
------------------------------------------------
[ 00.476% ] Init. of Soot:  40
[ 00.048% ] Loading Jars:  4
[ 72.432% ] Polyglot phases:  6093
[ 00.036% ] Resolve class names:  3
[ 00.024% ] Declare Parents:  2
[ 00.535% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.701% ] Intertype Adjuster:  59
[ 06.408% ] Retrieving bodies:  539
[ 00.000% ] Weave Initializers:  0
[ 00.273% ] Load shadow types:  23
[ 09.463% ] Compute advice lists:  796
[ 00.048% ] Intertype weave:  4
[ 00.464% ] Add aspect code:  39
[ 01.129% ] Weaving advice:  95
[ 00.000% ] Validate jimple:  0
[ 04.458% ] Soot Packs:  375
[ 03.507% ] Soot Writing Output:  295
================================================
Abc started on Thu Jun 24 08:08:49 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void test() {
        C2 c2 = new C2();
        org.aspectj.testing.Tester.checkEqual(c2.foo(),
                                              142,
                                              "modified c2.foo()");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Driver() { super(); }
}
class C1 {
    private int myInteger = 100;
    
    static aspect A {
        int around (C2 c2):
        target(c2) &&
          call(int (*).foo()) {
            int result = this.proceed(c2);
            return result + c2.getC1()/*<unknown>*/.myInteger;
        }
        
        public static C1.A aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public A() { super(); }
    }
    
    
    public C1() { super(); }
}
class C2 {
    public C1 getC1() { return new C1(); }
    
    int foo() { return 42; }
    
    public C2() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <C1: void <init>()> from C1
retrieve <C1: int access$000(C1)> from C1
retrieve <C1$A: int around$0(C2)> from C1$A
retrieve <C1$A: C1$A aspectOf()> from C1$A
retrieve <C1$A: boolean hasAspect()> from C1$A
retrieve <C1$A: void <init>()> from C1$A
retrieve <C1$A: int proceed$1(C2)> from C1$A
retrieve <C2: C1 getC1()> from C2
retrieve <C2: int foo()> from C2
retrieve <C2: void <init>()> from C2
Transforming C2... 
Transforming C1... 
Transforming C1$A... 
Transforming Driver... 
Transforming abc$access$C1$A$around$0... 
Abc finished on Thu Jun 24 08:08:57 BST 2004. ( 0 min. 8 sec. )
PASS: inner aspects and around()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 4 failed (check: 0), 35 passed (check: 0), 0 skipped.
Executing test 40 (base/test140): aspect inheritance and advice, introduction
Failed. Current status: 5 failed (check: 0), 35 passed (check: 0), 0 skipped.
Executing test 41 (base/test141): thisResultObject for primitives
================================================
Breakdown of abc phases  (total: 8744 millisec.)
------------------------------------------------
[ 00.446% ] Init. of Soot:  39
[ 00.034% ] Loading Jars:  3
[ 76.064% ] Polyglot phases:  6651
[ 00.034% ] Resolve class names:  3
[ 00.011% ] Declare Parents:  1
[ 00.572% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.435% ] Intertype Adjuster:  38
[ 06.553% ] Retrieving bodies:  573
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  27
[ 04.517% ] Compute advice lists:  395
[ 00.046% ] Intertype weave:  4
[ 00.229% ] Add aspect code:  20
[ 01.807% ] Weaving advice:  158
[ 00.000% ] Validate jimple:  0
[ 05.169% ] Soot Packs:  452
[ 03.774% ] Soot Writing Output:  330
================================================
Abc started on Thu Jun 24 08:09:13 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void test() {
        C1 c1 = new C1();
        c1.getInteger();
        c1.getDouble();
        c1.getVoid();
        c1.getString();
        c1.getBoolean();
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Driver() { super(); }
}
class C1 {
    int getInteger() { return 1; }
    
    double getDouble() { return 3.14; }
    
    void getVoid() {  }
    
    java.lang.String getString() { return "Hello World"; }
    
    boolean getBoolean() { return true; }
    
    public C1() { super(); }
}
aspect A1 {
    after() returning(Object result):
    target(C1) && call(* (*).*()) &&
      !call(void (*).finalize()) {
        if (result == null) {
            org.aspectj.testing.Tester.checkEqual(thisJoinPoint.getSignature().getName(),
                                                  "getVoid",
                                                  "void method");
        } else {
            java.lang.String resultClassName =
              result.getClass().getName();
            org.aspectj.testing.Tester.checkEqual("java.lang." +
                                                  thisJoinPoint.getSignature().getName().substring(3),
                                                  resultClassName,
                                                  "result object type");
        }
    }
    
    public static A1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A1() { super(); }
}
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <C1: void <init>()> from C1
retrieve <C1: int getInteger()> from C1
retrieve <C1: double getDouble()> from C1
retrieve <C1: void getVoid()> from C1
retrieve <C1: java.lang.String getString()> from C1
retrieve <C1: boolean getBoolean()> from C1
retrieve <A1: void afterReturning$0(java.lang.Object,org.aspectj.lang.JoinPoint)> from A1
retrieve <A1: A1 aspectOf()> from A1
retrieve <A1: boolean hasAspect()> from A1
retrieve <A1: void <init>()> from A1
Transforming A1... 
Transforming Driver... 
Transforming C1... 
Abc finished on Thu Jun 24 08:09:22 BST 2004. ( 0 min. 8 sec. )
PASS: thisResultObject for primitives()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 5 failed (check: 0), 36 passed (check: 0), 0 skipped.
Executing test 42 (base/test142): introductions calling super.
================================================
Breakdown of abc phases  (total: 11584 millisec.)
------------------------------------------------
[ 00.967% ] Init. of Soot:  112
[ 00.035% ] Loading Jars:  4
[ 72.143% ] Polyglot phases:  8357
[ 00.017% ] Resolve class names:  2
[ 00.017% ] Declare Parents:  2
[ 06.215% ] Recompute name pattern matches:  720
[ 00.000% ] Compute precedence relation:  0
[ 02.193% ] Intertype Adjuster:  254
[ 08.123% ] Retrieving bodies:  941
[ 00.009% ] Weave Initializers:  1
[ 00.207% ] Load shadow types:  24
[ 02.167% ] Compute advice lists:  251
[ 00.035% ] Intertype weave:  4
[ 00.613% ] Add aspect code:  71
[ 00.112% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.600% ] Soot Packs:  417
[ 03.548% ] Soot Writing Output:  411
================================================
Abc started on Thu Jun 24 08:09:26 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void test() {
        C2 c2 = new C2("FooBar");
        org.aspectj.testing.Tester.checkEqual(c2/*null*/.name,
                                              "FooBar",
                                              "C2\'s name");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Driver() { super(); }
}
class C1 {
    public java.lang.String name = null;
    
    public C1(java.lang.String name) {
        super();
        this/*<unknown>*/.name = name;
    }
}
class C2 extends C1 {
    C2() { super("dummy"); }
}
aspect A {
    C2.new(java.lang.String name) { super(name); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <C1: void <init>(java.lang.String)> from C1
retrieve <C2: void <init>()> from C2
retrieve <C2: void <init>(java.lang.String,A)> from C2
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void new$C2$3(C2,java.lang.String,A)> from A
Transforming C2... 
Transforming A... 
Transforming Driver... 
Transforming C1... 
Abc finished on Thu Jun 24 08:09:37 BST 2004. ( 0 min. 11 sec. )
PASS: introductions calling super.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 5 failed (check: 0), 37 passed (check: 0), 0 skipped.
Executing test 43 (base): allow one argument calls even when there's a comma in the arglist
================================================
Breakdown of abc phases  (total: 11100 millisec.)
------------------------------------------------
[ 00.748% ] Init. of Soot:  83
[ 00.027% ] Loading Jars:  3
[ 77.369% ] Polyglot phases:  8588
[ 00.009% ] Resolve class names:  1
[ 00.009% ] Declare Parents:  1
[ 01.306% ] Recompute name pattern matches:  145
[ 00.000% ] Compute precedence relation:  0
[ 07.045% ] Intertype Adjuster:  782
[ 07.090% ] Retrieving bodies:  787
[ 00.000% ] Weave Initializers:  0
[ 00.225% ] Load shadow types:  25
[ 00.856% ] Compute advice lists:  95
[ 00.027% ] Intertype weave:  3
[ 00.270% ] Add aspect code:  30
[ 00.414% ] Weaving advice:  46
[ 00.000% ] Validate jimple:  0
[ 02.234% ] Soot Packs:  248
[ 02.369% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 08:09:42 BST 2004
<<<< OneArgCallsIsOkay.java >>>>
public class OneArgCallsIsOkay {
    public static void main(java.lang.String[] args) {  }
    
    static void foo(int x, int y) {  }
    
    pointcut cut() : call(void (OneArgCallsIsOkay).foo(int, int));
    
    public OneArgCallsIsOkay() { super(); }
}
retrieve <OneArgCallsIsOkay: void main(java.lang.String[])> from OneArgCallsIsOkay
retrieve <OneArgCallsIsOkay: void foo(int,int)> from OneArgCallsIsOkay
retrieve <OneArgCallsIsOkay: void <init>()> from OneArgCallsIsOkay
Transforming OneArgCallsIsOkay... 
Abc finished on Thu Jun 24 08:09:53 BST 2004. ( 0 min. 11 sec. )
PASS: allow one argument calls even when there's a comma in the arglist()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 5 failed (check: 0), 38 passed (check: 0), 0 skipped.
Executing test 44 (new): advice on calls to static methods even works when called on super
================================================
Breakdown of abc phases  (total: 12601 millisec.)
------------------------------------------------
[ 00.738% ] Init. of Soot:  93
[ 00.032% ] Loading Jars:  4
[ 74.399% ] Polyglot phases:  9375
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 00.476% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 00.960% ] Intertype Adjuster:  121
[ 07.801% ] Retrieving bodies:  983
[ 00.000% ] Weave Initializers:  0
[ 00.452% ] Load shadow types:  57
[ 01.635% ] Compute advice lists:  206
[ 00.024% ] Intertype weave:  3
[ 00.698% ] Add aspect code:  88
[ 00.111% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 09.785% ] Soot Packs:  1233
[ 02.857% ] Soot Writing Output:  360
================================================
Failed. Current status: 6 failed (check: 0), 38 passed (check: 0), 0 skipped.
Executing test 45 (new): combined logic expression (handling coericions vs. parens)
================================================
Breakdown of abc phases  (total: 7246 millisec.)
------------------------------------------------
[ 00.524% ] Init. of Soot:  38
[ 00.055% ] Loading Jars:  4
[ 77.601% ] Polyglot phases:  5623
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.469% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.856% ] Intertype Adjuster:  62
[ 12.614% ] Retrieving bodies:  914
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  24
[ 02.070% ] Compute advice lists:  150
[ 00.041% ] Intertype weave:  3
[ 00.110% ] Add aspect code:  8
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.539% ] Soot Packs:  184
[ 02.581% ] Soot Writing Output:  187
================================================
Abc started on Thu Jun 24 08:10:13 BST 2004
<<<< CombinedLogic.java >>>>
import org.aspectj.testing.Tester;

public class CombinedLogic {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        java.lang.Object foo = null;
        int baz = 1;
        int foobaz = baz;
        if (null == foo && baz != foobaz) {
            org.aspectj.testing.Tester.check(false, "better not");
        } else {
            org.aspectj.testing.Tester.check(true,
                                             "it better be true");
        }
    }
    
    public CombinedLogic() { super(); }
}
retrieve <CombinedLogic: void main(java.lang.String[])> from CombinedLogic
retrieve <CombinedLogic: void test()> from CombinedLogic
retrieve <CombinedLogic: void <init>()> from CombinedLogic
Transforming CombinedLogic... 
Abc finished on Thu Jun 24 08:10:20 BST 2004. ( 0 min. 7 sec. )
PASS: combined logic expression (handling coericions vs. parens)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 6 failed (check: 0), 39 passed (check: 0), 0 skipped.
Executing test 46 (new): comment after class closes (with no new line at end)
Failed. Current status: 7 failed (check: 0), 39 passed (check: 0), 0 skipped.
Executing test 47 (new): handle multiple nested inner classes
Failed. Current status: 8 failed (check: 0), 39 passed (check: 0), 0 skipped.
Executing test 48 (new): multi-dimensional array initializers
================================================
Breakdown of abc phases  (total: 7277 millisec.)
------------------------------------------------
[ 00.522% ] Init. of Soot:  38
[ 00.055% ] Loading Jars:  4
[ 77.504% ] Polyglot phases:  5640
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.467% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.893% ] Intertype Adjuster:  65
[ 12.272% ] Retrieving bodies:  893
[ 00.000% ] Weave Initializers:  0
[ 00.302% ] Load shadow types:  22
[ 02.144% ] Compute advice lists:  156
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.165% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.556% ] Soot Packs:  186
[ 02.927% ] Soot Writing Output:  213
================================================
Abc started on Thu Jun 24 08:10:31 BST 2004
<<<< MultiArrays.java >>>>
import org.aspectj.testing.Tester;

public class MultiArrays {
    static int[][] data = { { 11, 12, 13 }, { 21, 22, 23 } };
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(MultiArrays/*MultiArrays*/.data[0][0],
                                              11,
                                              "0,0");
        org.aspectj.testing.Tester.checkEqual(MultiArrays/*MultiArrays*/.data[1][2],
                                              23,
                                              "1,2");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public MultiArrays() { super(); }
}
retrieve <MultiArrays: void test()> from MultiArrays
retrieve <MultiArrays: void main(java.lang.String[])> from MultiArrays
retrieve <MultiArrays: void <init>()> from MultiArrays
retrieve <MultiArrays: void <clinit>()> from MultiArrays
Transforming MultiArrays... 
Abc finished on Thu Jun 24 08:10:38 BST 2004. ( 0 min. 7 sec. )
PASS: multi-dimensional array initializers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 8 failed (check: 0), 40 passed (check: 0), 0 skipped.
Executing test 49 (new): probelm with the generated names of exceptions
================================================
Breakdown of abc phases  (total: 7530 millisec.)
------------------------------------------------
[ 00.518% ] Init. of Soot:  39
[ 00.040% ] Loading Jars:  3
[ 75.578% ] Polyglot phases:  5691
[ 00.013% ] Resolve class names:  1
[ 00.013% ] Declare Parents:  1
[ 00.465% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 06.228% ] Intertype Adjuster:  469
[ 07.224% ] Retrieving bodies:  544
[ 00.000% ] Weave Initializers:  0
[ 00.292% ] Load shadow types:  22
[ 03.798% ] Compute advice lists:  286
[ 00.040% ] Intertype weave:  3
[ 00.120% ] Add aspect code:  9
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.776% ] Soot Packs:  209
[ 02.722% ] Soot Writing Output:  205
================================================
Abc started on Thu Jun 24 08:10:41 BST 2004
<<<< ExceptionNames.java >>>>
import org.aspectj.testing.Tester;

public class ExceptionNames {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        java.lang.String exception = "";
        java.lang.reflect.Method liveRoutine = null;
        try {
            liveRoutine.invoke(null, null);
        }
        catch (java.lang.reflect.InvocationTargetException e) {
            java.lang.System/*java.lang.System*/.out.println(" " +
                                                             e.getTargetException());
            exception = e.getClass().toString();
        }
        catch (java.lang.Exception e) {
            exception = e.getClass().toString();
        }
        org.aspectj.testing.Tester.checkEqual(exception,
                                              "class java.lang.NullPointerException",
                                              "exception handled");
    }
    
    private void foo() {  }
    
    public ExceptionNames() { super(); }
}
retrieve <ExceptionNames: void main(java.lang.String[])> from ExceptionNames
retrieve <ExceptionNames: void test()> from ExceptionNames
retrieve <ExceptionNames: void foo()> from ExceptionNames
retrieve <ExceptionNames: void <init>()> from ExceptionNames
Transforming ExceptionNames... 
Abc finished on Thu Jun 24 08:10:49 BST 2004. ( 0 min. 7 sec. )
PASS: probelm with the generated names of exceptions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 8 failed (check: 0), 41 passed (check: 0), 0 skipped.
Executing test 50 (new): checks if the class field can be used on all of the primitive types
================================================
Breakdown of abc phases  (total: 8501 millisec.)
------------------------------------------------
[ 00.459% ] Init. of Soot:  39
[ 00.035% ] Loading Jars:  3
[ 70.651% ] Polyglot phases:  6006
[ 00.000% ] Resolve class names:  0
[ 00.024% ] Declare Parents:  2
[ 00.553% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 05.846% ] Intertype Adjuster:  497
[ 06.858% ] Retrieving bodies:  583
[ 00.000% ] Weave Initializers:  0
[ 00.271% ] Load shadow types:  23
[ 08.670% ] Compute advice lists:  737
[ 00.035% ] Intertype weave:  3
[ 00.106% ] Add aspect code:  9
[ 00.141% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.529% ] Soot Packs:  300
[ 02.823% ] Soot Writing Output:  240
================================================
Failed. Current status: 9 failed (check: 0), 41 passed (check: 0), 0 skipped.
Executing test 51 (new/volatileKeyword): advice on a static method
================================================
Breakdown of abc phases  (total: 7252 millisec.)
------------------------------------------------
[ 00.538% ] Init. of Soot:  39
[ 00.041% ] Loading Jars:  3
[ 77.634% ] Polyglot phases:  5630
[ 00.014% ] Resolve class names:  1
[ 00.028% ] Declare Parents:  2
[ 00.469% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.869% ] Intertype Adjuster:  63
[ 12.231% ] Retrieving bodies:  887
[ 00.000% ] Weave Initializers:  0
[ 00.317% ] Load shadow types:  23
[ 02.041% ] Compute advice lists:  148
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.165% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.716% ] Soot Packs:  197
[ 02.772% ] Soot Writing Output:  201
================================================
Abc started on Thu Jun 24 08:11:02 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    static volatile boolean completed = true;
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.check(Driver/*Driver*/.completed,
                                         "static volatile filed");
        org.aspectj.testing.Tester.check(new C()/*<unknown>*/.completed,
                                         "instance of volatile filed");
    }
    
    public Driver() { super(); }
}
class C {
    volatile boolean completed = true;
    
    public C() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <clinit>()> from Driver
retrieve <C: void <init>()> from C
Transforming C... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:11:10 BST 2004. ( 0 min. 7 sec. )
PASS: advice on a static method()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 9 failed (check: 0), 42 passed (check: 0), 0 skipped.
Executing test 52 (new/innerConsSyntax): inner constructor syntax causes compile error
Failed. Current status: 10 failed (check: 0), 42 passed (check: 0), 0 skipped.
Executing test 53 (new/paramWidening): widening of method parameters to match javac
================================================
Breakdown of abc phases  (total: 7238 millisec.)
------------------------------------------------
[ 00.511% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 83.062% ] Polyglot phases:  6012
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.470% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.539% ] Intertype Adjuster:  39
[ 07.226% ] Retrieving bodies:  523
[ 00.000% ] Weave Initializers:  0
[ 00.318% ] Load shadow types:  23
[ 01.907% ] Compute advice lists:  138
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.166% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.888% ] Soot Packs:  209
[ 02.666% ] Soot Writing Output:  193
================================================
Abc started on Thu Jun 24 08:11:22 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    private static java.util.Vector v = new java.util.Vector();
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        long l = foo(42);
        org.aspectj.testing.Tester.check(l == 42, "foo(42) == 42");
    }
    
    private static float foo(float f) { return f; }
    
    private static long foo(long l) { return l; }
    
    public Driver() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: float foo(float)> from Driver
retrieve <Driver: long foo(long)> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
Transforming Driver... 
Abc finished on Thu Jun 24 08:11:29 BST 2004. ( 0 min. 7 sec. )
PASS: widening of method parameters to match javac()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 10 failed (check: 0), 43 passed (check: 0), 0 skipped.
Executing test 54 (pureJava/equalsMethOnStr): equals method on quoted strings
================================================
Breakdown of abc phases  (total: 7217 millisec.)
------------------------------------------------
[ 00.527% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  3
[ 77.886% ] Polyglot phases:  5621
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.734% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.540% ] Intertype Adjuster:  39
[ 12.554% ] Retrieving bodies:  906
[ 00.000% ] Weave Initializers:  0
[ 00.388% ] Load shadow types:  28
[ 02.037% ] Compute advice lists:  147
[ 00.042% ] Intertype weave:  3
[ 00.111% ] Add aspect code:  8
[ 00.180% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.425% ] Soot Packs:  175
[ 02.508% ] Soot Writing Output:  181
================================================
Abc started on Thu Jun 24 08:11:32 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    private static java.util.Vector v = new java.util.Vector();
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.check("foo".equals("foo"),
                                         "foo equals foo");
    }
    
    public Driver() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
Transforming Driver... 
Abc finished on Thu Jun 24 08:11:39 BST 2004. ( 0 min. 7 sec. )
PASS: equals method on quoted strings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 10 failed (check: 0), 44 passed (check: 0), 0 skipped.
Executing test 55 (new): parenthesized string literals matching primitive type names
================================================
Breakdown of abc phases  (total: 7075 millisec.)
------------------------------------------------
[ 00.537% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  3
[ 78.375% ] Polyglot phases:  5545
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.664% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.551% ] Intertype Adjuster:  39
[ 12.919% ] Retrieving bodies:  914
[ 00.000% ] Weave Initializers:  0
[ 00.325% ] Load shadow types:  23
[ 01.272% ] Compute advice lists:  90
[ 00.042% ] Intertype weave:  3
[ 00.113% ] Add aspect code:  8
[ 00.170% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.587% ] Soot Packs:  183
[ 02.375% ] Soot Writing Output:  168
================================================
Abc started on Thu Jun 24 08:11:41 BST 2004
<<<< ParenPrimitive.java >>>>
import org.aspectj.testing.Tester;

public class ParenPrimitive {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(typenameFor(null),
                                              "int");
    }
    
    private static java.lang.String typenameFor(java.lang.String type) {
        return "int";
    }
    
    public ParenPrimitive() { super(); }
}
retrieve <ParenPrimitive: void main(java.lang.String[])> from ParenPrimitive
retrieve <ParenPrimitive: java.lang.String typenameFor(java.lang.String)> from ParenPrimitive
retrieve <ParenPrimitive: void <init>()> from ParenPrimitive
Transforming ParenPrimitive... 
Abc finished on Thu Jun 24 08:11:49 BST 2004. ( 0 min. 7 sec. )
PASS: parenthesized string literals matching primitive type names()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 10 failed (check: 0), 45 passed (check: 0), 0 skipped.
Executing test 56 (pureJava/anonInnerClass): anonymous inner class
================================================
Breakdown of abc phases  (total: 7344 millisec.)
------------------------------------------------
[ 00.517% ] Init. of Soot:  38
[ 00.054% ] Loading Jars:  4
[ 76.389% ] Polyglot phases:  5610
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.681% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 06.604% ] Intertype Adjuster:  485
[ 06.849% ] Retrieving bodies:  503
[ 00.000% ] Weave Initializers:  0
[ 00.313% ] Load shadow types:  23
[ 02.219% ] Compute advice lists:  163
[ 00.041% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  9
[ 00.163% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.955% ] Soot Packs:  217
[ 03.064% ] Soot Writing Output:  225
================================================
Abc started on Thu Jun 24 08:11:51 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;
import java.util.Iterator;

public class Driver {
    public static void main(java.lang.String[] args) {
        C c = new C();
        java.lang.String s = (java.lang.String) c.result();
        org.aspectj.testing.Tester.checkEqual(s, "-anon", "");
    }
    
    public Driver() { super(); }
}
class C {
    public java.lang.String result() {
        return getIt(new java.util.Iterator() {
                         public Object next() { return "-anon"; }
                         
                         public boolean hasNext() { return true; }
                         
                         public void remove() {  }
                     });
    }
    
    public java.lang.String getIt(java.util.Iterator u) {
        return (java.lang.String) u.next();
    }
    
    public C() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <C: java.lang.String result()> from C
retrieve <C: java.lang.String getIt(java.util.Iterator)> from C
retrieve <C: void <init>()> from C
retrieve <C$1: void <init>(C)> from C$1
retrieve <C$1: void remove()> from C$1
retrieve <C$1: boolean hasNext()> from C$1
retrieve <C$1: java.lang.Object next()> from C$1
Transforming C... 
Transforming Driver... 
Transforming C$1... 
Abc finished on Thu Jun 24 08:11:59 BST 2004. ( 0 min. 7 sec. )
PASS: anonymous inner class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 10 failed (check: 0), 46 passed (check: 0), 0 skipped.
Executing test 57 (new): simple type coercions tests
================================================
Breakdown of abc phases  (total: 7450 millisec.)
------------------------------------------------
[ 01.181% ] Init. of Soot:  88
[ 00.711% ] Loading Jars:  53
[ 77.221% ] Polyglot phases:  5753
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.698% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.523% ] Intertype Adjuster:  39
[ 12.268% ] Retrieving bodies:  914
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  23
[ 02.081% ] Compute advice lists:  155
[ 00.040% ] Intertype weave:  3
[ 00.107% ] Add aspect code:  8
[ 00.188% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.376% ] Soot Packs:  177
[ 02.268% ] Soot Writing Output:  169
================================================
Abc started on Thu Jun 24 08:12:01 BST 2004
<<<< TypeCoercions.java >>>>
import org.aspectj.testing.Tester;

public class TypeCoercions {
    public static void main(java.lang.String[] args) {
        char c1 = 'e';
        char c2 = 'f';
        org.aspectj.testing.Tester.checkEqual("hello".indexOf(c1), 1);
        org.aspectj.testing.Tester.checkEqual("hello".indexOf(c2),
                                              -1);
    }
    
    public TypeCoercions() { super(); }
}
retrieve <TypeCoercions: void main(java.lang.String[])> from TypeCoercions
retrieve <TypeCoercions: void <init>()> from TypeCoercions
Transforming TypeCoercions... 
Abc finished on Thu Jun 24 08:12:09 BST 2004. ( 0 min. 7 sec. )
PASS: simple type coercions tests()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 10 failed (check: 0), 47 passed (check: 0), 0 skipped.
Executing test 58 (new): order of type declarations shouldn't matter
Failed. Current status: 11 failed (check: 0), 47 passed (check: 0), 0 skipped.
Executing test 59 (pureJava): parsing of parenthesized 'this' (in returns)
================================================
Breakdown of abc phases  (total: 6903 millisec.)
------------------------------------------------
[ 00.550% ] Init. of Soot:  38
[ 00.058% ] Loading Jars:  4
[ 78.299% ] Polyglot phases:  5405
[ 00.014% ] Resolve class names:  1
[ 00.029% ] Declare Parents:  2
[ 00.681% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.579% ] Intertype Adjuster:  40
[ 12.516% ] Retrieving bodies:  864
[ 00.000% ] Weave Initializers:  0
[ 00.333% ] Load shadow types:  23
[ 01.289% ] Compute advice lists:  89
[ 00.043% ] Intertype weave:  3
[ 00.130% ] Add aspect code:  9
[ 00.174% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.767% ] Soot Packs:  191
[ 02.535% ] Soot Writing Output:  175
================================================
Abc started on Thu Jun 24 08:12:20 BST 2004
<<<< ReturnThis.java >>>>
public class ReturnThis {
    public static void main(java.lang.String[] args) {
        new C().foo();
    }
    
    public ReturnThis() { super(); }
}
class C {
    public C foo() { return this; }
    
    public C() { super(); }
}
retrieve <ReturnThis: void main(java.lang.String[])> from ReturnThis
retrieve <ReturnThis: void <init>()> from ReturnThis
retrieve <C: void <init>()> from C
retrieve <C: C foo()> from C
Transforming ReturnThis... 
Transforming C... 
Abc finished on Thu Jun 24 08:12:27 BST 2004. ( 0 min. 7 sec. )
PASS: parsing of parenthesized 'this' (in returns)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 48 passed (check: 0), 0 skipped.
Executing test 60 (new): Scanner non recognizing strictfp.
================================================
Breakdown of abc phases  (total: 7226 millisec.)
------------------------------------------------
[ 00.526% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  3
[ 78.010% ] Polyglot phases:  5637
[ 00.014% ] Resolve class names:  1
[ 00.028% ] Declare Parents:  2
[ 00.637% ] Recompute name pattern matches:  46
[ 00.014% ] Compute precedence relation:  1
[ 06.740% ] Intertype Adjuster:  487
[ 06.380% ] Retrieving bodies:  461
[ 00.000% ] Weave Initializers:  0
[ 00.332% ] Load shadow types:  24
[ 01.937% ] Compute advice lists:  140
[ 00.042% ] Intertype weave:  3
[ 00.111% ] Add aspect code:  8
[ 00.180% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.463% ] Soot Packs:  178
[ 02.546% ] Soot Writing Output:  184
================================================
Abc started on Thu Jun 24 08:12:30 BST 2004
<<<< StrictFp.java >>>>
import org.aspectj.testing.*;

public strictfp class StrictFp {
    public static void main(java.lang.String[] args) {
        new StrictFp().go();
        org.aspectj.testing.Tester.check(StrictFp/*StrictFp*/.ran,
                                         "go did not run");
    }
    
    static boolean ran = false;
    
    void go() { StrictFp/*StrictFp*/.ran = true; }
    
    public StrictFp() { super(); }
}
retrieve <StrictFp: void main(java.lang.String[])> from StrictFp
retrieve <StrictFp: void go()> from StrictFp
retrieve <StrictFp: void <init>()> from StrictFp
retrieve <StrictFp: void <clinit>()> from StrictFp
Transforming StrictFp... 
Abc finished on Thu Jun 24 08:12:37 BST 2004. ( 0 min. 7 sec. )
PASS: Scanner non recognizing strictfp.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 49 passed (check: 0), 0 skipped.
Executing test 61 (pureJava): Strings are folded and interned correctly
================================================
Breakdown of abc phases  (total: 7200 millisec.)
------------------------------------------------
[ 00.514% ] Init. of Soot:  37
[ 00.056% ] Loading Jars:  4
[ 77.514% ] Polyglot phases:  5581
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.778% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.556% ] Intertype Adjuster:  40
[ 12.194% ] Retrieving bodies:  878
[ 00.000% ] Weave Initializers:  0
[ 00.306% ] Load shadow types:  22
[ 02.444% ] Compute advice lists:  176
[ 00.042% ] Intertype weave:  3
[ 00.111% ] Add aspect code:  8
[ 00.181% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.611% ] Soot Packs:  188
[ 02.667% ] Soot Writing Output:  192
================================================
Abc started on Thu Jun 24 08:12:39 BST 2004
<<<< StringFold.java >>>>
import org.aspectj.testing.Tester;

public class StringFold {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEq("th" +
                                           "ere",
                                           "the" +
                                           "re",
                                           "\"th\" + \"ere\" == \"the\" + \"re\"");
        org.aspectj.testing.Tester.checkEq(StringFoldHelper/*StringFoldHelper*/.xx,
                                           "th",
                                           "StringFoldHelper.xx == \"th\"");
        org.aspectj.testing.Tester.checkEq(StringFoldHelper/*StringFoldHelper*/.xx +
                                           "ere",
                                           "there",
                                           "StringFoldHelper.xx + \"ere\" == \"there\"");
        org.aspectj.testing.Tester.checkEq(StringFoldHelper/*StringFoldHelper*/.xx +
                                           "",
                                           StringFoldHelper/*StringFoldHelper*/.xx,
                                           "StringFoldHelper.xx + \"\" == StringFoldHelper.xx");
        org.aspectj.testing.Tester.checkEq("\'7",
                                           "\'7",
                                           "2-digit octal escape");
    }
    
    public StringFold() { super(); }
}
class StringFoldHelper {
    public static final java.lang.String xx = "th";
    
    public StringFoldHelper() { super(); }
}
retrieve <StringFold: void main(java.lang.String[])> from StringFold
retrieve <StringFold: void <init>()> from StringFold
retrieve <StringFoldHelper: void <init>()> from StringFoldHelper
retrieve <StringFoldHelper: void <clinit>()> from StringFoldHelper
Transforming StringFold... 
Transforming StringFoldHelper... 
Abc finished on Thu Jun 24 08:12:47 BST 2004. ( 0 min. 7 sec. )
PASS: Strings are folded and interned correctly()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 50 passed (check: 0), 0 skipped.
Executing test 62 (pureJava): Cast binds tighter than equality tests
================================================
Breakdown of abc phases  (total: 6808 millisec.)
------------------------------------------------
[ 00.573% ] Init. of Soot:  39
[ 00.044% ] Loading Jars:  3
[ 78.187% ] Polyglot phases:  5323
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.617% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.573% ] Intertype Adjuster:  39
[ 13.176% ] Retrieving bodies:  897
[ 00.000% ] Weave Initializers:  0
[ 00.353% ] Load shadow types:  24
[ 01.190% ] Compute advice lists:  81
[ 00.044% ] Intertype weave:  3
[ 00.132% ] Add aspect code:  9
[ 00.176% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.717% ] Soot Packs:  185
[ 02.189% ] Soot Writing Output:  149
================================================
Abc started on Thu Jun 24 08:12:49 BST 2004
<<<< CastAndBinary.java >>>>
public class CastAndBinary {
    public static void main(java.lang.String[] args) {
        java.lang.System/*java.lang.System*/.out.println((int) 3 ==
                                                         5);
    }
    
    public CastAndBinary() { super(); }
}
retrieve <CastAndBinary: void main(java.lang.String[])> from CastAndBinary
retrieve <CastAndBinary: void <init>()> from CastAndBinary
Transforming CastAndBinary... 
Abc finished on Thu Jun 24 08:12:56 BST 2004. ( 0 min. 6 sec. )
false
PASS: Cast binds tighter than equality tests()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 51 passed (check: 0), 0 skipped.
Executing test 63 (pureJava): Boundary base values can be parsed
================================================
Breakdown of abc phases  (total: 8073 millisec.)
------------------------------------------------
[ 00.458% ] Init. of Soot:  37
[ 00.050% ] Loading Jars:  4
[ 75.709% ] Polyglot phases:  6112
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.644% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 05.896% ] Intertype Adjuster:  476
[ 06.553% ] Retrieving bodies:  529
[ 00.000% ] Weave Initializers:  0
[ 00.285% ] Load shadow types:  23
[ 04.843% ] Compute advice lists:  391
[ 00.050% ] Intertype weave:  4
[ 00.111% ] Add aspect code:  9
[ 00.186% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 02.564% ] Soot Packs:  207
[ 02.626% ] Soot Writing Output:  212
================================================
Abc started on Thu Jun 24 08:12:59 BST 2004
<<<< BoundaryNums.java >>>>
import org.aspectj.testing.Tester;

public class BoundaryNums {
    public static void main(java.lang.String[] args) {
        byte minByte = -128;
        byte maxByte = 127;
        byte minByteHex = -128;
        byte maxByteHex = 127;
        org.aspectj.testing.Tester.checkEqual(minByte,
                                              java.lang.Byte/*java.lang.Byte*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxByte,
                                              java.lang.Byte/*java.lang.Byte*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(minByteHex,
                                              java.lang.Byte/*java.lang.Byte*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxByteHex,
                                              java.lang.Byte/*java.lang.Byte*/.MAX_VALUE);
        short minShort = -32768;
        short maxShort = 32767;
        short minShortHex = -32768;
        short maxShortHex = 32767;
        org.aspectj.testing.Tester.checkEqual(minShort,
                                              java.lang.Short/*java.lang.Short*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxShort,
                                              java.lang.Short/*java.lang.Short*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(minShortHex,
                                              java.lang.Short/*java.lang.Short*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxShortHex,
                                              java.lang.Short/*java.lang.Short*/.MAX_VALUE);
        char maxChar = 65535;
        char maxCharHex = 65535;
        char maxCharChar = '\uffff';
        org.aspectj.testing.Tester.checkEqual(maxChar,
                                              java.lang.Character/*java.lang.Character*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxCharHex,
                                              java.lang.Character/*java.lang.Character*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxCharChar,
                                              java.lang.Character/*java.lang.Character*/.MAX_VALUE);
        int minInt = -(-2147483648);
        int maxInt = 2147483647;
        int minIntHex = -(-2147483648);
        int maxIntHex = 2147483647;
        org.aspectj.testing.Tester.checkEqual(minInt,
                                              java.lang.Integer/*java.lang.Integer*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxInt,
                                              java.lang.Integer/*java.lang.Integer*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(minIntHex,
                                              java.lang.Integer/*java.lang.Integer*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxIntHex,
                                              java.lang.Integer/*java.lang.Integer*/.MAX_VALUE);
        long minLong = -(-9223372036854775808L);
        long maxLong = 9223372036854775807L;
        long minLongHex = -(-9223372036854775808L);
        long maxLongHex = 9223372036854775807L;
        org.aspectj.testing.Tester.checkEqual(minLong,
                                              java.lang.Long/*java.lang.Long*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxLong,
                                              java.lang.Long/*java.lang.Long*/.MAX_VALUE);
        org.aspectj.testing.Tester.checkEqual(minLongHex,
                                              java.lang.Long/*java.lang.Long*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxLongHex,
                                              java.lang.Long/*java.lang.Long*/.MAX_VALUE);
        float minPosFloat = 1.4E-45F;
        float maxPosFloat = 3.4028235E38F;
        org.aspectj.testing.Tester.checkEqual(minPosFloat,
                                              java.lang.Float/*java.lang.Float*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxPosFloat,
                                              java.lang.Float/*java.lang.Float*/.MAX_VALUE);
        double minPosDouble = 4.9E-324;
        double maxPosDouble = 1.7976931348623157E308;
        org.aspectj.testing.Tester.checkEqual(minPosDouble,
                                              java.lang.Double/*java.lang.Double*/.MIN_VALUE);
        org.aspectj.testing.Tester.checkEqual(maxPosDouble,
                                              java.lang.Double/*java.lang.Double*/.MAX_VALUE);
    }
    
    public BoundaryNums() { super(); }
}
retrieve <BoundaryNums: void main(java.lang.String[])> from BoundaryNums
retrieve <BoundaryNums: void <init>()> from BoundaryNums
Transforming BoundaryNums... 
Abc finished on Thu Jun 24 08:13:07 BST 2004. ( 0 min. 8 sec. )
PASS: Boundary base values can be parsed()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 11 failed (check: 0), 52 passed (check: 0), 0 skipped.
Executing test 64 (pureJava): State is passed correctly across nested annonymous inners
================================================
Breakdown of abc phases  (total: 8185 millisec.)
------------------------------------------------
[ 00.464% ] Init. of Soot:  38
[ 00.049% ] Loading Jars:  4
[ 71.912% ] Polyglot phases:  5886
[ 00.012% ] Resolve class names:  1
[ 00.024% ] Declare Parents:  2
[ 00.660% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.476% ] Intertype Adjuster:  39
[ 06.597% ] Retrieving bodies:  540
[ 00.000% ] Weave Initializers:  0
[ 00.269% ] Load shadow types:  22
[ 12.670% ] Compute advice lists:  1037
[ 00.037% ] Intertype weave:  3
[ 00.110% ] Add aspect code:  9
[ 00.183% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 03.445% ] Soot Packs:  282
[ 03.091% ] Soot Writing Output:  253
================================================
Abc started on Thu Jun 24 08:13:09 BST 2004
<<<< NestedInners.java >>>>
import org.aspectj.testing.Tester;

public class NestedInners {
    public static void main(java.lang.String[] args) {
        java.lang.Runnable r = new Outer().m("arg:");
        r.run();
        org.aspectj.testing.Tester.check("arg:varg:0");
        org.aspectj.testing.Tester.check("deep-arg:varg:1");
        r.run();
        org.aspectj.testing.Tester.check("arg:varg:2");
        org.aspectj.testing.Tester.check("deep-arg:varg:3");
    }
    
    public NestedInners() { super(); }
}
class Outer {
    public java.lang.Runnable m(final java.lang.String sarg) {
        final java.lang.String svar = "v" + sarg;
        return new java.lang.Runnable() {
            int counter = 0;
            
            public void run() {
                Tester.note(sarg + svar + counter++);
                new Runnable() {
                    public void run() {
                        Tester.note("deep-" + sarg + svar +
                                    counter++);
                    }
                }.run();
            }
        };
    }
    
    public Outer() { super(); }
}
retrieve <NestedInners: void main(java.lang.String[])> from NestedInners
retrieve <NestedInners: void <init>()> from NestedInners
retrieve <Outer: void <init>()> from Outer
retrieve <Outer: java.lang.Runnable m(java.lang.String)> from Outer
retrieve <Outer$1: void <init>(Outer,java.lang.String,java.lang.String)> from Outer$1
retrieve <Outer$1: void run()> from Outer$1
retrieve <Outer$2: void <init>(Outer$1)> from Outer$2
retrieve <Outer$2: void run()> from Outer$2
retrieve <Outer$2: void <init>(Outer$1)> from Outer$2
retrieve <Outer$2: void run()> from Outer$2
Transforming NestedInners... 
Transforming Outer... 
Transforming Outer$1... 
Transforming Outer$2... 
Abc finished on Thu Jun 24 08:13:18 BST 2004. ( 0 min. 8 sec. )
PASS: State is passed correctly across nested annonymous inners()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 11 failed (check: 0), 53 passed (check: 0), 0 skipped.
Executing test 65 (pureJava): ?: expressions should typecheck in interesting ways
================================================
Breakdown of abc phases  (total: 9130 millisec.)
------------------------------------------------
[ 00.416% ] Init. of Soot:  38
[ 00.033% ] Loading Jars:  3
[ 66.835% ] Polyglot phases:  6102
[ 00.000% ] Resolve class names:  0
[ 00.022% ] Declare Parents:  2
[ 00.493% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.504% ] Intertype Adjuster:  46
[ 13.297% ] Retrieving bodies:  1214
[ 00.000% ] Weave Initializers:  0
[ 00.329% ] Load shadow types:  30
[ 09.606% ] Compute advice lists:  877
[ 00.033% ] Intertype weave:  3
[ 00.099% ] Add aspect code:  9
[ 00.142% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.987% ] Soot Packs:  364
[ 04.206% ] Soot Writing Output:  384
================================================
Abc started on Thu Jun 24 08:13:20 BST 2004
<<<< TriTestTypecheck.java >>>>
class A {
    public A() { super(); }
}
interface G {}
class E extends A implements G {
    public E() { super(); }
}
public class TriTestTypecheck {
    public static void main(java.lang.String[] args) {  }
    
    void byteCall(byte b) {  }
    
    void shortCall(short s) {  }
    
    void charCall(char c) {  }
    
    void intCall(int i) {  }
    
    void longCall(long l) {  }
    
    void floatCall(float f) {  }
    
    void doubleCall(double d) {  }
    
    void booleanCall(boolean t) {  }
    
    void aCall(A a) {  }
    
    void eCall(E e) {  }
    
    void gCall(G g) {  }
    
    void foo(boolean t,
             byte b,
             short s,
             char c,
             int i,
             long l,
             float f,
             double d,
             A a,
             E e,
             G g) {
        byteCall(t ? 37 : b);
        byteCall(t ? b : 37);
        byteCall(t ? b : b);
        shortCall(t ? 37 : s);
        shortCall(t ? s : 37);
        shortCall(t ? b : s);
        shortCall(t ? s : b);
        shortCall(t ? s : s);
        charCall(t ? 37 : c);
        charCall(t ? c : 37);
        charCall(t ? c : c);
        intCall(t ? 257 : b);
        intCall(t ? b : 257);
        intCall(t ? 65537 : s);
        intCall(t ? s : 65537);
        intCall(t ? -1 : c);
        intCall(t ? c : -1);
        intCall(t ? i : i);
        longCall(t ? l : b);
        longCall(t ? b : l);
        longCall(t ? l : s);
        longCall(t ? s : l);
        longCall(t ? l : c);
        longCall(t ? c : l);
        longCall(t ? l : i);
        longCall(t ? i : l);
        longCall(t ? l : l);
        floatCall(t ? f : b);
        floatCall(t ? b : f);
        floatCall(t ? f : s);
        floatCall(t ? s : f);
        floatCall(t ? f : c);
        floatCall(t ? c : f);
        floatCall(t ? f : i);
        floatCall(t ? i : f);
        floatCall(t ? f : l);
        floatCall(t ? l : f);
        floatCall(t ? f : f);
        doubleCall(t ? d : b);
        doubleCall(t ? b : d);
        doubleCall(t ? d : s);
        doubleCall(t ? s : d);
        doubleCall(t ? d : c);
        doubleCall(t ? c : d);
        doubleCall(t ? d : i);
        doubleCall(t ? i : d);
        doubleCall(t ? d : l);
        doubleCall(t ? l : d);
        doubleCall(t ? d : f);
        doubleCall(t ? f : d);
        doubleCall(t ? d : d);
        booleanCall(t ? t : t);
        aCall(t ? a : null);
        aCall(t ? null : a);
        aCall(t ? a : e);
        aCall(t ? e : a);
        aCall(t ? a : a);
        gCall(t ? g : null);
        gCall(t ? null : g);
        gCall(t ? g : e);
        gCall(t ? e : g);
        gCall(t ? g : g);
        eCall(t ? e : e);
    }
    
    public TriTestTypecheck() { super(); }
}
retrieve <A: void <init>()> from A
retrieve <E: void <init>()> from E
retrieve <TriTestTypecheck: void main(java.lang.String[])> from TriTestTypecheck
retrieve <TriTestTypecheck: void byteCall(byte)> from TriTestTypecheck
retrieve <TriTestTypecheck: void shortCall(short)> from TriTestTypecheck
retrieve <TriTestTypecheck: void charCall(char)> from TriTestTypecheck
retrieve <TriTestTypecheck: void intCall(int)> from TriTestTypecheck
retrieve <TriTestTypecheck: void longCall(long)> from TriTestTypecheck
retrieve <TriTestTypecheck: void floatCall(float)> from TriTestTypecheck
retrieve <TriTestTypecheck: void doubleCall(double)> from TriTestTypecheck
retrieve <TriTestTypecheck: void booleanCall(boolean)> from TriTestTypecheck
retrieve <TriTestTypecheck: void aCall(A)> from TriTestTypecheck
retrieve <TriTestTypecheck: void eCall(E)> from TriTestTypecheck
retrieve <TriTestTypecheck: void gCall(G)> from TriTestTypecheck
retrieve <TriTestTypecheck: void foo(boolean,byte,short,char,int,long,float,double,A,E,G)> from TriTestTypecheck
retrieve <TriTestTypecheck: void <init>()> from TriTestTypecheck
Transforming TriTestTypecheck... 
Transforming G... 
Transforming E... 
Transforming A... 
Abc finished on Thu Jun 24 08:13:29 BST 2004. ( 0 min. 9 sec. )
PASS: ?: expressions should typecheck in interesting ways()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 11 failed (check: 0), 54 passed (check: 0), 0 skipped.
Executing test 66 (pureJava): cast expressions should allow casts to/from interfaces at compile-time.
================================================
Breakdown of abc phases  (total: 6866 millisec.)
------------------------------------------------
[ 00.568% ] Init. of Soot:  39
[ 00.044% ] Loading Jars:  3
[ 78.139% ] Polyglot phases:  5365
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.772% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.568% ] Intertype Adjuster:  39
[ 12.657% ] Retrieving bodies:  869
[ 00.000% ] Weave Initializers:  0
[ 00.335% ] Load shadow types:  23
[ 00.874% ] Compute advice lists:  60
[ 00.044% ] Intertype weave:  3
[ 00.131% ] Add aspect code:  9
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.694% ] Soot Packs:  185
[ 02.957% ] Soot Writing Output:  203
================================================
Abc started on Thu Jun 24 08:13:32 BST 2004
<<<< InterfaceCast.java >>>>
class A {
    public A() { super(); }
}
interface I {}
class B extends A implements I {
    public B() { super(); }
}
public class InterfaceCast {
    public static void main(java.lang.String[] args) {  }
    
    void foo(A a, B b, I i) {
        A a0 = a;
        A a1 = b;
        A a2 = (A) i;
        B b0 = (B) a;
        B b1 = b;
        B b2 = (B) i;
        I i0 = (I) a;
        I i1 = b;
        I i2 = i;
    }
    
    public InterfaceCast() { super(); }
}
retrieve <A: void <init>()> from A
retrieve <B: void <init>()> from B
retrieve <InterfaceCast: void <init>()> from InterfaceCast
retrieve <InterfaceCast: void main(java.lang.String[])> from InterfaceCast
retrieve <InterfaceCast: void foo(A,B,I)> from InterfaceCast
Transforming I... 
Transforming A... 
Transforming B... 
Transforming InterfaceCast... 
Abc finished on Thu Jun 24 08:13:39 BST 2004. ( 0 min. 6 sec. )
PASS: cast expressions should allow casts to/from interfaces at compile-time.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 55 passed (check: 0), 0 skipped.
Executing test 67 (pureJava): various anonymous inner classes plus super types tests
================================================
Breakdown of abc phases  (total: 7368 millisec.)
------------------------------------------------
[ 00.516% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 80.334% ] Polyglot phases:  5919
[ 00.014% ] Resolve class names:  1
[ 00.027% ] Declare Parents:  2
[ 00.448% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.841% ] Intertype Adjuster:  62
[ 07.112% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 03.027% ] Compute advice lists:  223
[ 00.041% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  9
[ 00.190% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.678% ] Soot Packs:  271
[ 03.312% ] Soot Writing Output:  244
================================================
Abc started on Thu Jun 24 08:13:41 BST 2004
<<<< InnerSuper.java >>>>
import org.aspectj.testing.Tester;

public class InnerSuper {
    public static void main(java.lang.String[] args) {
        Counter c = new C().makeCounter();
        c.count();
        org.aspectj.testing.Tester.checkEqual(c/*null*/.n,
                                              1,
                                              "counted");
    }
    
    public InnerSuper() { super(); }
}
class C {
    public Counter makeCounter() {
        return new Counter() {
            public void count() { n += 1; }
        };
    }
    
    public C.InnerCounter makeInnerCounter() {
        class MyCounter extends C.InnerCounter {
            public void count() {
                this/*null*/.n += 1;
                toString();
            }
            
            public void lookat(java.lang.Object o) {
                boolean b = o.equals("abc");
            }
            
            public MyCounter() { super(); }
        }
        ;
        return new MyCounter();
    }
    
    protected class InnerCounter {
        protected int n;
        
        protected java.lang.Object o;
        
        public InnerCounter() { super(); }
    }
    
    
    public C() { super(); }
}
class Counter {
    protected int n = 0;
    
    public void count() {  }
    
    public Counter() { super(); }
}
retrieve <InnerSuper: void <init>()> from InnerSuper
retrieve <InnerSuper: void main(java.lang.String[])> from InnerSuper
retrieve <C: Counter makeCounter()> from C
retrieve <C: C$InnerCounter makeInnerCounter()> from C
retrieve <C: void <init>()> from C
retrieve <C$1: void count()> from C$1
retrieve <C$1: void <init>(C)> from C$1
retrieve <C$1MyCounter: void count()> from C$1MyCounter
retrieve <C$1MyCounter: void lookat(java.lang.Object)> from C$1MyCounter
retrieve <C$1MyCounter: void <init>(C)> from C$1MyCounter
retrieve <C$InnerCounter: void <init>(C)> from C$InnerCounter
retrieve <Counter: void count()> from Counter
retrieve <Counter: void <init>()> from Counter
retrieve <C$1MyCounter: void count()> from C$1MyCounter
retrieve <C$1MyCounter: void lookat(java.lang.Object)> from C$1MyCounter
retrieve <C$1MyCounter: void <init>(C)> from C$1MyCounter
Transforming Counter... 
Transforming InnerSuper... 
Transforming C... 
Transforming C$1MyCounter... 
Transforming C$1... 
Transforming C$InnerCounter... 
Abc finished on Thu Jun 24 08:13:49 BST 2004. ( 0 min. 7 sec. )
PASS: various anonymous inner classes plus super types tests()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 56 passed (check: 0), 0 skipped.
Executing test 68 (new): Doesn't parse an array-returning method that throws an exception
================================================
Breakdown of abc phases  (total: 7655 millisec.)
------------------------------------------------
[ 00.496% ] Init. of Soot:  38
[ 00.052% ] Loading Jars:  4
[ 73.690% ] Polyglot phases:  5641
[ 00.013% ] Resolve class names:  1
[ 00.026% ] Declare Parents:  2
[ 00.444% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.836% ] Intertype Adjuster:  64
[ 07.707% ] Retrieving bodies:  590
[ 00.000% ] Weave Initializers:  0
[ 00.300% ] Load shadow types:  23
[ 10.059% ] Compute advice lists:  770
[ 00.039% ] Intertype weave:  3
[ 00.118% ] Add aspect code:  9
[ 00.157% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.018% ] Soot Packs:  231
[ 03.044% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 08:13:51 BST 2004
<<<< ArrayMethod.java >>>>
import org.aspectj.testing.*;

public class ArrayMethod {
    public static void main(java.lang.String[] args) {
        new ArrayMethod().go();
        org.aspectj.testing.Tester.check(true, "compiled");
    }
    
    void go() {
        try {
            int[] array1 = array1();
            int[] array2 = array2();
            for (int i = 0; i < array1/*null*/.length; i++) {
                org.aspectj.testing.Tester.checkEqual(array1[i], i);
                org.aspectj.testing.Tester.checkEqual(array2[i], i);
            }
        }
        catch (java.lang.Exception e) {  }
    }
    
    int[] array1() throws java.lang.Exception {
        return new int[] { 0, 1, 2 };
    }
    
    int[] array2() throws java.lang.Exception {
        return new int[] { 0, 1, 2 };
    }
    
    public ArrayMethod() { super(); }
}
retrieve <ArrayMethod: void main(java.lang.String[])> from ArrayMethod
retrieve <ArrayMethod: void go()> from ArrayMethod
retrieve <ArrayMethod: int[] array1()> from ArrayMethod
retrieve <ArrayMethod: int[] array2()> from ArrayMethod
retrieve <ArrayMethod: void <init>()> from ArrayMethod
Transforming ArrayMethod... 
Abc finished on Thu Jun 24 08:13:59 BST 2004. ( 0 min. 7 sec. )
PASS: Doesn't parse an array-returning method that throws an exception()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 11 failed (check: 0), 57 passed (check: 0), 0 skipped.
Executing test 69 (new): Crashes when a lot of zeros are in front of a double variable [!!! purejava]
================================================
Breakdown of abc phases  (total: 8239 millisec.)
------------------------------------------------
[ 00.461% ] Init. of Soot:  38
[ 00.049% ] Loading Jars:  4
[ 75.883% ] Polyglot phases:  6252
[ 00.000% ] Resolve class names:  0
[ 00.024% ] Declare Parents:  2
[ 00.401% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 07.076% ] Intertype Adjuster:  583
[ 07.040% ] Retrieving bodies:  580
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  23
[ 02.075% ] Compute advice lists:  171
[ 00.036% ] Intertype weave:  3
[ 00.109% ] Add aspect code:  9
[ 00.146% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.022% ] Soot Packs:  249
[ 03.398% ] Soot Writing Output:  280
================================================
Abc started on Thu Jun 24 08:14:02 BST 2004
<<<< Zeros.java >>>>
import org.aspectj.testing.*;

public class Zeros {
    public static void main(java.lang.String[] args) {
        new Zeros().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        double d01 = 0.1;
        double d02 = 0.11;
        double d03 = 0.111;
        double d04 = 0.1111;
        double d05 = 0.11111;
        double d06 = 0.111111;
        double d07 = 0.1111111;
        double d08 = 0.11111111;
        double d09 = 0.111111111;
        double d10 = 0.1111111111;
        double d11 = 0.11111111111;
        double d12 = 0.111111111111;
        double d13 = 0.1111111111111;
        double d14 = 0.11111111111111;
        double d15 = 0.111111111111111;
        double d16 = 0.1111111111111111;
        double d17 = 0.1111111111111111;
        double d18 = 0.1111111111111111;
        double d19 = 0.1111111111111111;
        double d20 = 0.1111111111111111;
        double d21 = 0.1111111111111111;
        double d22 = 0.1111111111111111;
        double d23 = 0.1111111111111111;
        double d24 = 0.1111111111111111;
        double d25 = 0.1111111111111111;
        double d26 = 0.1111111111111111;
        double d27 = 0.1111111111111111;
        double d28 = 0.1111111111111111;
        double d29 = 0.1111111111111111;
        double d30 = 0.1111111111111111;
        double d31 = 0.1111111111111111;
        double d32 = 0.1111111111111111;
        double d33 = 0.1111111111111111;
        double d34 = 0.1111111111111111;
        double d35 = 0.1111111111111111;
        double d36 = 0.1111111111111111;
        double d37 = 0.1111111111111111;
        double d38 = 0.1111111111111111;
        double d39 = 0.1111111111111111;
        double d40 = 0.1111111111111111;
        double d41 = 0.1111111111111111;
        double d42 = 0.1111111111111111;
        double d43 = 0.1111111111111111;
        double d44 = 0.1111111111111111;
        double d45 = 0.1111111111111111;
        double d46 = 0.1111111111111111;
        double d47 = 0.1111111111111111;
        double d48 = 0.1111111111111111;
        double d49 = 0.1111111111111111;
        double d50 = 0.1111111111111111;
        double d51 = 0.1111111111111111;
        double d52 = 0.1111111111111111;
        double d53 = 0.1111111111111111;
        double d54 = 0.1111111111111111;
        double d55 = 0.1111111111111111;
        double d56 = 0.1111111111111111;
        double d57 = 0.1111111111111111;
        double d58 = 0.1111111111111111;
        double d59 = 0.1111111111111111;
        double d60 = 0.1111111111111111;
        double d61 = 0.1111111111111111;
        double d62 = 0.1111111111111111;
        double d63 = 0.1111111111111111;
        double d64 = 0.1111111111111111;
        double d65 = 0.1111111111111111;
        double d66 = 0.1111111111111111;
        double d67 = 0.1111111111111111;
        double d68 = 0.1111111111111111;
        double d69 = 0.1111111111111111;
        double d70 = 0.1111111111111111;
        double d71 = 0.1111111111111111;
        double d72 = 0.1111111111111111;
        double d73 = 0.1111111111111111;
        double d74 = 0.1111111111111111;
        double d75 = 0.1111111111111111;
        double d76 = 0.1111111111111111;
        double d77 = 0.1111111111111111;
        double d78 = 0.1111111111111111;
        double d79 = 0.1111111111111111;
        double d80 = 0.1111111111111111;
        double d81 = 0.1111111111111111;
        double d82 = 0.1111111111111111;
        double d83 = 0.1111111111111111;
        double d84 = 0.1111111111111111;
        double d85 = 0.1111111111111111;
        double d86 = 0.1111111111111111;
        double d87 = 0.1111111111111111;
        double d88 = 0.1111111111111111;
        double d89 = 0.1111111111111111;
        double d90 = 0.1111111111111111;
        double d91 = 0.1111111111111111;
        double d92 = 0.1111111111111111;
        double d93 = 0.1111111111111111;
        double d94 = 0.1111111111111111;
        double d95 = 0.1111111111111111;
        double d96 = 0.1111111111111111;
        double d97 = 0.1111111111111111;
        double d98 = 0.1111111111111111;
        double d99 = 0.1111111111111111;
        double d100 = 0.1111111111111111;
        double d101 = 0.1111111111111111;
        double d102 = 0.1111111111111111;
        double d103 = 0.1111111111111111;
        double d104 = 0.1111111111111111;
        double d105 = 0.1111111111111111;
        double d106 = 0.1111111111111111;
        double d107 = 0.1111111111111111;
        double d108 = 0.1111111111111111;
        double d109 = 0.1111111111111111;
        double d110 = 0.1111111111111111;
        double d111 = 0.1111111111111111;
        double d112 = 0.1111111111111111;
        double d113 = 0.1111111111111111;
        double d114 = 0.1111111111111111;
        double d115 = 0.1111111111111111;
        double d116 = 0.1111111111111111;
        double d117 = 0.1111111111111111;
        double d118 = 0.1111111111111111;
        double d119 = 0.1111111111111111;
        double d120 = 0.1111111111111111;
        double d121 = 0.1111111111111111;
        double d122 = 0.1111111111111111;
        double d123 = 0.1111111111111111;
        double d124 = 0.1111111111111111;
        double d125 = 0.1111111111111111;
        double d126 = 0.1111111111111111;
        double d127 = 0.1111111111111111;
        double d128 = 0.1111111111111111;
        double d129 = 0.1111111111111111;
        double d130 = 0.1111111111111111;
        double d131 = 0.1111111111111111;
        double d132 = 0.1111111111111111;
        double d133 = 0.1111111111111111;
        double d134 = 0.1111111111111111;
        double d135 = 0.1111111111111111;
        double d136 = 0.1111111111111111;
        double d137 = 0.1111111111111111;
        double d138 = 0.1111111111111111;
        double d139 = 0.1111111111111111;
        double d140 = 0.1111111111111111;
        double d141 = 0.1111111111111111;
        double d142 = 0.1111111111111111;
        double d143 = 0.1111111111111111;
        double d144 = 0.1111111111111111;
        double d145 = 0.1111111111111111;
        double d146 = 0.1111111111111111;
        double d147 = 0.1111111111111111;
        double d148 = 0.1111111111111111;
        double d149 = 0.1111111111111111;
        double d150 = 0.1111111111111111;
        double d151 = 0.1111111111111111;
        double d152 = 0.1111111111111111;
        double d153 = 0.1111111111111111;
        double d154 = 0.1111111111111111;
        double d155 = 0.1111111111111111;
        double d156 = 0.1111111111111111;
        double d157 = 0.1111111111111111;
        double d158 = 0.1111111111111111;
        double d159 = 0.1111111111111111;
        double d160 = 0.1111111111111111;
        double d161 = 0.1111111111111111;
        double d162 = 0.1111111111111111;
        double d163 = 0.1111111111111111;
        double d164 = 0.1111111111111111;
        double d165 = 0.1111111111111111;
        double d166 = 0.1111111111111111;
        double d167 = 0.1111111111111111;
        double d168 = 0.1111111111111111;
        double d169 = 0.1111111111111111;
        double d170 = 0.1111111111111111;
        double d171 = 0.1111111111111111;
        double d172 = 0.1111111111111111;
        double d173 = 0.1111111111111111;
        double d174 = 0.1111111111111111;
        double d175 = 0.1111111111111111;
        double d176 = 0.1111111111111111;
        double d177 = 0.1111111111111111;
        double d178 = 0.1111111111111111;
        double d179 = 0.1111111111111111;
        double d180 = 0.1111111111111111;
        double d181 = 0.1111111111111111;
        double d182 = 0.1111111111111111;
        double d183 = 0.1111111111111111;
        double d184 = 0.1111111111111111;
        double d185 = 0.1111111111111111;
        double d186 = 0.1111111111111111;
        double d187 = 0.1111111111111111;
        double d188 = 0.1111111111111111;
        double d189 = 0.1111111111111111;
        double d190 = 0.1111111111111111;
        double d191 = 0.1111111111111111;
        double d192 = 0.1111111111111111;
        double d193 = 0.1111111111111111;
        double d194 = 0.1111111111111111;
        double d195 = 0.1111111111111111;
        double d196 = 0.1111111111111111;
        double d197 = 0.1111111111111111;
        double d198 = 0.1111111111111111;
        double d199 = 0.1111111111111111;
        org.aspectj.testing.Tester.check(true, "compiled!");
    }
    
    public Zeros() { super(); }
}
retrieve <Zeros: void main(java.lang.String[])> from Zeros
retrieve <Zeros: void realMain(java.lang.String[])> from Zeros
retrieve <Zeros: void <init>()> from Zeros
Transforming Zeros... 
Abc finished on Thu Jun 24 08:14:10 BST 2004. ( 0 min. 8 sec. )
PASS: Crashes when a lot of zeros are in front of a double variable [!!! purej...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 11 failed (check: 0), 58 passed (check: 0), 0 skipped.
Executing test 70 (pureJava): Various comment syntaxes should be handled.
================================================
Breakdown of abc phases  (total: 6636 millisec.)
------------------------------------------------
[ 00.573% ] Init. of Soot:  38
[ 00.045% ] Loading Jars:  3
[ 79.159% ] Polyglot phases:  5253
[ 00.015% ] Resolve class names:  1
[ 00.030% ] Declare Parents:  2
[ 00.753% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.573% ] Intertype Adjuster:  38
[ 12.764% ] Retrieving bodies:  847
[ 00.000% ] Weave Initializers:  0
[ 00.542% ] Load shadow types:  36
[ 00.678% ] Compute advice lists:  45
[ 00.045% ] Intertype weave:  3
[ 00.136% ] Add aspect code:  9
[ 00.181% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.140% ] Soot Packs:  142
[ 02.366% ] Soot Writing Output:  157
================================================
Abc started on Thu Jun 24 08:14:13 BST 2004
<<<< CommentSyntax.java >>>>
public class CommentSyntax {
    public static void main(java.lang.String[] args) {  }
    
    public CommentSyntax() { super(); }
}
retrieve <CommentSyntax: void main(java.lang.String[])> from CommentSyntax
retrieve <CommentSyntax: void <init>()> from CommentSyntax
Transforming CommentSyntax... 
Abc finished on Thu Jun 24 08:14:20 BST 2004. ( 0 min. 6 sec. )
PASS: Various comment syntaxes should be handled.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 59 passed (check: 0), 0 skipped.
Executing test 71 (pureJava/abstractInner): Abstract inner classes across package boundaries
================================================
Breakdown of abc phases  (total: 7027 millisec.)
------------------------------------------------
[ 00.527% ] Init. of Soot:  37
[ 00.057% ] Loading Jars:  4
[ 77.757% ] Polyglot phases:  5464
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.441% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.555% ] Intertype Adjuster:  39
[ 12.580% ] Retrieving bodies:  884
[ 00.000% ] Weave Initializers:  0
[ 00.327% ] Load shadow types:  23
[ 01.452% ] Compute advice lists:  102
[ 00.043% ] Intertype weave:  3
[ 00.128% ] Add aspect code:  9
[ 00.185% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.917% ] Soot Packs:  205
[ 03.003% ] Soot Writing Output:  211
================================================
Abc started on Thu Jun 24 08:14:22 BST 2004
<<<< C.java >>>>
public class C extends pkg.A {
    void xxx() { this.new pkg.A.B("hiya") {}; }
    
    public static void main(java.lang.String[] args) {
        new C().xxx();
    }
    
    public C() { super(); }
}
<<<< A.java >>>>
package pkg;

public class A {
    public abstract class B {
        public B(java.lang.String x) { super(); }
    }
    
    
    public A() { super(); }
}
retrieve <C: void xxx()> from C
retrieve <C: void <init>()> from C
retrieve <C: void main(java.lang.String[])> from C
retrieve <C$1: void <init>(C,java.lang.String)> from C$1
retrieve <pkg.A: void <init>()> from pkg.A
retrieve <pkg.A$B: void <init>(pkg.A,java.lang.String)> from pkg.A$B
Transforming pkg.A... 
Transforming pkg.A$B... 
Transforming C... 
Transforming C$1... 
Abc finished on Thu Jun 24 08:14:29 BST 2004. ( 0 min. 7 sec. )
PASS: Abstract inner classes across package boundaries()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 11 failed (check: 0), 60 passed (check: 0), 0 skipped.
Executing test 72 (pureJava): inner classes accessing outers and some more inner class names
================================================
Breakdown of abc phases  (total: 7553 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  3
[ 78.260% ] Polyglot phases:  5911
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.688% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.503% ] Intertype Adjuster:  38
[ 07.428% ] Retrieving bodies:  561
[ 00.000% ] Weave Initializers:  0
[ 00.305% ] Load shadow types:  23
[ 04.078% ] Compute advice lists:  308
[ 00.040% ] Intertype weave:  3
[ 00.119% ] Add aspect code:  9
[ 00.185% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 04.197% ] Soot Packs:  317
[ 03.628% ] Soot Writing Output:  274
================================================
Failed. Current status: 12 failed (check: 0), 60 passed (check: 0), 0 skipped.
Executing test 73 (pureJava): remember to cast folded values down to the proper types.
================================================
Breakdown of abc phases  (total: 7195 millisec.)
------------------------------------------------
[ 00.528% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  3
[ 78.096% ] Polyglot phases:  5619
[ 00.014% ] Resolve class names:  1
[ 00.014% ] Declare Parents:  1
[ 00.778% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.542% ] Intertype Adjuster:  39
[ 12.509% ] Retrieving bodies:  900
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  23
[ 01.710% ] Compute advice lists:  123
[ 00.042% ] Intertype weave:  3
[ 00.125% ] Add aspect code:  9
[ 00.167% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.543% ] Soot Packs:  183
[ 02.571% ] Soot Writing Output:  185
================================================
Abc started on Thu Jun 24 08:14:42 BST 2004
<<<< CastingFoldedValues.java >>>>
import org.aspectj.testing.Tester;

public class CastingFoldedValues {
    static final char i = 'c';
    
    static boolean foundChar = false;
    
    static void foo(char c) {
        CastingFoldedValues/*CastingFoldedValues*/.foundChar = true;
    }
    
    static void foo(int c) {  }
    
    public static void main(java.lang.String[] args) {
        foo(CastingFoldedValues/*CastingFoldedValues*/.i);
        org.aspectj.testing.Tester.check(CastingFoldedValues/*CastingFoldedValues*/.foundChar,
                                         "forgot to cast folded char down to char type");
    }
    
    public CastingFoldedValues() { super(); }
}
retrieve <CastingFoldedValues: void foo(char)> from CastingFoldedValues
retrieve <CastingFoldedValues: void foo(int)> from CastingFoldedValues
retrieve <CastingFoldedValues: void main(java.lang.String[])> from CastingFoldedValues
retrieve <CastingFoldedValues: void <init>()> from CastingFoldedValues
retrieve <CastingFoldedValues: void <clinit>()> from CastingFoldedValues
Transforming CastingFoldedValues... 
Abc finished on Thu Jun 24 08:14:49 BST 2004. ( 0 min. 7 sec. )
PASS: remember to cast folded values down to the proper types.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 12 failed (check: 0), 61 passed (check: 0), 0 skipped.
Executing test 74 (pureJava): inner classes can be built using protected constructors in super
================================================
Breakdown of abc phases  (total: 13013 millisec.)
------------------------------------------------
[ 00.300% ] Init. of Soot:  39
[ 00.023% ] Loading Jars:  3
[ 84.615% ] Polyglot phases:  11011
[ 00.000% ] Resolve class names:  0
[ 00.015% ] Declare Parents:  2
[ 00.799% ] Recompute name pattern matches:  104
[ 00.000% ] Compute precedence relation:  0
[ 00.400% ] Intertype Adjuster:  52
[ 10.051% ] Retrieving bodies:  1308
[ 00.000% ] Weave Initializers:  0
[ 00.177% ] Load shadow types:  23
[ 00.430% ] Compute advice lists:  56
[ 00.023% ] Intertype weave:  3
[ 00.061% ] Add aspect code:  8
[ 00.100% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 01.468% ] Soot Packs:  191
[ 01.537% ] Soot Writing Output:  200
================================================
Abc started on Thu Jun 24 08:14:52 BST 2004
<<<< VariousConstructors.java >>>>
import org.aspectj.testing.Tester;
import java.awt.Component;

public class VariousConstructors {
    public static void main(java.lang.String[] args) {
        java.awt.Component c = new java.awt.Component() {};
        AbstractC ac = new AbstractC() {};
    }
    
    public VariousConstructors() { super(); }
}
abstract class AbstractC {
    public AbstractC() { super(); }
}
retrieve <VariousConstructors: void main(java.lang.String[])> from VariousConstructors
retrieve <VariousConstructors: void <init>()> from VariousConstructors
retrieve <VariousConstructors$2: void <init>()> from VariousConstructors$2
retrieve <VariousConstructors$1: void <init>()> from VariousConstructors$1
retrieve <AbstractC: void <init>()> from AbstractC
Transforming VariousConstructors... 
Transforming VariousConstructors$1... 
Transforming VariousConstructors$2... 
Transforming AbstractC... 
Abc finished on Thu Jun 24 08:15:05 BST 2004. ( 0 min. 13 sec. )
PASS: inner classes can be built using protected constructors in super()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 12 failed (check: 0), 62 passed (check: 0), 0 skipped.
Executing test 75 (pureJava): check that nested constructions of local classes work
================================================
Breakdown of abc phases  (total: 6740 millisec.)
------------------------------------------------
[ 00.564% ] Init. of Soot:  38
[ 00.045% ] Loading Jars:  3
[ 78.546% ] Polyglot phases:  5294
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.697% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.579% ] Intertype Adjuster:  39
[ 12.760% ] Retrieving bodies:  860
[ 00.000% ] Weave Initializers:  0
[ 00.341% ] Load shadow types:  23
[ 00.920% ] Compute advice lists:  62
[ 00.045% ] Intertype weave:  3
[ 00.134% ] Add aspect code:  9
[ 00.193% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.567% ] Soot Packs:  173
[ 02.582% ] Soot Writing Output:  174
================================================
Abc started on Thu Jun 24 08:15:08 BST 2004
<<<< NestedConstructionsOfLocalClasses.java >>>>
public class NestedConstructionsOfLocalClasses {
    public static void main(java.lang.String[] args) {
        class D {
            void x() { new D(); }
            
            public D() { super(); }
        }
        ;
    }
    
    public NestedConstructionsOfLocalClasses() { super(); }
}
retrieve <NestedConstructionsOfLocalClasses: void main(java.lang.String[])> from NestedConstructionsOfLocalClasses
retrieve <NestedConstructionsOfLocalClasses: void <init>()> from NestedConstructionsOfLocalClasses
retrieve <NestedConstructionsOfLocalClasses$1D: void <init>()> from NestedConstructionsOfLocalClasses$1D
retrieve <NestedConstructionsOfLocalClasses$1D: void x()> from NestedConstructionsOfLocalClasses$1D
retrieve <NestedConstructionsOfLocalClasses$1D: void <init>()> from NestedConstructionsOfLocalClasses$1D
retrieve <NestedConstructionsOfLocalClasses$1D: void x()> from NestedConstructionsOfLocalClasses$1D
Transforming NestedConstructionsOfLocalClasses... 
Transforming NestedConstructionsOfLocalClasses$1D... 
Abc finished on Thu Jun 24 08:15:14 BST 2004. ( 0 min. 6 sec. )
PASS: check that nested constructions of local classes work()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 12 failed (check: 0), 63 passed (check: 0), 0 skipped.
Executing test 76 (pureJava): Make sure anonymous classes can have non-nullary constructors
================================================
Breakdown of abc phases  (total: 6808 millisec.)
------------------------------------------------
[ 00.543% ] Init. of Soot:  37
[ 00.059% ] Loading Jars:  4
[ 78.760% ] Polyglot phases:  5362
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.455% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.573% ] Intertype Adjuster:  39
[ 12.618% ] Retrieving bodies:  859
[ 00.000% ] Weave Initializers:  0
[ 00.323% ] Load shadow types:  22
[ 00.925% ] Compute advice lists:  63
[ 00.044% ] Intertype weave:  3
[ 00.132% ] Add aspect code:  9
[ 00.176% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.806% ] Soot Packs:  191
[ 02.556% ] Soot Writing Output:  174
================================================
Abc started on Thu Jun 24 08:15:17 BST 2004
<<<< NonNullaryAnonymous.java >>>>
public class NonNullaryAnonymous {
    NonNullaryAnonymous(int x) { super(); }
    
    java.lang.Object x = new NonNullaryAnonymous(3) {};
    
    public static void main(java.lang.String[] args) {  }
}
retrieve <NonNullaryAnonymous: void <init>(int)> from NonNullaryAnonymous
retrieve <NonNullaryAnonymous: void main(java.lang.String[])> from NonNullaryAnonymous
retrieve <NonNullaryAnonymous$1: void <init>(NonNullaryAnonymous,int)> from NonNullaryAnonymous$1
Transforming NonNullaryAnonymous... 
Transforming NonNullaryAnonymous$1... 
Abc finished on Thu Jun 24 08:15:24 BST 2004. ( 0 min. 6 sec. )
PASS: Make sure anonymous classes can have non-nullary constructors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 12 failed (check: 0), 64 passed (check: 0), 0 skipped.
Executing test 77 (new): Full names are dropped from inner interfaces
================================================
Breakdown of abc phases  (total: 7926 millisec.)
------------------------------------------------
[ 00.479% ] Init. of Soot:  38
[ 00.050% ] Loading Jars:  4
[ 74.905% ] Polyglot phases:  5937
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.618% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 06.157% ] Intertype Adjuster:  488
[ 06.397% ] Retrieving bodies:  507
[ 00.000% ] Weave Initializers:  0
[ 00.278% ] Load shadow types:  22
[ 04.845% ] Compute advice lists:  384
[ 00.038% ] Intertype weave:  3
[ 00.101% ] Add aspect code:  8
[ 00.164% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.242% ] Soot Packs:  257
[ 02.700% ] Soot Writing Output:  214
================================================
Abc started on Thu Jun 24 08:15:26 BST 2004
<<<< PR417a.java >>>>
import org.aspectj.testing.*;

public class PR417a {
    public static interface Types {
        java.lang.Integer INT = new java.lang.Integer(3);
        
        int i = 0;
        
        byte b = (byte) 1;
        
        long l = 2L;
        
        double d = (double) 3;
        
        float f = (float) 4;
        
        short s = (short) 5;
        
        char c = 'c';
    }
    
    
    public static interface StaticTypes {
        java.lang.Integer INT = new java.lang.Integer(3);
        
        int i = 0;
        
        byte b = (byte) 1;
        
        long l = 2L;
        
        double d = (double) 3;
        
        float f = (float) 4;
        
        short s = (short) 5;
        
        char c = 'c';
    }
    
    
    public static void main(java.lang.String[] args) {
        new PR417a().run();
    }
    
    public void run() {
        org.aspectj.testing.Tester.check(PR417a.Types/*PR417a.Types*/.INT.equals(new java.lang.Integer(3)),
                                         "INT != 3");
        org.aspectj.testing.Tester.checkEqual(PR417a.Types/*PR417a.Types*/.i,
                                              0);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.Types/*PR417a.Types*/.b,
                                              1);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.Types/*PR417a.Types*/.l,
                                              2);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.Types/*PR417a.Types*/.d,
                                              3);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.Types/*PR417a.Types*/.f,
                                              4);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.Types/*PR417a.Types*/.s,
                                              5);
        org.aspectj.testing.Tester.checkEqual(PR417a.Types/*PR417a.Types*/.c,
                                              'c');
        org.aspectj.testing.Tester.check(PR417a.StaticTypes/*PR417a.StaticTypes*/.INT.equals(new java.lang.Integer(3)),
                                         "INT != 3");
        org.aspectj.testing.Tester.checkEqual(PR417a.StaticTypes/*PR417a.StaticTypes*/.i,
                                              0);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.StaticTypes/*PR417a.StaticTypes*/.b,
                                              1);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.StaticTypes/*PR417a.StaticTypes*/.l,
                                              2);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.StaticTypes/*PR417a.StaticTypes*/.d,
                                              3);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.StaticTypes/*PR417a.StaticTypes*/.f,
                                              4);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417a.StaticTypes/*PR417a.StaticTypes*/.s,
                                              5);
        org.aspectj.testing.Tester.checkEqual(PR417a.StaticTypes/*PR417a.StaticTypes*/.c,
                                              'c');
    }
    
    public PR417a() { super(); }
}
retrieve <PR417a: void main(java.lang.String[])> from PR417a
retrieve <PR417a: void run()> from PR417a
retrieve <PR417a: void <init>()> from PR417a
retrieve <PR417a$Types: void <clinit>()> from PR417a$Types
retrieve <PR417a$StaticTypes: void <clinit>()> from PR417a$StaticTypes
Transforming PR417a... 
Transforming PR417a$Types... 
Transforming PR417a$StaticTypes... 
Abc finished on Thu Jun 24 08:15:34 BST 2004. ( 0 min. 8 sec. )
PASS: Full names are dropped from inner interfaces()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 65 passed (check: 0), 0 skipped.
Executing test 78 (new): Making sure full names stay on static inner classes
================================================
Breakdown of abc phases  (total: 7669 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  37
[ 00.052% ] Loading Jars:  4
[ 76.646% ] Polyglot phases:  5878
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.456% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 06.246% ] Intertype Adjuster:  479
[ 06.415% ] Retrieving bodies:  492
[ 00.013% ] Weave Initializers:  1
[ 00.287% ] Load shadow types:  22
[ 03.325% ] Compute advice lists:  255
[ 00.026% ] Intertype weave:  2
[ 00.117% ] Add aspect code:  9
[ 00.170% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.895% ] Soot Packs:  222
[ 02.843% ] Soot Writing Output:  218
================================================
Abc started on Thu Jun 24 08:15:37 BST 2004
<<<< PR417b.java >>>>
import org.aspectj.testing.*;

public class PR417b {
    public static class StaticTypes {
        public static java.lang.Integer INT =
          new java.lang.Integer(3);
        
        public static int i = 0;
        
        public static byte b = (byte) 1;
        
        public static long l = 2L;
        
        public static double d = (double) 3;
        
        public static float f = (float) 4;
        
        public static short s = (short) 5;
        
        public static char c = 'c';
        
        public StaticTypes() { super(); }
    }
    
    
    public static void main(java.lang.String[] args) {
        new PR417b().run();
    }
    
    public void run() {
        org.aspectj.testing.Tester.check(PR417b.StaticTypes/*PR417b.StaticTypes*/.INT.equals(new java.lang.Integer(3)),
                                         "INT != 3");
        org.aspectj.testing.Tester.checkEqual(PR417b.StaticTypes/*PR417b.StaticTypes*/.i,
                                              0);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417b.StaticTypes/*PR417b.StaticTypes*/.b,
                                              1);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417b.StaticTypes/*PR417b.StaticTypes*/.l,
                                              2);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417b.StaticTypes/*PR417b.StaticTypes*/.d,
                                              3);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417b.StaticTypes/*PR417b.StaticTypes*/.f,
                                              4);
        org.aspectj.testing.Tester.checkEqual((int)
                                                PR417b.StaticTypes/*PR417b.StaticTypes*/.s,
                                              5);
        org.aspectj.testing.Tester.checkEqual(PR417b.StaticTypes/*PR417b.StaticTypes*/.c,
                                              'c');
    }
    
    public PR417b() { super(); }
}
retrieve <PR417b: void main(java.lang.String[])> from PR417b
retrieve <PR417b: void run()> from PR417b
retrieve <PR417b: void <init>()> from PR417b
retrieve <PR417b$StaticTypes: void <init>()> from PR417b$StaticTypes
retrieve <PR417b$StaticTypes: void <clinit>()> from PR417b$StaticTypes
Transforming PR417b... 
Transforming PR417b$StaticTypes... 
Abc finished on Thu Jun 24 08:15:45 BST 2004. ( 0 min. 7 sec. )
PASS: Making sure full names stay on static inner classes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 66 passed (check: 0), 0 skipped.
Executing test 79 (pureJava): The current AspectJ compiler cannot parse qualified superclass constructor invocations
================================================
Breakdown of abc phases  (total: 7438 millisec.)
------------------------------------------------
[ 00.511% ] Init. of Soot:  38
[ 00.054% ] Loading Jars:  4
[ 74.993% ] Polyglot phases:  5578
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.699% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 06.319% ] Intertype Adjuster:  470
[ 06.628% ] Retrieving bodies:  493
[ 00.000% ] Weave Initializers:  0
[ 00.323% ] Load shadow types:  24
[ 03.670% ] Compute advice lists:  273
[ 00.040% ] Intertype weave:  3
[ 00.121% ] Add aspect code:  9
[ 00.175% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.119% ] Soot Packs:  232
[ 03.321% ] Soot Writing Output:  247
================================================
Abc started on Thu Jun 24 08:15:47 BST 2004
<<<< QualifiedSuperClassConstructorInvocations_PR401.java >>>>
public class QualifiedSuperClassConstructorInvocations_PR401 {
    public static void main(java.lang.String[] args) {
        ChildOfInner coi = new ChildOfInner();
        org.aspectj.testing.Tester.checkEqual(S/*S*/.s,
                                              "Outer:Inner:ChildOfInner");
    }
    
    public QualifiedSuperClassConstructorInvocations_PR401() {
        super();
    }
}
class S {
    static java.lang.String s = "";
    
    public S() { super(); }
}
class Outer {
    public Outer() {
        super();
        S/*S*/.s += "Outer";
    }
    
    class Inner {
        public Inner() {
            super();
            S/*S*/.s += ":Inner";
        }
    }
    
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() {
        new Outer().super();
        S/*S*/.s += ":ChildOfInner";
    }
}
retrieve <QualifiedSuperClassConstructorInvocations_PR401: void main(java.lang.String[])> from QualifiedSuperClassConstructorInvocations_PR401
retrieve <QualifiedSuperClassConstructorInvocations_PR401: void <init>()> from QualifiedSuperClassConstructorInvocations_PR401
retrieve <S: void <init>()> from S
retrieve <S: void <clinit>()> from S
retrieve <Outer: void <init>()> from Outer
retrieve <Outer$Inner: void <init>(Outer)> from Outer$Inner
retrieve <ChildOfInner: void <init>()> from ChildOfInner
Transforming S... 
Transforming Outer... 
Transforming ChildOfInner... 
Transforming QualifiedSuperClassConstructorInvocations_PR401... 
Transforming Outer$Inner... 
Abc finished on Thu Jun 24 08:15:55 BST 2004. ( 0 min. 7 sec. )
PASS: The current AspectJ compiler cannot parse qualified superclass construct...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 12 failed (check: 0), 67 passed (check: 0), 0 skipped.
Executing test 80 (pureJava): More thourough test of static members using full names
================================================
Breakdown of abc phases  (total: 21682 millisec.)
------------------------------------------------
[ 00.171% ] Init. of Soot:  37
[ 00.018% ] Loading Jars:  4
[ 46.001% ] Polyglot phases:  9974
[ 00.005% ] Resolve class names:  1
[ 00.009% ] Declare Parents:  2
[ 00.166% ] Recompute name pattern matches:  36
[ 00.000% ] Compute precedence relation:  0
[ 00.314% ] Intertype Adjuster:  68
[ 09.418% ] Retrieving bodies:  2042
[ 00.000% ] Weave Initializers:  0
[ 00.101% ] Load shadow types:  22
[ 31.321% ] Compute advice lists:  6791
[ 00.018% ] Intertype weave:  4
[ 00.037% ] Add aspect code:  8
[ 00.111% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 05.904% ] Soot Packs:  1280
[ 06.406% ] Soot Writing Output:  1389
================================================
Abc started on Thu Jun 24 08:15:57 BST 2004
<<<< Statics.java >>>>
public class Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 0);
    
    public static byte b = (byte) 1 + 0;
    
    public static short s = (short) 1 + 0;
    
    public static int i = (int) 1 + 0;
    
    public static long l = (long) 1 + 0;
    
    public static float f = (float) 1 + 0;
    
    public static double d = (double) 1 + 0;
    
    public static char c = (char) '1' + 0;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 0);
        
        public static byte b = (byte) 2 + 0;
        
        public static short s = (short) 2 + 0;
        
        public static int i = (int) 2 + 0;
        
        public static long l = (long) 2 + 0;
        
        public static float f = (float) 2 + 0;
        
        public static double d = (double) 2 + 0;
        
        public static char c = (char) '2' + 0;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 0);
            
            public static byte b = (byte) 3 + 0;
            
            public static short s = (short) 3 + 0;
            
            public static int i = (int) 3 + 0;
            
            public static long l = (long) 3 + 0;
            
            public static float f = (float) 3 + 0;
            
            public static double d = (double) 3 + 0;
            
            public static char c = (char) '3' + 0;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 0);
            
            byte b = (byte) 4 + 0;
            
            short s = (short) 4 + 0;
            
            int i = (int) 4 + 0;
            
            long l = (long) 4 + 0;
            
            float f = (float) 4 + 0;
            
            double d = (double) 4 + 0;
            
            char c = (char) '4' + 0;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 0);
            
            byte b = (byte) 5 + 0;
            
            short s = (short) 5 + 0;
            
            int i = (int) 5 + 0;
            
            long l = (long) 5 + 0;
            
            float f = (float) 5 + 0;
            
            double d = (double) 5 + 0;
            
            char c = (char) '5' + 0;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 0);
            
            byte b = (byte) 6 + 0;
            
            short s = (short) 6 + 0;
            
            int i = (int) 6 + 0;
            
            long l = (long) 6 + 0;
            
            float f = (float) 6 + 0;
            
            double d = (double) 6 + 0;
            
            char c = (char) '6' + 0;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 0);
            
            byte b = (byte) 7 + 0;
            
            short s = (short) 7 + 0;
            
            int i = (int) 7 + 0;
            
            long l = (long) 7 + 0;
            
            float f = (float) 7 + 0;
            
            double d = (double) 7 + 0;
            
            char c = (char) '7' + 0;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 10);
        
        byte b = (byte) 2 + 10;
        
        short s = (short) 2 + 10;
        
        int i = (int) 2 + 10;
        
        long l = (long) 2 + 10;
        
        float f = (float) 2 + 10;
        
        double d = (double) 2 + 10;
        
        char c = (char) '2' + 10;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 10);
            
            public static byte b = (byte) 3 + 10;
            
            public static short s = (short) 3 + 10;
            
            public static int i = (int) 3 + 10;
            
            public static long l = (long) 3 + 10;
            
            public static float f = (float) 3 + 10;
            
            public static double d = (double) 3 + 10;
            
            public static char c = (char) '3' + 10;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 10);
            
            byte b = (byte) 4 + 10;
            
            short s = (short) 4 + 10;
            
            int i = (int) 4 + 10;
            
            long l = (long) 4 + 10;
            
            float f = (float) 4 + 10;
            
            double d = (double) 4 + 10;
            
            char c = (char) '4' + 10;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 10);
            
            byte b = (byte) 5 + 10;
            
            short s = (short) 5 + 10;
            
            int i = (int) 5 + 10;
            
            long l = (long) 5 + 10;
            
            float f = (float) 5 + 10;
            
            double d = (double) 5 + 10;
            
            char c = (char) '5' + 10;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 10);
            
            byte b = (byte) 6 + 10;
            
            short s = (short) 6 + 10;
            
            int i = (int) 6 + 10;
            
            long l = (long) 6 + 10;
            
            float f = (float) 6 + 10;
            
            double d = (double) 6 + 10;
            
            char c = (char) '6' + 10;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 10);
            
            byte b = (byte) 7 + 10;
            
            short s = (short) 7 + 10;
            
            int i = (int) 7 + 10;
            
            long l = (long) 7 + 10;
            
            float f = (float) 7 + 10;
            
            double d = (double) 7 + 10;
            
            char c = (char) '7' + 10;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 20);
        
        byte b = (byte) 2 + 20;
        
        short s = (short) 2 + 20;
        
        int i = (int) 2 + 20;
        
        long l = (long) 2 + 20;
        
        float f = (float) 2 + 20;
        
        double d = (double) 2 + 20;
        
        char c = (char) '2' + 20;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 20);
            
            public static byte b = (byte) 3 + 20;
            
            public static short s = (short) 3 + 20;
            
            public static int i = (int) 3 + 20;
            
            public static long l = (long) 3 + 20;
            
            public static float f = (float) 3 + 20;
            
            public static double d = (double) 3 + 20;
            
            public static char c = (char) '3' + 20;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 20);
            
            byte b = (byte) 4 + 20;
            
            short s = (short) 4 + 20;
            
            int i = (int) 4 + 20;
            
            long l = (long) 4 + 20;
            
            float f = (float) 4 + 20;
            
            double d = (double) 4 + 20;
            
            char c = (char) '4' + 20;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 20);
            
            byte b = (byte) 5 + 20;
            
            short s = (short) 5 + 20;
            
            int i = (int) 5 + 20;
            
            long l = (long) 5 + 20;
            
            float f = (float) 5 + 20;
            
            double d = (double) 5 + 20;
            
            char c = (char) '5' + 20;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 20);
            
            byte b = (byte) 6 + 20;
            
            short s = (short) 6 + 20;
            
            int i = (int) 6 + 20;
            
            long l = (long) 6 + 20;
            
            float f = (float) 6 + 20;
            
            double d = (double) 6 + 20;
            
            char c = (char) '6' + 20;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 20);
            
            byte b = (byte) 7 + 20;
            
            short s = (short) 7 + 20;
            
            int i = (int) 7 + 20;
            
            long l = (long) 7 + 20;
            
            float f = (float) 7 + 20;
            
            double d = (double) 7 + 20;
            
            char c = (char) '7' + 20;
        }
        
    }
    
    
    public Statics() { super(); }
}
<<<< SubC1.java >>>>
package p1.subp1;

public class SubC1 {
    public SubC1() { super(); }
}
<<<< C1.java >>>>
package p1;

public class C1 {
    public C1() { super(); }
}
<<<< P1Statics.java >>>>
package p1;

public class P1Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 1);
    
    public static byte b = (byte) 1 + 1;
    
    public static short s = (short) 1 + 1;
    
    public static int i = (int) 1 + 1;
    
    public static long l = (long) 1 + 1;
    
    public static float f = (float) 1 + 1;
    
    public static double d = (double) 1 + 1;
    
    public static char c = (char) '1' + 1;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 1);
        
        public static byte b = (byte) 2 + 1;
        
        public static short s = (short) 2 + 1;
        
        public static int i = (int) 2 + 1;
        
        public static long l = (long) 2 + 1;
        
        public static float f = (float) 2 + 1;
        
        public static double d = (double) 2 + 1;
        
        public static char c = (char) '2' + 1;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 1);
            
            public static byte b = (byte) 3 + 1;
            
            public static short s = (short) 3 + 1;
            
            public static int i = (int) 3 + 1;
            
            public static long l = (long) 3 + 1;
            
            public static float f = (float) 3 + 1;
            
            public static double d = (double) 3 + 1;
            
            public static char c = (char) '3' + 1;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 1);
            
            byte b = (byte) 4 + 1;
            
            short s = (short) 4 + 1;
            
            int i = (int) 4 + 1;
            
            long l = (long) 4 + 1;
            
            float f = (float) 4 + 1;
            
            double d = (double) 4 + 1;
            
            char c = (char) '4' + 1;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 1);
            
            byte b = (byte) 5 + 1;
            
            short s = (short) 5 + 1;
            
            int i = (int) 5 + 1;
            
            long l = (long) 5 + 1;
            
            float f = (float) 5 + 1;
            
            double d = (double) 5 + 1;
            
            char c = (char) '5' + 1;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 1);
            
            byte b = (byte) 6 + 1;
            
            short s = (short) 6 + 1;
            
            int i = (int) 6 + 1;
            
            long l = (long) 6 + 1;
            
            float f = (float) 6 + 1;
            
            double d = (double) 6 + 1;
            
            char c = (char) '6' + 1;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 1);
            
            byte b = (byte) 7 + 1;
            
            short s = (short) 7 + 1;
            
            int i = (int) 7 + 1;
            
            long l = (long) 7 + 1;
            
            float f = (float) 7 + 1;
            
            double d = (double) 7 + 1;
            
            char c = (char) '7' + 1;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 11);
        
        byte b = (byte) 2 + 11;
        
        short s = (short) 2 + 11;
        
        int i = (int) 2 + 11;
        
        long l = (long) 2 + 11;
        
        float f = (float) 2 + 11;
        
        double d = (double) 2 + 11;
        
        char c = (char) '2' + 11;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 11);
            
            public static byte b = (byte) 3 + 11;
            
            public static short s = (short) 3 + 11;
            
            public static int i = (int) 3 + 11;
            
            public static long l = (long) 3 + 11;
            
            public static float f = (float) 3 + 11;
            
            public static double d = (double) 3 + 11;
            
            public static char c = (char) '3' + 11;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 11);
            
            byte b = (byte) 4 + 11;
            
            short s = (short) 4 + 11;
            
            int i = (int) 4 + 11;
            
            long l = (long) 4 + 11;
            
            float f = (float) 4 + 11;
            
            double d = (double) 4 + 11;
            
            char c = (char) '4' + 11;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 11);
            
            byte b = (byte) 5 + 11;
            
            short s = (short) 5 + 11;
            
            int i = (int) 5 + 11;
            
            long l = (long) 5 + 11;
            
            float f = (float) 5 + 11;
            
            double d = (double) 5 + 11;
            
            char c = (char) '5' + 11;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 11);
            
            byte b = (byte) 6 + 11;
            
            short s = (short) 6 + 11;
            
            int i = (int) 6 + 11;
            
            long l = (long) 6 + 11;
            
            float f = (float) 6 + 11;
            
            double d = (double) 6 + 11;
            
            char c = (char) '6' + 11;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 11);
            
            byte b = (byte) 7 + 11;
            
            short s = (short) 7 + 11;
            
            int i = (int) 7 + 11;
            
            long l = (long) 7 + 11;
            
            float f = (float) 7 + 11;
            
            double d = (double) 7 + 11;
            
            char c = (char) '7' + 11;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 21);
        
        byte b = (byte) 2 + 21;
        
        short s = (short) 2 + 21;
        
        int i = (int) 2 + 21;
        
        long l = (long) 2 + 21;
        
        float f = (float) 2 + 21;
        
        double d = (double) 2 + 21;
        
        char c = (char) '2' + 21;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 21);
            
            public static byte b = (byte) 3 + 21;
            
            public static short s = (short) 3 + 21;
            
            public static int i = (int) 3 + 21;
            
            public static long l = (long) 3 + 21;
            
            public static float f = (float) 3 + 21;
            
            public static double d = (double) 3 + 21;
            
            public static char c = (char) '3' + 21;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 21);
            
            byte b = (byte) 4 + 21;
            
            short s = (short) 4 + 21;
            
            int i = (int) 4 + 21;
            
            long l = (long) 4 + 21;
            
            float f = (float) 4 + 21;
            
            double d = (double) 4 + 21;
            
            char c = (char) '4' + 21;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 21);
            
            byte b = (byte) 5 + 21;
            
            short s = (short) 5 + 21;
            
            int i = (int) 5 + 21;
            
            long l = (long) 5 + 21;
            
            float f = (float) 5 + 21;
            
            double d = (double) 5 + 21;
            
            char c = (char) '5' + 21;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 21);
            
            byte b = (byte) 6 + 21;
            
            short s = (short) 6 + 21;
            
            int i = (int) 6 + 21;
            
            long l = (long) 6 + 21;
            
            float f = (float) 6 + 21;
            
            double d = (double) 6 + 21;
            
            char c = (char) '6' + 21;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 21);
            
            byte b = (byte) 7 + 21;
            
            short s = (short) 7 + 21;
            
            int i = (int) 7 + 21;
            
            long l = (long) 7 + 21;
            
            float f = (float) 7 + 21;
            
            double d = (double) 7 + 21;
            
            char c = (char) '7' + 21;
        }
        
    }
    
    
    public P1Statics() { super(); }
}
<<<< StaticMembers_PR421.java >>>>
import org.aspectj.testing.*;

public class StaticMembers_PR421 {
    public static void main(java.lang.String[] args) {
        new StaticMembers_PR421().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.b,
                                              (byte) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.s,
                                              (short) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.i,
                                              1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.l,
                                              1 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.f,
                                              (float) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.d,
                                              (double) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.c,
                                              '1' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.i,
                                              2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.l,
                                              2 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.d,
                                              (double) (double) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.c,
                                              '2' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.i,
                                              2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.l,
                                              2 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.i,
                                              2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.l,
                                              2 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.c,
                                              '2' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.b,
                                              (byte) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.s,
                                              (short) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.i,
                                              1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.l,
                                              1 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.f,
                                              (float) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.d,
                                              (double) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.c,
                                              '1' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.i,
                                              2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.l,
                                              2 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.d,
                                              (double) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.c,
                                              '2' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.i,
                                              2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.l,
                                              2 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.i,
                                              2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.l,
                                              2 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.c,
                                              '2' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.b,
                                              (byte) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.s,
                                              (short) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.i,
                                              1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.l,
                                              1 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.f,
                                              (float) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.d,
                                              (double) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.c,
                                              '1' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.i,
                                              2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.l,
                                              2 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.d,
                                              (double) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.c,
                                              '2' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.i,
                                              2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.l,
                                              2 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.i,
                                              2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.l,
                                              2 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.c,
                                              '2' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              22);
    }
    
    public StaticMembers_PR421() { super(); }
}
<<<< P1P2Statics.java >>>>
package p1.p2;

public class P1P2Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 2);
    
    public static byte b = (byte) 1 + 2;
    
    public static short s = (short) 1 + 2;
    
    public static int i = (int) 1 + 2;
    
    public static long l = (long) 1 + 2;
    
    public static float f = (float) 1 + 2;
    
    public static double d = (double) 1 + 2;
    
    public static char c = (char) '1' + 2;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 2);
        
        public static byte b = (byte) 2 + 2;
        
        public static short s = (short) 2 + 2;
        
        public static int i = (int) 2 + 2;
        
        public static long l = (long) 2 + 2;
        
        public static float f = (float) 2 + 2;
        
        public static double d = (double) 2 + 2;
        
        public static char c = (char) '2' + 2;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 2);
            
            public static byte b = (byte) 3 + 2;
            
            public static short s = (short) 3 + 2;
            
            public static int i = (int) 3 + 2;
            
            public static long l = (long) 3 + 2;
            
            public static float f = (float) 3 + 2;
            
            public static double d = (double) 3 + 2;
            
            public static char c = (char) '3' + 2;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 2);
            
            byte b = (byte) 4 + 2;
            
            short s = (short) 4 + 2;
            
            int i = (int) 4 + 2;
            
            long l = (long) 4 + 2;
            
            float f = (float) 4 + 2;
            
            double d = (double) 4 + 2;
            
            char c = (char) '4' + 2;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 2);
            
            byte b = (byte) 5 + 2;
            
            short s = (short) 5 + 2;
            
            int i = (int) 5 + 2;
            
            long l = (long) 5 + 2;
            
            float f = (float) 5 + 2;
            
            double d = (double) 5 + 2;
            
            char c = (char) '5' + 2;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 2);
            
            byte b = (byte) 6 + 2;
            
            short s = (short) 6 + 2;
            
            int i = (int) 6 + 2;
            
            long l = (long) 6 + 2;
            
            float f = (float) 6 + 2;
            
            double d = (double) 6 + 2;
            
            char c = (char) '6' + 2;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 2);
            
            byte b = (byte) 7 + 2;
            
            short s = (short) 7 + 2;
            
            int i = (int) 7 + 2;
            
            long l = (long) 7 + 2;
            
            float f = (float) 7 + 2;
            
            double d = (double) 7 + 2;
            
            char c = (char) '7' + 2;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 12);
        
        byte b = (byte) 2 + 12;
        
        short s = (short) 2 + 12;
        
        int i = (int) 2 + 12;
        
        long l = (long) 2 + 12;
        
        float f = (float) 2 + 12;
        
        double d = (double) 2 + 12;
        
        char c = (char) '2' + 12;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 12);
            
            public static byte b = (byte) 3 + 12;
            
            public static short s = (short) 3 + 12;
            
            public static int i = (int) 3 + 12;
            
            public static long l = (long) 3 + 12;
            
            public static float f = (float) 3 + 12;
            
            public static double d = (double) 3 + 12;
            
            public static char c = (char) '3' + 12;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 12);
            
            byte b = (byte) 4 + 12;
            
            short s = (short) 4 + 12;
            
            int i = (int) 4 + 12;
            
            long l = (long) 4 + 12;
            
            float f = (float) 4 + 12;
            
            double d = (double) 4 + 12;
            
            char c = (char) '4' + 12;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 12);
            
            byte b = (byte) 5 + 12;
            
            short s = (short) 5 + 12;
            
            int i = (int) 5 + 12;
            
            long l = (long) 5 + 12;
            
            float f = (float) 5 + 12;
            
            double d = (double) 5 + 12;
            
            char c = (char) '5' + 12;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 12);
            
            byte b = (byte) 6 + 12;
            
            short s = (short) 6 + 12;
            
            int i = (int) 6 + 12;
            
            long l = (long) 6 + 12;
            
            float f = (float) 6 + 12;
            
            double d = (double) 6 + 12;
            
            char c = (char) '6' + 12;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 12);
            
            byte b = (byte) 7 + 12;
            
            short s = (short) 7 + 12;
            
            int i = (int) 7 + 12;
            
            long l = (long) 7 + 12;
            
            float f = (float) 7 + 12;
            
            double d = (double) 7 + 12;
            
            char c = (char) '7' + 12;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 22);
        
        byte b = (byte) 2 + 22;
        
        short s = (short) 2 + 22;
        
        int i = (int) 2 + 22;
        
        long l = (long) 2 + 22;
        
        float f = (float) 2 + 22;
        
        double d = (double) 2 + 22;
        
        char c = (char) '2' + 22;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 22);
            
            public static byte b = (byte) 3 + 22;
            
            public static short s = (short) 3 + 22;
            
            public static int i = (int) 3 + 22;
            
            public static long l = (long) 3 + 22;
            
            public static float f = (float) 3 + 22;
            
            public static double d = (double) 3 + 22;
            
            public static char c = (char) '3' + 22;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 22);
            
            byte b = (byte) 4 + 22;
            
            short s = (short) 4 + 22;
            
            int i = (int) 4 + 22;
            
            long l = (long) 4 + 22;
            
            float f = (float) 4 + 22;
            
            double d = (double) 4 + 22;
            
            char c = (char) '4' + 22;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 22);
            
            byte b = (byte) 5 + 22;
            
            short s = (short) 5 + 22;
            
            int i = (int) 5 + 22;
            
            long l = (long) 5 + 22;
            
            float f = (float) 5 + 22;
            
            double d = (double) 5 + 22;
            
            char c = (char) '5' + 22;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 22);
            
            byte b = (byte) 6 + 22;
            
            short s = (short) 6 + 22;
            
            int i = (int) 6 + 22;
            
            long l = (long) 6 + 22;
            
            float f = (float) 6 + 22;
            
            double d = (double) 6 + 22;
            
            char c = (char) '6' + 22;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 22);
            
            byte b = (byte) 7 + 22;
            
            short s = (short) 7 + 22;
            
            int i = (int) 7 + 22;
            
            long l = (long) 7 + 22;
            
            float f = (float) 7 + 22;
            
            double d = (double) 7 + 22;
            
            char c = (char) '7' + 22;
        }
        
    }
    
    
    public P1P2Statics() { super(); }
}
retrieve <Statics: void <init>()> from Statics
retrieve <Statics: void <clinit>()> from Statics
retrieve <Statics$NestedStaticClass: void <init>()> from Statics$NestedStaticClass
retrieve <Statics$NestedStaticClass: void <clinit>()> from Statics$NestedStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticClass: void <init>()> from Statics$NestedStaticClass$InnerStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from Statics$NestedStaticClass$InnerStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from Statics$NestedStaticClass$InnerStaticInterface
retrieve <Statics$NestedStaticClass$InnerInterface: void <clinit>()> from Statics$NestedStaticClass$InnerInterface
retrieve <Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <Statics$NestedStaticInterface: void <clinit>()> from Statics$NestedStaticInterface
retrieve <Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from Statics$NestedStaticInterface$InnerStaticClass
retrieve <Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticClass
retrieve <Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticInterface
retrieve <Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from Statics$NestedStaticInterface$InnerInterface
retrieve <Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <Statics$NestedInterface: void <clinit>()> from Statics$NestedInterface
retrieve <Statics$NestedInterface$InnerStaticClass: void <init>()> from Statics$NestedInterface$InnerStaticClass
retrieve <Statics$NestedInterface$InnerStaticClass: void <clinit>()> from Statics$NestedInterface$InnerStaticClass
retrieve <Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from Statics$NestedInterface$InnerStaticInterface
retrieve <Statics$NestedInterface$InnerInterface: void <clinit>()> from Statics$NestedInterface$InnerInterface
retrieve <Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedInterface$InnerInterfaceNoStatics
retrieve <p1.subp1.SubC1: void <init>()> from p1.subp1.SubC1
retrieve <p1.C1: void <init>()> from p1.C1
retrieve <p1.P1Statics: void <init>()> from p1.P1Statics
retrieve <p1.P1Statics: void <clinit>()> from p1.P1Statics
retrieve <p1.P1Statics$NestedStaticClass: void <init>()> from p1.P1Statics$NestedStaticClass
retrieve <p1.P1Statics$NestedStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticClass: void <init>()> from p1.P1Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticInterface
retrieve <p1.P1Statics$NestedStaticClass$InnerInterface: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerInterface
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from p1.P1Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <p1.P1Statics$NestedInterface: void <clinit>()> from p1.P1Statics$NestedInterface
retrieve <p1.P1Statics$NestedInterface$InnerStaticClass: void <init>()> from p1.P1Statics$NestedInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedInterface$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticInterface
retrieve <p1.P1Statics$NestedInterface$InnerInterface: void <clinit>()> from p1.P1Statics$NestedInterface$InnerInterface
retrieve <p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedInterface$InnerInterfaceNoStatics
retrieve <StaticMembers_PR421: void realMain(java.lang.String[])> from StaticMembers_PR421
retrieve <StaticMembers_PR421: void <init>()> from StaticMembers_PR421
retrieve <StaticMembers_PR421: void main(java.lang.String[])> from StaticMembers_PR421
retrieve <p1.p2.P1P2Statics: void <init>()> from p1.p2.P1P2Statics
retrieve <p1.p2.P1P2Statics: void <clinit>()> from p1.p2.P1P2Statics
retrieve <p1.p2.P1P2Statics$NestedStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics
Transforming p1.p2.P1P2Statics... 
Transforming p1.p2.P1P2Statics$NestedStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticClass... 
Transforming p1.P1Statics... 
Transforming p1.P1Statics$NestedInterface... 
Transforming p1.P1Statics$NestedStaticClass... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.P1Statics$NestedInterface$InnerStaticInterface... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedInterface$InnerStaticClass... 
Transforming p1.P1Statics$NestedStaticInterface... 
Transforming p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticInterface$InnerInterface... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticClass... 
Transforming p1.P1Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming p1.P1Statics$NestedInterface$InnerInterface... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticClass$InnerInterface... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticInterface... 
Transforming p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming p1.C1... 
Transforming StaticMembers_PR421... 
Transforming Statics... 
Transforming Statics$NestedInterface... 
Transforming Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticClass... 
Transforming Statics$NestedStaticClass$InnerStaticInterface... 
Transforming Statics$NestedInterface$InnerStaticClass... 
Transforming Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerInterface... 
Transforming Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticInterface... 
Transforming Statics$NestedInterface$InnerInterface... 
Transforming Statics$NestedInterface$InnerStaticInterface... 
Transforming Statics$NestedStaticInterface$InnerInterface... 
Transforming Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming Statics$NestedStaticInterface$InnerStaticClass... 
Transforming Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.subp1.SubC1... 
Abc finished on Thu Jun 24 08:16:19 BST 2004. ( 0 min. 21 sec. )
PASS: More thourough test of static members using full names()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 23 seconds
Passed. Current status: 12 failed (check: 0), 68 passed (check: 0), 0 skipped.
Executing test 81 (pureJava): More thourough test of static members using imports
================================================
Breakdown of abc phases  (total: 21706 millisec.)
------------------------------------------------
[ 00.175% ] Init. of Soot:  38
[ 00.018% ] Loading Jars:  4
[ 43.592% ] Polyglot phases:  9462
[ 00.074% ] Resolve class names:  16
[ 01.944% ] Declare Parents:  422
[ 00.184% ] Recompute name pattern matches:  40
[ 00.000% ] Compute precedence relation:  0
[ 00.184% ] Intertype Adjuster:  40
[ 09.173% ] Retrieving bodies:  1991
[ 00.000% ] Weave Initializers:  0
[ 00.106% ] Load shadow types:  23
[ 29.259% ] Compute advice lists:  6351
[ 00.014% ] Intertype weave:  3
[ 00.041% ] Add aspect code:  9
[ 00.111% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 08.744% ] Soot Packs:  1898
[ 06.381% ] Soot Writing Output:  1385
================================================
Abc started on Thu Jun 24 08:16:22 BST 2004
<<<< Statics.java >>>>
public class Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 0);
    
    public static byte b = (byte) 1 + 0;
    
    public static short s = (short) 1 + 0;
    
    public static int i = (int) 1 + 0;
    
    public static long l = (long) 1 + 0;
    
    public static float f = (float) 1 + 0;
    
    public static double d = (double) 1 + 0;
    
    public static char c = (char) '1' + 0;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 0);
        
        public static byte b = (byte) 2 + 0;
        
        public static short s = (short) 2 + 0;
        
        public static int i = (int) 2 + 0;
        
        public static long l = (long) 2 + 0;
        
        public static float f = (float) 2 + 0;
        
        public static double d = (double) 2 + 0;
        
        public static char c = (char) '2' + 0;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 0);
            
            public static byte b = (byte) 3 + 0;
            
            public static short s = (short) 3 + 0;
            
            public static int i = (int) 3 + 0;
            
            public static long l = (long) 3 + 0;
            
            public static float f = (float) 3 + 0;
            
            public static double d = (double) 3 + 0;
            
            public static char c = (char) '3' + 0;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 0);
            
            byte b = (byte) 4 + 0;
            
            short s = (short) 4 + 0;
            
            int i = (int) 4 + 0;
            
            long l = (long) 4 + 0;
            
            float f = (float) 4 + 0;
            
            double d = (double) 4 + 0;
            
            char c = (char) '4' + 0;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 0);
            
            byte b = (byte) 5 + 0;
            
            short s = (short) 5 + 0;
            
            int i = (int) 5 + 0;
            
            long l = (long) 5 + 0;
            
            float f = (float) 5 + 0;
            
            double d = (double) 5 + 0;
            
            char c = (char) '5' + 0;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 0);
            
            byte b = (byte) 6 + 0;
            
            short s = (short) 6 + 0;
            
            int i = (int) 6 + 0;
            
            long l = (long) 6 + 0;
            
            float f = (float) 6 + 0;
            
            double d = (double) 6 + 0;
            
            char c = (char) '6' + 0;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 0);
            
            byte b = (byte) 7 + 0;
            
            short s = (short) 7 + 0;
            
            int i = (int) 7 + 0;
            
            long l = (long) 7 + 0;
            
            float f = (float) 7 + 0;
            
            double d = (double) 7 + 0;
            
            char c = (char) '7' + 0;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 10);
        
        byte b = (byte) 2 + 10;
        
        short s = (short) 2 + 10;
        
        int i = (int) 2 + 10;
        
        long l = (long) 2 + 10;
        
        float f = (float) 2 + 10;
        
        double d = (double) 2 + 10;
        
        char c = (char) '2' + 10;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 10);
            
            public static byte b = (byte) 3 + 10;
            
            public static short s = (short) 3 + 10;
            
            public static int i = (int) 3 + 10;
            
            public static long l = (long) 3 + 10;
            
            public static float f = (float) 3 + 10;
            
            public static double d = (double) 3 + 10;
            
            public static char c = (char) '3' + 10;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 10);
            
            byte b = (byte) 4 + 10;
            
            short s = (short) 4 + 10;
            
            int i = (int) 4 + 10;
            
            long l = (long) 4 + 10;
            
            float f = (float) 4 + 10;
            
            double d = (double) 4 + 10;
            
            char c = (char) '4' + 10;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 10);
            
            byte b = (byte) 5 + 10;
            
            short s = (short) 5 + 10;
            
            int i = (int) 5 + 10;
            
            long l = (long) 5 + 10;
            
            float f = (float) 5 + 10;
            
            double d = (double) 5 + 10;
            
            char c = (char) '5' + 10;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 10);
            
            byte b = (byte) 6 + 10;
            
            short s = (short) 6 + 10;
            
            int i = (int) 6 + 10;
            
            long l = (long) 6 + 10;
            
            float f = (float) 6 + 10;
            
            double d = (double) 6 + 10;
            
            char c = (char) '6' + 10;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 10);
            
            byte b = (byte) 7 + 10;
            
            short s = (short) 7 + 10;
            
            int i = (int) 7 + 10;
            
            long l = (long) 7 + 10;
            
            float f = (float) 7 + 10;
            
            double d = (double) 7 + 10;
            
            char c = (char) '7' + 10;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 20);
        
        byte b = (byte) 2 + 20;
        
        short s = (short) 2 + 20;
        
        int i = (int) 2 + 20;
        
        long l = (long) 2 + 20;
        
        float f = (float) 2 + 20;
        
        double d = (double) 2 + 20;
        
        char c = (char) '2' + 20;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 20);
            
            public static byte b = (byte) 3 + 20;
            
            public static short s = (short) 3 + 20;
            
            public static int i = (int) 3 + 20;
            
            public static long l = (long) 3 + 20;
            
            public static float f = (float) 3 + 20;
            
            public static double d = (double) 3 + 20;
            
            public static char c = (char) '3' + 20;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 20);
            
            byte b = (byte) 4 + 20;
            
            short s = (short) 4 + 20;
            
            int i = (int) 4 + 20;
            
            long l = (long) 4 + 20;
            
            float f = (float) 4 + 20;
            
            double d = (double) 4 + 20;
            
            char c = (char) '4' + 20;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 20);
            
            byte b = (byte) 5 + 20;
            
            short s = (short) 5 + 20;
            
            int i = (int) 5 + 20;
            
            long l = (long) 5 + 20;
            
            float f = (float) 5 + 20;
            
            double d = (double) 5 + 20;
            
            char c = (char) '5' + 20;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 20);
            
            byte b = (byte) 6 + 20;
            
            short s = (short) 6 + 20;
            
            int i = (int) 6 + 20;
            
            long l = (long) 6 + 20;
            
            float f = (float) 6 + 20;
            
            double d = (double) 6 + 20;
            
            char c = (char) '6' + 20;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 20);
            
            byte b = (byte) 7 + 20;
            
            short s = (short) 7 + 20;
            
            int i = (int) 7 + 20;
            
            long l = (long) 7 + 20;
            
            float f = (float) 7 + 20;
            
            double d = (double) 7 + 20;
            
            char c = (char) '7' + 20;
        }
        
    }
    
    
    public Statics() { super(); }
}
<<<< SubC1.java >>>>
package p1.subp1;

public class SubC1 {
    public SubC1() { super(); }
}
<<<< C1.java >>>>
package p1;

public class C1 {
    public C1() { super(); }
}
<<<< StaticMembersImports_PR421.java >>>>
import org.aspectj.testing.*;
import p1.*;
import p1.p2.*;

public class StaticMembersImports_PR421 {
    public static void main(java.lang.String[] args) {
        new StaticMembersImports_PR421().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.b,
                                              (byte) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.s,
                                              (short) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.i,
                                              1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.l,
                                              1 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.f,
                                              (float) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.d,
                                              (double) 1 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics/*Statics*/.c,
                                              '1' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.i,
                                              2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.l,
                                              2 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.d,
                                              (double) (double) 2 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass/*Statics.NestedStaticClass*/.c,
                                              '2' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticClass/*Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterface/*Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterface/*Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    0));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              0L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticClass.InnerInterfaceNoStatics/*Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              0);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.i,
                                              2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.l,
                                              2 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface/*Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticClass/*Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterface/*Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterface/*Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    10));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              10L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedStaticInterface.InnerInterfaceNoStatics/*Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              10);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.i,
                                              2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.l,
                                              2 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface/*Statics.NestedInterface*/.c,
                                              '2' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticClass/*Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterface/*Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterface/*Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerStaticInterfaceNoStatics/*Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    20));
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              20L);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              20);
        org.aspectj.testing.Tester.checkEqual(Statics.NestedInterface.InnerInterfaceNoStatics/*Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              20);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.b,
                                              (byte) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.s,
                                              (short) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.i,
                                              1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.l,
                                              1 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.f,
                                              (float) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.d,
                                              (double) 1 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics/*p1.P1Statics*/.c,
                                              '1' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.i,
                                              2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.l,
                                              2 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.d,
                                              (double) 2 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass/*p1.P1Statics.NestedStaticClass*/.c,
                                              '2' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticClass/*p1.P1Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterface/*p1.P1Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterface/*p1.P1Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    1));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              1L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              1);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.i,
                                              2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.l,
                                              2 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface/*p1.P1Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticClass/*p1.P1Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterface/*p1.P1Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterface/*p1.P1Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    11));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              11L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              11);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.i,
                                              2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.l,
                                              2 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface/*p1.P1Statics.NestedInterface*/.c,
                                              '2' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticClass/*p1.P1Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterface/*p1.P1Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterface/*p1.P1Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    21));
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              21L);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.P1Statics.NestedInterface.InnerInterfaceNoStatics/*p1.P1Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              21);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.I,
                                              new java.lang.Integer(1 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.b,
                                              (byte) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.s,
                                              (short) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.i,
                                              1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.l,
                                              1 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.f,
                                              (float) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.d,
                                              (double) 1 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics/*p1.p2.P1P2Statics*/.c,
                                              '1' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.I,
                                              new java.lang.Integer(2 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.b,
                                              (byte) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.s,
                                              (short) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.i,
                                              2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.l,
                                              2 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.f,
                                              (float) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.d,
                                              (double) 2 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass/*p1.p2.P1P2Statics.NestedStaticClass*/.c,
                                              '2' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.s,
                                              (short) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.i,
                                              3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.l,
                                              3 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.f,
                                              (float) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.d,
                                              (double) 3 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticClass*/.c,
                                              '3' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.i,
                                              4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.l,
                                              4 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterface*/.c,
                                              '4' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.b,
                                              (byte) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.s,
                                              (short) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.i,
                                              5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.l,
                                              5 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.f,
                                              (float) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.d,
                                              (double) 5 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterface/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterface*/.c,
                                              '5' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    2));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              2L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticClass.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              2);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.b,
                                              (byte) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.s,
                                              (short) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.i,
                                              2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.l,
                                              2 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.f,
                                              (float) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.d,
                                              (double) 2 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface*/.c,
                                              '2' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.i,
                                              3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.l,
                                              3 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticClass*/.c,
                                              '3' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.i,
                                              4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.l,
                                              4 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.i,
                                              5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.l,
                                              5 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterface*/.c,
                                              '5' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    12));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              12L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedStaticInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              12);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.I,
                                              new java.lang.Integer(2 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.b,
                                              (byte) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.s,
                                              (short) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.i,
                                              2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.l,
                                              2 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.f,
                                              (float) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.d,
                                              (double) 2 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface/*p1.p2.P1P2Statics.NestedInterface*/.c,
                                              '2' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.I,
                                              new java.lang.Integer(3 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.b,
                                              (byte) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.s,
                                              (short) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.i,
                                              3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.l,
                                              3 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.f,
                                              (float) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.d,
                                              (double) 3 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticClass/*p1.p2.P1P2Statics.NestedInterface.InnerStaticClass*/.c,
                                              '3' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.I,
                                              new java.lang.Integer(4 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.b,
                                              (byte) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.s,
                                              (short) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.i,
                                              4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.l,
                                              4 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.f,
                                              (float) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.d,
                                              (double) 4 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterface*/.c,
                                              '4' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.I,
                                              new java.lang.Integer(5 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.b,
                                              (byte) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.s,
                                              (short) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.i,
                                              5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.l,
                                              5 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.f,
                                              (float) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.d,
                                              (double) 5 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterface/*p1.p2.P1P2Statics.NestedInterface.InnerInterface*/.c,
                                              '5' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.I,
                                              new java.lang.Integer(6 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.b,
                                              (byte) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.s,
                                              (short) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.i,
                                              6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.l,
                                              6 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.f,
                                              (float) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.d,
                                              (double) 6 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerStaticInterfaceNoStatics*/.c,
                                              '6' +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.I,
                                              new java.lang.Integer(7 +
                                                                    22));
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.b,
                                              (byte) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.s,
                                              (short) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.i,
                                              7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.l,
                                              7 +
                                              22L);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.f,
                                              (float) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.d,
                                              (double) 7 +
                                              22);
        org.aspectj.testing.Tester.checkEqual(p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics/*p1.p2.P1P2Statics.NestedInterface.InnerInterfaceNoStatics*/.c,
                                              '7' +
                                              22);
    }
    
    public StaticMembersImports_PR421() { super(); }
}
<<<< P1Statics.java >>>>
package p1;

public class P1Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 1);
    
    public static byte b = (byte) 1 + 1;
    
    public static short s = (short) 1 + 1;
    
    public static int i = (int) 1 + 1;
    
    public static long l = (long) 1 + 1;
    
    public static float f = (float) 1 + 1;
    
    public static double d = (double) 1 + 1;
    
    public static char c = (char) '1' + 1;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 1);
        
        public static byte b = (byte) 2 + 1;
        
        public static short s = (short) 2 + 1;
        
        public static int i = (int) 2 + 1;
        
        public static long l = (long) 2 + 1;
        
        public static float f = (float) 2 + 1;
        
        public static double d = (double) 2 + 1;
        
        public static char c = (char) '2' + 1;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 1);
            
            public static byte b = (byte) 3 + 1;
            
            public static short s = (short) 3 + 1;
            
            public static int i = (int) 3 + 1;
            
            public static long l = (long) 3 + 1;
            
            public static float f = (float) 3 + 1;
            
            public static double d = (double) 3 + 1;
            
            public static char c = (char) '3' + 1;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 1);
            
            byte b = (byte) 4 + 1;
            
            short s = (short) 4 + 1;
            
            int i = (int) 4 + 1;
            
            long l = (long) 4 + 1;
            
            float f = (float) 4 + 1;
            
            double d = (double) 4 + 1;
            
            char c = (char) '4' + 1;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 1);
            
            byte b = (byte) 5 + 1;
            
            short s = (short) 5 + 1;
            
            int i = (int) 5 + 1;
            
            long l = (long) 5 + 1;
            
            float f = (float) 5 + 1;
            
            double d = (double) 5 + 1;
            
            char c = (char) '5' + 1;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 1);
            
            byte b = (byte) 6 + 1;
            
            short s = (short) 6 + 1;
            
            int i = (int) 6 + 1;
            
            long l = (long) 6 + 1;
            
            float f = (float) 6 + 1;
            
            double d = (double) 6 + 1;
            
            char c = (char) '6' + 1;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 1);
            
            byte b = (byte) 7 + 1;
            
            short s = (short) 7 + 1;
            
            int i = (int) 7 + 1;
            
            long l = (long) 7 + 1;
            
            float f = (float) 7 + 1;
            
            double d = (double) 7 + 1;
            
            char c = (char) '7' + 1;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 11);
        
        byte b = (byte) 2 + 11;
        
        short s = (short) 2 + 11;
        
        int i = (int) 2 + 11;
        
        long l = (long) 2 + 11;
        
        float f = (float) 2 + 11;
        
        double d = (double) 2 + 11;
        
        char c = (char) '2' + 11;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 11);
            
            public static byte b = (byte) 3 + 11;
            
            public static short s = (short) 3 + 11;
            
            public static int i = (int) 3 + 11;
            
            public static long l = (long) 3 + 11;
            
            public static float f = (float) 3 + 11;
            
            public static double d = (double) 3 + 11;
            
            public static char c = (char) '3' + 11;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 11);
            
            byte b = (byte) 4 + 11;
            
            short s = (short) 4 + 11;
            
            int i = (int) 4 + 11;
            
            long l = (long) 4 + 11;
            
            float f = (float) 4 + 11;
            
            double d = (double) 4 + 11;
            
            char c = (char) '4' + 11;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 11);
            
            byte b = (byte) 5 + 11;
            
            short s = (short) 5 + 11;
            
            int i = (int) 5 + 11;
            
            long l = (long) 5 + 11;
            
            float f = (float) 5 + 11;
            
            double d = (double) 5 + 11;
            
            char c = (char) '5' + 11;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 11);
            
            byte b = (byte) 6 + 11;
            
            short s = (short) 6 + 11;
            
            int i = (int) 6 + 11;
            
            long l = (long) 6 + 11;
            
            float f = (float) 6 + 11;
            
            double d = (double) 6 + 11;
            
            char c = (char) '6' + 11;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 11);
            
            byte b = (byte) 7 + 11;
            
            short s = (short) 7 + 11;
            
            int i = (int) 7 + 11;
            
            long l = (long) 7 + 11;
            
            float f = (float) 7 + 11;
            
            double d = (double) 7 + 11;
            
            char c = (char) '7' + 11;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 21);
        
        byte b = (byte) 2 + 21;
        
        short s = (short) 2 + 21;
        
        int i = (int) 2 + 21;
        
        long l = (long) 2 + 21;
        
        float f = (float) 2 + 21;
        
        double d = (double) 2 + 21;
        
        char c = (char) '2' + 21;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 21);
            
            public static byte b = (byte) 3 + 21;
            
            public static short s = (short) 3 + 21;
            
            public static int i = (int) 3 + 21;
            
            public static long l = (long) 3 + 21;
            
            public static float f = (float) 3 + 21;
            
            public static double d = (double) 3 + 21;
            
            public static char c = (char) '3' + 21;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 21);
            
            byte b = (byte) 4 + 21;
            
            short s = (short) 4 + 21;
            
            int i = (int) 4 + 21;
            
            long l = (long) 4 + 21;
            
            float f = (float) 4 + 21;
            
            double d = (double) 4 + 21;
            
            char c = (char) '4' + 21;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 21);
            
            byte b = (byte) 5 + 21;
            
            short s = (short) 5 + 21;
            
            int i = (int) 5 + 21;
            
            long l = (long) 5 + 21;
            
            float f = (float) 5 + 21;
            
            double d = (double) 5 + 21;
            
            char c = (char) '5' + 21;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 21);
            
            byte b = (byte) 6 + 21;
            
            short s = (short) 6 + 21;
            
            int i = (int) 6 + 21;
            
            long l = (long) 6 + 21;
            
            float f = (float) 6 + 21;
            
            double d = (double) 6 + 21;
            
            char c = (char) '6' + 21;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 21);
            
            byte b = (byte) 7 + 21;
            
            short s = (short) 7 + 21;
            
            int i = (int) 7 + 21;
            
            long l = (long) 7 + 21;
            
            float f = (float) 7 + 21;
            
            double d = (double) 7 + 21;
            
            char c = (char) '7' + 21;
        }
        
    }
    
    
    public P1Statics() { super(); }
}
<<<< P1P2Statics.java >>>>
package p1.p2;

public class P1P2Statics {
    public static java.lang.Integer I = new java.lang.Integer(1 + 2);
    
    public static byte b = (byte) 1 + 2;
    
    public static short s = (short) 1 + 2;
    
    public static int i = (int) 1 + 2;
    
    public static long l = (long) 1 + 2;
    
    public static float f = (float) 1 + 2;
    
    public static double d = (double) 1 + 2;
    
    public static char c = (char) '1' + 2;
    
    public static class NestedStaticClass {
        public static java.lang.Integer I =
          new java.lang.Integer(2 + 2);
        
        public static byte b = (byte) 2 + 2;
        
        public static short s = (short) 2 + 2;
        
        public static int i = (int) 2 + 2;
        
        public static long l = (long) 2 + 2;
        
        public static float f = (float) 2 + 2;
        
        public static double d = (double) 2 + 2;
        
        public static char c = (char) '2' + 2;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 2);
            
            public static byte b = (byte) 3 + 2;
            
            public static short s = (short) 3 + 2;
            
            public static int i = (int) 3 + 2;
            
            public static long l = (long) 3 + 2;
            
            public static float f = (float) 3 + 2;
            
            public static double d = (double) 3 + 2;
            
            public static char c = (char) '3' + 2;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 2);
            
            byte b = (byte) 4 + 2;
            
            short s = (short) 4 + 2;
            
            int i = (int) 4 + 2;
            
            long l = (long) 4 + 2;
            
            float f = (float) 4 + 2;
            
            double d = (double) 4 + 2;
            
            char c = (char) '4' + 2;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 2);
            
            byte b = (byte) 5 + 2;
            
            short s = (short) 5 + 2;
            
            int i = (int) 5 + 2;
            
            long l = (long) 5 + 2;
            
            float f = (float) 5 + 2;
            
            double d = (double) 5 + 2;
            
            char c = (char) '5' + 2;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 2);
            
            byte b = (byte) 6 + 2;
            
            short s = (short) 6 + 2;
            
            int i = (int) 6 + 2;
            
            long l = (long) 6 + 2;
            
            float f = (float) 6 + 2;
            
            double d = (double) 6 + 2;
            
            char c = (char) '6' + 2;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 2);
            
            byte b = (byte) 7 + 2;
            
            short s = (short) 7 + 2;
            
            int i = (int) 7 + 2;
            
            long l = (long) 7 + 2;
            
            float f = (float) 7 + 2;
            
            double d = (double) 7 + 2;
            
            char c = (char) '7' + 2;
        }
        
        
        public NestedStaticClass() { super(); }
    }
    
    
    public static interface NestedStaticInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 12);
        
        byte b = (byte) 2 + 12;
        
        short s = (short) 2 + 12;
        
        int i = (int) 2 + 12;
        
        long l = (long) 2 + 12;
        
        float f = (float) 2 + 12;
        
        double d = (double) 2 + 12;
        
        char c = (char) '2' + 12;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 12);
            
            public static byte b = (byte) 3 + 12;
            
            public static short s = (short) 3 + 12;
            
            public static int i = (int) 3 + 12;
            
            public static long l = (long) 3 + 12;
            
            public static float f = (float) 3 + 12;
            
            public static double d = (double) 3 + 12;
            
            public static char c = (char) '3' + 12;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 12);
            
            byte b = (byte) 4 + 12;
            
            short s = (short) 4 + 12;
            
            int i = (int) 4 + 12;
            
            long l = (long) 4 + 12;
            
            float f = (float) 4 + 12;
            
            double d = (double) 4 + 12;
            
            char c = (char) '4' + 12;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 12);
            
            byte b = (byte) 5 + 12;
            
            short s = (short) 5 + 12;
            
            int i = (int) 5 + 12;
            
            long l = (long) 5 + 12;
            
            float f = (float) 5 + 12;
            
            double d = (double) 5 + 12;
            
            char c = (char) '5' + 12;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 12);
            
            byte b = (byte) 6 + 12;
            
            short s = (short) 6 + 12;
            
            int i = (int) 6 + 12;
            
            long l = (long) 6 + 12;
            
            float f = (float) 6 + 12;
            
            double d = (double) 6 + 12;
            
            char c = (char) '6' + 12;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 12);
            
            byte b = (byte) 7 + 12;
            
            short s = (short) 7 + 12;
            
            int i = (int) 7 + 12;
            
            long l = (long) 7 + 12;
            
            float f = (float) 7 + 12;
            
            double d = (double) 7 + 12;
            
            char c = (char) '7' + 12;
        }
        
    }
    
    
    public static interface NestedInterface {
        java.lang.Integer I = new java.lang.Integer(2 + 22);
        
        byte b = (byte) 2 + 22;
        
        short s = (short) 2 + 22;
        
        int i = (int) 2 + 22;
        
        long l = (long) 2 + 22;
        
        float f = (float) 2 + 22;
        
        double d = (double) 2 + 22;
        
        char c = (char) '2' + 22;
        
        public static class InnerStaticClass {
            public static java.lang.Integer I =
              new java.lang.Integer(3 + 22);
            
            public static byte b = (byte) 3 + 22;
            
            public static short s = (short) 3 + 22;
            
            public static int i = (int) 3 + 22;
            
            public static long l = (long) 3 + 22;
            
            public static float f = (float) 3 + 22;
            
            public static double d = (double) 3 + 22;
            
            public static char c = (char) '3' + 22;
            
            public InnerStaticClass() { super(); }
        }
        
        
        public static interface InnerStaticInterface {
            java.lang.Integer I = new java.lang.Integer(4 + 22);
            
            byte b = (byte) 4 + 22;
            
            short s = (short) 4 + 22;
            
            int i = (int) 4 + 22;
            
            long l = (long) 4 + 22;
            
            float f = (float) 4 + 22;
            
            double d = (double) 4 + 22;
            
            char c = (char) '4' + 22;
        }
        
        
        public static interface InnerInterface {
            java.lang.Integer I = new java.lang.Integer(5 + 22);
            
            byte b = (byte) 5 + 22;
            
            short s = (short) 5 + 22;
            
            int i = (int) 5 + 22;
            
            long l = (long) 5 + 22;
            
            float f = (float) 5 + 22;
            
            double d = (double) 5 + 22;
            
            char c = (char) '5' + 22;
        }
        
        
        public static interface InnerStaticInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(6 + 22);
            
            byte b = (byte) 6 + 22;
            
            short s = (short) 6 + 22;
            
            int i = (int) 6 + 22;
            
            long l = (long) 6 + 22;
            
            float f = (float) 6 + 22;
            
            double d = (double) 6 + 22;
            
            char c = (char) '6' + 22;
        }
        
        
        public static interface InnerInterfaceNoStatics {
            java.lang.Integer I = new java.lang.Integer(7 + 22);
            
            byte b = (byte) 7 + 22;
            
            short s = (short) 7 + 22;
            
            int i = (int) 7 + 22;
            
            long l = (long) 7 + 22;
            
            float f = (float) 7 + 22;
            
            double d = (double) 7 + 22;
            
            char c = (char) '7' + 22;
        }
        
    }
    
    
    public P1P2Statics() { super(); }
}
retrieve <Statics: void <init>()> from Statics
retrieve <Statics: void <clinit>()> from Statics
retrieve <Statics$NestedStaticClass: void <init>()> from Statics$NestedStaticClass
retrieve <Statics$NestedStaticClass: void <clinit>()> from Statics$NestedStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticClass: void <init>()> from Statics$NestedStaticClass$InnerStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from Statics$NestedStaticClass$InnerStaticClass
retrieve <Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from Statics$NestedStaticClass$InnerStaticInterface
retrieve <Statics$NestedStaticClass$InnerInterface: void <clinit>()> from Statics$NestedStaticClass$InnerInterface
retrieve <Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <Statics$NestedStaticInterface: void <clinit>()> from Statics$NestedStaticInterface
retrieve <Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from Statics$NestedStaticInterface$InnerStaticClass
retrieve <Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticClass
retrieve <Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticInterface
retrieve <Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from Statics$NestedStaticInterface$InnerInterface
retrieve <Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <Statics$NestedInterface: void <clinit>()> from Statics$NestedInterface
retrieve <Statics$NestedInterface$InnerStaticClass: void <init>()> from Statics$NestedInterface$InnerStaticClass
retrieve <Statics$NestedInterface$InnerStaticClass: void <clinit>()> from Statics$NestedInterface$InnerStaticClass
retrieve <Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from Statics$NestedInterface$InnerStaticInterface
retrieve <Statics$NestedInterface$InnerInterface: void <clinit>()> from Statics$NestedInterface$InnerInterface
retrieve <Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from Statics$NestedInterface$InnerInterfaceNoStatics
retrieve <p1.subp1.SubC1: void <init>()> from p1.subp1.SubC1
retrieve <p1.C1: void <init>()> from p1.C1
retrieve <StaticMembersImports_PR421: void realMain(java.lang.String[])> from StaticMembersImports_PR421
retrieve <StaticMembersImports_PR421: void <init>()> from StaticMembersImports_PR421
retrieve <StaticMembersImports_PR421: void main(java.lang.String[])> from StaticMembersImports_PR421
retrieve <p1.P1Statics: void <init>()> from p1.P1Statics
retrieve <p1.P1Statics: void <clinit>()> from p1.P1Statics
retrieve <p1.P1Statics$NestedStaticClass: void <init>()> from p1.P1Statics$NestedStaticClass
retrieve <p1.P1Statics$NestedStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticClass: void <init>()> from p1.P1Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticInterface
retrieve <p1.P1Statics$NestedStaticClass$InnerInterface: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerInterface
retrieve <p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from p1.P1Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerInterface
retrieve <p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <p1.P1Statics$NestedInterface: void <clinit>()> from p1.P1Statics$NestedInterface
retrieve <p1.P1Statics$NestedInterface$InnerStaticClass: void <init>()> from p1.P1Statics$NestedInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedInterface$InnerStaticClass: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticClass
retrieve <p1.P1Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticInterface
retrieve <p1.P1Statics$NestedInterface$InnerInterface: void <clinit>()> from p1.P1Statics$NestedInterface$InnerInterface
retrieve <p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <p1.P1Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.P1Statics$NestedInterface$InnerInterfaceNoStatics
retrieve <p1.p2.P1P2Statics: void <init>()> from p1.p2.P1P2Statics
retrieve <p1.p2.P1P2Statics: void <clinit>()> from p1.p2.P1P2Statics
retrieve <p1.p2.P1P2Statics$NestedStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticClass: void <init>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticClass: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticClass
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerInterface: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerInterface
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics
retrieve <p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics: void <clinit>()> from p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics
Transforming p1.p2.P1P2Statics... 
Transforming p1.p2.P1P2Statics$NestedStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerStaticInterface... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerInterface... 
Transforming p1.p2.P1P2Statics$NestedStaticInterface$InnerStaticClass... 
Transforming p1.p2.P1P2Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming p1.p2.P1P2Statics$NestedInterface$InnerStaticClass... 
Transforming p1.P1Statics... 
Transforming p1.P1Statics$NestedStaticClass... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticInterface... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticInterface... 
Transforming p1.P1Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming p1.P1Statics$NestedInterface... 
Transforming p1.P1Statics$NestedInterface$InnerStaticClass... 
Transforming p1.P1Statics$NestedStaticClass$InnerInterface... 
Transforming p1.P1Statics$NestedInterface$InnerInterface... 
Transforming p1.P1Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticClass... 
Transforming p1.P1Statics$NestedStaticInterface$InnerInterface... 
Transforming p1.P1Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming p1.P1Statics$NestedInterface$InnerStaticInterface... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming p1.P1Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming StaticMembersImports_PR421... 
Transforming Statics... 
Transforming Statics$NestedInterface... 
Transforming Statics$NestedInterface$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticClass... 
Transforming Statics$NestedStaticClass$InnerStaticInterface... 
Transforming Statics$NestedInterface$InnerStaticClass... 
Transforming Statics$NestedStaticClass$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerInterface... 
Transforming Statics$NestedInterface$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticInterface... 
Transforming Statics$NestedInterface$InnerInterface... 
Transforming Statics$NestedInterface$InnerStaticInterface... 
Transforming Statics$NestedStaticInterface$InnerInterface... 
Transforming Statics$NestedStaticInterface$InnerStaticInterface... 
Transforming Statics$NestedStaticInterface$InnerStaticClass... 
Transforming Statics$NestedStaticInterface$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticInterface$InnerInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerStaticInterfaceNoStatics... 
Transforming Statics$NestedStaticClass$InnerStaticClass... 
Transforming p1.C1... 
Transforming p1.subp1.SubC1... 
Abc finished on Thu Jun 24 08:16:44 BST 2004. ( 0 min. 21 sec. )
PASS: More thourough test of static members using imports()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 23 seconds
Passed. Current status: 12 failed (check: 0), 69 passed (check: 0), 0 skipped.
Executing test 82 (pureJava/conflictingPackageNames): Looking in class Java for java.lang.String WITH separate compilation
================================================
Breakdown of abc phases  (total: 6747 millisec.)
------------------------------------------------
[ 00.548% ] Init. of Soot:  37
[ 00.044% ] Loading Jars:  3
[ 77.397% ] Polyglot phases:  5222
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.726% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.608% ] Intertype Adjuster:  41
[ 13.058% ] Retrieving bodies:  881
[ 00.000% ] Weave Initializers:  0
[ 00.341% ] Load shadow types:  23
[ 00.904% ] Compute advice lists:  61
[ 00.044% ] Intertype weave:  3
[ 00.133% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.053% ] Soot Packs:  206
[ 02.935% ] Soot Writing Output:  198
================================================
================================================
Breakdown of abc phases  (total: 3557 millisec.)
------------------------------------------------
[ 00.000% ] Init. of Soot:  0
[ 00.000% ] Loading Jars:  0
[ 91.397% ] Polyglot phases:  3251
[ 00.000% ] Resolve class names:  0
[ 00.000% ] Declare Parents:  0
[ 00.984% ] Recompute name pattern matches:  35
[ 00.028% ] Compute precedence relation:  1
[ 00.309% ] Intertype Adjuster:  11
[ 00.675% ] Retrieving bodies:  24
[ 00.000% ] Weave Initializers:  0
[ 00.000% ] Load shadow types:  0
[ 04.948% ] Compute advice lists:  176
[ 00.000% ] Intertype weave:  0
[ 00.000% ] Add aspect code:  0
[ 00.028% ] Weaving advice:  1
[ 00.000% ] Validate jimple:  0
[ 01.012% ] Soot Packs:  36
[ 00.618% ] Soot Writing Output:  22
================================================
Abc started on Thu Jun 24 08:16:46 BST 2004
<<<< Java.java >>>>
public class Java {
    public java.lang.String lang() {
        throw new java.lang.RuntimeException("String lang(): shouldn\'t have been called");
    }
    
    public static class lang {
        public static class String {
            public String() {
                super();
                throw new java.lang.RuntimeException("new String(): shouldn\'t have been called");
            }
        }
        
        
        static Java.lang.String String() { return null; }
        
        public lang() { super(); }
    }
    
    
    public Java() { super(); }
}
retrieve <Java: java.lang.String lang()> from Java
retrieve <Java: void <init>()> from Java
retrieve <Java$lang: void <init>()> from Java$lang
retrieve <Java$lang: Java$lang$String String()> from Java$lang
retrieve <Java$lang$String: void <init>()> from Java$lang$String
Transforming Java... 
Transforming Java$lang... 
Transforming Java$lang$String... 
Abc finished on Thu Jun 24 08:16:53 BST 2004. ( 0 min. 6 sec. )
Abc started on Thu Jun 24 08:16:53 BST 2004
<<<< Main.java >>>>
import org.aspectj.testing.*;

public class Main {
    public static void main(java.lang.String[] args) {
        new Main().go();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void go() {
        java.lang.String str0 = new java.lang.String("String:String");
        java.lang.String str1 =
          new java.lang.String("java.lang.String:String");
        java.lang.String str2 =
          new java.lang.String("String:java.lang.String");
        java.lang.String str3 =
          new java.lang.String("String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str0, "String:String");
        org.aspectj.testing.Tester.checkEqual(str1,
                                              "java.lang.String:String");
        org.aspectj.testing.Tester.checkEqual(str2,
                                              "String:java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str3,
                                              "String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.event("Driver.go");
    }
    
    static { org.aspectj.testing.Tester.expectEvent("Driver.go"); }
    
    public Main() { super(); }
}
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void go()> from Main
retrieve <Main: void <init>()> from Main
retrieve <Main: void <clinit>()> from Main
Transforming Main... 
Abc finished on Thu Jun 24 08:16:57 BST 2004. ( 0 min. 3 sec. )
PASS: Looking in class Java for java.lang.String WITH separate compilation()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 12 failed (check: 0), 70 passed (check: 0), 0 skipped.
Executing test 83 (pureJava/conflictingPackageNames): Looking in class Java for java.lang.String WITHOUT separate compilation
================================================
Breakdown of abc phases  (total: 8043 millisec.)
------------------------------------------------
[ 00.485% ] Init. of Soot:  39
[ 00.037% ] Loading Jars:  3
[ 77.409% ] Polyglot phases:  6226
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.696% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 05.856% ] Intertype Adjuster:  471
[ 06.366% ] Retrieving bodies:  512
[ 00.000% ] Weave Initializers:  0
[ 00.274% ] Load shadow types:  22
[ 03.034% ] Compute advice lists:  244
[ 00.050% ] Intertype weave:  4
[ 00.099% ] Add aspect code:  8
[ 00.162% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.710% ] Soot Packs:  218
[ 02.797% ] Soot Writing Output:  225
================================================
Abc started on Thu Jun 24 08:16:59 BST 2004
<<<< Main.java >>>>
import org.aspectj.testing.*;

public class Main {
    public static void main(java.lang.String[] args) {
        new Main().go();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void go() {
        java.lang.String str0 = new java.lang.String("String:String");
        java.lang.String str1 =
          new java.lang.String("java.lang.String:String");
        java.lang.String str2 =
          new java.lang.String("String:java.lang.String");
        java.lang.String str3 =
          new java.lang.String("String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str0, "String:String");
        org.aspectj.testing.Tester.checkEqual(str1,
                                              "java.lang.String:String");
        org.aspectj.testing.Tester.checkEqual(str2,
                                              "String:java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str3,
                                              "String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.event("Driver.go");
    }
    
    static { org.aspectj.testing.Tester.expectEvent("Driver.go"); }
    
    public Main() { super(); }
}
<<<< Java.java >>>>
public class Java {
    public java.lang.String lang() {
        throw new java.lang.RuntimeException("String lang(): shouldn\'t have been called");
    }
    
    public static class lang {
        public static class String {
            public String() {
                super();
                throw new java.lang.RuntimeException("new String(): shouldn\'t have been called");
            }
        }
        
        
        static Java.lang.String String() { return null; }
        
        public lang() { super(); }
    }
    
    
    public Java() { super(); }
}
retrieve <Main: void go()> from Main
retrieve <Main: void <init>()> from Main
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void <clinit>()> from Main
retrieve <Java: java.lang.String lang()> from Java
retrieve <Java: void <init>()> from Java
retrieve <Java$lang: void <init>()> from Java$lang
retrieve <Java$lang: Java$lang$String String()> from Java$lang
retrieve <Java$lang$String: void <init>()> from Java$lang$String
Transforming Java... 
Transforming Java$lang... 
Transforming Java$lang$String... 
Transforming Main... 
Abc finished on Thu Jun 24 08:17:07 BST 2004. ( 0 min. 8 sec. )
PASS: Looking in class Java for java.lang.String WITHOUT separate compilation()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 71 passed (check: 0), 0 skipped.
Executing test 84 (pureJava/conflictingPackageNamesWithPackages): Looking in class Java for java.lang.String WITH separate compilation with packages
================================================
Breakdown of abc phases  (total: 6881 millisec.)
------------------------------------------------
[ 00.552% ] Init. of Soot:  38
[ 00.044% ] Loading Jars:  3
[ 77.314% ] Polyglot phases:  5320
[ 00.000% ] Resolve class names:  0
[ 00.160% ] Declare Parents:  11
[ 00.436% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 00.581% ] Intertype Adjuster:  40
[ 13.574% ] Retrieving bodies:  934
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  22
[ 00.857% ] Compute advice lists:  59
[ 00.044% ] Intertype weave:  3
[ 00.131% ] Add aspect code:  9
[ 00.174% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.892% ] Soot Packs:  199
[ 02.921% ] Soot Writing Output:  201
================================================
================================================
Breakdown of abc phases  (total: 3531 millisec.)
------------------------------------------------
[ 00.000% ] Init. of Soot:  0
[ 00.000% ] Loading Jars:  0
[ 91.815% ] Polyglot phases:  3242
[ 00.000% ] Resolve class names:  0
[ 00.000% ] Declare Parents:  0
[ 00.963% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.340% ] Intertype Adjuster:  12
[ 00.680% ] Retrieving bodies:  24
[ 00.000% ] Weave Initializers:  0
[ 00.000% ] Load shadow types:  0
[ 04.786% ] Compute advice lists:  169
[ 00.000% ] Intertype weave:  0
[ 00.000% ] Add aspect code:  0
[ 00.000% ] Weaving advice:  0
[ 00.000% ] Validate jimple:  0
[ 00.793% ] Soot Packs:  28
[ 00.623% ] Soot Writing Output:  22
================================================
Abc started on Thu Jun 24 08:17:10 BST 2004
<<<< Java.java >>>>
package conflictingPackageNamesWithPackages;

public class Java {
    public java.lang.String lang() {
        throw new java.lang.RuntimeException("String lang(): shouldn\'t have been called");
    }
    
    public static class lang {
        public static class String {
            public String() {
                super();
                throw new java.lang.RuntimeException("new String(): shouldn\'t have been called");
            }
        }
        
        
        static conflictingPackageNamesWithPackages.Java.lang.String String() {
            return null;
        }
        
        public lang() { super(); }
    }
    
    
    public Java() { super(); }
}
retrieve <conflictingPackageNamesWithPackages.Java: java.lang.String lang()> from conflictingPackageNamesWithPackages.Java
retrieve <conflictingPackageNamesWithPackages.Java: void <init>()> from conflictingPackageNamesWithPackages.Java
retrieve <conflictingPackageNamesWithPackages.Java$lang: conflictingPackageNamesWithPackages.Java$lang$String String()> from conflictingPackageNamesWithPackages.Java$lang
retrieve <conflictingPackageNamesWithPackages.Java$lang: void <init>()> from conflictingPackageNamesWithPackages.Java$lang
retrieve <conflictingPackageNamesWithPackages.Java$lang$String: void <init>()> from conflictingPackageNamesWithPackages.Java$lang$String
Transforming conflictingPackageNamesWithPackages.Java... 
Transforming conflictingPackageNamesWithPackages.Java$lang... 
Transforming conflictingPackageNamesWithPackages.Java$lang$String... 
Abc finished on Thu Jun 24 08:17:17 BST 2004. ( 0 min. 6 sec. )
Abc started on Thu Jun 24 08:17:17 BST 2004
<<<< Main.java >>>>
package conflictingPackageNamesWithPackages;

import org.aspectj.testing.*;

public class Main {
    public static void main(java.lang.String[] args) {
        new conflictingPackageNamesWithPackages.Main().go();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void go() {
        java.lang.String str0 = new java.lang.String("String:String");
        java.lang.String str1 =
          new java.lang.String("java.lang.String:String");
        java.lang.String str2 =
          new java.lang.String("String:java.lang.String");
        java.lang.String str3 =
          new java.lang.String("String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str0, "String:String");
        org.aspectj.testing.Tester.checkEqual(str1,
                                              "java.lang.String:String");
        org.aspectj.testing.Tester.checkEqual(str2,
                                              "String:java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str3,
                                              "String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.event("Driver.go");
    }
    
    static { org.aspectj.testing.Tester.expectEvent("Driver.go"); }
    
    public Main() { super(); }
}
retrieve <conflictingPackageNamesWithPackages.Main: void main(java.lang.String[])> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void go()> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void <init>()> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void <clinit>()> from conflictingPackageNamesWithPackages.Main
Transforming conflictingPackageNamesWithPackages.Main... 
Abc finished on Thu Jun 24 08:17:20 BST 2004. ( 0 min. 3 sec. )
PASS: Looking in class Java for java.lang.String WITH separate compilation wit...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 12 failed (check: 0), 72 passed (check: 0), 0 skipped.
Executing test 85 (pureJava/conflictingPackageNamesWithPackages): Looking in class Java for java.lang.String WITHOUT separate compilation with packages
================================================
Breakdown of abc phases  (total: 7777 millisec.)
------------------------------------------------
[ 00.489% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 76.726% ] Polyglot phases:  5967
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.656% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 06.211% ] Intertype Adjuster:  483
[ 06.596% ] Retrieving bodies:  513
[ 00.000% ] Weave Initializers:  0
[ 00.296% ] Load shadow types:  23
[ 02.867% ] Compute advice lists:  223
[ 00.039% ] Intertype weave:  3
[ 00.103% ] Add aspect code:  8
[ 00.167% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.855% ] Soot Packs:  222
[ 02.932% ] Soot Writing Output:  228
================================================
Abc started on Thu Jun 24 08:17:23 BST 2004
<<<< Main.java >>>>
package conflictingPackageNamesWithPackages;

import org.aspectj.testing.*;

public class Main {
    public static void main(java.lang.String[] args) {
        new conflictingPackageNamesWithPackages.Main().go();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void go() {
        java.lang.String str0 = new java.lang.String("String:String");
        java.lang.String str1 =
          new java.lang.String("java.lang.String:String");
        java.lang.String str2 =
          new java.lang.String("String:java.lang.String");
        java.lang.String str3 =
          new java.lang.String("String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str0, "String:String");
        org.aspectj.testing.Tester.checkEqual(str1,
                                              "java.lang.String:String");
        org.aspectj.testing.Tester.checkEqual(str2,
                                              "String:java.lang.String");
        org.aspectj.testing.Tester.checkEqual(str3,
                                              "String:java.lang.java.lang.String");
        org.aspectj.testing.Tester.event("Driver.go");
    }
    
    static { org.aspectj.testing.Tester.expectEvent("Driver.go"); }
    
    public Main() { super(); }
}
<<<< Java.java >>>>
package conflictingPackageNamesWithPackages;

public class Java {
    public java.lang.String lang() {
        throw new java.lang.RuntimeException("String lang(): shouldn\'t have been called");
    }
    
    public static class lang {
        public static class String {
            public String() {
                super();
                throw new java.lang.RuntimeException("new String(): shouldn\'t have been called");
            }
        }
        
        
        static conflictingPackageNamesWithPackages.Java.lang.String String() {
            return null;
        }
        
        public lang() { super(); }
    }
    
    
    public Java() { super(); }
}
retrieve <conflictingPackageNamesWithPackages.Main: void main(java.lang.String[])> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void go()> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void <init>()> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Main: void <clinit>()> from conflictingPackageNamesWithPackages.Main
retrieve <conflictingPackageNamesWithPackages.Java: java.lang.String lang()> from conflictingPackageNamesWithPackages.Java
retrieve <conflictingPackageNamesWithPackages.Java: void <init>()> from conflictingPackageNamesWithPackages.Java
retrieve <conflictingPackageNamesWithPackages.Java$lang: void <init>()> from conflictingPackageNamesWithPackages.Java$lang
retrieve <conflictingPackageNamesWithPackages.Java$lang: conflictingPackageNamesWithPackages.Java$lang$String String()> from conflictingPackageNamesWithPackages.Java$lang
retrieve <conflictingPackageNamesWithPackages.Java$lang$String: void <init>()> from conflictingPackageNamesWithPackages.Java$lang$String
Transforming conflictingPackageNamesWithPackages.Main... 
Transforming conflictingPackageNamesWithPackages.Java... 
Transforming conflictingPackageNamesWithPackages.Java$lang... 
Transforming conflictingPackageNamesWithPackages.Java$lang$String... 
Abc finished on Thu Jun 24 08:17:31 BST 2004. ( 0 min. 7 sec. )
PASS: Looking in class Java for java.lang.String WITHOUT separate compilation ...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 73 passed (check: 0), 0 skipped.
Executing test 86 (pureJava): Testing ternary operations.
================================================
Breakdown of abc phases  (total: 24453 millisec.)
------------------------------------------------
[ 00.155% ] Init. of Soot:  38
[ 00.012% ] Loading Jars:  3
[ 55.048% ] Polyglot phases:  13461
[ 00.000% ] Resolve class names:  0
[ 00.008% ] Declare Parents:  2
[ 00.192% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.159% ] Intertype Adjuster:  39
[ 18.578% ] Retrieving bodies:  4543
[ 00.000% ] Weave Initializers:  0
[ 00.094% ] Load shadow types:  23
[ 03.930% ] Compute advice lists:  961
[ 00.012% ] Intertype weave:  3
[ 00.033% ] Add aspect code:  8
[ 00.053% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 12.763% ] Soot Packs:  3121
[ 08.960% ] Soot Writing Output:  2191
================================================
Abc started on Thu Jun 24 08:17:33 BST 2004
<<<< MultiTernaryOps.java >>>>
import org.aspectj.testing.*;

public class MultiTernaryOps {
    public static void main(java.lang.String[] args) {
        new MultiTernaryOps().realMain(args);
    }
    
    int c = 0;
    
    int z = 0;
    
    public void realMain(java.lang.String[] args) {
        int SIZE = 1000;
        int[] xs = new int[SIZE];
        boolean b = true;
        int e = 123;
        java.lang.Object o = null;
        java.lang.Object ot = new MultiTernaryOps.t();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : 2);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? 2 : 1);
        e();
        c(2);
        xs[this/*null*/.c++] = (t(0) ? (f(1) ? 2 : 1) : 3);
        e();
        c(2);
        xs[this/*null*/.c++] = (t(0) ? (f(1) ? 2 : 1) : 3);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? (x() ? 2 : 3) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? (x() ? 2 : 3) : 1);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : 3) : 4);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : 3) : 4);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : 3) : 4);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? 2 : 3) : 1) : 4);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? 2 : 3) : 1) : 4);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? 2 : 3) : 1) : 4);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? 2 : 1) : 3) : 4);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? 2 : 1) : 3) : 4);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? 2 : 1) : 3) : 4);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (t(3) ? 1 : 2) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (t(3) ? 1 : 2) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (t(3) ? 1 : 2) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (t(3) ? 1 : 2) : 3) : 4) : 5);
        e();
        c(1);
        xs[this/*null*/.c++] =
          (f(0) ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] =
          (f(0) ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] =
          (f(0) ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c(1);
        xs[this/*null*/.c++] =
          (f(0) ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? (f(1) ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (f(2) ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (f(3) ? 2 : 1) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (f(3) ? 2 : 1) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (f(3) ? 2 : 1) : 3) : 4) : 5);
        e();
        c(4);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? (f(3) ? 2 : 1) : 3) : 4) : 5);
        e();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : (x() ? 2 : 3));
        e();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : (x() ? 2 : 3));
        e();
        c(2);
        xs[this/*null*/.c++] = (f(0) ? 2 : (t(1) ? 1 : 3));
        e();
        c(2);
        xs[this/*null*/.c++] = (f(0) ? 2 : (t(1) ? 1 : 3));
        e();
        c(2);
        xs[this/*null*/.c++] = (f(0) ? 2 : (f(1) ? 3 : 1));
        e();
        c(2);
        xs[this/*null*/.c++] = (f(0) ? 2 : (f(1) ? 3 : 1));
        e();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c(1);
        xs[this/*null*/.c++] = (t(0) ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (t(1) ? 1 : (x() ? 3 : 4)));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (t(1) ? 1 : (x() ? 3 : 4)));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (t(1) ? 1 : (x() ? 3 : 4)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (t(2) ? 1 : 4)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (t(2) ? 1 : 4)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (t(2) ? 1 : 4)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (f(2) ? 4 : 1)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (f(2) ? 4 : 1)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (f(0) ? 2 : (f(1) ? 3 : (f(2) ? 4 : 1)));
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(3);
        xs[this/*null*/.c++] =
          (t(0) ? (t(1) ? (t(2) ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : 2);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? 2 : 3) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? 2 : 3) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 2 : 3) : 1) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 2 : 3) : 1) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 2 : 3) : 1) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? (x() ? (x() ? (x() ? 5 : 2) : 3) : 4) : 1);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? (x() ? 4 : 2) : 3) : 1) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? (x() ? 3 : 2) : 1) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (o instanceof MultiTernaryOps.t ? 2 : 1) : 3) : 4) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 2 : 3));
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 2 : 3));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (ot instanceof MultiTernaryOps.t ? 1 : 3));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (ot instanceof MultiTernaryOps.t ? 1 : 3));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : 1));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : 1));
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 2 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (ot instanceof MultiTernaryOps.t ? 1 : (x() ? 3 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (ot instanceof MultiTernaryOps.t ? 1 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (ot instanceof MultiTernaryOps.t ? 1 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (ot instanceof MultiTernaryOps.t ? 1 : 4)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (o instanceof MultiTernaryOps.t ? 4 : 1)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (o instanceof MultiTernaryOps.t ? 4 : 1)));
        e();
        c();
        xs[this/*null*/.c++] =
          (o instanceof MultiTernaryOps.t ? 2 : (o instanceof MultiTernaryOps.t ? 3 : (o instanceof MultiTernaryOps.t ? 4 : 1)));
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c();
        xs[this/*null*/.c++] =
          (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? (ot instanceof MultiTernaryOps.t ? 1 : 2) : (x() ? 3 : 4)) : 5);
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z += (t(0) ? 1 : 9));
        e();
        c(1, 2);
        xs[this/*null*/.c++] = (this/*null*/.z -= (t(0) ? 1 : 9));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z *= (t(0) ? 1 : 9));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z /= (t(0) ? 1 : 9));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z &= (t(0) ? 1 : 9));
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z |= (t(0) ? 1 : 9));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z ^= (t(0) ? 2 : 9));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z %= (t(0) ? 2 : 9));
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z <<= (t(0) ? 1 : 9));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z >>= (t(0) ? 1 : 9));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z >>>= (t(0) ? 1 : 0));
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z += (f(0) ? 9 : 1));
        e();
        c(1, 2);
        xs[this/*null*/.c++] = (this/*null*/.z -= (f(0) ? 9 : 1));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z *= (f(0) ? 9 : 1));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z /= (f(0) ? 9 : 1));
        e();
        c(1, 1);
        xs[this/*null*/.c++] = (this/*null*/.z &= (f(0) ? 9 : 1));
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z |= (f(0) ? 9 : 1));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z ^= (f(0) ? 9 : 2));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z %= (f(0) ? 9 : 2));
        e();
        c(1, 0);
        xs[this/*null*/.c++] = (this/*null*/.z <<= (f(0) ? 9 : 1));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z >>= (f(0) ? 9 : 1));
        e();
        c(1, 3);
        xs[this/*null*/.c++] = (this/*null*/.z >>>= (f(0) ? 0 : 1));
        e();
        c(2);
        xs[this/*null*/.c++] = (t(0) ? 2 + (t(1) ? -1 : 1) : 3);
        e();
        c(1);
        xs[this/*null*/.c++] = (f(0) ? 2 + (x() ? 3 : 1) : 1);
        e();
        c(2);
        xs[this/*null*/.c++] = (t(0) ? 2 + (f(1) ? 1 : -1) : 3);
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? 2 + (t(1) ? -1 : 1) : (x() ? 3 : 4));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? 2 + (t(1) ? -1 : 1) : (x() ? 3 : 4));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 + (x() ? -1 : 1) : (t(1) ? 1 : 4));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 + (x() ? -1 : 1) : (t(1) ? 1 : 4));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 + (x() ? -1 : 1) : (f(1) ? 4 : 1));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (f(0) ? 2 + (x() ? -1 : 1) : (f(1) ? 4 : 1));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? 2 + (f(1) ? 1 : -1) : (x() ? 3 : 4));
        e();
        c(2);
        xs[this/*null*/.c++] =
          (t(0) ? 2 + (f(1) ? 1 : -1) : (x() ? 3 : 4));
        e();
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : 3);
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : 3);
        e(1);
        c(1, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : 1);
        e(-1);
        c(1, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : 1);
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (t(0) ? this/*null*/.z = (t(1) ? 1 : 2) : (x() ? 3 : 4));
        e(1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (t(1) ? 1 : 4));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        c(2, -1);
        xs[this/*null*/.c++] =
          (f(0) ? this/*null*/.z = (x() ? 3 : 2) : (f(1) ? 4 : 1));
        e(-1);
        for (int i = 0; i < xs/*null*/.length; i++) {
            if (xs[i] != 0) {
                org.aspectj.testing.Tester.check(xs[i] ==
                                                 1,
                                                 "xs[" + i + "]=" +
                                                 xs[i] +
                                                 ", not 1!");
            }
        }
    }
    
    static class t {
        public t() { super(); }
    }
    
    
    int cur = 0;
    
    int expect = -1;
    
    private void c(int expect, int z) {
        this/*<unknown>*/.expect = expect;
        this/*null*/.cur = 0;
        this/*<unknown>*/.z = z;
    }
    
    private void c(int expect) { c(expect, 0); }
    
    private void c() { c(-1); }
    
    private void e(int z) {
        if (z != -123) {
            org.aspectj.testing.Tester.check(this/*<unknown>*/.z ==
                                             z,
                                             this/*null*/.c + ": z=" +
                                             this/*<unknown>*/.z +
                                             ", should be " +
                                             z);
        }
        if (this/*null*/.expect >= 0) {
            org.aspectj.testing.Tester.check(this/*null*/.expect ==
                                             this/*null*/.cur,
                                             this/*null*/.c +
                                             ": expect=" +
                                             this/*null*/.expect +
                                             ", should be " +
                                             this/*null*/.cur);
        }
    }
    
    private void e() { e(-123); }
    
    private boolean t(int i) { return b(i, true); }
    
    private boolean f(int i) { return b(i, false); }
    
    private boolean x() { return b(-1, false); }
    
    private boolean b(int i, boolean b) {
        org.aspectj.testing.Tester.check(i >=
                                         0,
                                         this/*null*/.c +
                                         ": this expression shouldn\'t have been evaluated");
        if (i >= 0)
            org.aspectj.testing.Tester.check(i ==
                                             this/*null*/.cur,
                                             this/*null*/.c + ": i=" +
                                             i +
                                             ", should be " +
                                             this/*null*/.cur);
        this/*null*/.cur++;
        return b;
    }
    
    public MultiTernaryOps() { super(); }
}
retrieve <MultiTernaryOps: void main(java.lang.String[])> from MultiTernaryOps
retrieve <MultiTernaryOps: void realMain(java.lang.String[])> from MultiTernaryOps
retrieve <MultiTernaryOps: void c(int,int)> from MultiTernaryOps
retrieve <MultiTernaryOps: void c(int)> from MultiTernaryOps
retrieve <MultiTernaryOps: void c()> from MultiTernaryOps
retrieve <MultiTernaryOps: void e(int)> from MultiTernaryOps
retrieve <MultiTernaryOps: void e()> from MultiTernaryOps
retrieve <MultiTernaryOps: boolean t(int)> from MultiTernaryOps
retrieve <MultiTernaryOps: boolean f(int)> from MultiTernaryOps
retrieve <MultiTernaryOps: boolean x()> from MultiTernaryOps
retrieve <MultiTernaryOps: boolean b(int,boolean)> from MultiTernaryOps
retrieve <MultiTernaryOps: void <init>()> from MultiTernaryOps
retrieve <MultiTernaryOps$t: void <init>()> from MultiTernaryOps$t
Transforming MultiTernaryOps... 
Transforming MultiTernaryOps$t... 
Abc finished on Thu Jun 24 08:17:58 BST 2004. ( 0 min. 24 sec. )
PASS: Testing ternary operations.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 25 seconds
Passed. Current status: 12 failed (check: 0), 74 passed (check: 0), 0 skipped.
Executing test 87 (pureJava): Lifting locals in switch statements.
================================================
Breakdown of abc phases  (total: 7727 millisec.)
------------------------------------------------
[ 00.505% ] Init. of Soot:  39
[ 00.039% ] Loading Jars:  3
[ 81.804% ] Polyglot phases:  6321
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.595% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.582% ] Intertype Adjuster:  45
[ 07.118% ] Retrieving bodies:  550
[ 00.000% ] Weave Initializers:  0
[ 00.298% ] Load shadow types:  23
[ 02.834% ] Compute advice lists:  219
[ 00.039% ] Intertype weave:  3
[ 00.116% ] Add aspect code:  9
[ 00.155% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.119% ] Soot Packs:  241
[ 02.770% ] Soot Writing Output:  214
================================================
Abc started on Thu Jun 24 08:18:00 BST 2004
<<<< SwitchStmtLocals.java >>>>
import org.aspectj.testing.Tester;

public class SwitchStmtLocals {
    public static void main(java.lang.String[] args) {
        new SwitchStmtLocals().realMain(args);
    }
    
    int i = 40;
    
    public void realMain(java.lang.String[] args) {
        int val;
        val = 1;
        this/*null*/.i = 40;
        switch (val) {
            case 0:
                int i = 10;
                break;
            case 1:
                val = (i = 20);
                break;
            default:
                val = (i = 30);
                break;
        }
        org.aspectj.testing.Tester.checkEqual(val, 20);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.i, 40);
        val = 1;
        this/*null*/.i = 40;
        switch (val) {
            case 0:
                int i = 10;
                break;
            case 1:
                switch (val - 1) {
                    case 0:
                        val = (i = 20);
                        break;
                    default:
                        val = (i = 30);
                        break;
                }
                break;
            default:
                i = 30;
                break;
        }
        org.aspectj.testing.Tester.checkEqual(val, 20);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.i, 40);
        val = 1;
        this/*null*/.i = 40;
        switch (val) {
            case 0:
                int i = 10;
                break;
            case 1:
                switch (val - 1) {
                    case 0:
                        switch (val - 1) {
                            case 0:
                                val = (i = 20);
                                break;
                            default:
                                val = (i = 30);
                                break;
                        }
                        break;
                    default:
                        val = (i = 30);
                        break;
                }
                break;
            default:
                i = 30;
                break;
        }
        org.aspectj.testing.Tester.checkEqual(val, 20);
        org.aspectj.testing.Tester.checkEqual(this/*null*/.i, 40);
    }
    
    public SwitchStmtLocals() { super(); }
}
retrieve <SwitchStmtLocals: void main(java.lang.String[])> from SwitchStmtLocals
retrieve <SwitchStmtLocals: void realMain(java.lang.String[])> from SwitchStmtLocals
retrieve <SwitchStmtLocals: void <init>()> from SwitchStmtLocals
Transforming SwitchStmtLocals... 
Abc finished on Thu Jun 24 08:18:08 BST 2004. ( 0 min. 7 sec. )
PASS: Lifting locals in switch statements.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 75 passed (check: 0), 0 skipped.
Executing test 88 (pureJava): Getting confused when looking up method signatures
================================================
Breakdown of abc phases  (total: 10383 millisec.)
------------------------------------------------
[ 00.366% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  4
[ 64.904% ] Polyglot phases:  6739
[ 00.000% ] Resolve class names:  0
[ 00.019% ] Declare Parents:  2
[ 00.327% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.385% ] Intertype Adjuster:  40
[ 07.859% ] Retrieving bodies:  816
[ 00.000% ] Weave Initializers:  0
[ 00.231% ] Load shadow types:  24
[ 16.344% ] Compute advice lists:  1697
[ 00.029% ] Intertype weave:  3
[ 00.087% ] Add aspect code:  9
[ 00.154% ] Weaving advice:  16
[ 00.000% ] Validate jimple:  0
[ 04.623% ] Soot Packs:  480
[ 04.633% ] Soot Writing Output:  481
================================================
Abc started on Thu Jun 24 08:18:11 BST 2004
<<<< MethodSigs.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class MethodSigs {
    public static void main(java.lang.String[] args) {
        new MethodSigs().realMain(args);
    }
    
    java.lang.String want;
    
    void want(java.lang.String want) {
        this/*<unknown>*/.want = want;
    }
    
    void w(java.lang.String s) { want(s); }
    
    void have(java.lang.Object have, java.lang.Object msg) {
        org.aspectj.testing.Tester.checkEqual(this/*null*/.want,
                                              have,
                                              msg +
                                              "");
    }
    
    void have(java.lang.Object have) {
        org.aspectj.testing.Tester.checkEqual(this/*null*/.want,
                                              have);
    }
    
    public void realMain(java.lang.String[] args) {
        lists();
        integers();
    }
    
    void lists() {
        java.lang.Object o =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.lang.Object o1 =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.lang.Object o2 =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.util.List l =
          new java.util.Vector() {
            public String toString() {
                return "l:" + super.toString();
            }
        };
        java.util.List l1 =
          new java.util.Vector() {
            public String toString() {
                return "l1:" + super.toString();
            }
        };
        java.util.List l2 =
          new java.util.Vector() {
            public String toString() {
                return "l2:" + super.toString();
            }
        };
        java.util.Collection c =
          new java.util.Vector() {
            public String toString() {
                return "c:" + super.toString();
            }
        };
        java.util.Collection c1 =
          new java.util.Vector() {
            public String toString() {
                return "c1:" + super.toString();
            }
        };
        java.util.Collection c2 =
          new java.util.Vector() {
            public String toString() {
                return "c2:" + super.toString();
            }
        };
        java.util.Set s =
          new java.util.HashSet() {
            public String toString() {
                return "s:" + super.toString();
            }
        };
        java.util.Set s1 =
          new java.util.HashSet() {
            public String toString() {
                return "s1:" + super.toString();
            }
        };
        java.util.Set s2 =
          new java.util.HashSet() {
            public String toString() {
                return "s2:" + super.toString();
            }
        };
        want("a:Object,Object");
        a(o1, o2);
        want("a:List,Object");
        a(l, o);
        want("a:Object,List");
        a(o, l);
        want("a:Collection,Object");
        a(c, o);
        want("a:Object,Collection");
        a(o, c);
        want("a:List,Collection");
        a(l, c);
        want("a:Collection,List");
        a(c, l);
        want("a:Collection,Collection");
        a(c1, c2);
        want("a:Set,Collection");
        a(s, c);
        want("a:Collection,Set");
        a(c, s);
        want("a:Set,Set");
        a(s1, s2);
        want("a:List,Set");
        a(l, s);
        want("a:Set,List");
        a(s, l);
    }
    
    public void a(java.lang.Object o1, java.lang.Object o2) {
        have("a:Object,Object");
    }
    
    public void a(java.util.List l, java.lang.Object o) {
        have("a:List,Object");
    }
    
    public void a(java.lang.Object o, java.util.List l) {
        have("a:Object,List");
    }
    
    public void a(java.util.Collection c, java.lang.Object o) {
        have("a:Collection,Object");
    }
    
    public void a(java.lang.Object o, java.util.Collection c) {
        have("a:Object,Collection");
    }
    
    public void a(java.util.List l, java.util.Collection c) {
        have("a:List,Collection");
    }
    
    public void a(java.util.Collection c, java.util.List l) {
        have("a:Collection,List");
    }
    
    public void a(java.util.Collection c1, java.util.Collection c2) {
        have("a:Collection,Collection");
    }
    
    public void a(java.util.Set s, java.util.Collection c) {
        have("a:Set,Collection");
    }
    
    public void a(java.util.Collection c, java.util.Set s) {
        have("a:Collection,Set");
    }
    
    public void a(java.util.Set s1, java.util.Set s2) {
        have("a:Set,Set");
    }
    
    public void a(java.util.List l, java.util.Set s) {
        have("a:List,Set");
    }
    
    public void a(java.util.Set s, java.util.List l) {
        have("a:Set,List");
    }
    
    void integers() {
        java.lang.Integer i = new java.lang.Integer(0);
        java.lang.Integer i1 = new java.lang.Integer(1);
        java.lang.Integer i2 = new java.lang.Integer(2);
        java.lang.Object o =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.lang.Object o1 =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.lang.Object o2 =
          new java.lang.Object() {
            public String toString() { return "o"; }
        };
        java.lang.Object oi = new java.lang.Integer(3);
        w("Object,Object");
        f(o1, o2);
        w("Integer,Object");
        f(i, o);
        w("Object,Integer");
        f(o, i);
        w("Integer,Integer");
        f(i1, i2);
        w("Object,Object");
        f(oi, oi);
        w("Object,Object");
        f(oi, o);
        w("Object,Object");
        f(o, oi);
    }
    
    public void f(java.lang.Object o1, java.lang.Object o2) {
        have("Object,Object", o1 + ":" + o2);
    }
    
    public void f(java.lang.Integer i, java.lang.Object o) {
        have("Integer,Object", i + ":" + o);
    }
    
    public void f(java.lang.Object o, java.lang.Integer i) {
        have("Object,Integer", o + ":" + i);
    }
    
    public void f(java.lang.Integer i1, java.lang.Integer i2) {
        have("Integer,Integer", i1 + ":" + i2);
    }
    
    public MethodSigs() { super(); }
}
retrieve <MethodSigs: void main(java.lang.String[])> from MethodSigs
retrieve <MethodSigs: void want(java.lang.String)> from MethodSigs
retrieve <MethodSigs: void w(java.lang.String)> from MethodSigs
retrieve <MethodSigs: void have(java.lang.Object,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void have(java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void realMain(java.lang.String[])> from MethodSigs
retrieve <MethodSigs: void lists()> from MethodSigs
retrieve <MethodSigs: void a(java.lang.Object,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void a(java.util.List,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void a(java.lang.Object,java.util.List)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Collection,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void a(java.lang.Object,java.util.Collection)> from MethodSigs
retrieve <MethodSigs: void a(java.util.List,java.util.Collection)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Collection,java.util.List)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Collection,java.util.Collection)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Set,java.util.Collection)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Collection,java.util.Set)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Set,java.util.Set)> from MethodSigs
retrieve <MethodSigs: void a(java.util.List,java.util.Set)> from MethodSigs
retrieve <MethodSigs: void a(java.util.Set,java.util.List)> from MethodSigs
retrieve <MethodSigs: void integers()> from MethodSigs
retrieve <MethodSigs: void f(java.lang.Object,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void f(java.lang.Integer,java.lang.Object)> from MethodSigs
retrieve <MethodSigs: void f(java.lang.Object,java.lang.Integer)> from MethodSigs
retrieve <MethodSigs: void f(java.lang.Integer,java.lang.Integer)> from MethodSigs
retrieve <MethodSigs: void <init>()> from MethodSigs
retrieve <MethodSigs$13: void <init>(MethodSigs)> from MethodSigs$13
retrieve <MethodSigs$13: java.lang.String toString()> from MethodSigs$13
retrieve <MethodSigs$10: void <init>(MethodSigs)> from MethodSigs$10
retrieve <MethodSigs$10: java.lang.String toString()> from MethodSigs$10
retrieve <MethodSigs$5: void <init>(MethodSigs)> from MethodSigs$5
retrieve <MethodSigs$5: java.lang.String toString()> from MethodSigs$5
retrieve <MethodSigs$9: void <init>(MethodSigs)> from MethodSigs$9
retrieve <MethodSigs$9: java.lang.String toString()> from MethodSigs$9
retrieve <MethodSigs$6: void <init>(MethodSigs)> from MethodSigs$6
retrieve <MethodSigs$6: java.lang.String toString()> from MethodSigs$6
retrieve <MethodSigs$1: void <init>(MethodSigs)> from MethodSigs$1
retrieve <MethodSigs$1: java.lang.String toString()> from MethodSigs$1
retrieve <MethodSigs$8: void <init>(MethodSigs)> from MethodSigs$8
retrieve <MethodSigs$8: java.lang.String toString()> from MethodSigs$8
retrieve <MethodSigs$3: void <init>(MethodSigs)> from MethodSigs$3
retrieve <MethodSigs$3: java.lang.String toString()> from MethodSigs$3
retrieve <MethodSigs$11: void <init>(MethodSigs)> from MethodSigs$11
retrieve <MethodSigs$11: java.lang.String toString()> from MethodSigs$11
retrieve <MethodSigs$12: void <init>(MethodSigs)> from MethodSigs$12
retrieve <MethodSigs$12: java.lang.String toString()> from MethodSigs$12
retrieve <MethodSigs$14: void <init>(MethodSigs)> from MethodSigs$14
retrieve <MethodSigs$14: java.lang.String toString()> from MethodSigs$14
retrieve <MethodSigs$4: void <init>(MethodSigs)> from MethodSigs$4
retrieve <MethodSigs$4: java.lang.String toString()> from MethodSigs$4
retrieve <MethodSigs$7: void <init>(MethodSigs)> from MethodSigs$7
retrieve <MethodSigs$7: java.lang.String toString()> from MethodSigs$7
retrieve <MethodSigs$15: void <init>(MethodSigs)> from MethodSigs$15
retrieve <MethodSigs$15: java.lang.String toString()> from MethodSigs$15
retrieve <MethodSigs$2: void <init>(MethodSigs)> from MethodSigs$2
retrieve <MethodSigs$2: java.lang.String toString()> from MethodSigs$2
Transforming MethodSigs... 
Transforming MethodSigs$1... 
Transforming MethodSigs$2... 
Transforming MethodSigs$3... 
Transforming MethodSigs$4... 
Transforming MethodSigs$5... 
Transforming MethodSigs$6... 
Transforming MethodSigs$7... 
Transforming MethodSigs$8... 
Transforming MethodSigs$9... 
Transforming MethodSigs$10... 
Transforming MethodSigs$11... 
Transforming MethodSigs$12... 
Transforming MethodSigs$13... 
Transforming MethodSigs$14... 
Transforming MethodSigs$15... 
Abc finished on Thu Jun 24 08:18:21 BST 2004. ( 0 min. 10 sec. )
PASS: Getting confused when looking up method signatures()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 12 failed (check: 0), 76 passed (check: 0), 0 skipped.
Executing test 89 (pureJava): Not recognizing the chars '\0', '\1', '\2', '\3', '\4', '\5', '\6', '\7'
================================================
Breakdown of abc phases  (total: 7958 millisec.)
------------------------------------------------
[ 00.478% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 75.584% ] Polyglot phases:  6015
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.440% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.829% ] Intertype Adjuster:  66
[ 08.846% ] Retrieving bodies:  704
[ 00.000% ] Weave Initializers:  0
[ 00.276% ] Load shadow types:  22
[ 03.167% ] Compute advice lists:  252
[ 00.038% ] Intertype weave:  3
[ 00.101% ] Add aspect code:  8
[ 00.163% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.411% ] Soot Packs:  351
[ 05.604% ] Soot Writing Output:  446
================================================
Abc started on Thu Jun 24 08:18:24 BST 2004
<<<< Chars.java >>>>
import org.aspectj.testing.Tester;

public class Chars {
    public static void main(java.lang.String[] args) {
        new Chars().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        char[] cs =
          new char[] { '\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007', '\b', '\t', '\n', '\013', '\f', '\r', '\016', '\017', '\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027', '\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037', ' ', '!', '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\177', '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207', '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217', '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227', '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237', '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247', '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257', '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267', '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277', '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307', '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317', '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327', '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337', '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347', '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357', '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367', '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377' };
        for (int i = 0; i < cs/*null*/.length; i++) {
            org.aspectj.testing.Tester.check((int) cs[i] ==
                                             i,
                                             i + "!=\'\\" +
                                             java.lang.Integer.toOctalString(i) +
                                             "\'");
        }
    }
    
    public Chars() { super(); }
}
retrieve <Chars: void main(java.lang.String[])> from Chars
retrieve <Chars: void realMain(java.lang.String[])> from Chars
retrieve <Chars: void <init>()> from Chars
Transforming Chars... 
Abc finished on Thu Jun 24 08:18:32 BST 2004. ( 0 min. 8 sec. )
PASS: Not recognizing the chars '\0', '\1', '\2', '\3', '\4', '\5', '\6', '\7'()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 12 failed (check: 0), 77 passed (check: 0), 0 skipped.
Executing test 90 (pureJava): Test chars '\0', '\1', '\2', '\3', '\4', '\5', '\6', '\7' with a case statement
================================================
Breakdown of abc phases  (total: 10013 millisec.)
------------------------------------------------
[ 00.389% ] Init. of Soot:  39
[ 00.040% ] Loading Jars:  4
[ 75.592% ] Polyglot phases:  7569
[ 00.000% ] Resolve class names:  0
[ 00.020% ] Declare Parents:  2
[ 00.539% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.389% ] Intertype Adjuster:  39
[ 09.847% ] Retrieving bodies:  986
[ 00.000% ] Weave Initializers:  0
[ 00.220% ] Load shadow types:  22
[ 03.116% ] Compute advice lists:  312
[ 00.030% ] Intertype weave:  3
[ 00.090% ] Add aspect code:  9
[ 00.130% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.234% ] Soot Packs:  424
[ 05.363% ] Soot Writing Output:  537
================================================
Abc started on Thu Jun 24 08:18:34 BST 2004
<<<< CaseClauses.java >>>>
import org.aspectj.testing.Tester;

public class CaseClauses {
    public static void main(java.lang.String[] args) {
        new CaseClauses().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        int SIZE = 255;
        boolean[] bs = new boolean[SIZE];
        for (int i = 0; i < bs/*null*/.length; i++) { bs[i] = false; }
        for (int i = 0; i < SIZE; i++) {
            switch ((char) i) {
                case '\000':
                    bs[0] = true;
                    break;
                case '\001':
                    bs[1] = true;
                    break;
                case '\002':
                    bs[2] = true;
                    break;
                case '\003':
                    bs[3] = true;
                    break;
                case '\004':
                    bs[4] = true;
                    break;
                case '\005':
                    bs[5] = true;
                    break;
                case '\006':
                    bs[6] = true;
                    break;
                case '\007':
                    bs[7] = true;
                    break;
                case '\b':
                    bs[8] = true;
                    break;
                case '\t':
                    bs[9] = true;
                    break;
                case '\n':
                    bs[10] = true;
                    break;
                case '\013':
                    bs[11] = true;
                    break;
                case '\f':
                    bs[12] = true;
                    break;
                case '\r':
                    bs[13] = true;
                    break;
                case '\016':
                    bs[14] = true;
                    break;
                case '\017':
                    bs[15] = true;
                    break;
                case '\020':
                    bs[16] = true;
                    break;
                case '\021':
                    bs[17] = true;
                    break;
                case '\022':
                    bs[18] = true;
                    break;
                case '\023':
                    bs[19] = true;
                    break;
                case '\024':
                    bs[20] = true;
                    break;
                case '\025':
                    bs[21] = true;
                    break;
                case '\026':
                    bs[22] = true;
                    break;
                case '\027':
                    bs[23] = true;
                    break;
                case '\030':
                    bs[24] = true;
                    break;
                case '\031':
                    bs[25] = true;
                    break;
                case '\032':
                    bs[26] = true;
                    break;
                case '\033':
                    bs[27] = true;
                    break;
                case '\034':
                    bs[28] = true;
                    break;
                case '\035':
                    bs[29] = true;
                    break;
                case '\036':
                    bs[30] = true;
                    break;
                case '\037':
                    bs[31] = true;
                    break;
                case ' ':
                    bs[32] = true;
                    break;
                case '!':
                    bs[33] = true;
                    break;
                case '\"':
                    bs[34] = true;
                    break;
                case '#':
                    bs[35] = true;
                    break;
                case '$':
                    bs[36] = true;
                    break;
                case '%':
                    bs[37] = true;
                    break;
                case '&':
                    bs[38] = true;
                    break;
                case '\'':
                    bs[39] = true;
                    break;
                case '(':
                    bs[40] = true;
                    break;
                case ')':
                    bs[41] = true;
                    break;
                case '*':
                    bs[42] = true;
                    break;
                case '+':
                    bs[43] = true;
                    break;
                case ',':
                    bs[44] = true;
                    break;
                case '-':
                    bs[45] = true;
                    break;
                case '.':
                    bs[46] = true;
                    break;
                case '/':
                    bs[47] = true;
                    break;
                case '0':
                    bs[48] = true;
                    break;
                case '1':
                    bs[49] = true;
                    break;
                case '2':
                    bs[50] = true;
                    break;
                case '3':
                    bs[51] = true;
                    break;
                case '4':
                    bs[52] = true;
                    break;
                case '5':
                    bs[53] = true;
                    break;
                case '6':
                    bs[54] = true;
                    break;
                case '7':
                    bs[55] = true;
                    break;
                case '8':
                    bs[56] = true;
                    break;
                case '9':
                    bs[57] = true;
                    break;
                case ':':
                    bs[58] = true;
                    break;
                case ';':
                    bs[59] = true;
                    break;
                case '<':
                    bs[60] = true;
                    break;
                case '=':
                    bs[61] = true;
                    break;
                case '>':
                    bs[62] = true;
                    break;
                case '?':
                    bs[63] = true;
                    break;
                case '@':
                    bs[64] = true;
                    break;
                case 'A':
                    bs[65] = true;
                    break;
                case 'B':
                    bs[66] = true;
                    break;
                case 'C':
                    bs[67] = true;
                    break;
                case 'D':
                    bs[68] = true;
                    break;
                case 'E':
                    bs[69] = true;
                    break;
                case 'F':
                    bs[70] = true;
                    break;
                case 'G':
                    bs[71] = true;
                    break;
                case 'H':
                    bs[72] = true;
                    break;
                case 'I':
                    bs[73] = true;
                    break;
                case 'J':
                    bs[74] = true;
                    break;
                case 'K':
                    bs[75] = true;
                    break;
                case 'L':
                    bs[76] = true;
                    break;
                case 'M':
                    bs[77] = true;
                    break;
                case 'N':
                    bs[78] = true;
                    break;
                case 'O':
                    bs[79] = true;
                    break;
                case 'P':
                    bs[80] = true;
                    break;
                case 'Q':
                    bs[81] = true;
                    break;
                case 'R':
                    bs[82] = true;
                    break;
                case 'S':
                    bs[83] = true;
                    break;
                case 'T':
                    bs[84] = true;
                    break;
                case 'U':
                    bs[85] = true;
                    break;
                case 'V':
                    bs[86] = true;
                    break;
                case 'W':
                    bs[87] = true;
                    break;
                case 'X':
                    bs[88] = true;
                    break;
                case 'Y':
                    bs[89] = true;
                    break;
                case 'Z':
                    bs[90] = true;
                    break;
                case '[':
                    bs[91] = true;
                    break;
                case '\\':
                    bs[92] = true;
                    break;
                case ']':
                    bs[93] = true;
                    break;
                case '^':
                    bs[94] = true;
                    break;
                case '_':
                    bs[95] = true;
                    break;
                case '`':
                    bs[96] = true;
                    break;
                case 'a':
                    bs[97] = true;
                    break;
                case 'b':
                    bs[98] = true;
                    break;
                case 'c':
                    bs[99] = true;
                    break;
                case 'd':
                    bs[100] = true;
                    break;
                case 'e':
                    bs[101] = true;
                    break;
                case 'f':
                    bs[102] = true;
                    break;
                case 'g':
                    bs[103] = true;
                    break;
                case 'h':
                    bs[104] = true;
                    break;
                case 'i':
                    bs[105] = true;
                    break;
                case 'j':
                    bs[106] = true;
                    break;
                case 'k':
                    bs[107] = true;
                    break;
                case 'l':
                    bs[108] = true;
                    break;
                case 'm':
                    bs[109] = true;
                    break;
                case 'n':
                    bs[110] = true;
                    break;
                case 'o':
                    bs[111] = true;
                    break;
                case 'p':
                    bs[112] = true;
                    break;
                case 'q':
                    bs[113] = true;
                    break;
                case 'r':
                    bs[114] = true;
                    break;
                case 's':
                    bs[115] = true;
                    break;
                case 't':
                    bs[116] = true;
                    break;
                case 'u':
                    bs[117] = true;
                    break;
                case 'v':
                    bs[118] = true;
                    break;
                case 'w':
                    bs[119] = true;
                    break;
                case 'x':
                    bs[120] = true;
                    break;
                case 'y':
                    bs[121] = true;
                    break;
                case 'z':
                    bs[122] = true;
                    break;
                case '{':
                    bs[123] = true;
                    break;
                case '|':
                    bs[124] = true;
                    break;
                case '}':
                    bs[125] = true;
                    break;
                case '~':
                    bs[126] = true;
                    break;
                case '\177':
                    bs[127] = true;
                    break;
                case '\200':
                    bs[128] = true;
                    break;
                case '\201':
                    bs[129] = true;
                    break;
                case '\202':
                    bs[130] = true;
                    break;
                case '\203':
                    bs[131] = true;
                    break;
                case '\204':
                    bs[132] = true;
                    break;
                case '\205':
                    bs[133] = true;
                    break;
                case '\206':
                    bs[134] = true;
                    break;
                case '\207':
                    bs[135] = true;
                    break;
                case '\210':
                    bs[136] = true;
                    break;
                case '\211':
                    bs[137] = true;
                    break;
                case '\212':
                    bs[138] = true;
                    break;
                case '\213':
                    bs[139] = true;
                    break;
                case '\214':
                    bs[140] = true;
                    break;
                case '\215':
                    bs[141] = true;
                    break;
                case '\216':
                    bs[142] = true;
                    break;
                case '\217':
                    bs[143] = true;
                    break;
                case '\220':
                    bs[144] = true;
                    break;
                case '\221':
                    bs[145] = true;
                    break;
                case '\222':
                    bs[146] = true;
                    break;
                case '\223':
                    bs[147] = true;
                    break;
                case '\224':
                    bs[148] = true;
                    break;
                case '\225':
                    bs[149] = true;
                    break;
                case '\226':
                    bs[150] = true;
                    break;
                case '\227':
                    bs[151] = true;
                    break;
                case '\230':
                    bs[152] = true;
                    break;
                case '\231':
                    bs[153] = true;
                    break;
                case '\232':
                    bs[154] = true;
                    break;
                case '\233':
                    bs[155] = true;
                    break;
                case '\234':
                    bs[156] = true;
                    break;
                case '\235':
                    bs[157] = true;
                    break;
                case '\236':
                    bs[158] = true;
                    break;
                case '\237':
                    bs[159] = true;
                    break;
                case '\240':
                    bs[160] = true;
                    break;
                case '\241':
                    bs[161] = true;
                    break;
                case '\242':
                    bs[162] = true;
                    break;
                case '\243':
                    bs[163] = true;
                    break;
                case '\244':
                    bs[164] = true;
                    break;
                case '\245':
                    bs[165] = true;
                    break;
                case '\246':
                    bs[166] = true;
                    break;
                case '\247':
                    bs[167] = true;
                    break;
                case '\250':
                    bs[168] = true;
                    break;
                case '\251':
                    bs[169] = true;
                    break;
                case '\252':
                    bs[170] = true;
                    break;
                case '\253':
                    bs[171] = true;
                    break;
                case '\254':
                    bs[172] = true;
                    break;
                case '\255':
                    bs[173] = true;
                    break;
                case '\256':
                    bs[174] = true;
                    break;
                case '\257':
                    bs[175] = true;
                    break;
                case '\260':
                    bs[176] = true;
                    break;
                case '\261':
                    bs[177] = true;
                    break;
                case '\262':
                    bs[178] = true;
                    break;
                case '\263':
                    bs[179] = true;
                    break;
                case '\264':
                    bs[180] = true;
                    break;
                case '\265':
                    bs[181] = true;
                    break;
                case '\266':
                    bs[182] = true;
                    break;
                case '\267':
                    bs[183] = true;
                    break;
                case '\270':
                    bs[184] = true;
                    break;
                case '\271':
                    bs[185] = true;
                    break;
                case '\272':
                    bs[186] = true;
                    break;
                case '\273':
                    bs[187] = true;
                    break;
                case '\274':
                    bs[188] = true;
                    break;
                case '\275':
                    bs[189] = true;
                    break;
                case '\276':
                    bs[190] = true;
                    break;
                case '\277':
                    bs[191] = true;
                    break;
                case '\300':
                    bs[192] = true;
                    break;
                case '\301':
                    bs[193] = true;
                    break;
                case '\302':
                    bs[194] = true;
                    break;
                case '\303':
                    bs[195] = true;
                    break;
                case '\304':
                    bs[196] = true;
                    break;
                case '\305':
                    bs[197] = true;
                    break;
                case '\306':
                    bs[198] = true;
                    break;
                case '\307':
                    bs[199] = true;
                    break;
                case '\310':
                    bs[200] = true;
                    break;
                case '\311':
                    bs[201] = true;
                    break;
                case '\312':
                    bs[202] = true;
                    break;
                case '\313':
                    bs[203] = true;
                    break;
                case '\314':
                    bs[204] = true;
                    break;
                case '\315':
                    bs[205] = true;
                    break;
                case '\316':
                    bs[206] = true;
                    break;
                case '\317':
                    bs[207] = true;
                    break;
                case '\320':
                    bs[208] = true;
                    break;
                case '\321':
                    bs[209] = true;
                    break;
                case '\322':
                    bs[210] = true;
                    break;
                case '\323':
                    bs[211] = true;
                    break;
                case '\324':
                    bs[212] = true;
                    break;
                case '\325':
                    bs[213] = true;
                    break;
                case '\326':
                    bs[214] = true;
                    break;
                case '\327':
                    bs[215] = true;
                    break;
                case '\330':
                    bs[216] = true;
                    break;
                case '\331':
                    bs[217] = true;
                    break;
                case '\332':
                    bs[218] = true;
                    break;
                case '\333':
                    bs[219] = true;
                    break;
                case '\334':
                    bs[220] = true;
                    break;
                case '\335':
                    bs[221] = true;
                    break;
                case '\336':
                    bs[222] = true;
                    break;
                case '\337':
                    bs[223] = true;
                    break;
                case '\340':
                    bs[224] = true;
                    break;
                case '\341':
                    bs[225] = true;
                    break;
                case '\342':
                    bs[226] = true;
                    break;
                case '\343':
                    bs[227] = true;
                    break;
                case '\344':
                    bs[228] = true;
                    break;
                case '\345':
                    bs[229] = true;
                    break;
                case '\346':
                    bs[230] = true;
                    break;
                case '\347':
                    bs[231] = true;
                    break;
                case '\350':
                    bs[232] = true;
                    break;
                case '\351':
                    bs[233] = true;
                    break;
                case '\352':
                    bs[234] = true;
                    break;
                case '\353':
                    bs[235] = true;
                    break;
                case '\354':
                    bs[236] = true;
                    break;
                case '\355':
                    bs[237] = true;
                    break;
                case '\356':
                    bs[238] = true;
                    break;
                case '\357':
                    bs[239] = true;
                    break;
                case '\360':
                    bs[240] = true;
                    break;
                case '\361':
                    bs[241] = true;
                    break;
                case '\362':
                    bs[242] = true;
                    break;
                case '\363':
                    bs[243] = true;
                    break;
                case '\364':
                    bs[244] = true;
                    break;
                case '\365':
                    bs[245] = true;
                    break;
                case '\366':
                    bs[246] = true;
                    break;
                case '\367':
                    bs[247] = true;
                    break;
                case '\370':
                    bs[248] = true;
                    break;
                case '\371':
                    bs[249] = true;
                    break;
                case '\372':
                    bs[250] = true;
                    break;
                case '\373':
                    bs[251] = true;
                    break;
                case '\374':
                    bs[252] = true;
                    break;
                case '\375':
                    bs[253] = true;
                    break;
                case '\376':
                    bs[254] = true;
                    break;
                case '\377':
                    bs[255] = true;
                    break;
                default:
                    org.aspectj.testing.Tester.check(false,
                                                     "should be here:" +
                                                     i);
            }
        }
        for (int i = 0; i < bs/*null*/.length; i++) {
            org.aspectj.testing.Tester.check(bs[i],
                                             "bs[" + i +
                                             "] wasn\'t caught --> \'\\" +
                                             java.lang.Integer.toOctalString(i) +
                                             "\'");
        }
    }
    
    public CaseClauses() { super(); }
}
retrieve <CaseClauses: void main(java.lang.String[])> from CaseClauses
retrieve <CaseClauses: void realMain(java.lang.String[])> from CaseClauses
retrieve <CaseClauses: void <init>()> from CaseClauses
Transforming CaseClauses... 
Abc finished on Thu Jun 24 08:18:44 BST 2004. ( 0 min. 10 sec. )
PASS: Test chars '\0', '\1', '\2', '\3', '\4', '\5', '\6', '\7' with a case st...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 12 failed (check: 0), 78 passed (check: 0), 0 skipped.
Executing test 91 (pureJava): Checking character values with all the unicode chars.
Failed. Current status: 13 failed (check: 0), 78 passed (check: 0), 0 skipped.
Executing test 92 (pureJava): Trouble finding methods with the same name and different parameter types
================================================
Breakdown of abc phases  (total: 7855 millisec.)
------------------------------------------------
[ 00.484% ] Init. of Soot:  38
[ 00.051% ] Loading Jars:  4
[ 72.094% ] Polyglot phases:  5663
[ 00.013% ] Resolve class names:  1
[ 00.013% ] Declare Parents:  1
[ 00.573% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.789% ] Intertype Adjuster:  62
[ 06.926% ] Retrieving bodies:  544
[ 00.000% ] Weave Initializers:  0
[ 00.293% ] Load shadow types:  23
[ 12.132% ] Compute advice lists:  953
[ 00.038% ] Intertype weave:  3
[ 00.102% ] Add aspect code:  8
[ 00.165% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.297% ] Soot Packs:  259
[ 03.030% ] Soot Writing Output:  238
================================================
Abc started on Thu Jun 24 08:21:39 BST 2004
<<<< MethodsWithTheSameName.java >>>>
import org.aspectj.testing.Tester;

public class MethodsWithTheSameName {
    public static void main(java.lang.String[] args) {
        MethodsWithTheSameName.Inner i =
          new MethodsWithTheSameName.Inner("inner");
        i.f((java.lang.String) null);
        i.f("call1");
        i.f(new MethodsWithTheSameName.Inner("call2"));
        org.aspectj.testing.Tester.checkEqual(MethodsWithTheSameName/*MethodsWithTheSameName*/.strings,
                                              "null:inner-null:null-inner:null:call2:");
    }
    
    static java.lang.String strings = "";
    
    static class Inner {
        java.lang.String s;
        
        Inner(java.lang.String s) {
            super();
            this/*<unknown>*/.s = s;
        }
        
        void f(java.lang.String str) {
            f(str ==
              null ? null : new MethodsWithTheSameName.Inner("null-" +
                                                             this/*null*/.s));
            f(str ==
              null ? new MethodsWithTheSameName.Inner(this/*null*/.s +
                                                      "-null") : null);
        }
        
        void f(MethodsWithTheSameName.Inner i) {
            MethodsWithTheSameName/*MethodsWithTheSameName*/.strings +=
              i + ":";
        }
        
        public java.lang.String toString() { return this/*null*/.s; }
    }
    
    
    public MethodsWithTheSameName() { super(); }
}
retrieve <MethodsWithTheSameName: void main(java.lang.String[])> from MethodsWithTheSameName
retrieve <MethodsWithTheSameName: void <init>()> from MethodsWithTheSameName
retrieve <MethodsWithTheSameName: void <clinit>()> from MethodsWithTheSameName
retrieve <MethodsWithTheSameName$Inner: void <init>(java.lang.String)> from MethodsWithTheSameName$Inner
retrieve <MethodsWithTheSameName$Inner: void f(java.lang.String)> from MethodsWithTheSameName$Inner
retrieve <MethodsWithTheSameName$Inner: void f(MethodsWithTheSameName$Inner)> from MethodsWithTheSameName$Inner
retrieve <MethodsWithTheSameName$Inner: java.lang.String toString()> from MethodsWithTheSameName$Inner
Transforming MethodsWithTheSameName... 
Transforming MethodsWithTheSameName$Inner... 
Abc finished on Thu Jun 24 08:21:47 BST 2004. ( 0 min. 7 sec. )
PASS: Trouble finding methods with the same name and different parameter types()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 13 failed (check: 0), 79 passed (check: 0), 0 skipped.
Executing test 93 (pureJava): Binding non-public static inner classes of interfaces in other packages
================================================
Breakdown of abc phases  (total: 7260 millisec.)
------------------------------------------------
[ 00.510% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 77.975% ] Polyglot phases:  5661
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.468% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.551% ] Intertype Adjuster:  40
[ 12.452% ] Retrieving bodies:  904
[ 00.000% ] Weave Initializers:  0
[ 00.317% ] Load shadow types:  23
[ 01.928% ] Compute advice lists:  140
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.658% ] Soot Packs:  193
[ 02.713% ] Soot Writing Output:  197
================================================
Abc started on Thu Jun 24 08:21:50 BST 2004
<<<< StaticClassesInInterfaces.java >>>>
import org.aspectj.testing.Tester;
import anotherPackage.*;

public class StaticClassesInInterfaces {
    public static void main(java.lang.String[] args) {
        new StaticClassesInInterfaces().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        anotherPackage.AnotherPackageInterface.Inner inner = null;
        org.aspectj.testing.Tester.check(true, "compiled!");
    }
    
    public StaticClassesInInterfaces() { super(); }
}
<<<< AnotherPackageInterface.java >>>>
package anotherPackage;

public interface AnotherPackageInterface {
    static class Inner {
        public Inner() { super(); }
    }
    
}
retrieve <StaticClassesInInterfaces: void realMain(java.lang.String[])> from StaticClassesInInterfaces
retrieve <StaticClassesInInterfaces: void <init>()> from StaticClassesInInterfaces
retrieve <StaticClassesInInterfaces: void main(java.lang.String[])> from StaticClassesInInterfaces
retrieve <anotherPackage.AnotherPackageInterface$Inner: void <init>()> from anotherPackage.AnotherPackageInterface$Inner
Transforming anotherPackage.AnotherPackageInterface... 
Transforming anotherPackage.AnotherPackageInterface$Inner... 
Transforming StaticClassesInInterfaces... 
Abc finished on Thu Jun 24 08:21:57 BST 2004. ( 0 min. 7 sec. )
PASS: Binding non-public static inner classes of interfaces in other packages()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 13 failed (check: 0), 80 passed (check: 0), 0 skipped.
Executing test 94 (pureJava): Not recognizing the octal chars '\0', '\1', '\2', '\3', '\4', '\5', '\6', '\7'
================================================
Breakdown of abc phases  (total: 8827 millisec.)
------------------------------------------------
[ 00.419% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  4
[ 71.270% ] Polyglot phases:  6291
[ 00.000% ] Resolve class names:  0
[ 00.023% ] Declare Parents:  2
[ 00.634% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.453% ] Intertype Adjuster:  40
[ 08.191% ] Retrieving bodies:  723
[ 00.000% ] Weave Initializers:  0
[ 00.261% ] Load shadow types:  23
[ 02.764% ] Compute advice lists:  244
[ 00.034% ] Intertype weave:  3
[ 00.102% ] Add aspect code:  9
[ 00.136% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.965% ] Soot Packs:  350
[ 11.703% ] Soot Writing Output:  1033
================================================
Abc started on Thu Jun 24 08:22:00 BST 2004
<<<< OctalChars.java >>>>
import org.aspectj.testing.Tester;

public class OctalChars {
    public static void main(java.lang.String[] args) {
        new OctalChars().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        char[][] chars =
          { { '\000', '\000', '\000' }, { '\001', '\001', '\001' }, { '\002', '\002', '\002' }, { '\003', '\003', '\003' }, { '\004', '\004', '\004' }, { '\005', '\005', '\005' }, { '\006', '\006', '\006' }, { '\007', '\007', '\007' }, { '\b', '\b' }, { '\t', '\t' }, { '\n', '\n' }, { '\013', '\013' }, { '\f', '\f' }, { '\r', '\r' }, { '\016', '\016' }, { '\017', '\017' }, { '\020', '\020' }, { '\021', '\021' }, { '\022', '\022' }, { '\023', '\023' }, { '\024', '\024' }, { '\025', '\025' }, { '\026', '\026' }, { '\027', '\027' }, { '\030', '\030' }, { '\031', '\031' }, { '\032', '\032' }, { '\033', '\033' }, { '\034', '\034' }, { '\035', '\035' }, { '\036', '\036' }, { '\037', '\037' }, { ' ', ' ' }, { '!', '!' }, { '\"', '\"' }, { '#', '#' }, { '$', '$' }, { '%', '%' }, { '&', '&' }, { '\'', '\'' }, { '(', '(' }, { ')', ')' }, { '*', '*' }, { '+', '+' }, { ',', ',' }, { '-', '-' }, { '.', '.' }, { '/', '/' }, { '0', '0' }, { '1', '1' }, { '2', '2' }, { '3', '3' }, { '4', '4' }, { '5', '5' }, { '6', '6' }, { '7', '7' }, { '8', '8' }, { '9', '9' }, { ':', ':' }, { ';', ';' }, { '<', '<' }, { '=', '=' }, { '>', '>' }, { '?', '?' } };
        for (int i = 0; i < chars/*null*/.length; i++) {
            char[] cs = chars[i];
            for (int j = 0; j < cs/*null*/.length; j++) {
                org.aspectj.testing.Tester.check((int) cs[j] ==
                                                 i,
                                                 i + "!=\'\\" +
                                                 java.lang.Integer.toOctalString(i) +
                                                 "\'");
            }
        }
    }
    
    public OctalChars() { super(); }
}
retrieve <OctalChars: void main(java.lang.String[])> from OctalChars
retrieve <OctalChars: void realMain(java.lang.String[])> from OctalChars
retrieve <OctalChars: void <init>()> from OctalChars
Transforming OctalChars... 
Abc finished on Thu Jun 24 08:22:09 BST 2004. ( 0 min. 8 sec. )
PASS: Not recognizing the octal chars '\0', '\1', '\2', '\3', '\4', '\5', '\6'...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 13 failed (check: 0), 81 passed (check: 0), 0 skipped.
Executing test 95 (pureJava): Members with the same name as their package cause confusion with fully-qualified names.
================================================
Breakdown of abc phases  (total: 7401 millisec.)
------------------------------------------------
[ 00.500% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 76.949% ] Polyglot phases:  5695
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.716% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 06.472% ] Intertype Adjuster:  479
[ 06.648% ] Retrieving bodies:  492
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  22
[ 02.486% ] Compute advice lists:  184
[ 00.041% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  9
[ 00.162% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.743% ] Soot Packs:  203
[ 02.783% ] Soot Writing Output:  206
================================================
Abc started on Thu Jun 24 08:22:11 BST 2004
<<<< Main.java >>>>
package samenames;

import org.aspectj.testing.Tester;

public class Main {
    static samenames.Main samenames = new samenames.Main();
    
    public static void main(java.lang.String[] args) {
        samenames.Main/*samenames.Main*/.samenames.realMain(args);
    }
    
    void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(1,
                                              samenames.Other.returns1());
        org.aspectj.testing.Tester.checkEqual(2,
                                              new samenames.Other().returns2());
    }
    
    public Main() { super(); }
}
<<<< Other.java >>>>
package samenames;

public class Other {
    static int returns1() { return true ? 1 : 2; }
    
    int returns2() { return true ? 2 : 1; }
    
    public Other() { super(); }
}
retrieve <samenames.Main: void main(java.lang.String[])> from samenames.Main
retrieve <samenames.Main: void realMain(java.lang.String[])> from samenames.Main
retrieve <samenames.Main: void <init>()> from samenames.Main
retrieve <samenames.Main: void <clinit>()> from samenames.Main
retrieve <samenames.Other: void <init>()> from samenames.Other
retrieve <samenames.Other: int returns1()> from samenames.Other
retrieve <samenames.Other: int returns2()> from samenames.Other
Transforming samenames.Main... 
Transforming samenames.Other... 
Abc finished on Thu Jun 24 08:22:19 BST 2004. ( 0 min. 7 sec. )
PASS: Members with the same name as their package cause confusion with fully-q...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 13 failed (check: 0), 82 passed (check: 0), 0 skipped.
Executing test 96 (pureJava): Fully-qual'ed names with same start as variable names
================================================
Breakdown of abc phases  (total: 7916 millisec.)
------------------------------------------------
[ 00.467% ] Init. of Soot:  37
[ 00.051% ] Loading Jars:  4
[ 74.747% ] Polyglot phases:  5917
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.657% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 06.139% ] Intertype Adjuster:  486
[ 06.645% ] Retrieving bodies:  526
[ 00.000% ] Weave Initializers:  0
[ 00.291% ] Load shadow types:  23
[ 04.952% ] Compute advice lists:  392
[ 00.038% ] Intertype weave:  3
[ 00.114% ] Add aspect code:  9
[ 00.152% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.842% ] Soot Packs:  225
[ 02.880% ] Soot Writing Output:  228
================================================
Abc started on Thu Jun 24 08:22:21 BST 2004
<<<< FullNames.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class FullNames {
    public static void main(java.lang.String[] args) {
        new FullNames().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        a();
        b();
        c();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("a");
               org.aspectj.testing.Tester.expectEvent("b");
               org.aspectj.testing.Tester.expectEvent(java.lang.String.class.toString());
           }
    
    private void a() {
        java.lang.String java = new java.lang.String("a");
        org.aspectj.testing.Tester.event(java);
    }
    
    public void b() {
        java.lang.String java =
          java.lang.String.copyValueOf(new char[] { 'b' });
        org.aspectj.testing.Tester.event(java);
    }
    
    public void c() {
        java.lang.Class java = java.lang.String.class;
        org.aspectj.testing.Tester.event(java.toString());
    }
    
    public FullNames() { super(); }
}
retrieve <FullNames: java.lang.Class class$(java.lang.String)> from FullNames
retrieve <FullNames: void main(java.lang.String[])> from FullNames
retrieve <FullNames: void realMain(java.lang.String[])> from FullNames
retrieve <FullNames: void a()> from FullNames
retrieve <FullNames: void b()> from FullNames
retrieve <FullNames: void c()> from FullNames
retrieve <FullNames: void <init>()> from FullNames
retrieve <FullNames: void <clinit>()> from FullNames
Transforming FullNames... 
Abc finished on Thu Jun 24 08:22:29 BST 2004. ( 0 min. 8 sec. )
PASS: Fully-qual'ed names with same start as variable names()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 13 failed (check: 0), 83 passed (check: 0), 0 skipped.
Executing test 97 (pureJava): Fully qualifying inner classes within annonymous classes causes problems.
================================================
Breakdown of abc phases  (total: 6887 millisec.)
------------------------------------------------
[ 00.566% ] Init. of Soot:  39
[ 00.044% ] Loading Jars:  3
[ 77.363% ] Polyglot phases:  5328
[ 00.015% ] Resolve class names:  1
[ 00.015% ] Declare Parents:  1
[ 00.755% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.566% ] Intertype Adjuster:  39
[ 12.662% ] Retrieving bodies:  872
[ 00.000% ] Weave Initializers:  0
[ 00.334% ] Load shadow types:  23
[ 01.379% ] Compute advice lists:  95
[ 00.044% ] Intertype weave:  3
[ 00.131% ] Add aspect code:  9
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.890% ] Soot Packs:  199
[ 03.049% ] Soot Writing Output:  210
================================================
Abc started on Thu Jun 24 08:22:32 BST 2004
<<<< InnerClassesInAnnonymousClasses.java >>>>
public class InnerClassesInAnnonymousClasses {
    public static void main(java.lang.String[] args) {
        new InnerClassesInAnnonymousClasses().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        new java.lang.Runnable() {
            public void run() {  }
            
            class Inner {}
            
            
            Inner inner = new Inner();
        };
    }
    
    public InnerClassesInAnnonymousClasses() { super(); }
}
retrieve <InnerClassesInAnnonymousClasses: void main(java.lang.String[])> from InnerClassesInAnnonymousClasses
retrieve <InnerClassesInAnnonymousClasses: void realMain(java.lang.String[])> from InnerClassesInAnnonymousClasses
retrieve <InnerClassesInAnnonymousClasses: void <init>()> from InnerClassesInAnnonymousClasses
retrieve <InnerClassesInAnnonymousClasses$1: void <init>(InnerClassesInAnnonymousClasses)> from InnerClassesInAnnonymousClasses$1
retrieve <InnerClassesInAnnonymousClasses$1: void run()> from InnerClassesInAnnonymousClasses$1
retrieve <InnerClassesInAnnonymousClasses$1$Inner: void <init>(InnerClassesInAnnonymousClasses$1)> from InnerClassesInAnnonymousClasses$1$Inner
retrieve <InnerClassesInAnnonymousClasses$1$Inner: void <init>(InnerClassesInAnnonymousClasses$1)> from InnerClassesInAnnonymousClasses$1$Inner
Transforming InnerClassesInAnnonymousClasses... 
Transforming InnerClassesInAnnonymousClasses$1... 
Transforming InnerClassesInAnnonymousClasses$1$Inner... 
Abc finished on Thu Jun 24 08:22:39 BST 2004. ( 0 min. 6 sec. )
PASS: Fully qualifying inner classes within annonymous classes causes problems.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 13 failed (check: 0), 84 passed (check: 0), 0 skipped.
Executing test 98 (pureJava): Calls to methods in outer annonymous classes are being qual's incorrectly with 'this'
================================================
Breakdown of abc phases  (total: 8347 millisec.)
------------------------------------------------
[ 00.443% ] Init. of Soot:  37
[ 00.048% ] Loading Jars:  4
[ 70.025% ] Polyglot phases:  5845
[ 00.000% ] Resolve class names:  0
[ 00.024% ] Declare Parents:  2
[ 00.695% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 05.643% ] Intertype Adjuster:  471
[ 06.374% ] Retrieving bodies:  532
[ 00.000% ] Weave Initializers:  0
[ 00.264% ] Load shadow types:  22
[ 09.632% ] Compute advice lists:  804
[ 00.060% ] Intertype weave:  5
[ 00.108% ] Add aspect code:  9
[ 00.216% ] Weaving advice:  18
[ 00.012% ] Validate jimple:  1
[ 03.486% ] Soot Packs:  291
[ 02.971% ] Soot Writing Output:  248
================================================
Abc started on Thu Jun 24 08:22:41 BST 2004
<<<< MisplacedThisInAnnonymousInnerClasses.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class MisplacedThisInAnnonymousInnerClasses {
    public static void main(java.lang.String[] args) {
        new MisplacedThisInAnnonymousInnerClasses().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("run0");
        org.aspectj.testing.Tester.expectEvent("run1");
        org.aspectj.testing.Tester.expectEvent("run2");
        org.aspectj.testing.Tester.expectEvent("run3");
        org.aspectj.testing.Tester.expectEvent("outer0");
        org.aspectj.testing.Tester.expectEvent("outer1");
        org.aspectj.testing.Tester.expectEvent("outer2");
        new java.lang.Runnable() {
            public void outer(int i) { Tester.event("outer" + i); }
            
            public void run() {
                Tester.event("run0");
                new Runnable() {
                    public void run() {
                        Tester.event("run1");
                        outer(0);
                        new Runnable() {
                            public void run() {
                                Tester.event("run2");
                                outer(1);
                                new Runnable() {
                                    public void run() {
                                        Tester.event("run3");
                                        outer(2);
                                    }
                                }.run();
                            }
                        }.run();
                    }
                }.run();
            }
        }.run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public MisplacedThisInAnnonymousInnerClasses() { super(); }
}
retrieve <MisplacedThisInAnnonymousInnerClasses: void main(java.lang.String[])> from MisplacedThisInAnnonymousInnerClasses
retrieve <MisplacedThisInAnnonymousInnerClasses: void realMain(java.lang.String[])> from MisplacedThisInAnnonymousInnerClasses
retrieve <MisplacedThisInAnnonymousInnerClasses: void <init>()> from MisplacedThisInAnnonymousInnerClasses
retrieve <MisplacedThisInAnnonymousInnerClasses$1: void <init>(MisplacedThisInAnnonymousInnerClasses)> from MisplacedThisInAnnonymousInnerClasses$1
retrieve <MisplacedThisInAnnonymousInnerClasses$1: void outer(int)> from MisplacedThisInAnnonymousInnerClasses$1
retrieve <MisplacedThisInAnnonymousInnerClasses$1: void run()> from MisplacedThisInAnnonymousInnerClasses$1
retrieve <MisplacedThisInAnnonymousInnerClasses$2: void <init>(MisplacedThisInAnnonymousInnerClasses$1)> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$2: void run()> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void <init>(MisplacedThisInAnnonymousInnerClasses$2)> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void run()> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void <init>(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void run()> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$2: void <init>(MisplacedThisInAnnonymousInnerClasses$1)> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$2: MisplacedThisInAnnonymousInnerClasses$1 access$000(MisplacedThisInAnnonymousInnerClasses$2)> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$2: void run()> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$2: MisplacedThisInAnnonymousInnerClasses$1 access$200(MisplacedThisInAnnonymousInnerClasses$2)> from MisplacedThisInAnnonymousInnerClasses$2
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void <init>(MisplacedThisInAnnonymousInnerClasses$2)> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void run()> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$3: MisplacedThisInAnnonymousInnerClasses$2 access$100(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void <init>(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void run()> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void <init>(MisplacedThisInAnnonymousInnerClasses$2)> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$3: void run()> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$3: MisplacedThisInAnnonymousInnerClasses$2 access$100(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$3
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void <init>(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void run()> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void <init>(MisplacedThisInAnnonymousInnerClasses$3)> from MisplacedThisInAnnonymousInnerClasses$4
retrieve <MisplacedThisInAnnonymousInnerClasses$4: void run()> from MisplacedThisInAnnonymousInnerClasses$4
Transforming MisplacedThisInAnnonymousInnerClasses... 
Transforming MisplacedThisInAnnonymousInnerClasses$1... 
Transforming MisplacedThisInAnnonymousInnerClasses$2... 
Transforming MisplacedThisInAnnonymousInnerClasses$3... 
Transforming MisplacedThisInAnnonymousInnerClasses$4... 
Abc finished on Thu Jun 24 08:22:50 BST 2004. ( 0 min. 8 sec. )
PASS: Calls to methods in outer annonymous classes are being qual's incorrectl...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 13 failed (check: 0), 85 passed (check: 0), 0 skipped.
Executing test 99 (pureJava/innersFromSourceAndBytecode): Reading inner classes from source and bytecode (1) -- was failing
================================================
Breakdown of abc phases  (total: 9962 millisec.)
------------------------------------------------
[ 00.381% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  4
[ 63.090% ] Polyglot phases:  6285
[ 00.010% ] Resolve class names:  1
[ 00.020% ] Declare Parents:  2
[ 00.331% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.632% ] Intertype Adjuster:  63
[ 11.965% ] Retrieving bodies:  1192
[ 00.000% ] Weave Initializers:  0
[ 00.221% ] Load shadow types:  22
[ 14.927% ] Compute advice lists:  1487
[ 00.030% ] Intertype weave:  3
[ 00.080% ] Add aspect code:  8
[ 00.151% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.608% ] Soot Packs:  459
[ 03.513% ] Soot Writing Output:  350
================================================
================================================
Breakdown of abc phases  (total: 7394 millisec.)
------------------------------------------------
[ 00.000% ] Init. of Soot:  0
[ 00.000% ] Loading Jars:  0
[ 49.324% ] Polyglot phases:  3647
[ 00.000% ] Resolve class names:  0
[ 00.000% ] Declare Parents:  0
[ 00.500% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 00.149% ] Intertype Adjuster:  11
[ 03.300% ] Retrieving bodies:  244
[ 00.000% ] Weave Initializers:  0
[ 00.000% ] Load shadow types:  0
[ 38.518% ] Compute advice lists:  2848
[ 00.000% ] Intertype weave:  0
[ 00.000% ] Add aspect code:  0
[ 00.054% ] Weaving advice:  4
[ 00.000% ] Validate jimple:  0
[ 04.382% ] Soot Packs:  324
[ 03.773% ] Soot Writing Output:  279
================================================
Abc started on Thu Jun 24 08:22:52 BST 2004
<<<< C.java >>>>
import org.aspectj.testing.Tester;

public class C {
    public void c() { a("C.c()"); }
    
    public void c(C c) { a("C.c(C)"); }
    
    public void c(C c, C.I i) { a("C.c(C,I)"); }
    
    public void c(C c, C.I.J ij) { a("C.c(C,I$J)"); }
    
    public void c(C c, C.I.J.K ijk) { a("C.c(C,I$J$K)"); }
    
    public void c(C c, C.I i, C.I.J ij) { a("C.c(C,I,I$J)"); }
    
    public void c(C c, C.I i, C.I.J.K ijk) { a("C.c(C,I,I$J$K)"); }
    
    public void c(C c, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I$J,I$J$K)");
    }
    
    public void c(C c, C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I,I$J,I$J$K)");
    }
    
    public void c(C.I i) { a("C.c(I)"); }
    
    public void c(C.I.J ij) { a("C.c(I$J)"); }
    
    public void c(C.I.J.K ijk) { a("C.c(I$J$K)"); }
    
    public void c(C.I i, C.I.J ij) { a("C.c(I,I$J)"); }
    
    public void c(C.I i, C.I.J.K ijk) { a("C.c(I,I$J$K)"); }
    
    public void c(C.I.J ij, C.I.J.K ijk) { a("C.c(I$J,I$J$K)"); }
    
    public void c(C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(I,I$J,I$J$K)");
    }
    
    public static class I {
        public void i() { a("C$I.i()"); }
        
        public void i(C c) { a("C$I.i(C)"); }
        
        public void i(C c, C.I i) { a("C$I.i(C,I)"); }
        
        public void i(C c, C.I.J j) { a("C$I.i(C,J)"); }
        
        public void i(C c, C.I.J.K jk) { a("C$I.i(C,J$K)"); }
        
        public void i(C c, C.I i, C.I.J j) { a("C$I.i(C,I,J)"); }
        
        public void i(C c, C.I i, C.I.J.K jk) { a("C$I.i(C,I,J$K)"); }
        
        public void i(C c, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,J,J$K)");
        }
        
        public void i(C c, C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,I,J,J$K)");
        }
        
        public void i(C.I i) { a("C$I.i(I)"); }
        
        public void i(C.I.J j) { a("C$I.i(J)"); }
        
        public void i(C.I.J.K jk) { a("C$I.i(J$K)"); }
        
        public void i(C.I i, C.I.J j) { a("C$I.i(I,J)"); }
        
        public void i(C.I i, C.I.J.K jk) { a("C$I.i(I,J$K)"); }
        
        public void i(C.I.J j, C.I.J.K jk) { a("C$I.i(J,J$K)"); }
        
        public void i(C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(I,J,J$K)");
        }
        
        public static class J {
            public void j() { a("C$I$J.j()"); }
            
            public void j(C c) { a("C$I$J.j(C)"); }
            
            public void j(C c, C.I i) { a("C$I$J.j(C,I)"); }
            
            public void j(C c, C.I.J j) { a("C$I$J.j(C,J)"); }
            
            public void j(C c, C.I.J.K k) { a("C$I$J.j(C,K)"); }
            
            public void j(C c, C.I i, C.I.J j) {
                a("C$I$J.j(C,I,J)");
            }
            
            public void j(C c, C.I i, C.I.J.K k) {
                a("C$I$J.j(C,I,K)");
            }
            
            public void j(C c, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,J,K)");
            }
            
            public void j(C c, C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,I,J,K)");
            }
            
            public void j(C.I i) { a("C$I$J.j(I)"); }
            
            public void j(C.I.J j) { a("C$I$J.j(J)"); }
            
            public void j(C.I.J.K k) { a("C$I$J.j(K)"); }
            
            public void j(C.I i, C.I.J j) { a("C$I$J.j(I,J)"); }
            
            public void j(C.I i, C.I.J.K k) { a("C$I$J.j(I,K)"); }
            
            public void j(C.I.J j, C.I.J.K k) { a("C$I$J.j(J,K)"); }
            
            public void j(C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(I,J,K)");
            }
            
            public static class K {
                public void k() { a("C$I$J$K.k()"); }
                
                public void k(C c) { a("C$I$J$K.k(C)"); }
                
                public void k(C c, C.I i) { a("C$I$J$K.k(C,I)"); }
                
                public void k(C c, C.I.J j) { a("C$I$J$K.k(C,J)"); }
                
                public void k(C c, C.I.J.K k) { a("C$I$J$K.k(C,K)"); }
                
                public void k(C c, C.I i, C.I.J j) {
                    a("C$I$J$K.k(C,I,J)");
                }
                
                public void k(C c, C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,K)");
                }
                
                public void k(C c, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,J,K)");
                }
                
                public void k(C c, C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,J,K)");
                }
                
                public void k(C.I i) { a("C$I$J$K.k(I)"); }
                
                public void k(C.I.J j) { a("C$I$J$K.k(J)"); }
                
                public void k(C.I.J.K k) { a("C$I$J$K.k(K)"); }
                
                public void k(C.I i, C.I.J j) { a("C$I$J$K.k(I,J)"); }
                
                public void k(C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(I,K)");
                }
                
                public void k(C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(J,K)");
                }
                
                public void k(C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(I,J,K)");
                }
                
                public K() { super(); }
            }
            
            
            public J() { super(); }
        }
        
        
        public I() { super(); }
    }
    
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public C() { super(); }
}
<<<< D.java >>>>
import org.aspectj.testing.Tester;

public class D {
    public void d() { a("D.d()"); }
    
    public void d(C c) { a("D.d(C)"); }
    
    public void d(C c, C.I ci) { a("D.d(C,C$I)"); }
    
    public void d(C c, C.I.J cij) { a("D.d(C,C$I$J)"); }
    
    public void d(C c, C.I.J.K cijk) { a("D.d(C,C$I$J$K)"); }
    
    public void d(C c, C.I ci, C.I.J cij) { a("D.d(C,C$I,C$I$J)"); }
    
    public void d(C c, C.I ci, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J$K)");
    }
    
    public void d(C c, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I$J,C$I$J$K)");
    }
    
    public void d(C c, C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci) { a("D.d(C$I)"); }
    
    public void d(C.I.J cij) { a("D.d(C$I$J)"); }
    
    public void d(C.I.J.K cijk) { a("D.d(C$I$J$K)"); }
    
    public void d(C.I ci, C.I.J cij) { a("D.d(C$I,C$I$J)"); }
    
    public void d(C.I ci, C.I.J.K cijk) { a("D.d(C$I,C$I$J$K)"); }
    
    public void d(C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I,C$I$J,C$I$J$K)");
    }
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public D() { super(); }
}
retrieve <C: void c(C$I,C$I$J$K)> from C
retrieve <C: void c(C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void a(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C: void c(C)> from C
retrieve <C: void c(C,C$I)> from C
retrieve <C: void c(C,C$I$J)> from C
retrieve <C: void c(C,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J)> from C
retrieve <C: void c(C,C$I,C$I$J$K)> from C
retrieve <C: void c(C,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I)> from C
retrieve <C: void c(C$I$J)> from C
retrieve <C: void c(C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J)> from C
retrieve <C$I: void i()> from C$I
retrieve <C$I: void i(C)> from C$I
retrieve <C$I: void i(C,C$I)> from C$I
retrieve <C$I: void i(C,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I)> from C$I
retrieve <C$I: void i(C$I$J)> from C$I
retrieve <C$I: void i(C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J)> from C$I
retrieve <C$I: void i(C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void <init>()> from C$I
retrieve <C$I$J: void j(C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void <init>()> from C$I$J
retrieve <C$I$J: void j()> from C$I$J
retrieve <C$I$J: void j(C)> from C$I$J
retrieve <C$I$J: void j(C,C$I)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I)> from C$I$J
retrieve <C$I$J: void j(C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J)> from C$I$J
retrieve <C$I$J$K: void k()> from C$I$J$K
retrieve <C$I$J$K: void k(C)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void <init>()> from C$I$J$K
retrieve <D: void d()> from D
retrieve <D: void d(C)> from D
retrieve <D: void d(C,C$I)> from D
retrieve <D: void d(C,C$I$J)> from D
retrieve <D: void d(C,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J)> from D
retrieve <D: void d(C,C$I,C$I$J$K)> from D
retrieve <D: void d(C,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I)> from D
retrieve <D: void d(C$I$J)> from D
retrieve <D: void d(C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J)> from D
retrieve <D: void d(C$I,C$I$J$K)> from D
retrieve <D: void d(C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void a(java.lang.String)> from D
retrieve <D: void <init>()> from D
Transforming D... 
Transforming C... 
Transforming C$I... 
Transforming C$I$J... 
Transforming C$I$J$K... 
Abc finished on Thu Jun 24 08:23:02 BST 2004. ( 0 min. 10 sec. )
Abc started on Thu Jun 24 08:23:02 BST 2004
<<<< Main.java >>>>
import org.aspectj.testing.Tester;

public class Main {
    public static void main(java.lang.String[] args) {
        new Main().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        m("D.d()");
        m("D.d(C)");
        m("D.d(C,C$I)");
        m("D.d(C,C$I$J)");
        m("D.d(C,C$I$J$K)");
        m("D.d(C,C$I,C$I$J)");
        m("D.d(C,C$I,C$I$J$K)");
        m("D.d(C,C$I$J,C$I$J$K)");
        m("D.d(C,C$I,C$I$J,C$I$J$K)");
        m("D.d(C$I)");
        m("D.d(C$I$J)");
        m("D.d(C$I$J$K)");
        m("D.d(C$I,C$I$J)");
        m("D.d(C$I,C$I$J$K)");
        m("D.d(C$I$J,C$I$J$K)");
        m("D.d(C$I,C$I$J,C$I$J$K)");
        m("C.c()");
        m("C.c(C)");
        m("C.c(C,I)");
        m("C.c(C,I$J)");
        m("C.c(C,I$J$K)");
        m("C.c(C,I,I$J)");
        m("C.c(C,I,I$J$K)");
        m("C.c(C,I$J,I$J$K)");
        m("C.c(C,I,I$J,I$J$K)");
        m("C.c(I)");
        m("C.c(I$J)");
        m("C.c(I$J$K)");
        m("C.c(I,I$J)");
        m("C.c(I,I$J$K)");
        m("C.c(I$J,I$J$K)");
        m("C.c(I,I$J,I$J$K)");
        m("C$I.i()");
        m("C$I.i(C)");
        m("C$I.i(C,I)");
        m("C$I.i(C,J)");
        m("C$I.i(C,J$K)");
        m("C$I.i(C,I,J)");
        m("C$I.i(C,I,J$K)");
        m("C$I.i(C,J,J$K)");
        m("C$I.i(C,I,J,J$K)");
        m("C$I.i(I)");
        m("C$I.i(J)");
        m("C$I.i(J$K)");
        m("C$I.i(I,J)");
        m("C$I.i(I,J$K)");
        m("C$I.i(J,J$K)");
        m("C$I.i(I,J,J$K)");
        m("C$I$J.j()");
        m("C$I$J.j(C)");
        m("C$I$J.j(C,I)");
        m("C$I$J.j(C,J)");
        m("C$I$J.j(C,K)");
        m("C$I$J.j(C,I,J)");
        m("C$I$J.j(C,I,K)");
        m("C$I$J.j(C,J,K)");
        m("C$I$J.j(C,I,J,K)");
        m("C$I$J.j(I)");
        m("C$I$J.j(J)");
        m("C$I$J.j(K)");
        m("C$I$J.j(I,J)");
        m("C$I$J.j(I,K)");
        m("C$I$J.j(J,K)");
        m("C$I$J.j(I,J,K)");
        m("C$I$J$K.k()");
        m("C$I$J$K.k(C)");
        m("C$I$J$K.k(C,I)");
        m("C$I$J$K.k(C,J)");
        m("C$I$J$K.k(C,K)");
        m("C$I$J$K.k(C,I,J)");
        m("C$I$J$K.k(C,I,K)");
        m("C$I$J$K.k(C,J,K)");
        m("C$I$J$K.k(C,I,J,K)");
        m("C$I$J$K.k(I)");
        m("C$I$J$K.k(J)");
        m("C$I$J$K.k(K)");
        m("C$I$J$K.k(I,J)");
        m("C$I$J$K.k(I,K)");
        m("C$I$J$K.k(J,K)");
        m("C$I$J$K.k(I,J,K)");
        D d = new D();
        C c = new C();
        C.I ci = new C.I();
        C.I.J cij = new C.I.J();
        C.I.J.K cijk = new C.I.J.K();
        d.d();
        d.d(c);
        d.d(c, ci);
        d.d(c, cij);
        d.d(c, cijk);
        d.d(c, ci, cij);
        d.d(c, ci, cijk);
        d.d(c, cij, cijk);
        d.d(c, ci, cij, cijk);
        d.d(ci);
        d.d(cij);
        d.d(cijk);
        d.d(ci, cij);
        d.d(ci, cijk);
        d.d(cij, cijk);
        d.d(ci, cij, cijk);
        c.c();
        c.c(c);
        c.c(c, ci);
        c.c(c, cij);
        c.c(c, cijk);
        c.c(c, ci, cij);
        c.c(c, ci, cijk);
        c.c(c, cij, cijk);
        c.c(c, ci, cij, cijk);
        c.c(ci);
        c.c(cij);
        c.c(cijk);
        c.c(ci, cij);
        c.c(ci, cijk);
        c.c(cij, cijk);
        c.c(ci, cij, cijk);
        ci.i();
        ci.i(c);
        ci.i(c, ci);
        ci.i(c, cij);
        ci.i(c, cijk);
        ci.i(c, ci, cij);
        ci.i(c, ci, cijk);
        ci.i(c, cij, cijk);
        ci.i(c, ci, cij, cijk);
        ci.i(ci);
        ci.i(cij);
        ci.i(cijk);
        ci.i(ci, cij);
        ci.i(ci, cijk);
        ci.i(cij, cijk);
        ci.i(ci, cij, cijk);
        cij.j();
        cij.j(c);
        cij.j(c, ci);
        cij.j(c, cij);
        cij.j(c, cijk);
        cij.j(c, ci, cij);
        cij.j(c, ci, cijk);
        cij.j(c, cij, cijk);
        cij.j(c, ci, cij, cijk);
        cij.j(ci);
        cij.j(cij);
        cij.j(cijk);
        cij.j(ci, cij);
        cij.j(ci, cijk);
        cij.j(cij, cijk);
        cij.j(ci, cij, cijk);
        cijk.k();
        cijk.k(c);
        cijk.k(c, ci);
        cijk.k(c, cij);
        cijk.k(c, cijk);
        cijk.k(c, ci, cij);
        cijk.k(c, ci, cijk);
        cijk.k(c, cij, cijk);
        cijk.k(c, ci, cij, cijk);
        cijk.k(ci);
        cijk.k(cij);
        cijk.k(cijk);
        cijk.k(ci, cij);
        cijk.k(ci, cijk);
        cijk.k(cij, cijk);
        cijk.k(ci, cij, cijk);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void m(java.lang.String msg) {
        org.aspectj.testing.Tester.expectEvent(msg);
    }
    
    public Main() { super(); }
}
<<<< C.java >>>>
import org.aspectj.testing.Tester;

public class C {
    public void c() { a("C.c()"); }
    
    public void c(C c) { a("C.c(C)"); }
    
    public void c(C c, C.I i) { a("C.c(C,I)"); }
    
    public void c(C c, C.I.J ij) { a("C.c(C,I$J)"); }
    
    public void c(C c, C.I.J.K ijk) { a("C.c(C,I$J$K)"); }
    
    public void c(C c, C.I i, C.I.J ij) { a("C.c(C,I,I$J)"); }
    
    public void c(C c, C.I i, C.I.J.K ijk) { a("C.c(C,I,I$J$K)"); }
    
    public void c(C c, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I$J,I$J$K)");
    }
    
    public void c(C c, C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I,I$J,I$J$K)");
    }
    
    public void c(C.I i) { a("C.c(I)"); }
    
    public void c(C.I.J ij) { a("C.c(I$J)"); }
    
    public void c(C.I.J.K ijk) { a("C.c(I$J$K)"); }
    
    public void c(C.I i, C.I.J ij) { a("C.c(I,I$J)"); }
    
    public void c(C.I i, C.I.J.K ijk) { a("C.c(I,I$J$K)"); }
    
    public void c(C.I.J ij, C.I.J.K ijk) { a("C.c(I$J,I$J$K)"); }
    
    public void c(C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(I,I$J,I$J$K)");
    }
    
    public static class I {
        public void i() { a("C$I.i()"); }
        
        public void i(C c) { a("C$I.i(C)"); }
        
        public void i(C c, C.I i) { a("C$I.i(C,I)"); }
        
        public void i(C c, C.I.J j) { a("C$I.i(C,J)"); }
        
        public void i(C c, C.I.J.K jk) { a("C$I.i(C,J$K)"); }
        
        public void i(C c, C.I i, C.I.J j) { a("C$I.i(C,I,J)"); }
        
        public void i(C c, C.I i, C.I.J.K jk) { a("C$I.i(C,I,J$K)"); }
        
        public void i(C c, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,J,J$K)");
        }
        
        public void i(C c, C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,I,J,J$K)");
        }
        
        public void i(C.I i) { a("C$I.i(I)"); }
        
        public void i(C.I.J j) { a("C$I.i(J)"); }
        
        public void i(C.I.J.K jk) { a("C$I.i(J$K)"); }
        
        public void i(C.I i, C.I.J j) { a("C$I.i(I,J)"); }
        
        public void i(C.I i, C.I.J.K jk) { a("C$I.i(I,J$K)"); }
        
        public void i(C.I.J j, C.I.J.K jk) { a("C$I.i(J,J$K)"); }
        
        public void i(C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(I,J,J$K)");
        }
        
        public static class J {
            public void j() { a("C$I$J.j()"); }
            
            public void j(C c) { a("C$I$J.j(C)"); }
            
            public void j(C c, C.I i) { a("C$I$J.j(C,I)"); }
            
            public void j(C c, C.I.J j) { a("C$I$J.j(C,J)"); }
            
            public void j(C c, C.I.J.K k) { a("C$I$J.j(C,K)"); }
            
            public void j(C c, C.I i, C.I.J j) {
                a("C$I$J.j(C,I,J)");
            }
            
            public void j(C c, C.I i, C.I.J.K k) {
                a("C$I$J.j(C,I,K)");
            }
            
            public void j(C c, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,J,K)");
            }
            
            public void j(C c, C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,I,J,K)");
            }
            
            public void j(C.I i) { a("C$I$J.j(I)"); }
            
            public void j(C.I.J j) { a("C$I$J.j(J)"); }
            
            public void j(C.I.J.K k) { a("C$I$J.j(K)"); }
            
            public void j(C.I i, C.I.J j) { a("C$I$J.j(I,J)"); }
            
            public void j(C.I i, C.I.J.K k) { a("C$I$J.j(I,K)"); }
            
            public void j(C.I.J j, C.I.J.K k) { a("C$I$J.j(J,K)"); }
            
            public void j(C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(I,J,K)");
            }
            
            public static class K {
                public void k() { a("C$I$J$K.k()"); }
                
                public void k(C c) { a("C$I$J$K.k(C)"); }
                
                public void k(C c, C.I i) { a("C$I$J$K.k(C,I)"); }
                
                public void k(C c, C.I.J j) { a("C$I$J$K.k(C,J)"); }
                
                public void k(C c, C.I.J.K k) { a("C$I$J$K.k(C,K)"); }
                
                public void k(C c, C.I i, C.I.J j) {
                    a("C$I$J$K.k(C,I,J)");
                }
                
                public void k(C c, C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,K)");
                }
                
                public void k(C c, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,J,K)");
                }
                
                public void k(C c, C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,J,K)");
                }
                
                public void k(C.I i) { a("C$I$J$K.k(I)"); }
                
                public void k(C.I.J j) { a("C$I$J$K.k(J)"); }
                
                public void k(C.I.J.K k) { a("C$I$J$K.k(K)"); }
                
                public void k(C.I i, C.I.J j) { a("C$I$J$K.k(I,J)"); }
                
                public void k(C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(I,K)");
                }
                
                public void k(C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(J,K)");
                }
                
                public void k(C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(I,J,K)");
                }
                
                public K() { super(); }
            }
            
            
            public J() { super(); }
        }
        
        
        public I() { super(); }
    }
    
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public C() { super(); }
}
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void realMain(java.lang.String[])> from Main
retrieve <Main: void m(java.lang.String)> from Main
retrieve <Main: void <init>()> from Main
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C: void c(C)> from C
retrieve <C: void c(C,C$I)> from C
retrieve <C: void c(C,C$I$J)> from C
retrieve <C: void c(C,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J)> from C
retrieve <C: void c(C,C$I,C$I$J$K)> from C
retrieve <C: void c(C,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I)> from C
retrieve <C: void c(C$I$J)> from C
retrieve <C: void c(C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J)> from C
retrieve <C: void c(C$I,C$I$J$K)> from C
retrieve <C: void c(C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void a(java.lang.String)> from C
retrieve <C$I: void i(C$I)> from C$I
retrieve <C$I: void i(C$I$J)> from C$I
retrieve <C$I: void i(C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J)> from C$I
retrieve <C$I: void i(C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void <init>()> from C$I
retrieve <C$I: void i()> from C$I
retrieve <C$I: void i(C)> from C$I
retrieve <C$I: void i(C,C$I)> from C$I
retrieve <C$I: void i(C,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I$J: void <init>()> from C$I$J
retrieve <C$I$J: void j()> from C$I$J
retrieve <C$I$J: void j(C)> from C$I$J
retrieve <C$I$J: void j(C,C$I)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I)> from C$I$J
retrieve <C$I$J: void j(C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J$K: void k(C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void <init>()> from C$I$J$K
retrieve <C$I$J$K: void k()> from C$I$J$K
retrieve <C$I$J$K: void k(C)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J,C$I$J$K)> from C$I$J$K
Transforming Main... 
Transforming C... 
Transforming C$I... 
Transforming C$I$J... 
Transforming C$I$J$K... 
Abc finished on Thu Jun 24 08:23:10 BST 2004. ( 0 min. 7 sec. )
PASS: Reading inner classes from source and bytecode (1) -- was failing()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 18 seconds
Passed. Current status: 13 failed (check: 0), 86 passed (check: 0), 0 skipped.
Executing test 100 (pureJava/innersFromSourceAndBytecode): Reading inner classes from source and bytecode (2)
================================================
Breakdown of abc phases  (total: 12933 millisec.)
------------------------------------------------
[ 00.294% ] Init. of Soot:  38
[ 00.023% ] Loading Jars:  3
[ 54.898% ] Polyglot phases:  7100
[ 00.000% ] Resolve class names:  0
[ 00.015% ] Declare Parents:  2
[ 00.271% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.495% ] Intertype Adjuster:  64
[ 10.833% ] Retrieving bodies:  1401
[ 00.008% ] Weave Initializers:  1
[ 00.178% ] Load shadow types:  23
[ 24.488% ] Compute advice lists:  3167
[ 00.023% ] Intertype weave:  3
[ 00.070% ] Add aspect code:  9
[ 00.116% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.392% ] Soot Packs:  568
[ 03.897% ] Soot Writing Output:  504
================================================
Abc started on Thu Jun 24 08:23:12 BST 2004
<<<< Main.java >>>>
import org.aspectj.testing.Tester;

public class Main {
    public static void main(java.lang.String[] args) {
        new Main().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        m("D.d()");
        m("D.d(C)");
        m("D.d(C,C$I)");
        m("D.d(C,C$I$J)");
        m("D.d(C,C$I$J$K)");
        m("D.d(C,C$I,C$I$J)");
        m("D.d(C,C$I,C$I$J$K)");
        m("D.d(C,C$I$J,C$I$J$K)");
        m("D.d(C,C$I,C$I$J,C$I$J$K)");
        m("D.d(C$I)");
        m("D.d(C$I$J)");
        m("D.d(C$I$J$K)");
        m("D.d(C$I,C$I$J)");
        m("D.d(C$I,C$I$J$K)");
        m("D.d(C$I$J,C$I$J$K)");
        m("D.d(C$I,C$I$J,C$I$J$K)");
        m("C.c()");
        m("C.c(C)");
        m("C.c(C,I)");
        m("C.c(C,I$J)");
        m("C.c(C,I$J$K)");
        m("C.c(C,I,I$J)");
        m("C.c(C,I,I$J$K)");
        m("C.c(C,I$J,I$J$K)");
        m("C.c(C,I,I$J,I$J$K)");
        m("C.c(I)");
        m("C.c(I$J)");
        m("C.c(I$J$K)");
        m("C.c(I,I$J)");
        m("C.c(I,I$J$K)");
        m("C.c(I$J,I$J$K)");
        m("C.c(I,I$J,I$J$K)");
        m("C$I.i()");
        m("C$I.i(C)");
        m("C$I.i(C,I)");
        m("C$I.i(C,J)");
        m("C$I.i(C,J$K)");
        m("C$I.i(C,I,J)");
        m("C$I.i(C,I,J$K)");
        m("C$I.i(C,J,J$K)");
        m("C$I.i(C,I,J,J$K)");
        m("C$I.i(I)");
        m("C$I.i(J)");
        m("C$I.i(J$K)");
        m("C$I.i(I,J)");
        m("C$I.i(I,J$K)");
        m("C$I.i(J,J$K)");
        m("C$I.i(I,J,J$K)");
        m("C$I$J.j()");
        m("C$I$J.j(C)");
        m("C$I$J.j(C,I)");
        m("C$I$J.j(C,J)");
        m("C$I$J.j(C,K)");
        m("C$I$J.j(C,I,J)");
        m("C$I$J.j(C,I,K)");
        m("C$I$J.j(C,J,K)");
        m("C$I$J.j(C,I,J,K)");
        m("C$I$J.j(I)");
        m("C$I$J.j(J)");
        m("C$I$J.j(K)");
        m("C$I$J.j(I,J)");
        m("C$I$J.j(I,K)");
        m("C$I$J.j(J,K)");
        m("C$I$J.j(I,J,K)");
        m("C$I$J$K.k()");
        m("C$I$J$K.k(C)");
        m("C$I$J$K.k(C,I)");
        m("C$I$J$K.k(C,J)");
        m("C$I$J$K.k(C,K)");
        m("C$I$J$K.k(C,I,J)");
        m("C$I$J$K.k(C,I,K)");
        m("C$I$J$K.k(C,J,K)");
        m("C$I$J$K.k(C,I,J,K)");
        m("C$I$J$K.k(I)");
        m("C$I$J$K.k(J)");
        m("C$I$J$K.k(K)");
        m("C$I$J$K.k(I,J)");
        m("C$I$J$K.k(I,K)");
        m("C$I$J$K.k(J,K)");
        m("C$I$J$K.k(I,J,K)");
        D d = new D();
        C c = new C();
        C.I ci = new C.I();
        C.I.J cij = new C.I.J();
        C.I.J.K cijk = new C.I.J.K();
        d.d();
        d.d(c);
        d.d(c, ci);
        d.d(c, cij);
        d.d(c, cijk);
        d.d(c, ci, cij);
        d.d(c, ci, cijk);
        d.d(c, cij, cijk);
        d.d(c, ci, cij, cijk);
        d.d(ci);
        d.d(cij);
        d.d(cijk);
        d.d(ci, cij);
        d.d(ci, cijk);
        d.d(cij, cijk);
        d.d(ci, cij, cijk);
        c.c();
        c.c(c);
        c.c(c, ci);
        c.c(c, cij);
        c.c(c, cijk);
        c.c(c, ci, cij);
        c.c(c, ci, cijk);
        c.c(c, cij, cijk);
        c.c(c, ci, cij, cijk);
        c.c(ci);
        c.c(cij);
        c.c(cijk);
        c.c(ci, cij);
        c.c(ci, cijk);
        c.c(cij, cijk);
        c.c(ci, cij, cijk);
        ci.i();
        ci.i(c);
        ci.i(c, ci);
        ci.i(c, cij);
        ci.i(c, cijk);
        ci.i(c, ci, cij);
        ci.i(c, ci, cijk);
        ci.i(c, cij, cijk);
        ci.i(c, ci, cij, cijk);
        ci.i(ci);
        ci.i(cij);
        ci.i(cijk);
        ci.i(ci, cij);
        ci.i(ci, cijk);
        ci.i(cij, cijk);
        ci.i(ci, cij, cijk);
        cij.j();
        cij.j(c);
        cij.j(c, ci);
        cij.j(c, cij);
        cij.j(c, cijk);
        cij.j(c, ci, cij);
        cij.j(c, ci, cijk);
        cij.j(c, cij, cijk);
        cij.j(c, ci, cij, cijk);
        cij.j(ci);
        cij.j(cij);
        cij.j(cijk);
        cij.j(ci, cij);
        cij.j(ci, cijk);
        cij.j(cij, cijk);
        cij.j(ci, cij, cijk);
        cijk.k();
        cijk.k(c);
        cijk.k(c, ci);
        cijk.k(c, cij);
        cijk.k(c, cijk);
        cijk.k(c, ci, cij);
        cijk.k(c, ci, cijk);
        cijk.k(c, cij, cijk);
        cijk.k(c, ci, cij, cijk);
        cijk.k(ci);
        cijk.k(cij);
        cijk.k(cijk);
        cijk.k(ci, cij);
        cijk.k(ci, cijk);
        cijk.k(cij, cijk);
        cijk.k(ci, cij, cijk);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void m(java.lang.String msg) {
        org.aspectj.testing.Tester.expectEvent(msg);
    }
    
    public Main() { super(); }
}
<<<< C.java >>>>
import org.aspectj.testing.Tester;

public class C {
    public void c() { a("C.c()"); }
    
    public void c(C c) { a("C.c(C)"); }
    
    public void c(C c, C.I i) { a("C.c(C,I)"); }
    
    public void c(C c, C.I.J ij) { a("C.c(C,I$J)"); }
    
    public void c(C c, C.I.J.K ijk) { a("C.c(C,I$J$K)"); }
    
    public void c(C c, C.I i, C.I.J ij) { a("C.c(C,I,I$J)"); }
    
    public void c(C c, C.I i, C.I.J.K ijk) { a("C.c(C,I,I$J$K)"); }
    
    public void c(C c, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I$J,I$J$K)");
    }
    
    public void c(C c, C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I,I$J,I$J$K)");
    }
    
    public void c(C.I i) { a("C.c(I)"); }
    
    public void c(C.I.J ij) { a("C.c(I$J)"); }
    
    public void c(C.I.J.K ijk) { a("C.c(I$J$K)"); }
    
    public void c(C.I i, C.I.J ij) { a("C.c(I,I$J)"); }
    
    public void c(C.I i, C.I.J.K ijk) { a("C.c(I,I$J$K)"); }
    
    public void c(C.I.J ij, C.I.J.K ijk) { a("C.c(I$J,I$J$K)"); }
    
    public void c(C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(I,I$J,I$J$K)");
    }
    
    public static class I {
        public void i() { a("C$I.i()"); }
        
        public void i(C c) { a("C$I.i(C)"); }
        
        public void i(C c, C.I i) { a("C$I.i(C,I)"); }
        
        public void i(C c, C.I.J j) { a("C$I.i(C,J)"); }
        
        public void i(C c, C.I.J.K jk) { a("C$I.i(C,J$K)"); }
        
        public void i(C c, C.I i, C.I.J j) { a("C$I.i(C,I,J)"); }
        
        public void i(C c, C.I i, C.I.J.K jk) { a("C$I.i(C,I,J$K)"); }
        
        public void i(C c, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,J,J$K)");
        }
        
        public void i(C c, C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,I,J,J$K)");
        }
        
        public void i(C.I i) { a("C$I.i(I)"); }
        
        public void i(C.I.J j) { a("C$I.i(J)"); }
        
        public void i(C.I.J.K jk) { a("C$I.i(J$K)"); }
        
        public void i(C.I i, C.I.J j) { a("C$I.i(I,J)"); }
        
        public void i(C.I i, C.I.J.K jk) { a("C$I.i(I,J$K)"); }
        
        public void i(C.I.J j, C.I.J.K jk) { a("C$I.i(J,J$K)"); }
        
        public void i(C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(I,J,J$K)");
        }
        
        public static class J {
            public void j() { a("C$I$J.j()"); }
            
            public void j(C c) { a("C$I$J.j(C)"); }
            
            public void j(C c, C.I i) { a("C$I$J.j(C,I)"); }
            
            public void j(C c, C.I.J j) { a("C$I$J.j(C,J)"); }
            
            public void j(C c, C.I.J.K k) { a("C$I$J.j(C,K)"); }
            
            public void j(C c, C.I i, C.I.J j) {
                a("C$I$J.j(C,I,J)");
            }
            
            public void j(C c, C.I i, C.I.J.K k) {
                a("C$I$J.j(C,I,K)");
            }
            
            public void j(C c, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,J,K)");
            }
            
            public void j(C c, C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,I,J,K)");
            }
            
            public void j(C.I i) { a("C$I$J.j(I)"); }
            
            public void j(C.I.J j) { a("C$I$J.j(J)"); }
            
            public void j(C.I.J.K k) { a("C$I$J.j(K)"); }
            
            public void j(C.I i, C.I.J j) { a("C$I$J.j(I,J)"); }
            
            public void j(C.I i, C.I.J.K k) { a("C$I$J.j(I,K)"); }
            
            public void j(C.I.J j, C.I.J.K k) { a("C$I$J.j(J,K)"); }
            
            public void j(C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(I,J,K)");
            }
            
            public static class K {
                public void k() { a("C$I$J$K.k()"); }
                
                public void k(C c) { a("C$I$J$K.k(C)"); }
                
                public void k(C c, C.I i) { a("C$I$J$K.k(C,I)"); }
                
                public void k(C c, C.I.J j) { a("C$I$J$K.k(C,J)"); }
                
                public void k(C c, C.I.J.K k) { a("C$I$J$K.k(C,K)"); }
                
                public void k(C c, C.I i, C.I.J j) {
                    a("C$I$J$K.k(C,I,J)");
                }
                
                public void k(C c, C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,K)");
                }
                
                public void k(C c, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,J,K)");
                }
                
                public void k(C c, C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,J,K)");
                }
                
                public void k(C.I i) { a("C$I$J$K.k(I)"); }
                
                public void k(C.I.J j) { a("C$I$J$K.k(J)"); }
                
                public void k(C.I.J.K k) { a("C$I$J$K.k(K)"); }
                
                public void k(C.I i, C.I.J j) { a("C$I$J$K.k(I,J)"); }
                
                public void k(C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(I,K)");
                }
                
                public void k(C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(J,K)");
                }
                
                public void k(C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(I,J,K)");
                }
                
                public K() { super(); }
            }
            
            
            public J() { super(); }
        }
        
        
        public I() { super(); }
    }
    
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public C() { super(); }
}
<<<< D.java >>>>
import org.aspectj.testing.Tester;

public class D {
    public void d() { a("D.d()"); }
    
    public void d(C c) { a("D.d(C)"); }
    
    public void d(C c, C.I ci) { a("D.d(C,C$I)"); }
    
    public void d(C c, C.I.J cij) { a("D.d(C,C$I$J)"); }
    
    public void d(C c, C.I.J.K cijk) { a("D.d(C,C$I$J$K)"); }
    
    public void d(C c, C.I ci, C.I.J cij) { a("D.d(C,C$I,C$I$J)"); }
    
    public void d(C c, C.I ci, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J$K)");
    }
    
    public void d(C c, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I$J,C$I$J$K)");
    }
    
    public void d(C c, C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci) { a("D.d(C$I)"); }
    
    public void d(C.I.J cij) { a("D.d(C$I$J)"); }
    
    public void d(C.I.J.K cijk) { a("D.d(C$I$J$K)"); }
    
    public void d(C.I ci, C.I.J cij) { a("D.d(C$I,C$I$J)"); }
    
    public void d(C.I ci, C.I.J.K cijk) { a("D.d(C$I,C$I$J$K)"); }
    
    public void d(C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I,C$I$J,C$I$J$K)");
    }
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public D() { super(); }
}
retrieve <Main: void <init>()> from Main
retrieve <Main: void realMain(java.lang.String[])> from Main
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void m(java.lang.String)> from Main
retrieve <C: void c(C,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I)> from C
retrieve <C: void c(C$I$J)> from C
retrieve <C: void c(C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J)> from C
retrieve <C: void c(C$I,C$I$J$K)> from C
retrieve <C: void c(C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void a(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C: void c(C)> from C
retrieve <C: void c(C,C$I)> from C
retrieve <C: void c(C,C$I$J)> from C
retrieve <C: void c(C,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J)> from C
retrieve <C: void c(C,C$I,C$I$J$K)> from C
retrieve <C$I: void i()> from C$I
retrieve <C$I: void i(C)> from C$I
retrieve <C$I: void i(C,C$I)> from C$I
retrieve <C$I: void i(C,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I)> from C$I
retrieve <C$I: void i(C$I$J)> from C$I
retrieve <C$I: void i(C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J)> from C$I
retrieve <C$I: void i(C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void <init>()> from C$I
retrieve <C$I$J: void j(C,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I)> from C$I$J
retrieve <C$I$J: void j(C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void <init>()> from C$I$J
retrieve <C$I$J: void j()> from C$I$J
retrieve <C$I$J: void j(C)> from C$I$J
retrieve <C$I$J: void j(C,C$I)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J$K: void k()> from C$I$J$K
retrieve <C$I$J$K: void k(C)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void <init>()> from C$I$J$K
retrieve <D: void d()> from D
retrieve <D: void d(C)> from D
retrieve <D: void d(C,C$I)> from D
retrieve <D: void d(C,C$I$J)> from D
retrieve <D: void d(C,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J)> from D
retrieve <D: void d(C,C$I,C$I$J$K)> from D
retrieve <D: void d(C,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I)> from D
retrieve <D: void d(C$I$J)> from D
retrieve <D: void d(C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J)> from D
retrieve <D: void d(C$I,C$I$J$K)> from D
retrieve <D: void d(C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void a(java.lang.String)> from D
retrieve <D: void <init>()> from D
Transforming D... 
Transforming C... 
Transforming C$I... 
Transforming C$I$J... 
Transforming C$I$J$K... 
Transforming Main... 
Abc finished on Thu Jun 24 08:23:25 BST 2004. ( 0 min. 13 sec. )
PASS: Reading inner classes from source and bytecode (2)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 13 failed (check: 0), 87 passed (check: 0), 0 skipped.
Executing test 101 (pureJava/innersFromSourceAndBytecode): Reading inner classes from source and bytecode (3)
================================================
Breakdown of abc phases  (total: 9687 millisec.)
------------------------------------------------
[ 00.382% ] Init. of Soot:  37
[ 00.031% ] Loading Jars:  3
[ 65.077% ] Polyglot phases:  6304
[ 00.000% ] Resolve class names:  0
[ 00.021% ] Declare Parents:  2
[ 00.630% ] Recompute name pattern matches:  61
[ 00.000% ] Compute precedence relation:  0
[ 00.454% ] Intertype Adjuster:  44
[ 12.140% ] Retrieving bodies:  1176
[ 00.000% ] Weave Initializers:  0
[ 00.227% ] Load shadow types:  22
[ 12.346% ] Compute advice lists:  1196
[ 00.031% ] Intertype weave:  3
[ 00.083% ] Add aspect code:  8
[ 00.155% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.769% ] Soot Packs:  462
[ 03.654% ] Soot Writing Output:  354
================================================
================================================
Breakdown of abc phases  (total: 7736 millisec.)
------------------------------------------------
[ 00.000% ] Init. of Soot:  0
[ 00.000% ] Loading Jars:  0
[ 47.544% ] Polyglot phases:  3678
[ 00.013% ] Resolve class names:  1
[ 00.000% ] Declare Parents:  0
[ 00.220% ] Recompute name pattern matches:  17
[ 00.000% ] Compute precedence relation:  0
[ 00.155% ] Intertype Adjuster:  12
[ 03.400% ] Retrieving bodies:  263
[ 00.000% ] Weave Initializers:  0
[ 00.000% ] Load shadow types:  0
[ 39.969% ] Compute advice lists:  3092
[ 00.000% ] Intertype weave:  0
[ 00.000% ] Add aspect code:  0
[ 00.039% ] Weaving advice:  3
[ 00.000% ] Validate jimple:  0
[ 04.783% ] Soot Packs:  370
[ 03.878% ] Soot Writing Output:  300
================================================
Abc started on Thu Jun 24 08:23:28 BST 2004
<<<< C.java >>>>
import org.aspectj.testing.Tester;

public class C {
    public void c() { a("C.c()"); }
    
    public void c(C c) { a("C.c(C)"); }
    
    public void c(C c, C.I i) { a("C.c(C,I)"); }
    
    public void c(C c, C.I.J ij) { a("C.c(C,I$J)"); }
    
    public void c(C c, C.I.J.K ijk) { a("C.c(C,I$J$K)"); }
    
    public void c(C c, C.I i, C.I.J ij) { a("C.c(C,I,I$J)"); }
    
    public void c(C c, C.I i, C.I.J.K ijk) { a("C.c(C,I,I$J$K)"); }
    
    public void c(C c, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I$J,I$J$K)");
    }
    
    public void c(C c, C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I,I$J,I$J$K)");
    }
    
    public void c(C.I i) { a("C.c(I)"); }
    
    public void c(C.I.J ij) { a("C.c(I$J)"); }
    
    public void c(C.I.J.K ijk) { a("C.c(I$J$K)"); }
    
    public void c(C.I i, C.I.J ij) { a("C.c(I,I$J)"); }
    
    public void c(C.I i, C.I.J.K ijk) { a("C.c(I,I$J$K)"); }
    
    public void c(C.I.J ij, C.I.J.K ijk) { a("C.c(I$J,I$J$K)"); }
    
    public void c(C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(I,I$J,I$J$K)");
    }
    
    public static class I {
        public void i() { a("C$I.i()"); }
        
        public void i(C c) { a("C$I.i(C)"); }
        
        public void i(C c, C.I i) { a("C$I.i(C,I)"); }
        
        public void i(C c, C.I.J j) { a("C$I.i(C,J)"); }
        
        public void i(C c, C.I.J.K jk) { a("C$I.i(C,J$K)"); }
        
        public void i(C c, C.I i, C.I.J j) { a("C$I.i(C,I,J)"); }
        
        public void i(C c, C.I i, C.I.J.K jk) { a("C$I.i(C,I,J$K)"); }
        
        public void i(C c, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,J,J$K)");
        }
        
        public void i(C c, C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,I,J,J$K)");
        }
        
        public void i(C.I i) { a("C$I.i(I)"); }
        
        public void i(C.I.J j) { a("C$I.i(J)"); }
        
        public void i(C.I.J.K jk) { a("C$I.i(J$K)"); }
        
        public void i(C.I i, C.I.J j) { a("C$I.i(I,J)"); }
        
        public void i(C.I i, C.I.J.K jk) { a("C$I.i(I,J$K)"); }
        
        public void i(C.I.J j, C.I.J.K jk) { a("C$I.i(J,J$K)"); }
        
        public void i(C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(I,J,J$K)");
        }
        
        public static class J {
            public void j() { a("C$I$J.j()"); }
            
            public void j(C c) { a("C$I$J.j(C)"); }
            
            public void j(C c, C.I i) { a("C$I$J.j(C,I)"); }
            
            public void j(C c, C.I.J j) { a("C$I$J.j(C,J)"); }
            
            public void j(C c, C.I.J.K k) { a("C$I$J.j(C,K)"); }
            
            public void j(C c, C.I i, C.I.J j) {
                a("C$I$J.j(C,I,J)");
            }
            
            public void j(C c, C.I i, C.I.J.K k) {
                a("C$I$J.j(C,I,K)");
            }
            
            public void j(C c, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,J,K)");
            }
            
            public void j(C c, C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,I,J,K)");
            }
            
            public void j(C.I i) { a("C$I$J.j(I)"); }
            
            public void j(C.I.J j) { a("C$I$J.j(J)"); }
            
            public void j(C.I.J.K k) { a("C$I$J.j(K)"); }
            
            public void j(C.I i, C.I.J j) { a("C$I$J.j(I,J)"); }
            
            public void j(C.I i, C.I.J.K k) { a("C$I$J.j(I,K)"); }
            
            public void j(C.I.J j, C.I.J.K k) { a("C$I$J.j(J,K)"); }
            
            public void j(C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(I,J,K)");
            }
            
            public static class K {
                public void k() { a("C$I$J$K.k()"); }
                
                public void k(C c) { a("C$I$J$K.k(C)"); }
                
                public void k(C c, C.I i) { a("C$I$J$K.k(C,I)"); }
                
                public void k(C c, C.I.J j) { a("C$I$J$K.k(C,J)"); }
                
                public void k(C c, C.I.J.K k) { a("C$I$J$K.k(C,K)"); }
                
                public void k(C c, C.I i, C.I.J j) {
                    a("C$I$J$K.k(C,I,J)");
                }
                
                public void k(C c, C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,K)");
                }
                
                public void k(C c, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,J,K)");
                }
                
                public void k(C c, C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,J,K)");
                }
                
                public void k(C.I i) { a("C$I$J$K.k(I)"); }
                
                public void k(C.I.J j) { a("C$I$J$K.k(J)"); }
                
                public void k(C.I.J.K k) { a("C$I$J$K.k(K)"); }
                
                public void k(C.I i, C.I.J j) { a("C$I$J$K.k(I,J)"); }
                
                public void k(C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(I,K)");
                }
                
                public void k(C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(J,K)");
                }
                
                public void k(C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(I,J,K)");
                }
                
                public K() { super(); }
            }
            
            
            public J() { super(); }
        }
        
        
        public I() { super(); }
    }
    
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public C() { super(); }
}
<<<< D.java >>>>
import org.aspectj.testing.Tester;

public class D {
    public void d() { a("D.d()"); }
    
    public void d(C c) { a("D.d(C)"); }
    
    public void d(C c, C.I ci) { a("D.d(C,C$I)"); }
    
    public void d(C c, C.I.J cij) { a("D.d(C,C$I$J)"); }
    
    public void d(C c, C.I.J.K cijk) { a("D.d(C,C$I$J$K)"); }
    
    public void d(C c, C.I ci, C.I.J cij) { a("D.d(C,C$I,C$I$J)"); }
    
    public void d(C c, C.I ci, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J$K)");
    }
    
    public void d(C c, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I$J,C$I$J$K)");
    }
    
    public void d(C c, C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci) { a("D.d(C$I)"); }
    
    public void d(C.I.J cij) { a("D.d(C$I$J)"); }
    
    public void d(C.I.J.K cijk) { a("D.d(C$I$J$K)"); }
    
    public void d(C.I ci, C.I.J cij) { a("D.d(C$I,C$I$J)"); }
    
    public void d(C.I ci, C.I.J.K cijk) { a("D.d(C$I,C$I$J$K)"); }
    
    public void d(C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I,C$I$J,C$I$J$K)");
    }
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public D() { super(); }
}
retrieve <C: void c(C$I,C$I$J$K)> from C
retrieve <C: void c(C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void a(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C: void c(C)> from C
retrieve <C: void c(C,C$I)> from C
retrieve <C: void c(C,C$I$J)> from C
retrieve <C: void c(C,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J)> from C
retrieve <C: void c(C,C$I,C$I$J$K)> from C
retrieve <C: void c(C,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I)> from C
retrieve <C: void c(C$I$J)> from C
retrieve <C: void c(C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J)> from C
retrieve <C$I: void i()> from C$I
retrieve <C$I: void i(C)> from C$I
retrieve <C$I: void i(C,C$I)> from C$I
retrieve <C$I: void i(C,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I)> from C$I
retrieve <C$I: void i(C$I$J)> from C$I
retrieve <C$I: void i(C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J)> from C$I
retrieve <C$I: void i(C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void <init>()> from C$I
retrieve <C$I$J: void j(C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void <init>()> from C$I$J
retrieve <C$I$J: void j()> from C$I$J
retrieve <C$I$J: void j(C)> from C$I$J
retrieve <C$I$J: void j(C,C$I)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I)> from C$I$J
retrieve <C$I$J: void j(C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J)> from C$I$J
retrieve <C$I$J$K: void k()> from C$I$J$K
retrieve <C$I$J$K: void k(C)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void <init>()> from C$I$J$K
retrieve <D: void d()> from D
retrieve <D: void d(C)> from D
retrieve <D: void d(C,C$I)> from D
retrieve <D: void d(C,C$I$J)> from D
retrieve <D: void d(C,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J)> from D
retrieve <D: void d(C,C$I,C$I$J$K)> from D
retrieve <D: void d(C,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I)> from D
retrieve <D: void d(C$I$J)> from D
retrieve <D: void d(C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J)> from D
retrieve <D: void d(C$I,C$I$J$K)> from D
retrieve <D: void d(C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void a(java.lang.String)> from D
retrieve <D: void <init>()> from D
Transforming D... 
Transforming C... 
Transforming C$I... 
Transforming C$I$J... 
Transforming C$I$J$K... 
Abc finished on Thu Jun 24 08:23:38 BST 2004. ( 0 min. 9 sec. )
Abc started on Thu Jun 24 08:23:38 BST 2004
<<<< Main.java >>>>
import org.aspectj.testing.Tester;

public class Main {
    public static void main(java.lang.String[] args) {
        new Main().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        m("D.d()");
        m("D.d(C)");
        m("D.d(C,C$I)");
        m("D.d(C,C$I$J)");
        m("D.d(C,C$I$J$K)");
        m("D.d(C,C$I,C$I$J)");
        m("D.d(C,C$I,C$I$J$K)");
        m("D.d(C,C$I$J,C$I$J$K)");
        m("D.d(C,C$I,C$I$J,C$I$J$K)");
        m("D.d(C$I)");
        m("D.d(C$I$J)");
        m("D.d(C$I$J$K)");
        m("D.d(C$I,C$I$J)");
        m("D.d(C$I,C$I$J$K)");
        m("D.d(C$I$J,C$I$J$K)");
        m("D.d(C$I,C$I$J,C$I$J$K)");
        m("C.c()");
        m("C.c(C)");
        m("C.c(C,I)");
        m("C.c(C,I$J)");
        m("C.c(C,I$J$K)");
        m("C.c(C,I,I$J)");
        m("C.c(C,I,I$J$K)");
        m("C.c(C,I$J,I$J$K)");
        m("C.c(C,I,I$J,I$J$K)");
        m("C.c(I)");
        m("C.c(I$J)");
        m("C.c(I$J$K)");
        m("C.c(I,I$J)");
        m("C.c(I,I$J$K)");
        m("C.c(I$J,I$J$K)");
        m("C.c(I,I$J,I$J$K)");
        m("C$I.i()");
        m("C$I.i(C)");
        m("C$I.i(C,I)");
        m("C$I.i(C,J)");
        m("C$I.i(C,J$K)");
        m("C$I.i(C,I,J)");
        m("C$I.i(C,I,J$K)");
        m("C$I.i(C,J,J$K)");
        m("C$I.i(C,I,J,J$K)");
        m("C$I.i(I)");
        m("C$I.i(J)");
        m("C$I.i(J$K)");
        m("C$I.i(I,J)");
        m("C$I.i(I,J$K)");
        m("C$I.i(J,J$K)");
        m("C$I.i(I,J,J$K)");
        m("C$I$J.j()");
        m("C$I$J.j(C)");
        m("C$I$J.j(C,I)");
        m("C$I$J.j(C,J)");
        m("C$I$J.j(C,K)");
        m("C$I$J.j(C,I,J)");
        m("C$I$J.j(C,I,K)");
        m("C$I$J.j(C,J,K)");
        m("C$I$J.j(C,I,J,K)");
        m("C$I$J.j(I)");
        m("C$I$J.j(J)");
        m("C$I$J.j(K)");
        m("C$I$J.j(I,J)");
        m("C$I$J.j(I,K)");
        m("C$I$J.j(J,K)");
        m("C$I$J.j(I,J,K)");
        m("C$I$J$K.k()");
        m("C$I$J$K.k(C)");
        m("C$I$J$K.k(C,I)");
        m("C$I$J$K.k(C,J)");
        m("C$I$J$K.k(C,K)");
        m("C$I$J$K.k(C,I,J)");
        m("C$I$J$K.k(C,I,K)");
        m("C$I$J$K.k(C,J,K)");
        m("C$I$J$K.k(C,I,J,K)");
        m("C$I$J$K.k(I)");
        m("C$I$J$K.k(J)");
        m("C$I$J$K.k(K)");
        m("C$I$J$K.k(I,J)");
        m("C$I$J$K.k(I,K)");
        m("C$I$J$K.k(J,K)");
        m("C$I$J$K.k(I,J,K)");
        D d = new D();
        C c = new C();
        C.I ci = new C.I();
        C.I.J cij = new C.I.J();
        C.I.J.K cijk = new C.I.J.K();
        d.d();
        d.d(c);
        d.d(c, ci);
        d.d(c, cij);
        d.d(c, cijk);
        d.d(c, ci, cij);
        d.d(c, ci, cijk);
        d.d(c, cij, cijk);
        d.d(c, ci, cij, cijk);
        d.d(ci);
        d.d(cij);
        d.d(cijk);
        d.d(ci, cij);
        d.d(ci, cijk);
        d.d(cij, cijk);
        d.d(ci, cij, cijk);
        c.c();
        c.c(c);
        c.c(c, ci);
        c.c(c, cij);
        c.c(c, cijk);
        c.c(c, ci, cij);
        c.c(c, ci, cijk);
        c.c(c, cij, cijk);
        c.c(c, ci, cij, cijk);
        c.c(ci);
        c.c(cij);
        c.c(cijk);
        c.c(ci, cij);
        c.c(ci, cijk);
        c.c(cij, cijk);
        c.c(ci, cij, cijk);
        ci.i();
        ci.i(c);
        ci.i(c, ci);
        ci.i(c, cij);
        ci.i(c, cijk);
        ci.i(c, ci, cij);
        ci.i(c, ci, cijk);
        ci.i(c, cij, cijk);
        ci.i(c, ci, cij, cijk);
        ci.i(ci);
        ci.i(cij);
        ci.i(cijk);
        ci.i(ci, cij);
        ci.i(ci, cijk);
        ci.i(cij, cijk);
        ci.i(ci, cij, cijk);
        cij.j();
        cij.j(c);
        cij.j(c, ci);
        cij.j(c, cij);
        cij.j(c, cijk);
        cij.j(c, ci, cij);
        cij.j(c, ci, cijk);
        cij.j(c, cij, cijk);
        cij.j(c, ci, cij, cijk);
        cij.j(ci);
        cij.j(cij);
        cij.j(cijk);
        cij.j(ci, cij);
        cij.j(ci, cijk);
        cij.j(cij, cijk);
        cij.j(ci, cij, cijk);
        cijk.k();
        cijk.k(c);
        cijk.k(c, ci);
        cijk.k(c, cij);
        cijk.k(c, cijk);
        cijk.k(c, ci, cij);
        cijk.k(c, ci, cijk);
        cijk.k(c, cij, cijk);
        cijk.k(c, ci, cij, cijk);
        cijk.k(ci);
        cijk.k(cij);
        cijk.k(cijk);
        cijk.k(ci, cij);
        cijk.k(ci, cijk);
        cijk.k(cij, cijk);
        cijk.k(ci, cij, cijk);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void m(java.lang.String msg) {
        org.aspectj.testing.Tester.expectEvent(msg);
    }
    
    public Main() { super(); }
}
<<<< C.java >>>>
import org.aspectj.testing.Tester;

public class C {
    public void c() { a("C.c()"); }
    
    public void c(C c) { a("C.c(C)"); }
    
    public void c(C c, C.I i) { a("C.c(C,I)"); }
    
    public void c(C c, C.I.J ij) { a("C.c(C,I$J)"); }
    
    public void c(C c, C.I.J.K ijk) { a("C.c(C,I$J$K)"); }
    
    public void c(C c, C.I i, C.I.J ij) { a("C.c(C,I,I$J)"); }
    
    public void c(C c, C.I i, C.I.J.K ijk) { a("C.c(C,I,I$J$K)"); }
    
    public void c(C c, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I$J,I$J$K)");
    }
    
    public void c(C c, C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(C,I,I$J,I$J$K)");
    }
    
    public void c(C.I i) { a("C.c(I)"); }
    
    public void c(C.I.J ij) { a("C.c(I$J)"); }
    
    public void c(C.I.J.K ijk) { a("C.c(I$J$K)"); }
    
    public void c(C.I i, C.I.J ij) { a("C.c(I,I$J)"); }
    
    public void c(C.I i, C.I.J.K ijk) { a("C.c(I,I$J$K)"); }
    
    public void c(C.I.J ij, C.I.J.K ijk) { a("C.c(I$J,I$J$K)"); }
    
    public void c(C.I i, C.I.J ij, C.I.J.K ijk) {
        a("C.c(I,I$J,I$J$K)");
    }
    
    public static class I {
        public void i() { a("C$I.i()"); }
        
        public void i(C c) { a("C$I.i(C)"); }
        
        public void i(C c, C.I i) { a("C$I.i(C,I)"); }
        
        public void i(C c, C.I.J j) { a("C$I.i(C,J)"); }
        
        public void i(C c, C.I.J.K jk) { a("C$I.i(C,J$K)"); }
        
        public void i(C c, C.I i, C.I.J j) { a("C$I.i(C,I,J)"); }
        
        public void i(C c, C.I i, C.I.J.K jk) { a("C$I.i(C,I,J$K)"); }
        
        public void i(C c, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,J,J$K)");
        }
        
        public void i(C c, C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(C,I,J,J$K)");
        }
        
        public void i(C.I i) { a("C$I.i(I)"); }
        
        public void i(C.I.J j) { a("C$I.i(J)"); }
        
        public void i(C.I.J.K jk) { a("C$I.i(J$K)"); }
        
        public void i(C.I i, C.I.J j) { a("C$I.i(I,J)"); }
        
        public void i(C.I i, C.I.J.K jk) { a("C$I.i(I,J$K)"); }
        
        public void i(C.I.J j, C.I.J.K jk) { a("C$I.i(J,J$K)"); }
        
        public void i(C.I i, C.I.J j, C.I.J.K jk) {
            a("C$I.i(I,J,J$K)");
        }
        
        public static class J {
            public void j() { a("C$I$J.j()"); }
            
            public void j(C c) { a("C$I$J.j(C)"); }
            
            public void j(C c, C.I i) { a("C$I$J.j(C,I)"); }
            
            public void j(C c, C.I.J j) { a("C$I$J.j(C,J)"); }
            
            public void j(C c, C.I.J.K k) { a("C$I$J.j(C,K)"); }
            
            public void j(C c, C.I i, C.I.J j) {
                a("C$I$J.j(C,I,J)");
            }
            
            public void j(C c, C.I i, C.I.J.K k) {
                a("C$I$J.j(C,I,K)");
            }
            
            public void j(C c, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,J,K)");
            }
            
            public void j(C c, C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(C,I,J,K)");
            }
            
            public void j(C.I i) { a("C$I$J.j(I)"); }
            
            public void j(C.I.J j) { a("C$I$J.j(J)"); }
            
            public void j(C.I.J.K k) { a("C$I$J.j(K)"); }
            
            public void j(C.I i, C.I.J j) { a("C$I$J.j(I,J)"); }
            
            public void j(C.I i, C.I.J.K k) { a("C$I$J.j(I,K)"); }
            
            public void j(C.I.J j, C.I.J.K k) { a("C$I$J.j(J,K)"); }
            
            public void j(C.I i, C.I.J j, C.I.J.K k) {
                a("C$I$J.j(I,J,K)");
            }
            
            public static class K {
                public void k() { a("C$I$J$K.k()"); }
                
                public void k(C c) { a("C$I$J$K.k(C)"); }
                
                public void k(C c, C.I i) { a("C$I$J$K.k(C,I)"); }
                
                public void k(C c, C.I.J j) { a("C$I$J$K.k(C,J)"); }
                
                public void k(C c, C.I.J.K k) { a("C$I$J$K.k(C,K)"); }
                
                public void k(C c, C.I i, C.I.J j) {
                    a("C$I$J$K.k(C,I,J)");
                }
                
                public void k(C c, C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,K)");
                }
                
                public void k(C c, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,J,K)");
                }
                
                public void k(C c, C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(C,I,J,K)");
                }
                
                public void k(C.I i) { a("C$I$J$K.k(I)"); }
                
                public void k(C.I.J j) { a("C$I$J$K.k(J)"); }
                
                public void k(C.I.J.K k) { a("C$I$J$K.k(K)"); }
                
                public void k(C.I i, C.I.J j) { a("C$I$J$K.k(I,J)"); }
                
                public void k(C.I i, C.I.J.K k) {
                    a("C$I$J$K.k(I,K)");
                }
                
                public void k(C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(J,K)");
                }
                
                public void k(C.I i, C.I.J j, C.I.J.K k) {
                    a("C$I$J$K.k(I,J,K)");
                }
                
                public K() { super(); }
            }
            
            
            public J() { super(); }
        }
        
        
        public I() { super(); }
    }
    
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public C() { super(); }
}
<<<< D.java >>>>
import org.aspectj.testing.Tester;

public class D {
    public void d() { a("D.d()"); }
    
    public void d(C c) { a("D.d(C)"); }
    
    public void d(C c, C.I ci) { a("D.d(C,C$I)"); }
    
    public void d(C c, C.I.J cij) { a("D.d(C,C$I$J)"); }
    
    public void d(C c, C.I.J.K cijk) { a("D.d(C,C$I$J$K)"); }
    
    public void d(C c, C.I ci, C.I.J cij) { a("D.d(C,C$I,C$I$J)"); }
    
    public void d(C c, C.I ci, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J$K)");
    }
    
    public void d(C c, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I$J,C$I$J$K)");
    }
    
    public void d(C c, C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C,C$I,C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci) { a("D.d(C$I)"); }
    
    public void d(C.I.J cij) { a("D.d(C$I$J)"); }
    
    public void d(C.I.J.K cijk) { a("D.d(C$I$J$K)"); }
    
    public void d(C.I ci, C.I.J cij) { a("D.d(C$I,C$I$J)"); }
    
    public void d(C.I ci, C.I.J.K cijk) { a("D.d(C$I,C$I$J$K)"); }
    
    public void d(C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I$J,C$I$J$K)");
    }
    
    public void d(C.I ci, C.I.J cij, C.I.J.K cijk) {
        a("D.d(C$I,C$I$J,C$I$J$K)");
    }
    
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public D() { super(); }
}
retrieve <Main: void <init>()> from Main
retrieve <Main: void realMain(java.lang.String[])> from Main
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void m(java.lang.String)> from Main
retrieve <C: void c(C)> from C
retrieve <C: void c(C,C$I)> from C
retrieve <C: void c(C,C$I$J)> from C
retrieve <C: void c(C,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J)> from C
retrieve <C: void c(C,C$I,C$I$J$K)> from C
retrieve <C: void c(C,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C,C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I)> from C
retrieve <C: void c(C$I$J)> from C
retrieve <C: void c(C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J)> from C
retrieve <C: void c(C$I,C$I$J$K)> from C
retrieve <C: void c(C$I$J,C$I$J$K)> from C
retrieve <C: void c(C$I,C$I$J,C$I$J$K)> from C
retrieve <C: void a(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C$I: void i()> from C$I
retrieve <C$I: void i(C)> from C$I
retrieve <C$I: void i(C,C$I)> from C$I
retrieve <C$I: void i(C,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C,C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I)> from C$I
retrieve <C$I: void i(C$I$J)> from C$I
retrieve <C$I: void i(C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J)> from C$I
retrieve <C$I: void i(C$I,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void i(C$I,C$I$J,C$I$J$K)> from C$I
retrieve <C$I: void <init>()> from C$I
retrieve <C$I$J: void j(C)> from C$I$J
retrieve <C$I$J: void j(C,C$I)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C,C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I)> from C$I$J
retrieve <C$I$J: void j(C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void j(C$I,C$I$J,C$I$J$K)> from C$I$J
retrieve <C$I$J: void <init>()> from C$I$J
retrieve <C$I$J: void j()> from C$I$J
retrieve <C$I$J$K: void k()> from C$I$J$K
retrieve <C$I$J$K: void k(C)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C,C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void k(C$I,C$I$J,C$I$J$K)> from C$I$J$K
retrieve <C$I$J$K: void <init>()> from C$I$J$K
retrieve <D: void d()> from D
retrieve <D: void d(C)> from D
retrieve <D: void d(C,C$I)> from D
retrieve <D: void d(C,C$I$J)> from D
retrieve <D: void d(C,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J)> from D
retrieve <D: void d(C,C$I,C$I$J$K)> from D
retrieve <D: void d(C,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C,C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I)> from D
retrieve <D: void d(C$I$J)> from D
retrieve <D: void d(C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J)> from D
retrieve <D: void d(C$I,C$I$J$K)> from D
retrieve <D: void d(C$I$J,C$I$J$K)> from D
retrieve <D: void d(C$I,C$I$J,C$I$J$K)> from D
retrieve <D: void a(java.lang.String)> from D
retrieve <D: void <init>()> from D
Transforming D... 
Transforming C... 
Transforming C$I... 
Transforming C$I$J... 
Transforming C$I$J$K... 
Transforming Main... 
Abc finished on Thu Jun 24 08:23:45 BST 2004. ( 0 min. 7 sec. )
PASS: Reading inner classes from source and bytecode (3)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 18 seconds
Passed. Current status: 13 failed (check: 0), 88 passed (check: 0), 0 skipped.
Executing test 102 (pureJava): Not lifting types correctly with bytes and shorts with ternary ops
================================================
Breakdown of abc phases  (total: 23163 millisec.)
------------------------------------------------
[ 00.160% ] Init. of Soot:  37
[ 00.017% ] Loading Jars:  4
[ 49.678% ] Polyglot phases:  11507
[ 00.004% ] Resolve class names:  1
[ 00.009% ] Declare Parents:  2
[ 00.212% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.168% ] Intertype Adjuster:  39
[ 25.770% ] Retrieving bodies:  5969
[ 00.000% ] Weave Initializers:  0
[ 00.095% ] Load shadow types:  22
[ 06.221% ] Compute advice lists:  1441
[ 00.017% ] Intertype weave:  4
[ 00.043% ] Add aspect code:  10
[ 00.065% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 11.799% ] Soot Packs:  2733
[ 05.742% ] Soot Writing Output:  1330
================================================
Abc started on Thu Jun 24 08:23:48 BST 2004
<<<< TernaryPrimitiveOps.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class TernaryPrimitiveOps {
    public static void main(java.lang.String[] args) {
        new TernaryPrimitiveOps().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        boolean t = true;
        boolean f = false;
        final int SIZE = 200;
        byte[] _bytes = new byte[SIZE];
        char[] _chars = new char[SIZE];
        double[] _doubles = new double[SIZE];
        int[] _ints = new int[SIZE];
        float[] _floats = new float[SIZE];
        long[] _longs = new long[SIZE];
        short[] _shorts = new short[SIZE];
        for (int i = 0; i < _bytes/*null*/.length; i++)
            _bytes[i] = (byte) -1;
        for (int i = 0; i < _chars/*null*/.length; i++)
            _chars[i] = (char) -1;
        for (int i = 0; i < _doubles/*null*/.length; i++)
            _doubles[i] = (double) -1;
        for (int i = 0; i < _ints/*null*/.length; i++)
            _ints[i] = (int) -1;
        for (int i = 0; i < _floats/*null*/.length; i++)
            _floats[i] = (float) -1;
        for (int i = 0; i < _longs/*null*/.length; i++)
            _longs[i] = (long) -1;
        for (int i = 0; i < _shorts/*null*/.length; i++)
            _shorts[i] = (short) -1;
        int i;
        i = 0;
        _bytes[i++] = (byte) (t ? 1 : 0);
        _bytes[i++] = (t ? (byte) 1 : 0);
        _bytes[i++] = (t ? (byte) 1 : (byte) 0);
        _bytes[i++] = (t ? (byte) 1 : (int) 0);
        _bytes[i++] = (byte) (f ? 0 : 1);
        _bytes[i++] = (f ? (byte) 0 : 1);
        _bytes[i++] = (f ? (byte) 0 : (byte) 1);
        _bytes[i++] = (f ? (byte) 0 : (int) 1);
        i = 0;
        _shorts[i++] = (short) (t ? 1 : 0);
        _shorts[i++] = (t ? (short) 1 : 0);
        _shorts[i++] = (t ? (short) 1 : (short) 0);
        _shorts[i++] = (t ? (short) 1 : (byte) 0);
        _shorts[i++] = (t ? (short) 1 : (int) 0);
        _shorts[i++] = (t ? (byte) 1 : 0);
        _shorts[i++] = (t ? (byte) 1 : (short) 0);
        _shorts[i++] = (t ? (byte) 1 : (byte) 0);
        _shorts[i++] = (t ? (byte) 1 : (int) 0);
        _shorts[i++] = (short) (f ? 0 : 1);
        _shorts[i++] = (f ? (short) 0 : 1);
        _shorts[i++] = (f ? (short) 0 : (short) 1);
        _shorts[i++] = (f ? (short) 0 : (byte) 1);
        _shorts[i++] = (f ? (short) 0 : (int) 1);
        _shorts[i++] = (f ? (byte) 0 : 1);
        _shorts[i++] = (f ? (byte) 0 : (short) 1);
        _shorts[i++] = (f ? (byte) 0 : (byte) 1);
        _shorts[i++] = (f ? (byte) 0 : (int) 1);
        i = 0;
        _longs[i++] = (t ? 1 : 0);
        _longs[i++] = (t ? (long) 1 : 0);
        _longs[i++] = (t ? (long) 1 : (long) 0);
        _longs[i++] = (t ? (long) 1 : (byte) 0);
        _longs[i++] = (t ? (long) 1 : (short) 0);
        _longs[i++] = (t ? (long) 1 : (char) 0);
        _longs[i++] = (t ? (long) 1 : (int) 0);
        _longs[i++] = (t ? (byte) 1 : 0);
        _longs[i++] = (t ? (byte) 1 : (long) 0);
        _longs[i++] = (t ? (byte) 1 : (byte) 0);
        _longs[i++] = (t ? (byte) 1 : (short) 0);
        _longs[i++] = (t ? (byte) 1 : (char) 0);
        _longs[i++] = (t ? (byte) 1 : (int) 0);
        _longs[i++] = (t ? (short) 1 : 0);
        _longs[i++] = (t ? (short) 1 : (long) 0);
        _longs[i++] = (t ? (short) 1 : (byte) 0);
        _longs[i++] = (t ? (short) 1 : (short) 0);
        _longs[i++] = (t ? (short) 1 : (char) 0);
        _longs[i++] = (t ? (short) 1 : (int) 0);
        _longs[i++] = (t ? (char) 1 : 0);
        _longs[i++] = (t ? (char) 1 : (long) 0);
        _longs[i++] = (t ? (char) 1 : (byte) 0);
        _longs[i++] = (t ? (char) 1 : (short) 0);
        _longs[i++] = (t ? (char) 1 : (char) 0);
        _longs[i++] = (t ? (char) 1 : (int) 0);
        _longs[i++] = (t ? (int) 1 : 0);
        _longs[i++] = (t ? (int) 1 : (long) 0);
        _longs[i++] = (t ? (int) 1 : (byte) 0);
        _longs[i++] = (t ? (int) 1 : (short) 0);
        _longs[i++] = (t ? (int) 1 : (char) 0);
        _longs[i++] = (t ? (int) 1 : (int) 0);
        _longs[i++] = (t ? 1 : 0);
        _longs[i++] = (t ? 1 : (byte) 0);
        _longs[i++] = (t ? 1 : (short) 0);
        _longs[i++] = (t ? 1 : (char) 0);
        _longs[i++] = (t ? 1 : (int) 0);
        _longs[i++] = (t ? (byte) 1 : 0);
        _longs[i++] = (t ? (short) 1 : 0);
        _longs[i++] = (t ? (char) 1 : 0);
        _longs[i++] = (t ? (int) 1 : 0);
        _longs[i++] = (f ? 0 : 1);
        _longs[i++] = (f ? (long) 0 : 1);
        _longs[i++] = (f ? (long) 0 : (long) 1);
        _longs[i++] = (f ? (long) 0 : (byte) 1);
        _longs[i++] = (f ? (long) 0 : (short) 1);
        _longs[i++] = (f ? (long) 0 : (char) 1);
        _longs[i++] = (f ? (long) 0 : (int) 1);
        _longs[i++] = (f ? (byte) 0 : 1);
        _longs[i++] = (f ? (byte) 0 : (long) 1);
        _longs[i++] = (f ? (byte) 0 : (byte) 1);
        _longs[i++] = (f ? (byte) 0 : (short) 1);
        _longs[i++] = (f ? (byte) 0 : (char) 1);
        _longs[i++] = (f ? (byte) 0 : (int) 1);
        _longs[i++] = (f ? (short) 0 : 1);
        _longs[i++] = (f ? (short) 0 : (long) 1);
        _longs[i++] = (f ? (short) 0 : (byte) 1);
        _longs[i++] = (f ? (short) 0 : (short) 1);
        _longs[i++] = (f ? (short) 0 : (char) 1);
        _longs[i++] = (f ? (short) 0 : (int) 1);
        _longs[i++] = (f ? (char) 0 : 1);
        _longs[i++] = (f ? (char) 0 : (long) 1);
        _longs[i++] = (f ? (char) 0 : (byte) 1);
        _longs[i++] = (f ? (char) 0 : (short) 1);
        _longs[i++] = (f ? (char) 0 : (char) 1);
        _longs[i++] = (f ? (char) 0 : (int) 1);
        _longs[i++] = (f ? (int) 0 : 1);
        _longs[i++] = (f ? (int) 0 : (long) 1);
        _longs[i++] = (f ? (int) 0 : (byte) 1);
        _longs[i++] = (f ? (int) 0 : (short) 1);
        _longs[i++] = (f ? (int) 0 : (char) 1);
        _longs[i++] = (f ? (int) 0 : (int) 1);
        _longs[i++] = (f ? 0 : 1);
        _longs[i++] = (f ? 0 : (byte) 1);
        _longs[i++] = (f ? 0 : (short) 1);
        _longs[i++] = (f ? 0 : (char) 1);
        _longs[i++] = (f ? 0 : (int) 1);
        _longs[i++] = (f ? (byte) 0 : 1);
        _longs[i++] = (f ? (short) 0 : 1);
        _longs[i++] = (f ? (char) 0 : 1);
        _longs[i++] = (f ? (int) 0 : 1);
        i = 0;
        _ints[i++] = (t ? 1 : 0);
        _ints[i++] = (t ? (int) 1 : 0);
        _ints[i++] = (t ? (int) 1 : (int) 0);
        _ints[i++] = (t ? (int) 1 : (byte) 0);
        _ints[i++] = (t ? (int) 1 : (short) 0);
        _ints[i++] = (t ? (int) 1 : (char) 0);
        _ints[i++] = (t ? (byte) 1 : 0);
        _ints[i++] = (t ? (byte) 1 : (byte) 0);
        _ints[i++] = (t ? (byte) 1 : (short) 0);
        _ints[i++] = (t ? (byte) 1 : (char) 0);
        _ints[i++] = (t ? (byte) 1 : (int) 0);
        _ints[i++] = (t ? (short) 1 : 0);
        _ints[i++] = (t ? (short) 1 : (byte) 0);
        _ints[i++] = (t ? (short) 1 : (short) 0);
        _ints[i++] = (t ? (short) 1 : (char) 0);
        _ints[i++] = (t ? (short) 1 : (int) 0);
        _ints[i++] = (t ? (char) 1 : 0);
        _ints[i++] = (t ? (char) 1 : (byte) 0);
        _ints[i++] = (t ? (char) 1 : (short) 0);
        _ints[i++] = (t ? (char) 1 : (char) 0);
        _ints[i++] = (t ? (char) 1 : (int) 0);
        _ints[i++] = (t ? (int) 1 : 0);
        _ints[i++] = (t ? (int) 1 : (byte) 0);
        _ints[i++] = (t ? (int) 1 : (short) 0);
        _ints[i++] = (t ? (int) 1 : (char) 0);
        _ints[i++] = (t ? (int) 1 : (int) 0);
        _ints[i++] = (t ? 1 : (byte) 0);
        _ints[i++] = (t ? 1 : (short) 0);
        _ints[i++] = (t ? 1 : (char) 0);
        _ints[i++] = (t ? (byte) 1 : 0);
        _ints[i++] = (t ? (short) 1 : 0);
        _ints[i++] = (t ? (char) 1 : 0);
        _ints[i++] = (f ? 0 : 1);
        _ints[i++] = (f ? (int) 0 : 1);
        _ints[i++] = (f ? (int) 0 : (int) 1);
        _ints[i++] = (f ? (int) 0 : (byte) 1);
        _ints[i++] = (f ? (int) 0 : (short) 1);
        _ints[i++] = (f ? (int) 0 : (char) 1);
        _ints[i++] = (f ? (byte) 0 : 1);
        _ints[i++] = (f ? (byte) 0 : (byte) 1);
        _ints[i++] = (f ? (byte) 0 : (short) 1);
        _ints[i++] = (f ? (byte) 0 : (char) 1);
        _ints[i++] = (f ? (byte) 0 : (int) 1);
        _ints[i++] = (f ? (short) 0 : 1);
        _ints[i++] = (f ? (short) 0 : (byte) 1);
        _ints[i++] = (f ? (short) 0 : (short) 1);
        _ints[i++] = (f ? (short) 0 : (char) 1);
        _ints[i++] = (f ? (short) 0 : (int) 1);
        _ints[i++] = (f ? (char) 0 : 1);
        _ints[i++] = (f ? (char) 0 : (byte) 1);
        _ints[i++] = (f ? (char) 0 : (short) 1);
        _ints[i++] = (f ? (char) 0 : (char) 1);
        _ints[i++] = (f ? (char) 0 : (int) 1);
        _ints[i++] = (f ? (int) 0 : 1);
        _ints[i++] = (f ? (int) 0 : (byte) 1);
        _ints[i++] = (f ? (int) 0 : (short) 1);
        _ints[i++] = (f ? (int) 0 : (char) 1);
        _ints[i++] = (f ? (int) 0 : (int) 1);
        _ints[i++] = (f ? 0 : (byte) 1);
        _ints[i++] = (f ? 0 : (short) 1);
        _ints[i++] = (f ? 0 : (char) 1);
        _ints[i++] = (f ? (byte) 0 : 1);
        _ints[i++] = (f ? (short) 0 : 1);
        _ints[i++] = (f ? (char) 0 : 1);
        i = 0;
        _floats[i++] = (t ? 1 : 0);
        _floats[i++] = (t ? 1 : (byte) 0);
        _floats[i++] = (t ? 1 : (short) 0);
        _floats[i++] = (t ? 1 : (char) 0);
        _floats[i++] = (t ? 1 : (int) 0);
        _floats[i++] = (t ? 1 : (long) 0);
        _floats[i++] = (t ? 1 : (float) 0);
        _floats[i++] = (t ? (float) 1 : 0);
        _floats[i++] = (t ? (float) 1 : (byte) 0);
        _floats[i++] = (t ? (float) 1 : (short) 0);
        _floats[i++] = (t ? (float) 1 : (char) 0);
        _floats[i++] = (t ? (float) 1 : (int) 0);
        _floats[i++] = (t ? (float) 1 : (long) 0);
        _floats[i++] = (t ? (float) 1 : (float) 0);
        _floats[i++] = (t ? (byte) 1 : 0);
        _floats[i++] = (t ? (byte) 1 : (byte) 0);
        _floats[i++] = (t ? (byte) 1 : (short) 0);
        _floats[i++] = (t ? (byte) 1 : (char) 0);
        _floats[i++] = (t ? (byte) 1 : (int) 0);
        _floats[i++] = (t ? (byte) 1 : (long) 0);
        _floats[i++] = (t ? (byte) 1 : (float) 0);
        _floats[i++] = (t ? (short) 1 : 0);
        _floats[i++] = (t ? (short) 1 : (byte) 0);
        _floats[i++] = (t ? (short) 1 : (short) 0);
        _floats[i++] = (t ? (short) 1 : (char) 0);
        _floats[i++] = (t ? (short) 1 : (int) 0);
        _floats[i++] = (t ? (short) 1 : (long) 0);
        _floats[i++] = (t ? (short) 1 : (float) 0);
        _floats[i++] = (t ? (char) 1 : 0);
        _floats[i++] = (t ? (char) 1 : (byte) 0);
        _floats[i++] = (t ? (char) 1 : (short) 0);
        _floats[i++] = (t ? (char) 1 : (char) 0);
        _floats[i++] = (t ? (char) 1 : (int) 0);
        _floats[i++] = (t ? (char) 1 : (long) 0);
        _floats[i++] = (t ? (char) 1 : (float) 0);
        _floats[i++] = (t ? (int) 1 : 0);
        _floats[i++] = (t ? (int) 1 : (byte) 0);
        _floats[i++] = (t ? (int) 1 : (short) 0);
        _floats[i++] = (t ? (int) 1 : (char) 0);
        _floats[i++] = (t ? (int) 1 : (int) 0);
        _floats[i++] = (t ? (int) 1 : (long) 0);
        _floats[i++] = (t ? (int) 1 : (float) 0);
        _floats[i++] = (t ? (long) 1 : 0);
        _floats[i++] = (t ? (long) 1 : (byte) 0);
        _floats[i++] = (t ? (long) 1 : (short) 0);
        _floats[i++] = (t ? (long) 1 : (char) 0);
        _floats[i++] = (t ? (long) 1 : (int) 0);
        _floats[i++] = (t ? (long) 1 : (long) 0);
        _floats[i++] = (t ? (long) 1 : (float) 0);
        _floats[i++] = (f ? 0 : 1);
        _floats[i++] = (f ? 0 : (byte) 1);
        _floats[i++] = (f ? 0 : (short) 1);
        _floats[i++] = (f ? 0 : (char) 1);
        _floats[i++] = (f ? 0 : (int) 1);
        _floats[i++] = (f ? 0 : (long) 1);
        _floats[i++] = (f ? 0 : (float) 1);
        _floats[i++] = (f ? (float) 0 : 1);
        _floats[i++] = (f ? (float) 0 : (byte) 1);
        _floats[i++] = (f ? (float) 0 : (short) 1);
        _floats[i++] = (f ? (float) 0 : (char) 1);
        _floats[i++] = (f ? (float) 0 : (int) 1);
        _floats[i++] = (f ? (float) 0 : (long) 1);
        _floats[i++] = (f ? (float) 0 : (float) 1);
        _floats[i++] = (f ? (byte) 0 : 1);
        _floats[i++] = (f ? (byte) 0 : (byte) 1);
        _floats[i++] = (f ? (byte) 0 : (short) 1);
        _floats[i++] = (f ? (byte) 0 : (char) 1);
        _floats[i++] = (f ? (byte) 0 : (int) 1);
        _floats[i++] = (f ? (byte) 0 : (long) 1);
        _floats[i++] = (f ? (byte) 0 : (float) 1);
        _floats[i++] = (f ? (short) 0 : 1);
        _floats[i++] = (f ? (short) 0 : (byte) 1);
        _floats[i++] = (f ? (short) 0 : (short) 1);
        _floats[i++] = (f ? (short) 0 : (char) 1);
        _floats[i++] = (f ? (short) 0 : (int) 1);
        _floats[i++] = (f ? (short) 0 : (long) 1);
        _floats[i++] = (f ? (short) 0 : (float) 1);
        _floats[i++] = (f ? (char) 0 : 1);
        _floats[i++] = (f ? (char) 0 : (byte) 1);
        _floats[i++] = (f ? (char) 0 : (short) 1);
        _floats[i++] = (f ? (char) 0 : (char) 1);
        _floats[i++] = (f ? (char) 0 : (int) 1);
        _floats[i++] = (f ? (char) 0 : (long) 1);
        _floats[i++] = (f ? (char) 0 : (float) 1);
        _floats[i++] = (f ? (int) 0 : 1);
        _floats[i++] = (f ? (int) 0 : (byte) 1);
        _floats[i++] = (f ? (int) 0 : (short) 1);
        _floats[i++] = (f ? (int) 0 : (char) 1);
        _floats[i++] = (f ? (int) 0 : (int) 1);
        _floats[i++] = (f ? (int) 0 : (long) 1);
        _floats[i++] = (f ? (int) 0 : (float) 1);
        _floats[i++] = (f ? (long) 0 : 1);
        _floats[i++] = (f ? (long) 0 : (byte) 1);
        _floats[i++] = (f ? (long) 0 : (short) 1);
        _floats[i++] = (f ? (long) 0 : (char) 1);
        _floats[i++] = (f ? (long) 0 : (int) 1);
        _floats[i++] = (f ? (long) 0 : (long) 1);
        _floats[i++] = (f ? (long) 0 : (float) 1);
        i = 0;
        _doubles[i++] = (t ? 1 : 0);
        _doubles[i++] = (t ? 1 : (byte) 0);
        _doubles[i++] = (t ? 1 : (short) 0);
        _doubles[i++] = (t ? 1 : (char) 0);
        _doubles[i++] = (t ? 1 : (int) 0);
        _doubles[i++] = (t ? 1 : (long) 0);
        _doubles[i++] = (t ? 1 : (float) 0);
        _doubles[i++] = (t ? 1 : (double) 0);
        _doubles[i++] = (t ? (double) 1 : 0);
        _doubles[i++] = (t ? (double) 1 : (byte) 0);
        _doubles[i++] = (t ? (double) 1 : (short) 0);
        _doubles[i++] = (t ? (double) 1 : (char) 0);
        _doubles[i++] = (t ? (double) 1 : (int) 0);
        _doubles[i++] = (t ? (double) 1 : (long) 0);
        _doubles[i++] = (t ? (double) 1 : (float) 0);
        _doubles[i++] = (t ? (double) 1 : (double) 0);
        _doubles[i++] = (t ? (byte) 1 : 0);
        _doubles[i++] = (t ? (byte) 1 : (byte) 0);
        _doubles[i++] = (t ? (byte) 1 : (short) 0);
        _doubles[i++] = (t ? (byte) 1 : (char) 0);
        _doubles[i++] = (t ? (byte) 1 : (int) 0);
        _doubles[i++] = (t ? (byte) 1 : (long) 0);
        _doubles[i++] = (t ? (byte) 1 : (float) 0);
        _doubles[i++] = (t ? (byte) 1 : (double) 0);
        _doubles[i++] = (t ? (short) 1 : 0);
        _doubles[i++] = (t ? (short) 1 : (byte) 0);
        _doubles[i++] = (t ? (short) 1 : (short) 0);
        _doubles[i++] = (t ? (short) 1 : (char) 0);
        _doubles[i++] = (t ? (short) 1 : (int) 0);
        _doubles[i++] = (t ? (short) 1 : (long) 0);
        _doubles[i++] = (t ? (short) 1 : (float) 0);
        _doubles[i++] = (t ? (short) 1 : (double) 0);
        _doubles[i++] = (t ? (char) 1 : 0);
        _doubles[i++] = (t ? (char) 1 : (byte) 0);
        _doubles[i++] = (t ? (char) 1 : (short) 0);
        _doubles[i++] = (t ? (char) 1 : (char) 0);
        _doubles[i++] = (t ? (char) 1 : (int) 0);
        _doubles[i++] = (t ? (char) 1 : (long) 0);
        _doubles[i++] = (t ? (char) 1 : (float) 0);
        _doubles[i++] = (t ? (char) 1 : (double) 0);
        _doubles[i++] = (t ? (int) 1 : 0);
        _doubles[i++] = (t ? (int) 1 : (byte) 0);
        _doubles[i++] = (t ? (int) 1 : (short) 0);
        _doubles[i++] = (t ? (int) 1 : (char) 0);
        _doubles[i++] = (t ? (int) 1 : (int) 0);
        _doubles[i++] = (t ? (int) 1 : (long) 0);
        _doubles[i++] = (t ? (int) 1 : (float) 0);
        _doubles[i++] = (t ? (int) 1 : (double) 0);
        _doubles[i++] = (t ? (long) 1 : 0);
        _doubles[i++] = (t ? (long) 1 : (byte) 0);
        _doubles[i++] = (t ? (long) 1 : (short) 0);
        _doubles[i++] = (t ? (long) 1 : (char) 0);
        _doubles[i++] = (t ? (long) 1 : (int) 0);
        _doubles[i++] = (t ? (long) 1 : (long) 0);
        _doubles[i++] = (t ? (long) 1 : (float) 0);
        _doubles[i++] = (t ? (long) 1 : (double) 0);
        _doubles[i++] = (t ? (float) 1 : 0);
        _doubles[i++] = (t ? (float) 1 : (byte) 0);
        _doubles[i++] = (t ? (float) 1 : (short) 0);
        _doubles[i++] = (t ? (float) 1 : (char) 0);
        _doubles[i++] = (t ? (float) 1 : (int) 0);
        _doubles[i++] = (t ? (float) 1 : (long) 0);
        _doubles[i++] = (t ? (float) 1 : (float) 0);
        _doubles[i++] = (t ? (float) 1 : (double) 0);
        _doubles[i++] = (f ? 0 : 1);
        _doubles[i++] = (f ? 0 : (byte) 1);
        _doubles[i++] = (f ? 0 : (short) 1);
        _doubles[i++] = (f ? 0 : (char) 1);
        _doubles[i++] = (f ? 0 : (int) 1);
        _doubles[i++] = (f ? 0 : (long) 1);
        _doubles[i++] = (f ? 0 : (float) 1);
        _doubles[i++] = (f ? 0 : (double) 1);
        _doubles[i++] = (f ? (double) 0 : 1);
        _doubles[i++] = (f ? (double) 0 : (byte) 1);
        _doubles[i++] = (f ? (double) 0 : (short) 1);
        _doubles[i++] = (f ? (double) 0 : (char) 1);
        _doubles[i++] = (f ? (double) 0 : (int) 1);
        _doubles[i++] = (f ? (double) 0 : (long) 1);
        _doubles[i++] = (f ? (double) 0 : (float) 1);
        _doubles[i++] = (f ? (double) 0 : (double) 1);
        _doubles[i++] = (f ? (byte) 0 : 1);
        _doubles[i++] = (f ? (byte) 0 : (byte) 1);
        _doubles[i++] = (f ? (byte) 0 : (short) 1);
        _doubles[i++] = (f ? (byte) 0 : (char) 1);
        _doubles[i++] = (f ? (byte) 0 : (int) 1);
        _doubles[i++] = (f ? (byte) 0 : (long) 1);
        _doubles[i++] = (f ? (byte) 0 : (float) 1);
        _doubles[i++] = (f ? (byte) 0 : (double) 1);
        _doubles[i++] = (f ? (short) 0 : 1);
        _doubles[i++] = (f ? (short) 0 : (byte) 1);
        _doubles[i++] = (f ? (short) 0 : (short) 1);
        _doubles[i++] = (f ? (short) 0 : (char) 1);
        _doubles[i++] = (f ? (short) 0 : (int) 1);
        _doubles[i++] = (f ? (short) 0 : (long) 1);
        _doubles[i++] = (f ? (short) 0 : (float) 1);
        _doubles[i++] = (f ? (short) 0 : (double) 1);
        _doubles[i++] = (f ? (char) 0 : 1);
        _doubles[i++] = (f ? (char) 0 : (byte) 1);
        _doubles[i++] = (f ? (char) 0 : (short) 1);
        _doubles[i++] = (f ? (char) 0 : (char) 1);
        _doubles[i++] = (f ? (char) 0 : (int) 1);
        _doubles[i++] = (f ? (char) 0 : (long) 1);
        _doubles[i++] = (f ? (char) 0 : (float) 1);
        _doubles[i++] = (f ? (char) 0 : (double) 1);
        _doubles[i++] = (f ? (int) 0 : 1);
        _doubles[i++] = (f ? (int) 0 : (byte) 1);
        _doubles[i++] = (f ? (int) 0 : (short) 1);
        _doubles[i++] = (f ? (int) 0 : (char) 1);
        _doubles[i++] = (f ? (int) 0 : (int) 1);
        _doubles[i++] = (f ? (int) 0 : (long) 1);
        _doubles[i++] = (f ? (int) 0 : (float) 1);
        _doubles[i++] = (f ? (int) 0 : (double) 1);
        _doubles[i++] = (f ? (long) 0 : 1);
        _doubles[i++] = (f ? (long) 0 : (byte) 1);
        _doubles[i++] = (f ? (long) 0 : (short) 1);
        _doubles[i++] = (f ? (long) 0 : (char) 1);
        _doubles[i++] = (f ? (long) 0 : (int) 1);
        _doubles[i++] = (f ? (long) 0 : (long) 1);
        _doubles[i++] = (f ? (long) 0 : (float) 1);
        _doubles[i++] = (f ? (long) 0 : (double) 1);
        _doubles[i++] = (f ? (float) 0 : 1);
        _doubles[i++] = (f ? (float) 0 : (byte) 1);
        _doubles[i++] = (f ? (float) 0 : (short) 1);
        _doubles[i++] = (f ? (float) 0 : (char) 1);
        _doubles[i++] = (f ? (float) 0 : (int) 1);
        _doubles[i++] = (f ? (float) 0 : (long) 1);
        _doubles[i++] = (f ? (float) 0 : (float) 1);
        _doubles[i++] = (f ? (float) 0 : (double) 1);
        for (int _i = 0; _i < _bytes/*null*/.length; _i++) {
            if (_bytes[_i] != (byte) -1) {
                org.aspectj.testing.Tester.check(_bytes[_i] ==
                                                 (byte) 1,
                                                 _bytes[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _chars/*null*/.length; _i++) {
            if (_chars[_i] != (char) -1) {
                org.aspectj.testing.Tester.check(_chars[_i] ==
                                                 (char) 1,
                                                 _chars[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _doubles/*null*/.length; _i++) {
            if (_doubles[_i] != (double) -1) {
                org.aspectj.testing.Tester.check(_doubles[_i] ==
                                                 (double) 1,
                                                 _doubles[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _ints/*null*/.length; _i++) {
            if (_ints[_i] != (int) -1) {
                org.aspectj.testing.Tester.check(_ints[_i] ==
                                                 (int) 1,
                                                 _ints[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _floats/*null*/.length; _i++) {
            if (_floats[_i] != (float) -1) {
                org.aspectj.testing.Tester.check(_floats[_i] ==
                                                 (float) 1,
                                                 _floats[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _longs/*null*/.length; _i++) {
            if (_longs[_i] != (long) -1) {
                org.aspectj.testing.Tester.check(_longs[_i] ==
                                                 (long) 1,
                                                 _longs[_i] +
                                                 " != 1");
            }
        }
        for (int _i = 0; _i < _shorts/*null*/.length; _i++) {
            if (_shorts[_i] != (short) -1) {
                org.aspectj.testing.Tester.check(_shorts[_i] ==
                                                 (short) 1,
                                                 _shorts[_i] +
                                                 " != 1");
            }
        }
    }
    
    public TernaryPrimitiveOps() { super(); }
}
retrieve <TernaryPrimitiveOps: void main(java.lang.String[])> from TernaryPrimitiveOps
retrieve <TernaryPrimitiveOps: void realMain(java.lang.String[])> from TernaryPrimitiveOps
retrieve <TernaryPrimitiveOps: void <init>()> from TernaryPrimitiveOps
Transforming TernaryPrimitiveOps... 
Abc finished on Thu Jun 24 08:24:11 BST 2004. ( 0 min. 23 sec. )
PASS: Not lifting types correctly with bytes and shorts with ternary ops()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 24 seconds
Passed. Current status: 13 failed (check: 0), 89 passed (check: 0), 0 skipped.
Executing test 103 (pureJava): Not looking up methods inside of anonymous declarations correctly.
================================================
Breakdown of abc phases  (total: 6879 millisec.)
------------------------------------------------
[ 00.552% ] Init. of Soot:  38
[ 00.044% ] Loading Jars:  3
[ 77.773% ] Polyglot phases:  5350
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.436% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 00.901% ] Intertype Adjuster:  62
[ 12.604% ] Retrieving bodies:  867
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  22
[ 01.352% ] Compute advice lists:  93
[ 00.044% ] Intertype weave:  3
[ 00.131% ] Add aspect code:  9
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.762% ] Soot Packs:  190
[ 02.864% ] Soot Writing Output:  197
================================================
Abc started on Thu Jun 24 08:24:14 BST 2004
<<<< AnonymousMethodLookup.java >>>>
public class AnonymousMethodLookup {
    public static void main(java.lang.String[] args) {
        new C() {
            { foo(); }
        };
    }
    
    public AnonymousMethodLookup() { super(); }
}
class C {
    void foo() {  }
    
    public C() { super(); }
}
retrieve <AnonymousMethodLookup: void <init>()> from AnonymousMethodLookup
retrieve <AnonymousMethodLookup: void main(java.lang.String[])> from AnonymousMethodLookup
retrieve <AnonymousMethodLookup$1: void <init>()> from AnonymousMethodLookup$1
retrieve <C: void foo()> from C
retrieve <C: void <init>()> from C
Transforming C... 
Transforming AnonymousMethodLookup... 
Transforming AnonymousMethodLookup$1... 
Abc finished on Thu Jun 24 08:24:21 BST 2004. ( 0 min. 6 sec. )
PASS: Not looking up methods inside of anonymous declarations correctly.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 13 failed (check: 0), 90 passed (check: 0), 0 skipped.
Executing test 104 (pureJava): Resolving extended classes with array parameters
================================================
Breakdown of abc phases  (total: 96900 millisec.)
------------------------------------------------
[ 00.038% ] Init. of Soot:  37
[ 00.004% ] Loading Jars:  4
[ 62.316% ] Polyglot phases:  60384
[ 00.001% ] Resolve class names:  1
[ 00.002% ] Declare Parents:  2
[ 00.051% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.588% ] Intertype Adjuster:  570
[ 03.111% ] Retrieving bodies:  3015
[ 00.000% ] Weave Initializers:  0
[ 00.024% ] Load shadow types:  23
[ 25.729% ] Compute advice lists:  24931
[ 00.004% ] Intertype weave:  4
[ 00.008% ] Add aspect code:  8
[ 00.114% ] Weaving advice:  110
[ 00.000% ] Validate jimple:  0
[ 03.676% ] Soot Packs:  3562
[ 04.334% ] Soot Writing Output:  4200
================================================
Abc started on Thu Jun 24 08:24:23 BST 2004
<<<< ResolvingArrayParameters.java >>>>
public class ResolvingArrayParameters {
    public static void main(java.lang.String[] args) {
        new ResolvingArrayParameters().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        wants();
        boolean[] booleans = new boolean[] {  };
        byte[] bytes = new byte[] {  };
        char[] chars = new char[] {  };
        short[] shorts = new short[] {  };
        int[] ints = new int[] {  };
        long[] longs = new long[] {  };
        float[] floats = new float[] {  };
        double[] doubles = new double[] {  };
        new CC_boolean().f(booleans);
        new CC_byte().f(bytes);
        new CC_char().f(chars);
        new CC_short().f(shorts);
        new CC_int().f(ints);
        new CC_long().f(longs);
        new CC_float().f(floats);
        new CC_double().f(doubles);
        new C_boolean_double().f(doubles);
        new C_boolean_double().f(booleans);
        new C_byte_double().f(doubles);
        new C_byte_double().f(bytes);
        new C_char_double().f(doubles);
        new C_char_double().f(chars);
        new C_short_double().f(doubles);
        new C_short_double().f(shorts);
        new C_int_double().f(doubles);
        new C_int_double().f(ints);
        new C_long_double().f(doubles);
        new C_long_double().f(longs);
        new C_float_double().f(doubles);
        new C_float_double().f(floats);
        new C_boolean_float().f(floats);
        new C_boolean_float().f(booleans);
        new C_byte_float().f(floats);
        new C_byte_float().f(bytes);
        new C_char_float().f(floats);
        new C_char_float().f(chars);
        new C_short_float().f(floats);
        new C_short_float().f(shorts);
        new C_int_float().f(floats);
        new C_int_float().f(ints);
        new C_long_float().f(floats);
        new C_long_float().f(longs);
        new C_double_float().f(floats);
        new C_double_float().f(doubles);
        new C_boolean_long().f(longs);
        new C_boolean_long().f(booleans);
        new C_byte_long().f(longs);
        new C_byte_long().f(bytes);
        new C_char_long().f(longs);
        new C_char_long().f(chars);
        new C_short_long().f(longs);
        new C_short_long().f(shorts);
        new C_int_long().f(longs);
        new C_int_long().f(ints);
        new C_float_long().f(longs);
        new C_float_long().f(floats);
        new C_double_long().f(longs);
        new C_double_long().f(doubles);
        new C_boolean_int().f(ints);
        new C_boolean_int().f(booleans);
        new C_byte_int().f(ints);
        new C_byte_int().f(bytes);
        new C_char_int().f(ints);
        new C_char_int().f(chars);
        new C_short_int().f(ints);
        new C_short_int().f(shorts);
        new C_long_int().f(ints);
        new C_long_int().f(longs);
        new C_float_int().f(ints);
        new C_float_int().f(floats);
        new C_double_int().f(ints);
        new C_double_int().f(doubles);
        new C_boolean_short().f(shorts);
        new C_boolean_short().f(booleans);
        new C_byte_short().f(shorts);
        new C_byte_short().f(bytes);
        new C_char_short().f(shorts);
        new C_char_short().f(chars);
        new C_int_short().f(shorts);
        new C_int_short().f(ints);
        new C_long_short().f(shorts);
        new C_long_short().f(longs);
        new C_float_short().f(shorts);
        new C_float_short().f(floats);
        new C_double_short().f(shorts);
        new C_double_short().f(doubles);
        new C_boolean_char().f(chars);
        new C_boolean_char().f(booleans);
        new C_byte_char().f(chars);
        new C_byte_char().f(bytes);
        new C_short_char().f(chars);
        new C_short_char().f(shorts);
        new C_int_char().f(chars);
        new C_int_char().f(ints);
        new C_long_char().f(chars);
        new C_long_char().f(longs);
        new C_float_char().f(chars);
        new C_float_char().f(floats);
        new C_double_char().f(chars);
        new C_double_char().f(doubles);
        new C_boolean_byte().f(bytes);
        new C_boolean_byte().f(booleans);
        new C_char_byte().f(bytes);
        new C_char_byte().f(chars);
        new C_short_byte().f(bytes);
        new C_short_byte().f(shorts);
        new C_int_byte().f(bytes);
        new C_int_byte().f(ints);
        new C_long_byte().f(bytes);
        new C_long_byte().f(longs);
        new C_float_byte().f(bytes);
        new C_float_byte().f(floats);
        new C_double_byte().f(bytes);
        new C_double_byte().f(doubles);
        new C_byte_boolean().f(booleans);
        new C_byte_boolean().f(bytes);
        new C_char_boolean().f(booleans);
        new C_char_boolean().f(chars);
        new C_short_boolean().f(booleans);
        new C_short_boolean().f(shorts);
        new C_int_boolean().f(booleans);
        new C_int_boolean().f(ints);
        new C_long_boolean().f(booleans);
        new C_long_boolean().f(longs);
        new C_float_boolean().f(booleans);
        new C_float_boolean().f(floats);
        new C_double_boolean().f(booleans);
        new C_double_boolean().f(doubles);
        new C_char_boolean_byte().f(chars);
        new C_char_boolean_byte().f(booleans);
        new C_char_boolean_byte().f(bytes);
        new C_short_boolean_byte().f(shorts);
        new C_short_boolean_byte().f(booleans);
        new C_short_boolean_byte().f(bytes);
        new C_int_boolean_byte().f(ints);
        new C_int_boolean_byte().f(booleans);
        new C_int_boolean_byte().f(bytes);
        new C_long_boolean_byte().f(longs);
        new C_long_boolean_byte().f(booleans);
        new C_long_boolean_byte().f(bytes);
        new C_float_boolean_byte().f(floats);
        new C_float_boolean_byte().f(booleans);
        new C_float_boolean_byte().f(bytes);
        new C_double_boolean_byte().f(doubles);
        new C_double_boolean_byte().f(booleans);
        new C_double_boolean_byte().f(bytes);
        new C_byte_boolean_double().f(bytes);
        new C_byte_boolean_double().f(booleans);
        new C_byte_boolean_double().f(doubles);
        new C_char_boolean_double().f(chars);
        new C_char_boolean_double().f(booleans);
        new C_char_boolean_double().f(doubles);
        new C_short_boolean_double().f(shorts);
        new C_short_boolean_double().f(booleans);
        new C_short_boolean_double().f(doubles);
        new C_int_boolean_double().f(ints);
        new C_int_boolean_double().f(booleans);
        new C_int_boolean_double().f(doubles);
        new C_long_boolean_double().f(longs);
        new C_long_boolean_double().f(booleans);
        new C_long_boolean_double().f(doubles);
        new C_float_boolean_double().f(floats);
        new C_float_boolean_double().f(booleans);
        new C_float_boolean_double().f(doubles);
        new C_byte_boolean_float().f(bytes);
        new C_byte_boolean_float().f(booleans);
        new C_byte_boolean_float().f(floats);
        new C_char_boolean_float().f(chars);
        new C_char_boolean_float().f(booleans);
        new C_char_boolean_float().f(floats);
        new C_short_boolean_float().f(shorts);
        new C_short_boolean_float().f(booleans);
        new C_short_boolean_float().f(floats);
        new C_int_boolean_float().f(ints);
        new C_int_boolean_float().f(booleans);
        new C_int_boolean_float().f(floats);
        new C_long_boolean_float().f(longs);
        new C_long_boolean_float().f(booleans);
        new C_long_boolean_float().f(floats);
        new C_double_boolean_float().f(doubles);
        new C_double_boolean_float().f(booleans);
        new C_double_boolean_float().f(floats);
        new C_byte_boolean_long().f(bytes);
        new C_byte_boolean_long().f(booleans);
        new C_byte_boolean_long().f(longs);
        new C_char_boolean_long().f(chars);
        new C_char_boolean_long().f(booleans);
        new C_char_boolean_long().f(longs);
        new C_short_boolean_long().f(shorts);
        new C_short_boolean_long().f(booleans);
        new C_short_boolean_long().f(longs);
        new C_int_boolean_long().f(ints);
        new C_int_boolean_long().f(booleans);
        new C_int_boolean_long().f(longs);
        new C_float_boolean_long().f(floats);
        new C_float_boolean_long().f(booleans);
        new C_float_boolean_long().f(longs);
        new C_double_boolean_long().f(doubles);
        new C_double_boolean_long().f(booleans);
        new C_double_boolean_long().f(longs);
        new C_byte_boolean_int().f(bytes);
        new C_byte_boolean_int().f(booleans);
        new C_byte_boolean_int().f(ints);
        new C_char_boolean_int().f(chars);
        new C_char_boolean_int().f(booleans);
        new C_char_boolean_int().f(ints);
        new C_short_boolean_int().f(shorts);
        new C_short_boolean_int().f(booleans);
        new C_short_boolean_int().f(ints);
        new C_long_boolean_int().f(longs);
        new C_long_boolean_int().f(booleans);
        new C_long_boolean_int().f(ints);
        new C_float_boolean_int().f(floats);
        new C_float_boolean_int().f(booleans);
        new C_float_boolean_int().f(ints);
        new C_double_boolean_int().f(doubles);
        new C_double_boolean_int().f(booleans);
        new C_double_boolean_int().f(ints);
        new C_byte_boolean_short().f(bytes);
        new C_byte_boolean_short().f(booleans);
        new C_byte_boolean_short().f(shorts);
        new C_char_boolean_short().f(chars);
        new C_char_boolean_short().f(booleans);
        new C_char_boolean_short().f(shorts);
        new C_int_boolean_short().f(ints);
        new C_int_boolean_short().f(booleans);
        new C_int_boolean_short().f(shorts);
        new C_long_boolean_short().f(longs);
        new C_long_boolean_short().f(booleans);
        new C_long_boolean_short().f(shorts);
        new C_float_boolean_short().f(floats);
        new C_float_boolean_short().f(booleans);
        new C_float_boolean_short().f(shorts);
        new C_double_boolean_short().f(doubles);
        new C_double_boolean_short().f(booleans);
        new C_double_boolean_short().f(shorts);
        new C_byte_boolean_char().f(bytes);
        new C_byte_boolean_char().f(booleans);
        new C_byte_boolean_char().f(chars);
        new C_short_boolean_char().f(shorts);
        new C_short_boolean_char().f(booleans);
        new C_short_boolean_char().f(chars);
        new C_int_boolean_char().f(ints);
        new C_int_boolean_char().f(booleans);
        new C_int_boolean_char().f(chars);
        new C_long_boolean_char().f(longs);
        new C_long_boolean_char().f(booleans);
        new C_long_boolean_char().f(chars);
        new C_float_boolean_char().f(floats);
        new C_float_boolean_char().f(booleans);
        new C_float_boolean_char().f(chars);
        new C_double_boolean_char().f(doubles);
        new C_double_boolean_char().f(booleans);
        new C_double_boolean_char().f(chars);
        new C_char_byte_boolean().f(chars);
        new C_char_byte_boolean().f(bytes);
        new C_char_byte_boolean().f(booleans);
        new C_short_byte_boolean().f(shorts);
        new C_short_byte_boolean().f(bytes);
        new C_short_byte_boolean().f(booleans);
        new C_int_byte_boolean().f(ints);
        new C_int_byte_boolean().f(bytes);
        new C_int_byte_boolean().f(booleans);
        new C_long_byte_boolean().f(longs);
        new C_long_byte_boolean().f(bytes);
        new C_long_byte_boolean().f(booleans);
        new C_float_byte_boolean().f(floats);
        new C_float_byte_boolean().f(bytes);
        new C_float_byte_boolean().f(booleans);
        new C_double_byte_boolean().f(doubles);
        new C_double_byte_boolean().f(bytes);
        new C_double_byte_boolean().f(booleans);
        new C_boolean_byte_char().f(booleans);
        new C_boolean_byte_char().f(bytes);
        new C_boolean_byte_char().f(chars);
        new C_short_byte_char().f(shorts);
        new C_short_byte_char().f(bytes);
        new C_short_byte_char().f(chars);
        new C_int_byte_char().f(ints);
        new C_int_byte_char().f(bytes);
        new C_int_byte_char().f(chars);
        new C_long_byte_char().f(longs);
        new C_long_byte_char().f(bytes);
        new C_long_byte_char().f(chars);
        new C_float_byte_char().f(floats);
        new C_float_byte_char().f(bytes);
        new C_float_byte_char().f(chars);
        new C_double_byte_char().f(doubles);
        new C_double_byte_char().f(bytes);
        new C_double_byte_char().f(chars);
        new C_boolean_byte_short().f(booleans);
        new C_boolean_byte_short().f(bytes);
        new C_boolean_byte_short().f(shorts);
        new C_char_byte_short().f(chars);
        new C_char_byte_short().f(bytes);
        new C_char_byte_short().f(shorts);
        new C_int_byte_short().f(ints);
        new C_int_byte_short().f(bytes);
        new C_int_byte_short().f(shorts);
        new C_long_byte_short().f(longs);
        new C_long_byte_short().f(bytes);
        new C_long_byte_short().f(shorts);
        new C_float_byte_short().f(floats);
        new C_float_byte_short().f(bytes);
        new C_float_byte_short().f(shorts);
        new C_double_byte_short().f(doubles);
        new C_double_byte_short().f(bytes);
        new C_double_byte_short().f(shorts);
        new C_boolean_byte_int().f(booleans);
        new C_boolean_byte_int().f(bytes);
        new C_boolean_byte_int().f(ints);
        new C_char_byte_int().f(chars);
        new C_char_byte_int().f(bytes);
        new C_char_byte_int().f(ints);
        new C_short_byte_int().f(shorts);
        new C_short_byte_int().f(bytes);
        new C_short_byte_int().f(ints);
        new C_long_byte_int().f(longs);
        new C_long_byte_int().f(bytes);
        new C_long_byte_int().f(ints);
        new C_float_byte_int().f(floats);
        new C_float_byte_int().f(bytes);
        new C_float_byte_int().f(ints);
        new C_double_byte_int().f(doubles);
        new C_double_byte_int().f(bytes);
        new C_double_byte_int().f(ints);
        new C_boolean_byte_long().f(booleans);
        new C_boolean_byte_long().f(bytes);
        new C_boolean_byte_long().f(longs);
        new C_char_byte_long().f(chars);
        new C_char_byte_long().f(bytes);
        new C_char_byte_long().f(longs);
        new C_short_byte_long().f(shorts);
        new C_short_byte_long().f(bytes);
        new C_short_byte_long().f(longs);
        new C_int_byte_long().f(ints);
        new C_int_byte_long().f(bytes);
        new C_int_byte_long().f(longs);
        new C_float_byte_long().f(floats);
        new C_float_byte_long().f(bytes);
        new C_float_byte_long().f(longs);
        new C_double_byte_long().f(doubles);
        new C_double_byte_long().f(bytes);
        new C_double_byte_long().f(longs);
        new C_boolean_byte_float().f(booleans);
        new C_boolean_byte_float().f(bytes);
        new C_boolean_byte_float().f(floats);
        new C_char_byte_float().f(chars);
        new C_char_byte_float().f(bytes);
        new C_char_byte_float().f(floats);
        new C_short_byte_float().f(shorts);
        new C_short_byte_float().f(bytes);
        new C_short_byte_float().f(floats);
        new C_int_byte_float().f(ints);
        new C_int_byte_float().f(bytes);
        new C_int_byte_float().f(floats);
        new C_long_byte_float().f(longs);
        new C_long_byte_float().f(bytes);
        new C_long_byte_float().f(floats);
        new C_double_byte_float().f(doubles);
        new C_double_byte_float().f(bytes);
        new C_double_byte_float().f(floats);
        new C_boolean_byte_double().f(booleans);
        new C_boolean_byte_double().f(bytes);
        new C_boolean_byte_double().f(doubles);
        new C_char_byte_double().f(chars);
        new C_char_byte_double().f(bytes);
        new C_char_byte_double().f(doubles);
        new C_short_byte_double().f(shorts);
        new C_short_byte_double().f(bytes);
        new C_short_byte_double().f(doubles);
        new C_int_byte_double().f(ints);
        new C_int_byte_double().f(bytes);
        new C_int_byte_double().f(doubles);
        new C_long_byte_double().f(longs);
        new C_long_byte_double().f(bytes);
        new C_long_byte_double().f(doubles);
        new C_float_byte_double().f(floats);
        new C_float_byte_double().f(bytes);
        new C_float_byte_double().f(doubles);
        new C_byte_char_boolean().f(bytes);
        new C_byte_char_boolean().f(chars);
        new C_byte_char_boolean().f(booleans);
        new C_short_char_boolean().f(shorts);
        new C_short_char_boolean().f(chars);
        new C_short_char_boolean().f(booleans);
        new C_int_char_boolean().f(ints);
        new C_int_char_boolean().f(chars);
        new C_int_char_boolean().f(booleans);
        new C_long_char_boolean().f(longs);
        new C_long_char_boolean().f(chars);
        new C_long_char_boolean().f(booleans);
        new C_float_char_boolean().f(floats);
        new C_float_char_boolean().f(chars);
        new C_float_char_boolean().f(booleans);
        new C_double_char_boolean().f(doubles);
        new C_double_char_boolean().f(chars);
        new C_double_char_boolean().f(booleans);
        new C_boolean_char_byte().f(booleans);
        new C_boolean_char_byte().f(chars);
        new C_boolean_char_byte().f(bytes);
        new C_short_char_byte().f(shorts);
        new C_short_char_byte().f(chars);
        new C_short_char_byte().f(bytes);
        new C_int_char_byte().f(ints);
        new C_int_char_byte().f(chars);
        new C_int_char_byte().f(bytes);
        new C_long_char_byte().f(longs);
        new C_long_char_byte().f(chars);
        new C_long_char_byte().f(bytes);
        new C_float_char_byte().f(floats);
        new C_float_char_byte().f(chars);
        new C_float_char_byte().f(bytes);
        new C_double_char_byte().f(doubles);
        new C_double_char_byte().f(chars);
        new C_double_char_byte().f(bytes);
        new C_boolean_char_short().f(booleans);
        new C_boolean_char_short().f(chars);
        new C_boolean_char_short().f(shorts);
        new C_byte_char_short().f(bytes);
        new C_byte_char_short().f(chars);
        new C_byte_char_short().f(shorts);
        new C_int_char_short().f(ints);
        new C_int_char_short().f(chars);
        new C_int_char_short().f(shorts);
        new C_long_char_short().f(longs);
        new C_long_char_short().f(chars);
        new C_long_char_short().f(shorts);
        new C_float_char_short().f(floats);
        new C_float_char_short().f(chars);
        new C_float_char_short().f(shorts);
        new C_double_char_short().f(doubles);
        new C_double_char_short().f(chars);
        new C_double_char_short().f(shorts);
        new C_boolean_char_int().f(booleans);
        new C_boolean_char_int().f(chars);
        new C_boolean_char_int().f(ints);
        new C_byte_char_int().f(bytes);
        new C_byte_char_int().f(chars);
        new C_byte_char_int().f(ints);
        new C_short_char_int().f(shorts);
        new C_short_char_int().f(chars);
        new C_short_char_int().f(ints);
        new C_long_char_int().f(longs);
        new C_long_char_int().f(chars);
        new C_long_char_int().f(ints);
        new C_float_char_int().f(floats);
        new C_float_char_int().f(chars);
        new C_float_char_int().f(ints);
        new C_double_char_int().f(doubles);
        new C_double_char_int().f(chars);
        new C_double_char_int().f(ints);
        new C_boolean_char_long().f(booleans);
        new C_boolean_char_long().f(chars);
        new C_boolean_char_long().f(longs);
        new C_byte_char_long().f(bytes);
        new C_byte_char_long().f(chars);
        new C_byte_char_long().f(longs);
        new C_short_char_long().f(shorts);
        new C_short_char_long().f(chars);
        new C_short_char_long().f(longs);
        new C_int_char_long().f(ints);
        new C_int_char_long().f(chars);
        new C_int_char_long().f(longs);
        new C_float_char_long().f(floats);
        new C_float_char_long().f(chars);
        new C_float_char_long().f(longs);
        new C_double_char_long().f(doubles);
        new C_double_char_long().f(chars);
        new C_double_char_long().f(longs);
        new C_boolean_char_float().f(booleans);
        new C_boolean_char_float().f(chars);
        new C_boolean_char_float().f(floats);
        new C_byte_char_float().f(bytes);
        new C_byte_char_float().f(chars);
        new C_byte_char_float().f(floats);
        new C_short_char_float().f(shorts);
        new C_short_char_float().f(chars);
        new C_short_char_float().f(floats);
        new C_int_char_float().f(ints);
        new C_int_char_float().f(chars);
        new C_int_char_float().f(floats);
        new C_long_char_float().f(longs);
        new C_long_char_float().f(chars);
        new C_long_char_float().f(floats);
        new C_double_char_float().f(doubles);
        new C_double_char_float().f(chars);
        new C_double_char_float().f(floats);
        new C_boolean_char_double().f(booleans);
        new C_boolean_char_double().f(chars);
        new C_boolean_char_double().f(doubles);
        new C_byte_char_double().f(bytes);
        new C_byte_char_double().f(chars);
        new C_byte_char_double().f(doubles);
        new C_short_char_double().f(shorts);
        new C_short_char_double().f(chars);
        new C_short_char_double().f(doubles);
        new C_int_char_double().f(ints);
        new C_int_char_double().f(chars);
        new C_int_char_double().f(doubles);
        new C_long_char_double().f(longs);
        new C_long_char_double().f(chars);
        new C_long_char_double().f(doubles);
        new C_float_char_double().f(floats);
        new C_float_char_double().f(chars);
        new C_float_char_double().f(doubles);
        new C_byte_double_boolean().f(bytes);
        new C_byte_double_boolean().f(doubles);
        new C_byte_double_boolean().f(booleans);
        new C_char_double_boolean().f(chars);
        new C_char_double_boolean().f(doubles);
        new C_char_double_boolean().f(booleans);
        new C_short_double_boolean().f(shorts);
        new C_short_double_boolean().f(doubles);
        new C_short_double_boolean().f(booleans);
        new C_int_double_boolean().f(ints);
        new C_int_double_boolean().f(doubles);
        new C_int_double_boolean().f(booleans);
        new C_long_double_boolean().f(longs);
        new C_long_double_boolean().f(doubles);
        new C_long_double_boolean().f(booleans);
        new C_float_double_boolean().f(floats);
        new C_float_double_boolean().f(doubles);
        new C_float_double_boolean().f(booleans);
        new C_boolean_double_byte().f(booleans);
        new C_boolean_double_byte().f(doubles);
        new C_boolean_double_byte().f(bytes);
        new C_char_double_byte().f(chars);
        new C_char_double_byte().f(doubles);
        new C_char_double_byte().f(bytes);
        new C_short_double_byte().f(shorts);
        new C_short_double_byte().f(doubles);
        new C_short_double_byte().f(bytes);
        new C_int_double_byte().f(ints);
        new C_int_double_byte().f(doubles);
        new C_int_double_byte().f(bytes);
        new C_long_double_byte().f(longs);
        new C_long_double_byte().f(doubles);
        new C_long_double_byte().f(bytes);
        new C_float_double_byte().f(floats);
        new C_float_double_byte().f(doubles);
        new C_float_double_byte().f(bytes);
        new C_boolean_double_char().f(booleans);
        new C_boolean_double_char().f(doubles);
        new C_boolean_double_char().f(chars);
        new C_byte_double_char().f(bytes);
        new C_byte_double_char().f(doubles);
        new C_byte_double_char().f(chars);
        new C_short_double_char().f(shorts);
        new C_short_double_char().f(doubles);
        new C_short_double_char().f(chars);
        new C_int_double_char().f(ints);
        new C_int_double_char().f(doubles);
        new C_int_double_char().f(chars);
        new C_long_double_char().f(longs);
        new C_long_double_char().f(doubles);
        new C_long_double_char().f(chars);
        new C_float_double_char().f(floats);
        new C_float_double_char().f(doubles);
        new C_float_double_char().f(chars);
        new C_boolean_double_short().f(booleans);
        new C_boolean_double_short().f(doubles);
        new C_boolean_double_short().f(shorts);
        new C_byte_double_short().f(bytes);
        new C_byte_double_short().f(doubles);
        new C_byte_double_short().f(shorts);
        new C_char_double_short().f(chars);
        new C_char_double_short().f(doubles);
        new C_char_double_short().f(shorts);
        new C_int_double_short().f(ints);
        new C_int_double_short().f(doubles);
        new C_int_double_short().f(shorts);
        new C_long_double_short().f(longs);
        new C_long_double_short().f(doubles);
        new C_long_double_short().f(shorts);
        new C_float_double_short().f(floats);
        new C_float_double_short().f(doubles);
        new C_float_double_short().f(shorts);
        new C_boolean_double_int().f(booleans);
        new C_boolean_double_int().f(doubles);
        new C_boolean_double_int().f(ints);
        new C_byte_double_int().f(bytes);
        new C_byte_double_int().f(doubles);
        new C_byte_double_int().f(ints);
        new C_char_double_int().f(chars);
        new C_char_double_int().f(doubles);
        new C_char_double_int().f(ints);
        new C_short_double_int().f(shorts);
        new C_short_double_int().f(doubles);
        new C_short_double_int().f(ints);
        new C_long_double_int().f(longs);
        new C_long_double_int().f(doubles);
        new C_long_double_int().f(ints);
        new C_float_double_int().f(floats);
        new C_float_double_int().f(doubles);
        new C_float_double_int().f(ints);
        new C_boolean_double_long().f(booleans);
        new C_boolean_double_long().f(doubles);
        new C_boolean_double_long().f(longs);
        new C_byte_double_long().f(bytes);
        new C_byte_double_long().f(doubles);
        new C_byte_double_long().f(longs);
        new C_char_double_long().f(chars);
        new C_char_double_long().f(doubles);
        new C_char_double_long().f(longs);
        new C_short_double_long().f(shorts);
        new C_short_double_long().f(doubles);
        new C_short_double_long().f(longs);
        new C_int_double_long().f(ints);
        new C_int_double_long().f(doubles);
        new C_int_double_long().f(longs);
        new C_float_double_long().f(floats);
        new C_float_double_long().f(doubles);
        new C_float_double_long().f(longs);
        new C_boolean_double_float().f(booleans);
        new C_boolean_double_float().f(doubles);
        new C_boolean_double_float().f(floats);
        new C_byte_double_float().f(bytes);
        new C_byte_double_float().f(doubles);
        new C_byte_double_float().f(floats);
        new C_char_double_float().f(chars);
        new C_char_double_float().f(doubles);
        new C_char_double_float().f(floats);
        new C_short_double_float().f(shorts);
        new C_short_double_float().f(doubles);
        new C_short_double_float().f(floats);
        new C_int_double_float().f(ints);
        new C_int_double_float().f(doubles);
        new C_int_double_float().f(floats);
        new C_long_double_float().f(longs);
        new C_long_double_float().f(doubles);
        new C_long_double_float().f(floats);
        new C_byte_float_boolean().f(bytes);
        new C_byte_float_boolean().f(floats);
        new C_byte_float_boolean().f(booleans);
        new C_char_float_boolean().f(chars);
        new C_char_float_boolean().f(floats);
        new C_char_float_boolean().f(booleans);
        new C_short_float_boolean().f(shorts);
        new C_short_float_boolean().f(floats);
        new C_short_float_boolean().f(booleans);
        new C_int_float_boolean().f(ints);
        new C_int_float_boolean().f(floats);
        new C_int_float_boolean().f(booleans);
        new C_long_float_boolean().f(longs);
        new C_long_float_boolean().f(floats);
        new C_long_float_boolean().f(booleans);
        new C_double_float_boolean().f(doubles);
        new C_double_float_boolean().f(floats);
        new C_double_float_boolean().f(booleans);
        new C_boolean_float_byte().f(booleans);
        new C_boolean_float_byte().f(floats);
        new C_boolean_float_byte().f(bytes);
        new C_char_float_byte().f(chars);
        new C_char_float_byte().f(floats);
        new C_char_float_byte().f(bytes);
        new C_short_float_byte().f(shorts);
        new C_short_float_byte().f(floats);
        new C_short_float_byte().f(bytes);
        new C_int_float_byte().f(ints);
        new C_int_float_byte().f(floats);
        new C_int_float_byte().f(bytes);
        new C_long_float_byte().f(longs);
        new C_long_float_byte().f(floats);
        new C_long_float_byte().f(bytes);
        new C_double_float_byte().f(doubles);
        new C_double_float_byte().f(floats);
        new C_double_float_byte().f(bytes);
        new C_boolean_float_char().f(booleans);
        new C_boolean_float_char().f(floats);
        new C_boolean_float_char().f(chars);
        new C_byte_float_char().f(bytes);
        new C_byte_float_char().f(floats);
        new C_byte_float_char().f(chars);
        new C_short_float_char().f(shorts);
        new C_short_float_char().f(floats);
        new C_short_float_char().f(chars);
        new C_int_float_char().f(ints);
        new C_int_float_char().f(floats);
        new C_int_float_char().f(chars);
        new C_long_float_char().f(longs);
        new C_long_float_char().f(floats);
        new C_long_float_char().f(chars);
        new C_double_float_char().f(doubles);
        new C_double_float_char().f(floats);
        new C_double_float_char().f(chars);
        new C_boolean_float_short().f(booleans);
        new C_boolean_float_short().f(floats);
        new C_boolean_float_short().f(shorts);
        new C_byte_float_short().f(bytes);
        new C_byte_float_short().f(floats);
        new C_byte_float_short().f(shorts);
        new C_char_float_short().f(chars);
        new C_char_float_short().f(floats);
        new C_char_float_short().f(shorts);
        new C_int_float_short().f(ints);
        new C_int_float_short().f(floats);
        new C_int_float_short().f(shorts);
        new C_long_float_short().f(longs);
        new C_long_float_short().f(floats);
        new C_long_float_short().f(shorts);
        new C_double_float_short().f(doubles);
        new C_double_float_short().f(floats);
        new C_double_float_short().f(shorts);
        new C_boolean_float_int().f(booleans);
        new C_boolean_float_int().f(floats);
        new C_boolean_float_int().f(ints);
        new C_byte_float_int().f(bytes);
        new C_byte_float_int().f(floats);
        new C_byte_float_int().f(ints);
        new C_char_float_int().f(chars);
        new C_char_float_int().f(floats);
        new C_char_float_int().f(ints);
        new C_short_float_int().f(shorts);
        new C_short_float_int().f(floats);
        new C_short_float_int().f(ints);
        new C_long_float_int().f(longs);
        new C_long_float_int().f(floats);
        new C_long_float_int().f(ints);
        new C_double_float_int().f(doubles);
        new C_double_float_int().f(floats);
        new C_double_float_int().f(ints);
        new C_boolean_float_long().f(booleans);
        new C_boolean_float_long().f(floats);
        new C_boolean_float_long().f(longs);
        new C_byte_float_long().f(bytes);
        new C_byte_float_long().f(floats);
        new C_byte_float_long().f(longs);
        new C_char_float_long().f(chars);
        new C_char_float_long().f(floats);
        new C_char_float_long().f(longs);
        new C_short_float_long().f(shorts);
        new C_short_float_long().f(floats);
        new C_short_float_long().f(longs);
        new C_long_float_long().f(longs);
        new C_long_float_long().f(floats);
        new C_long_float_long().f(longs);
        new C_double_float_long().f(doubles);
        new C_double_float_long().f(floats);
        new C_double_float_long().f(longs);
        new C_boolean_float_double().f(booleans);
        new C_boolean_float_double().f(floats);
        new C_boolean_float_double().f(doubles);
        new C_byte_float_double().f(bytes);
        new C_byte_float_double().f(floats);
        new C_byte_float_double().f(doubles);
        new C_char_float_double().f(chars);
        new C_char_float_double().f(floats);
        new C_char_float_double().f(doubles);
        new C_short_float_double().f(shorts);
        new C_short_float_double().f(floats);
        new C_short_float_double().f(doubles);
        new C_int_float_double().f(ints);
        new C_int_float_double().f(floats);
        new C_int_float_double().f(doubles);
        new C_long_float_double().f(longs);
        new C_long_float_double().f(floats);
        new C_long_float_double().f(doubles);
        new C_byte_int_boolean().f(bytes);
        new C_byte_int_boolean().f(ints);
        new C_byte_int_boolean().f(booleans);
        new C_char_int_boolean().f(chars);
        new C_char_int_boolean().f(ints);
        new C_char_int_boolean().f(booleans);
        new C_short_int_boolean().f(shorts);
        new C_short_int_boolean().f(ints);
        new C_short_int_boolean().f(booleans);
        new C_long_int_boolean().f(longs);
        new C_long_int_boolean().f(ints);
        new C_long_int_boolean().f(booleans);
        new C_float_int_boolean().f(floats);
        new C_float_int_boolean().f(ints);
        new C_float_int_boolean().f(booleans);
        new C_double_int_boolean().f(doubles);
        new C_double_int_boolean().f(ints);
        new C_double_int_boolean().f(booleans);
        new C_boolean_int_byte().f(booleans);
        new C_boolean_int_byte().f(ints);
        new C_boolean_int_byte().f(bytes);
        new C_char_int_byte().f(chars);
        new C_char_int_byte().f(ints);
        new C_char_int_byte().f(bytes);
        new C_short_int_byte().f(shorts);
        new C_short_int_byte().f(ints);
        new C_short_int_byte().f(bytes);
        new C_long_int_byte().f(longs);
        new C_long_int_byte().f(ints);
        new C_long_int_byte().f(bytes);
        new C_float_int_byte().f(floats);
        new C_float_int_byte().f(ints);
        new C_float_int_byte().f(bytes);
        new C_double_int_byte().f(doubles);
        new C_double_int_byte().f(ints);
        new C_double_int_byte().f(bytes);
        new C_boolean_int_char().f(booleans);
        new C_boolean_int_char().f(ints);
        new C_boolean_int_char().f(chars);
        new C_byte_int_char().f(bytes);
        new C_byte_int_char().f(ints);
        new C_byte_int_char().f(chars);
        new C_short_int_char().f(shorts);
        new C_short_int_char().f(ints);
        new C_short_int_char().f(chars);
        new C_long_int_char().f(longs);
        new C_long_int_char().f(ints);
        new C_long_int_char().f(chars);
        new C_float_int_char().f(floats);
        new C_float_int_char().f(ints);
        new C_float_int_char().f(chars);
        new C_double_int_char().f(doubles);
        new C_double_int_char().f(ints);
        new C_double_int_char().f(chars);
        new C_boolean_int_short().f(booleans);
        new C_boolean_int_short().f(ints);
        new C_boolean_int_short().f(shorts);
        new C_byte_int_short().f(bytes);
        new C_byte_int_short().f(ints);
        new C_byte_int_short().f(shorts);
        new C_char_int_short().f(chars);
        new C_char_int_short().f(ints);
        new C_char_int_short().f(shorts);
        new C_long_int_short().f(longs);
        new C_long_int_short().f(ints);
        new C_long_int_short().f(shorts);
        new C_float_int_short().f(floats);
        new C_float_int_short().f(ints);
        new C_float_int_short().f(shorts);
        new C_double_int_short().f(doubles);
        new C_double_int_short().f(ints);
        new C_double_int_short().f(shorts);
        new C_boolean_int_long().f(booleans);
        new C_boolean_int_long().f(ints);
        new C_boolean_int_long().f(longs);
        new C_byte_int_long().f(bytes);
        new C_byte_int_long().f(ints);
        new C_byte_int_long().f(longs);
        new C_char_int_long().f(chars);
        new C_char_int_long().f(ints);
        new C_char_int_long().f(longs);
        new C_short_int_long().f(shorts);
        new C_short_int_long().f(ints);
        new C_short_int_long().f(longs);
        new C_float_int_long().f(floats);
        new C_float_int_long().f(ints);
        new C_float_int_long().f(longs);
        new C_double_int_long().f(doubles);
        new C_double_int_long().f(ints);
        new C_double_int_long().f(longs);
        new C_boolean_int_float().f(booleans);
        new C_boolean_int_float().f(ints);
        new C_boolean_int_float().f(floats);
        new C_byte_int_float().f(bytes);
        new C_byte_int_float().f(ints);
        new C_byte_int_float().f(floats);
        new C_char_int_float().f(chars);
        new C_char_int_float().f(ints);
        new C_char_int_float().f(floats);
        new C_short_int_float().f(shorts);
        new C_short_int_float().f(ints);
        new C_short_int_float().f(floats);
        new C_long_int_float().f(longs);
        new C_long_int_float().f(ints);
        new C_long_int_float().f(floats);
        new C_double_int_float().f(doubles);
        new C_double_int_float().f(ints);
        new C_double_int_float().f(floats);
        new C_boolean_int_double().f(booleans);
        new C_boolean_int_double().f(ints);
        new C_boolean_int_double().f(doubles);
        new C_byte_int_double().f(bytes);
        new C_byte_int_double().f(ints);
        new C_byte_int_double().f(doubles);
        new C_char_int_double().f(chars);
        new C_char_int_double().f(ints);
        new C_char_int_double().f(doubles);
        new C_short_int_double().f(shorts);
        new C_short_int_double().f(ints);
        new C_short_int_double().f(doubles);
        new C_long_int_double().f(longs);
        new C_long_int_double().f(ints);
        new C_long_int_double().f(doubles);
        new C_float_int_double().f(floats);
        new C_float_int_double().f(ints);
        new C_float_int_double().f(doubles);
        new C_byte_short_boolean().f(bytes);
        new C_byte_short_boolean().f(shorts);
        new C_byte_short_boolean().f(booleans);
        new C_char_short_boolean().f(chars);
        new C_char_short_boolean().f(shorts);
        new C_char_short_boolean().f(booleans);
        new C_int_short_boolean().f(ints);
        new C_int_short_boolean().f(shorts);
        new C_int_short_boolean().f(booleans);
        new C_long_short_boolean().f(longs);
        new C_long_short_boolean().f(shorts);
        new C_long_short_boolean().f(booleans);
        new C_float_short_boolean().f(floats);
        new C_float_short_boolean().f(shorts);
        new C_float_short_boolean().f(booleans);
        new C_double_short_boolean().f(doubles);
        new C_double_short_boolean().f(shorts);
        new C_double_short_boolean().f(booleans);
        new C_boolean_short_byte().f(booleans);
        new C_boolean_short_byte().f(shorts);
        new C_boolean_short_byte().f(bytes);
        new C_char_short_byte().f(chars);
        new C_char_short_byte().f(shorts);
        new C_char_short_byte().f(bytes);
        new C_int_short_byte().f(ints);
        new C_int_short_byte().f(shorts);
        new C_int_short_byte().f(bytes);
        new C_long_short_byte().f(longs);
        new C_long_short_byte().f(shorts);
        new C_long_short_byte().f(bytes);
        new C_float_short_byte().f(floats);
        new C_float_short_byte().f(shorts);
        new C_float_short_byte().f(bytes);
        new C_double_short_byte().f(doubles);
        new C_double_short_byte().f(shorts);
        new C_double_short_byte().f(bytes);
        new C_boolean_short_char().f(booleans);
        new C_boolean_short_char().f(shorts);
        new C_boolean_short_char().f(chars);
        new C_byte_short_char().f(bytes);
        new C_byte_short_char().f(shorts);
        new C_byte_short_char().f(chars);
        new C_int_short_char().f(ints);
        new C_int_short_char().f(shorts);
        new C_int_short_char().f(chars);
        new C_long_short_char().f(longs);
        new C_long_short_char().f(shorts);
        new C_long_short_char().f(chars);
        new C_float_short_char().f(floats);
        new C_float_short_char().f(shorts);
        new C_float_short_char().f(chars);
        new C_double_short_char().f(doubles);
        new C_double_short_char().f(shorts);
        new C_double_short_char().f(chars);
        new C_boolean_short_int().f(booleans);
        new C_boolean_short_int().f(shorts);
        new C_boolean_short_int().f(ints);
        new C_byte_short_int().f(bytes);
        new C_byte_short_int().f(shorts);
        new C_byte_short_int().f(ints);
        new C_char_short_int().f(chars);
        new C_char_short_int().f(shorts);
        new C_char_short_int().f(ints);
        new C_long_short_int().f(longs);
        new C_long_short_int().f(shorts);
        new C_long_short_int().f(ints);
        new C_float_short_int().f(floats);
        new C_float_short_int().f(shorts);
        new C_float_short_int().f(ints);
        new C_double_short_int().f(doubles);
        new C_double_short_int().f(shorts);
        new C_double_short_int().f(ints);
        new C_boolean_short_long().f(booleans);
        new C_boolean_short_long().f(shorts);
        new C_boolean_short_long().f(longs);
        new C_byte_short_long().f(bytes);
        new C_byte_short_long().f(shorts);
        new C_byte_short_long().f(longs);
        new C_char_short_long().f(chars);
        new C_char_short_long().f(shorts);
        new C_char_short_long().f(longs);
        new C_int_short_long().f(ints);
        new C_int_short_long().f(shorts);
        new C_int_short_long().f(longs);
        new C_float_short_long().f(floats);
        new C_float_short_long().f(shorts);
        new C_float_short_long().f(longs);
        new C_double_short_long().f(doubles);
        new C_double_short_long().f(shorts);
        new C_double_short_long().f(longs);
        new C_boolean_short_float().f(booleans);
        new C_boolean_short_float().f(shorts);
        new C_boolean_short_float().f(floats);
        new C_byte_short_float().f(bytes);
        new C_byte_short_float().f(shorts);
        new C_byte_short_float().f(floats);
        new C_char_short_float().f(chars);
        new C_char_short_float().f(shorts);
        new C_char_short_float().f(floats);
        new C_int_short_float().f(ints);
        new C_int_short_float().f(shorts);
        new C_int_short_float().f(floats);
        new C_long_short_float().f(longs);
        new C_long_short_float().f(shorts);
        new C_long_short_float().f(floats);
        new C_double_short_float().f(doubles);
        new C_double_short_float().f(shorts);
        new C_double_short_float().f(floats);
        new C_boolean_short_double().f(booleans);
        new C_boolean_short_double().f(shorts);
        new C_boolean_short_double().f(doubles);
        new C_byte_short_double().f(bytes);
        new C_byte_short_double().f(shorts);
        new C_byte_short_double().f(doubles);
        new C_char_short_double().f(chars);
        new C_char_short_double().f(shorts);
        new C_char_short_double().f(doubles);
        new C_int_short_double().f(ints);
        new C_int_short_double().f(shorts);
        new C_int_short_double().f(doubles);
        new C_long_short_double().f(longs);
        new C_long_short_double().f(shorts);
        new C_long_short_double().f(doubles);
        new C_float_short_double().f(floats);
        new C_float_short_double().f(shorts);
        new C_float_short_double().f(doubles);
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    void m(java.lang.String msg) {
        org.aspectj.testing.Tester.expectEvent(msg);
    }
    
    void wants() {
        m("C_boolean-boolean");
        m("C_byte-byte");
        m("C_char-char");
        m("C_short-short");
        m("C_int-int");
        m("C_long-long");
        m("C_float-float");
        m("C_double-double");
        m("C_byte_double_boolean-byte");
        m("C_char_double_boolean-char");
        m("C_short_double_boolean-short");
        m("C_int_double_boolean-int");
        m("C_long_double_boolean-long");
        m("C_float_double_boolean-float");
        m("C_boolean_double_byte-boolean");
        m("C_char_double_byte-char");
        m("C_short_double_byte-short");
        m("C_int_double_byte-int");
        m("C_long_double_byte-long");
        m("C_float_double_byte-float");
        m("C_boolean_double_char-boolean");
        m("C_byte_double_char-byte");
        m("C_short_double_char-short");
        m("C_int_double_char-int");
        m("C_long_double_char-long");
        m("C_float_double_char-float");
        m("C_boolean_double_short-boolean");
        m("C_byte_double_short-byte");
        m("C_char_double_short-char");
        m("C_int_double_short-int");
        m("C_long_double_short-long");
        m("C_float_double_short-float");
        m("C_boolean_double_int-boolean");
        m("C_byte_double_int-byte");
        m("C_char_double_int-char");
        m("C_short_double_int-short");
        m("C_long_double_int-long");
        m("C_float_double_int-float");
        m("C_boolean_double_long-boolean");
        m("C_byte_double_long-byte");
        m("C_char_double_long-char");
        m("C_short_double_long-short");
        m("C_int_double_long-int");
        m("C_float_double_long-float");
        m("C_boolean_double_float-boolean");
        m("C_byte_double_float-byte");
        m("C_char_double_float-char");
        m("C_short_double_float-short");
        m("C_int_double_float-int");
        m("C_long_double_float-long");
        m("C_byte_float_boolean-byte");
        m("C_char_float_boolean-char");
        m("C_short_float_boolean-short");
        m("C_int_float_boolean-int");
        m("C_long_float_boolean-long");
        m("C_double_float_boolean-double");
        m("C_boolean_float_byte-boolean");
        m("C_char_float_byte-char");
        m("C_short_float_byte-short");
        m("C_int_float_byte-int");
        m("C_long_float_byte-long");
        m("C_double_float_byte-double");
        m("C_boolean_float_char-boolean");
        m("C_byte_float_char-byte");
        m("C_short_float_char-short");
        m("C_int_float_char-int");
        m("C_long_float_char-long");
        m("C_double_float_char-double");
        m("C_boolean_float_short-boolean");
        m("C_byte_float_short-byte");
        m("C_char_float_short-char");
        m("C_int_float_short-int");
        m("C_long_float_short-long");
        m("C_double_float_short-double");
        m("C_boolean_float_int-boolean");
        m("C_byte_float_int-byte");
        m("C_char_float_int-char");
        m("C_short_float_int-short");
        m("C_long_float_int-long");
        m("C_double_float_int-double");
        m("C_boolean_float_long-boolean");
        m("C_byte_float_long-byte");
        m("C_char_float_long-char");
        m("C_short_float_long-short");
        m("C_long_float_long-long");
        m("C_double_float_long-double");
        m("C_boolean_float_double-boolean");
        m("C_byte_float_double-byte");
        m("C_char_float_double-char");
        m("C_short_float_double-short");
        m("C_int_float_double-int");
        m("C_long_float_double-long");
        m("C_byte_int_boolean-byte");
        m("C_char_int_boolean-char");
        m("C_short_int_boolean-short");
        m("C_long_int_boolean-long");
        m("C_float_int_boolean-float");
        m("C_double_int_boolean-double");
        m("C_boolean_int_byte-boolean");
        m("C_char_int_byte-char");
        m("C_short_int_byte-short");
        m("C_long_int_byte-long");
        m("C_float_int_byte-float");
        m("C_double_int_byte-double");
        m("C_boolean_int_char-boolean");
        m("C_byte_int_char-byte");
        m("C_short_int_char-short");
        m("C_long_int_char-long");
        m("C_float_int_char-float");
        m("C_double_int_char-double");
        m("C_boolean_int_short-boolean");
        m("C_byte_int_short-byte");
        m("C_char_int_short-char");
        m("C_long_int_short-long");
        m("C_float_int_short-float");
        m("C_double_int_short-double");
        m("C_boolean_int_long-boolean");
        m("C_byte_int_long-byte");
        m("C_char_int_long-char");
        m("C_short_int_long-short");
        m("C_float_int_long-float");
        m("C_double_int_long-double");
        m("C_boolean_int_float-boolean");
        m("C_byte_int_float-byte");
        m("C_char_int_float-char");
        m("C_short_int_float-short");
        m("C_long_int_float-long");
        m("C_double_int_float-double");
        m("C_boolean_int_double-boolean");
        m("C_byte_int_double-byte");
        m("C_char_int_double-char");
        m("C_short_int_double-short");
        m("C_long_int_double-long");
        m("C_float_int_double-float");
        m("C_byte_short_boolean-byte");
        m("C_char_short_boolean-char");
        m("C_int_short_boolean-int");
        m("C_long_short_boolean-long");
        m("C_float_short_boolean-float");
        m("C_double_short_boolean-double");
        m("C_boolean_short_byte-boolean");
        m("C_char_short_byte-char");
        m("C_int_short_byte-int");
        m("C_long_short_byte-long");
        m("C_float_short_byte-float");
        m("C_double_short_byte-double");
        m("C_boolean_short_char-boolean");
        m("C_byte_short_char-byte");
        m("C_int_short_char-int");
        m("C_long_short_char-long");
        m("C_float_short_char-float");
        m("C_double_short_char-double");
        m("C_boolean_short_int-boolean");
        m("C_byte_short_int-byte");
        m("C_char_short_int-char");
        m("C_long_short_int-long");
        m("C_float_short_int-float");
        m("C_double_short_int-double");
        m("C_boolean_short_long-boolean");
        m("C_byte_short_long-byte");
        m("C_char_short_long-char");
        m("C_int_short_long-int");
        m("C_float_short_long-float");
        m("C_double_short_long-double");
        m("C_boolean_short_float-boolean");
        m("C_byte_short_float-byte");
        m("C_char_short_float-char");
        m("C_int_short_float-int");
        m("C_long_short_float-long");
        m("C_double_short_float-double");
        m("C_boolean_short_double-boolean");
        m("C_byte_short_double-byte");
        m("C_char_short_double-char");
        m("C_int_short_double-int");
        m("C_long_short_double-long");
        m("C_float_short_double-float");
        m("C_byte_char_boolean-byte");
        m("C_short_char_boolean-short");
        m("C_int_char_boolean-int");
        m("C_long_char_boolean-long");
        m("C_float_char_boolean-float");
        m("C_double_char_boolean-double");
        m("C_boolean_char_byte-boolean");
        m("C_short_char_byte-short");
        m("C_int_char_byte-int");
        m("C_long_char_byte-long");
        m("C_float_char_byte-float");
        m("C_double_char_byte-double");
        m("C_boolean_char_short-boolean");
        m("C_byte_char_short-byte");
        m("C_int_char_short-int");
        m("C_long_char_short-long");
        m("C_float_char_short-float");
        m("C_double_char_short-double");
        m("C_boolean_char_int-boolean");
        m("C_byte_char_int-byte");
        m("C_short_char_int-short");
        m("C_long_char_int-long");
        m("C_float_char_int-float");
        m("C_double_char_int-double");
        m("C_boolean_char_long-boolean");
        m("C_byte_char_long-byte");
        m("C_short_char_long-short");
        m("C_int_char_long-int");
        m("C_float_char_long-float");
        m("C_double_char_long-double");
        m("C_boolean_char_float-boolean");
        m("C_byte_char_float-byte");
        m("C_short_char_float-short");
        m("C_int_char_float-int");
        m("C_long_char_float-long");
        m("C_double_char_float-double");
        m("C_boolean_char_double-boolean");
        m("C_byte_char_double-byte");
        m("C_short_char_double-short");
        m("C_int_char_double-int");
        m("C_long_char_double-long");
        m("C_float_char_double-float");
        m("C_char_byte_boolean-char");
        m("C_short_byte_boolean-short");
        m("C_int_byte_boolean-int");
        m("C_long_byte_boolean-long");
        m("C_float_byte_boolean-float");
        m("C_double_byte_boolean-double");
        m("C_boolean_byte_char-boolean");
        m("C_short_byte_char-short");
        m("C_int_byte_char-int");
        m("C_long_byte_char-long");
        m("C_float_byte_char-float");
        m("C_double_byte_char-double");
        m("C_boolean_byte_short-boolean");
        m("C_char_byte_short-char");
        m("C_int_byte_short-int");
        m("C_long_byte_short-long");
        m("C_float_byte_short-float");
        m("C_double_byte_short-double");
        m("C_boolean_byte_int-boolean");
        m("C_char_byte_int-char");
        m("C_short_byte_int-short");
        m("C_long_byte_int-long");
        m("C_float_byte_int-float");
        m("C_double_byte_int-double");
        m("C_boolean_byte_long-boolean");
        m("C_char_byte_long-char");
        m("C_short_byte_long-short");
        m("C_int_byte_long-int");
        m("C_float_byte_long-float");
        m("C_double_byte_long-double");
        m("C_boolean_byte_float-boolean");
        m("C_char_byte_float-char");
        m("C_short_byte_float-short");
        m("C_int_byte_float-int");
        m("C_long_byte_float-long");
        m("C_double_byte_float-double");
        m("C_boolean_byte_double-boolean");
        m("C_char_byte_double-char");
        m("C_short_byte_double-short");
        m("C_int_byte_double-int");
        m("C_long_byte_double-long");
        m("C_float_byte_double-float");
        m("C_byte_boolean_double-byte");
        m("C_char_boolean_double-char");
        m("C_short_boolean_double-short");
        m("C_int_boolean_double-int");
        m("C_long_boolean_double-long");
        m("C_float_boolean_double-float");
        m("C_byte_boolean_float-byte");
        m("C_char_boolean_float-char");
        m("C_short_boolean_float-short");
        m("C_int_boolean_float-int");
        m("C_long_boolean_float-long");
        m("C_double_boolean_float-double");
        m("C_byte_boolean_long-byte");
        m("C_char_boolean_long-char");
        m("C_short_boolean_long-short");
        m("C_int_boolean_long-int");
        m("C_float_boolean_long-float");
        m("C_double_boolean_long-double");
        m("C_byte_boolean_int-byte");
        m("C_char_boolean_int-char");
        m("C_short_boolean_int-short");
        m("C_long_boolean_int-long");
        m("C_float_boolean_int-float");
        m("C_double_boolean_int-double");
        m("C_byte_boolean_short-byte");
        m("C_char_boolean_short-char");
        m("C_int_boolean_short-int");
        m("C_long_boolean_short-long");
        m("C_float_boolean_short-float");
        m("C_double_boolean_short-double");
        m("C_byte_boolean_char-byte");
        m("C_short_boolean_char-short");
        m("C_int_boolean_char-int");
        m("C_long_boolean_char-long");
        m("C_float_boolean_char-float");
        m("C_double_boolean_char-double");
        m("C_char_boolean_byte-char");
        m("C_short_boolean_byte-short");
        m("C_int_boolean_byte-int");
        m("C_long_boolean_byte-long");
        m("C_float_boolean_byte-float");
        m("C_double_boolean_byte-double");
        m("C_boolean_double-boolean");
        m("C_byte_double-byte");
        m("C_char_double-char");
        m("C_short_double-short");
        m("C_int_double-int");
        m("C_long_double-long");
        m("C_float_double-float");
        m("C_boolean_float-boolean");
        m("C_byte_float-byte");
        m("C_char_float-char");
        m("C_short_float-short");
        m("C_int_float-int");
        m("C_long_float-long");
        m("C_double_float-double");
        m("C_boolean_long-boolean");
        m("C_byte_long-byte");
        m("C_char_long-char");
        m("C_short_long-short");
        m("C_int_long-int");
        m("C_float_long-float");
        m("C_double_long-double");
        m("C_boolean_int-boolean");
        m("C_byte_int-byte");
        m("C_char_int-char");
        m("C_short_int-short");
        m("C_long_int-long");
        m("C_float_int-float");
        m("C_double_int-double");
        m("C_boolean_short-boolean");
        m("C_byte_short-byte");
        m("C_char_short-char");
        m("C_int_short-int");
        m("C_long_short-long");
        m("C_float_short-float");
        m("C_double_short-double");
        m("C_boolean_char-boolean");
        m("C_byte_char-byte");
        m("C_short_char-short");
        m("C_int_char-int");
        m("C_long_char-long");
        m("C_float_char-float");
        m("C_double_char-double");
        m("C_boolean_byte-boolean");
        m("C_char_byte-char");
        m("C_short_byte-short");
        m("C_int_byte-int");
        m("C_long_byte-long");
        m("C_float_byte-float");
        m("C_double_byte-double");
        m("C_byte_boolean-byte");
        m("C_char_boolean-char");
        m("C_short_boolean-short");
        m("C_int_boolean-int");
        m("C_long_boolean-long");
        m("C_float_boolean-float");
        m("C_double_boolean-double");
    }
    
    public ResolvingArrayParameters() { super(); }
}
class C_boolean {
    public void f(boolean[] xs) {  }
    
    public C_boolean() { super(); }
}
class C_byte {
    public void f(byte[] xs) {  }
    
    public C_byte() { super(); }
}
class C_char {
    public void f(char[] xs) {  }
    
    public C_char() { super(); }
}
class C_short {
    public void f(short[] xs) {  }
    
    public C_short() { super(); }
}
class C_int {
    public void f(int[] xs) {  }
    
    public C_int() { super(); }
}
class C_long {
    public void f(long[] xs) {  }
    
    public C_long() { super(); }
}
class C_float {
    public void f(float[] xs) {  }
    
    public C_float() { super(); }
}
class C_double {
    public void f(double[] xs) {  }
    
    public C_double() { super(); }
}
class CC_boolean {
    public void f(boolean[] xs) { A.a("C_boolean-boolean"); }
    
    public CC_boolean() { super(); }
}
class CC_byte {
    public void f(byte[] xs) { A.a("C_byte-byte"); }
    
    public CC_byte() { super(); }
}
class CC_char {
    public void f(char[] xs) { A.a("C_char-char"); }
    
    public CC_char() { super(); }
}
class CC_short {
    public void f(short[] xs) { A.a("C_short-short"); }
    
    public CC_short() { super(); }
}
class CC_int {
    public void f(int[] xs) { A.a("C_int-int"); }
    
    public CC_int() { super(); }
}
class CC_long {
    public void f(long[] xs) { A.a("C_long-long"); }
    
    public CC_long() { super(); }
}
class CC_float {
    public void f(float[] xs) { A.a("C_float-float"); }
    
    public CC_float() { super(); }
}
class CC_double {
    public void f(double[] xs) { A.a("C_double-double"); }
    
    public CC_double() { super(); }
}
class A {
    public static void a(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    public A() { super(); }
}
class C_byte_double_boolean extends C_double_boolean {
    public void f(byte[] xs) { A.a("C_byte_double_boolean-byte"); }
    
    public C_byte_double_boolean() { super(); }
}
class C_char_double_boolean extends C_double_boolean {
    public void f(char[] xs) { A.a("C_char_double_boolean-char"); }
    
    public C_char_double_boolean() { super(); }
}
class C_short_double_boolean extends C_double_boolean {
    public void f(short[] xs) { A.a("C_short_double_boolean-short"); }
    
    public C_short_double_boolean() { super(); }
}
class C_int_double_boolean extends C_double_boolean {
    public void f(int[] xs) { A.a("C_int_double_boolean-int"); }
    
    public C_int_double_boolean() { super(); }
}
class C_long_double_boolean extends C_double_boolean {
    public void f(long[] xs) { A.a("C_long_double_boolean-long"); }
    
    public C_long_double_boolean() { super(); }
}
class C_float_double_boolean extends C_double_boolean {
    public void f(float[] xs) { A.a("C_float_double_boolean-float"); }
    
    public C_float_double_boolean() { super(); }
}
class C_boolean_double_byte extends C_double_byte {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_byte-boolean");
    }
    
    public C_boolean_double_byte() { super(); }
}
class C_char_double_byte extends C_double_byte {
    public void f(char[] xs) { A.a("C_char_double_byte-char"); }
    
    public C_char_double_byte() { super(); }
}
class C_short_double_byte extends C_double_byte {
    public void f(short[] xs) { A.a("C_short_double_byte-short"); }
    
    public C_short_double_byte() { super(); }
}
class C_int_double_byte extends C_double_byte {
    public void f(int[] xs) { A.a("C_int_double_byte-int"); }
    
    public C_int_double_byte() { super(); }
}
class C_long_double_byte extends C_double_byte {
    public void f(long[] xs) { A.a("C_long_double_byte-long"); }
    
    public C_long_double_byte() { super(); }
}
class C_float_double_byte extends C_double_byte {
    public void f(float[] xs) { A.a("C_float_double_byte-float"); }
    
    public C_float_double_byte() { super(); }
}
class C_boolean_double_char extends C_double_char {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_char-boolean");
    }
    
    public C_boolean_double_char() { super(); }
}
class C_byte_double_char extends C_double_char {
    public void f(byte[] xs) { A.a("C_byte_double_char-byte"); }
    
    public C_byte_double_char() { super(); }
}
class C_short_double_char extends C_double_char {
    public void f(short[] xs) { A.a("C_short_double_char-short"); }
    
    public C_short_double_char() { super(); }
}
class C_int_double_char extends C_double_char {
    public void f(int[] xs) { A.a("C_int_double_char-int"); }
    
    public C_int_double_char() { super(); }
}
class C_long_double_char extends C_double_char {
    public void f(long[] xs) { A.a("C_long_double_char-long"); }
    
    public C_long_double_char() { super(); }
}
class C_float_double_char extends C_double_char {
    public void f(float[] xs) { A.a("C_float_double_char-float"); }
    
    public C_float_double_char() { super(); }
}
class C_boolean_double_short extends C_double_short {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_short-boolean");
    }
    
    public C_boolean_double_short() { super(); }
}
class C_byte_double_short extends C_double_short {
    public void f(byte[] xs) { A.a("C_byte_double_short-byte"); }
    
    public C_byte_double_short() { super(); }
}
class C_char_double_short extends C_double_short {
    public void f(char[] xs) { A.a("C_char_double_short-char"); }
    
    public C_char_double_short() { super(); }
}
class C_int_double_short extends C_double_short {
    public void f(int[] xs) { A.a("C_int_double_short-int"); }
    
    public C_int_double_short() { super(); }
}
class C_long_double_short extends C_double_short {
    public void f(long[] xs) { A.a("C_long_double_short-long"); }
    
    public C_long_double_short() { super(); }
}
class C_float_double_short extends C_double_short {
    public void f(float[] xs) { A.a("C_float_double_short-float"); }
    
    public C_float_double_short() { super(); }
}
class C_boolean_double_int extends C_double_int {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_int-boolean");
    }
    
    public C_boolean_double_int() { super(); }
}
class C_byte_double_int extends C_double_int {
    public void f(byte[] xs) { A.a("C_byte_double_int-byte"); }
    
    public C_byte_double_int() { super(); }
}
class C_char_double_int extends C_double_int {
    public void f(char[] xs) { A.a("C_char_double_int-char"); }
    
    public C_char_double_int() { super(); }
}
class C_short_double_int extends C_double_int {
    public void f(short[] xs) { A.a("C_short_double_int-short"); }
    
    public C_short_double_int() { super(); }
}
class C_long_double_int extends C_double_int {
    public void f(long[] xs) { A.a("C_long_double_int-long"); }
    
    public C_long_double_int() { super(); }
}
class C_float_double_int extends C_double_int {
    public void f(float[] xs) { A.a("C_float_double_int-float"); }
    
    public C_float_double_int() { super(); }
}
class C_boolean_double_long extends C_double_long {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_long-boolean");
    }
    
    public C_boolean_double_long() { super(); }
}
class C_byte_double_long extends C_double_long {
    public void f(byte[] xs) { A.a("C_byte_double_long-byte"); }
    
    public C_byte_double_long() { super(); }
}
class C_char_double_long extends C_double_long {
    public void f(char[] xs) { A.a("C_char_double_long-char"); }
    
    public C_char_double_long() { super(); }
}
class C_short_double_long extends C_double_long {
    public void f(short[] xs) { A.a("C_short_double_long-short"); }
    
    public C_short_double_long() { super(); }
}
class C_int_double_long extends C_double_long {
    public void f(int[] xs) { A.a("C_int_double_long-int"); }
    
    public C_int_double_long() { super(); }
}
class C_float_double_long extends C_double_long {
    public void f(float[] xs) { A.a("C_float_double_long-float"); }
    
    public C_float_double_long() { super(); }
}
class C_boolean_double_float extends C_double_float {
    public void f(boolean[] xs) {
        A.a("C_boolean_double_float-boolean");
    }
    
    public C_boolean_double_float() { super(); }
}
class C_byte_double_float extends C_double_float {
    public void f(byte[] xs) { A.a("C_byte_double_float-byte"); }
    
    public C_byte_double_float() { super(); }
}
class C_char_double_float extends C_double_float {
    public void f(char[] xs) { A.a("C_char_double_float-char"); }
    
    public C_char_double_float() { super(); }
}
class C_short_double_float extends C_double_float {
    public void f(short[] xs) { A.a("C_short_double_float-short"); }
    
    public C_short_double_float() { super(); }
}
class C_int_double_float extends C_double_float {
    public void f(int[] xs) { A.a("C_int_double_float-int"); }
    
    public C_int_double_float() { super(); }
}
class C_long_double_float extends C_double_float {
    public void f(long[] xs) { A.a("C_long_double_float-long"); }
    
    public C_long_double_float() { super(); }
}
class C_byte_float_boolean extends C_float_boolean {
    public void f(byte[] xs) { A.a("C_byte_float_boolean-byte"); }
    
    public C_byte_float_boolean() { super(); }
}
class C_char_float_boolean extends C_float_boolean {
    public void f(char[] xs) { A.a("C_char_float_boolean-char"); }
    
    public C_char_float_boolean() { super(); }
}
class C_short_float_boolean extends C_float_boolean {
    public void f(short[] xs) { A.a("C_short_float_boolean-short"); }
    
    public C_short_float_boolean() { super(); }
}
class C_int_float_boolean extends C_float_boolean {
    public void f(int[] xs) { A.a("C_int_float_boolean-int"); }
    
    public C_int_float_boolean() { super(); }
}
class C_long_float_boolean extends C_float_boolean {
    public void f(long[] xs) { A.a("C_long_float_boolean-long"); }
    
    public C_long_float_boolean() { super(); }
}
class C_double_float_boolean extends C_float_boolean {
    public void f(double[] xs) {
        A.a("C_double_float_boolean-double");
    }
    
    public C_double_float_boolean() { super(); }
}
class C_boolean_float_byte extends C_float_byte {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_byte-boolean");
    }
    
    public C_boolean_float_byte() { super(); }
}
class C_char_float_byte extends C_float_byte {
    public void f(char[] xs) { A.a("C_char_float_byte-char"); }
    
    public C_char_float_byte() { super(); }
}
class C_short_float_byte extends C_float_byte {
    public void f(short[] xs) { A.a("C_short_float_byte-short"); }
    
    public C_short_float_byte() { super(); }
}
class C_int_float_byte extends C_float_byte {
    public void f(int[] xs) { A.a("C_int_float_byte-int"); }
    
    public C_int_float_byte() { super(); }
}
class C_long_float_byte extends C_float_byte {
    public void f(long[] xs) { A.a("C_long_float_byte-long"); }
    
    public C_long_float_byte() { super(); }
}
class C_double_float_byte extends C_float_byte {
    public void f(double[] xs) { A.a("C_double_float_byte-double"); }
    
    public C_double_float_byte() { super(); }
}
class C_boolean_float_char extends C_float_char {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_char-boolean");
    }
    
    public C_boolean_float_char() { super(); }
}
class C_byte_float_char extends C_float_char {
    public void f(byte[] xs) { A.a("C_byte_float_char-byte"); }
    
    public C_byte_float_char() { super(); }
}
class C_short_float_char extends C_float_char {
    public void f(short[] xs) { A.a("C_short_float_char-short"); }
    
    public C_short_float_char() { super(); }
}
class C_int_float_char extends C_float_char {
    public void f(int[] xs) { A.a("C_int_float_char-int"); }
    
    public C_int_float_char() { super(); }
}
class C_long_float_char extends C_float_char {
    public void f(long[] xs) { A.a("C_long_float_char-long"); }
    
    public C_long_float_char() { super(); }
}
class C_double_float_char extends C_float_char {
    public void f(double[] xs) { A.a("C_double_float_char-double"); }
    
    public C_double_float_char() { super(); }
}
class C_boolean_float_short extends C_float_short {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_short-boolean");
    }
    
    public C_boolean_float_short() { super(); }
}
class C_byte_float_short extends C_float_short {
    public void f(byte[] xs) { A.a("C_byte_float_short-byte"); }
    
    public C_byte_float_short() { super(); }
}
class C_char_float_short extends C_float_short {
    public void f(char[] xs) { A.a("C_char_float_short-char"); }
    
    public C_char_float_short() { super(); }
}
class C_int_float_short extends C_float_short {
    public void f(int[] xs) { A.a("C_int_float_short-int"); }
    
    public C_int_float_short() { super(); }
}
class C_long_float_short extends C_float_short {
    public void f(long[] xs) { A.a("C_long_float_short-long"); }
    
    public C_long_float_short() { super(); }
}
class C_double_float_short extends C_float_short {
    public void f(double[] xs) { A.a("C_double_float_short-double"); }
    
    public C_double_float_short() { super(); }
}
class C_boolean_float_int extends C_float_int {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_int-boolean");
    }
    
    public C_boolean_float_int() { super(); }
}
class C_byte_float_int extends C_float_int {
    public void f(byte[] xs) { A.a("C_byte_float_int-byte"); }
    
    public C_byte_float_int() { super(); }
}
class C_char_float_int extends C_float_int {
    public void f(char[] xs) { A.a("C_char_float_int-char"); }
    
    public C_char_float_int() { super(); }
}
class C_short_float_int extends C_float_int {
    public void f(short[] xs) { A.a("C_short_float_int-short"); }
    
    public C_short_float_int() { super(); }
}
class C_long_float_int extends C_float_int {
    public void f(long[] xs) { A.a("C_long_float_int-long"); }
    
    public C_long_float_int() { super(); }
}
class C_double_float_int extends C_float_int {
    public void f(double[] xs) { A.a("C_double_float_int-double"); }
    
    public C_double_float_int() { super(); }
}
class C_boolean_float_long extends C_float_long {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_long-boolean");
    }
    
    public C_boolean_float_long() { super(); }
}
class C_byte_float_long extends C_float_long {
    public void f(byte[] xs) { A.a("C_byte_float_long-byte"); }
    
    public C_byte_float_long() { super(); }
}
class C_char_float_long extends C_float_long {
    public void f(char[] xs) { A.a("C_char_float_long-char"); }
    
    public C_char_float_long() { super(); }
}
class C_short_float_long extends C_float_long {
    public void f(short[] xs) { A.a("C_short_float_long-short"); }
    
    public C_short_float_long() { super(); }
}
class C_long_float_long extends C_float_long {
    public void f(long[] xs) { A.a("C_long_float_long-long"); }
    
    public C_long_float_long() { super(); }
}
class C_double_float_long extends C_float_long {
    public void f(double[] xs) { A.a("C_double_float_long-double"); }
    
    public C_double_float_long() { super(); }
}
class C_boolean_float_double extends C_float_double {
    public void f(boolean[] xs) {
        A.a("C_boolean_float_double-boolean");
    }
    
    public C_boolean_float_double() { super(); }
}
class C_byte_float_double extends C_float_double {
    public void f(byte[] xs) { A.a("C_byte_float_double-byte"); }
    
    public C_byte_float_double() { super(); }
}
class C_char_float_double extends C_float_double {
    public void f(char[] xs) { A.a("C_char_float_double-char"); }
    
    public C_char_float_double() { super(); }
}
class C_short_float_double extends C_float_double {
    public void f(short[] xs) { A.a("C_short_float_double-short"); }
    
    public C_short_float_double() { super(); }
}
class C_int_float_double extends C_float_double {
    public void f(int[] xs) { A.a("C_int_float_double-int"); }
    
    public C_int_float_double() { super(); }
}
class C_long_float_double extends C_float_double {
    public void f(long[] xs) { A.a("C_long_float_double-long"); }
    
    public C_long_float_double() { super(); }
}
class C_byte_int_boolean extends C_int_boolean {
    public void f(byte[] xs) { A.a("C_byte_int_boolean-byte"); }
    
    public C_byte_int_boolean() { super(); }
}
class C_char_int_boolean extends C_int_boolean {
    public void f(char[] xs) { A.a("C_char_int_boolean-char"); }
    
    public C_char_int_boolean() { super(); }
}
class C_short_int_boolean extends C_int_boolean {
    public void f(short[] xs) { A.a("C_short_int_boolean-short"); }
    
    public C_short_int_boolean() { super(); }
}
class C_long_int_boolean extends C_int_boolean {
    public void f(long[] xs) { A.a("C_long_int_boolean-long"); }
    
    public C_long_int_boolean() { super(); }
}
class C_float_int_boolean extends C_int_boolean {
    public void f(float[] xs) { A.a("C_float_int_boolean-float"); }
    
    public C_float_int_boolean() { super(); }
}
class C_double_int_boolean extends C_int_boolean {
    public void f(double[] xs) { A.a("C_double_int_boolean-double"); }
    
    public C_double_int_boolean() { super(); }
}
class C_boolean_int_byte extends C_int_byte {
    public void f(boolean[] xs) { A.a("C_boolean_int_byte-boolean"); }
    
    public C_boolean_int_byte() { super(); }
}
class C_char_int_byte extends C_int_byte {
    public void f(char[] xs) { A.a("C_char_int_byte-char"); }
    
    public C_char_int_byte() { super(); }
}
class C_short_int_byte extends C_int_byte {
    public void f(short[] xs) { A.a("C_short_int_byte-short"); }
    
    public C_short_int_byte() { super(); }
}
class C_long_int_byte extends C_int_byte {
    public void f(long[] xs) { A.a("C_long_int_byte-long"); }
    
    public C_long_int_byte() { super(); }
}
class C_float_int_byte extends C_int_byte {
    public void f(float[] xs) { A.a("C_float_int_byte-float"); }
    
    public C_float_int_byte() { super(); }
}
class C_double_int_byte extends C_int_byte {
    public void f(double[] xs) { A.a("C_double_int_byte-double"); }
    
    public C_double_int_byte() { super(); }
}
class C_boolean_int_char extends C_int_char {
    public void f(boolean[] xs) { A.a("C_boolean_int_char-boolean"); }
    
    public C_boolean_int_char() { super(); }
}
class C_byte_int_char extends C_int_char {
    public void f(byte[] xs) { A.a("C_byte_int_char-byte"); }
    
    public C_byte_int_char() { super(); }
}
class C_short_int_char extends C_int_char {
    public void f(short[] xs) { A.a("C_short_int_char-short"); }
    
    public C_short_int_char() { super(); }
}
class C_long_int_char extends C_int_char {
    public void f(long[] xs) { A.a("C_long_int_char-long"); }
    
    public C_long_int_char() { super(); }
}
class C_float_int_char extends C_int_char {
    public void f(float[] xs) { A.a("C_float_int_char-float"); }
    
    public C_float_int_char() { super(); }
}
class C_double_int_char extends C_int_char {
    public void f(double[] xs) { A.a("C_double_int_char-double"); }
    
    public C_double_int_char() { super(); }
}
class C_boolean_int_short extends C_int_short {
    public void f(boolean[] xs) {
        A.a("C_boolean_int_short-boolean");
    }
    
    public C_boolean_int_short() { super(); }
}
class C_byte_int_short extends C_int_short {
    public void f(byte[] xs) { A.a("C_byte_int_short-byte"); }
    
    public C_byte_int_short() { super(); }
}
class C_char_int_short extends C_int_short {
    public void f(char[] xs) { A.a("C_char_int_short-char"); }
    
    public C_char_int_short() { super(); }
}
class C_long_int_short extends C_int_short {
    public void f(long[] xs) { A.a("C_long_int_short-long"); }
    
    public C_long_int_short() { super(); }
}
class C_float_int_short extends C_int_short {
    public void f(float[] xs) { A.a("C_float_int_short-float"); }
    
    public C_float_int_short() { super(); }
}
class C_double_int_short extends C_int_short {
    public void f(double[] xs) { A.a("C_double_int_short-double"); }
    
    public C_double_int_short() { super(); }
}
class C_boolean_int_long extends C_int_long {
    public void f(boolean[] xs) { A.a("C_boolean_int_long-boolean"); }
    
    public C_boolean_int_long() { super(); }
}
class C_byte_int_long extends C_int_long {
    public void f(byte[] xs) { A.a("C_byte_int_long-byte"); }
    
    public C_byte_int_long() { super(); }
}
class C_char_int_long extends C_int_long {
    public void f(char[] xs) { A.a("C_char_int_long-char"); }
    
    public C_char_int_long() { super(); }
}
class C_short_int_long extends C_int_long {
    public void f(short[] xs) { A.a("C_short_int_long-short"); }
    
    public C_short_int_long() { super(); }
}
class C_float_int_long extends C_int_long {
    public void f(float[] xs) { A.a("C_float_int_long-float"); }
    
    public C_float_int_long() { super(); }
}
class C_double_int_long extends C_int_long {
    public void f(double[] xs) { A.a("C_double_int_long-double"); }
    
    public C_double_int_long() { super(); }
}
class C_boolean_int_float extends C_int_float {
    public void f(boolean[] xs) {
        A.a("C_boolean_int_float-boolean");
    }
    
    public C_boolean_int_float() { super(); }
}
class C_byte_int_float extends C_int_float {
    public void f(byte[] xs) { A.a("C_byte_int_float-byte"); }
    
    public C_byte_int_float() { super(); }
}
class C_char_int_float extends C_int_float {
    public void f(char[] xs) { A.a("C_char_int_float-char"); }
    
    public C_char_int_float() { super(); }
}
class C_short_int_float extends C_int_float {
    public void f(short[] xs) { A.a("C_short_int_float-short"); }
    
    public C_short_int_float() { super(); }
}
class C_long_int_float extends C_int_float {
    public void f(long[] xs) { A.a("C_long_int_float-long"); }
    
    public C_long_int_float() { super(); }
}
class C_double_int_float extends C_int_float {
    public void f(double[] xs) { A.a("C_double_int_float-double"); }
    
    public C_double_int_float() { super(); }
}
class C_boolean_int_double extends C_int_double {
    public void f(boolean[] xs) {
        A.a("C_boolean_int_double-boolean");
    }
    
    public C_boolean_int_double() { super(); }
}
class C_byte_int_double extends C_int_double {
    public void f(byte[] xs) { A.a("C_byte_int_double-byte"); }
    
    public C_byte_int_double() { super(); }
}
class C_char_int_double extends C_int_double {
    public void f(char[] xs) { A.a("C_char_int_double-char"); }
    
    public C_char_int_double() { super(); }
}
class C_short_int_double extends C_int_double {
    public void f(short[] xs) { A.a("C_short_int_double-short"); }
    
    public C_short_int_double() { super(); }
}
class C_long_int_double extends C_int_double {
    public void f(long[] xs) { A.a("C_long_int_double-long"); }
    
    public C_long_int_double() { super(); }
}
class C_float_int_double extends C_int_double {
    public void f(float[] xs) { A.a("C_float_int_double-float"); }
    
    public C_float_int_double() { super(); }
}
class C_byte_short_boolean extends C_short_boolean {
    public void f(byte[] xs) { A.a("C_byte_short_boolean-byte"); }
    
    public C_byte_short_boolean() { super(); }
}
class C_char_short_boolean extends C_short_boolean {
    public void f(char[] xs) { A.a("C_char_short_boolean-char"); }
    
    public C_char_short_boolean() { super(); }
}
class C_int_short_boolean extends C_short_boolean {
    public void f(int[] xs) { A.a("C_int_short_boolean-int"); }
    
    public C_int_short_boolean() { super(); }
}
class C_long_short_boolean extends C_short_boolean {
    public void f(long[] xs) { A.a("C_long_short_boolean-long"); }
    
    public C_long_short_boolean() { super(); }
}
class C_float_short_boolean extends C_short_boolean {
    public void f(float[] xs) { A.a("C_float_short_boolean-float"); }
    
    public C_float_short_boolean() { super(); }
}
class C_double_short_boolean extends C_short_boolean {
    public void f(double[] xs) {
        A.a("C_double_short_boolean-double");
    }
    
    public C_double_short_boolean() { super(); }
}
class C_boolean_short_byte extends C_short_byte {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_byte-boolean");
    }
    
    public C_boolean_short_byte() { super(); }
}
class C_char_short_byte extends C_short_byte {
    public void f(char[] xs) { A.a("C_char_short_byte-char"); }
    
    public C_char_short_byte() { super(); }
}
class C_int_short_byte extends C_short_byte {
    public void f(int[] xs) { A.a("C_int_short_byte-int"); }
    
    public C_int_short_byte() { super(); }
}
class C_long_short_byte extends C_short_byte {
    public void f(long[] xs) { A.a("C_long_short_byte-long"); }
    
    public C_long_short_byte() { super(); }
}
class C_float_short_byte extends C_short_byte {
    public void f(float[] xs) { A.a("C_float_short_byte-float"); }
    
    public C_float_short_byte() { super(); }
}
class C_double_short_byte extends C_short_byte {
    public void f(double[] xs) { A.a("C_double_short_byte-double"); }
    
    public C_double_short_byte() { super(); }
}
class C_boolean_short_char extends C_short_char {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_char-boolean");
    }
    
    public C_boolean_short_char() { super(); }
}
class C_byte_short_char extends C_short_char {
    public void f(byte[] xs) { A.a("C_byte_short_char-byte"); }
    
    public C_byte_short_char() { super(); }
}
class C_int_short_char extends C_short_char {
    public void f(int[] xs) { A.a("C_int_short_char-int"); }
    
    public C_int_short_char() { super(); }
}
class C_long_short_char extends C_short_char {
    public void f(long[] xs) { A.a("C_long_short_char-long"); }
    
    public C_long_short_char() { super(); }
}
class C_float_short_char extends C_short_char {
    public void f(float[] xs) { A.a("C_float_short_char-float"); }
    
    public C_float_short_char() { super(); }
}
class C_double_short_char extends C_short_char {
    public void f(double[] xs) { A.a("C_double_short_char-double"); }
    
    public C_double_short_char() { super(); }
}
class C_boolean_short_int extends C_short_int {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_int-boolean");
    }
    
    public C_boolean_short_int() { super(); }
}
class C_byte_short_int extends C_short_int {
    public void f(byte[] xs) { A.a("C_byte_short_int-byte"); }
    
    public C_byte_short_int() { super(); }
}
class C_char_short_int extends C_short_int {
    public void f(char[] xs) { A.a("C_char_short_int-char"); }
    
    public C_char_short_int() { super(); }
}
class C_long_short_int extends C_short_int {
    public void f(long[] xs) { A.a("C_long_short_int-long"); }
    
    public C_long_short_int() { super(); }
}
class C_float_short_int extends C_short_int {
    public void f(float[] xs) { A.a("C_float_short_int-float"); }
    
    public C_float_short_int() { super(); }
}
class C_double_short_int extends C_short_int {
    public void f(double[] xs) { A.a("C_double_short_int-double"); }
    
    public C_double_short_int() { super(); }
}
class C_boolean_short_long extends C_short_long {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_long-boolean");
    }
    
    public C_boolean_short_long() { super(); }
}
class C_byte_short_long extends C_short_long {
    public void f(byte[] xs) { A.a("C_byte_short_long-byte"); }
    
    public C_byte_short_long() { super(); }
}
class C_char_short_long extends C_short_long {
    public void f(char[] xs) { A.a("C_char_short_long-char"); }
    
    public C_char_short_long() { super(); }
}
class C_int_short_long extends C_short_long {
    public void f(int[] xs) { A.a("C_int_short_long-int"); }
    
    public C_int_short_long() { super(); }
}
class C_float_short_long extends C_short_long {
    public void f(float[] xs) { A.a("C_float_short_long-float"); }
    
    public C_float_short_long() { super(); }
}
class C_double_short_long extends C_short_long {
    public void f(double[] xs) { A.a("C_double_short_long-double"); }
    
    public C_double_short_long() { super(); }
}
class C_boolean_short_float extends C_short_float {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_float-boolean");
    }
    
    public C_boolean_short_float() { super(); }
}
class C_byte_short_float extends C_short_float {
    public void f(byte[] xs) { A.a("C_byte_short_float-byte"); }
    
    public C_byte_short_float() { super(); }
}
class C_char_short_float extends C_short_float {
    public void f(char[] xs) { A.a("C_char_short_float-char"); }
    
    public C_char_short_float() { super(); }
}
class C_int_short_float extends C_short_float {
    public void f(int[] xs) { A.a("C_int_short_float-int"); }
    
    public C_int_short_float() { super(); }
}
class C_long_short_float extends C_short_float {
    public void f(long[] xs) { A.a("C_long_short_float-long"); }
    
    public C_long_short_float() { super(); }
}
class C_double_short_float extends C_short_float {
    public void f(double[] xs) { A.a("C_double_short_float-double"); }
    
    public C_double_short_float() { super(); }
}
class C_boolean_short_double extends C_short_double {
    public void f(boolean[] xs) {
        A.a("C_boolean_short_double-boolean");
    }
    
    public C_boolean_short_double() { super(); }
}
class C_byte_short_double extends C_short_double {
    public void f(byte[] xs) { A.a("C_byte_short_double-byte"); }
    
    public C_byte_short_double() { super(); }
}
class C_char_short_double extends C_short_double {
    public void f(char[] xs) { A.a("C_char_short_double-char"); }
    
    public C_char_short_double() { super(); }
}
class C_int_short_double extends C_short_double {
    public void f(int[] xs) { A.a("C_int_short_double-int"); }
    
    public C_int_short_double() { super(); }
}
class C_long_short_double extends C_short_double {
    public void f(long[] xs) { A.a("C_long_short_double-long"); }
    
    public C_long_short_double() { super(); }
}
class C_float_short_double extends C_short_double {
    public void f(float[] xs) { A.a("C_float_short_double-float"); }
    
    public C_float_short_double() { super(); }
}
class C_byte_char_boolean extends C_char_boolean {
    public void f(byte[] xs) { A.a("C_byte_char_boolean-byte"); }
    
    public C_byte_char_boolean() { super(); }
}
class C_short_char_boolean extends C_char_boolean {
    public void f(short[] xs) { A.a("C_short_char_boolean-short"); }
    
    public C_short_char_boolean() { super(); }
}
class C_int_char_boolean extends C_char_boolean {
    public void f(int[] xs) { A.a("C_int_char_boolean-int"); }
    
    public C_int_char_boolean() { super(); }
}
class C_long_char_boolean extends C_char_boolean {
    public void f(long[] xs) { A.a("C_long_char_boolean-long"); }
    
    public C_long_char_boolean() { super(); }
}
class C_float_char_boolean extends C_char_boolean {
    public void f(float[] xs) { A.a("C_float_char_boolean-float"); }
    
    public C_float_char_boolean() { super(); }
}
class C_double_char_boolean extends C_char_boolean {
    public void f(double[] xs) {
        A.a("C_double_char_boolean-double");
    }
    
    public C_double_char_boolean() { super(); }
}
class C_boolean_char_byte extends C_char_byte {
    public void f(boolean[] xs) {
        A.a("C_boolean_char_byte-boolean");
    }
    
    public C_boolean_char_byte() { super(); }
}
class C_short_char_byte extends C_char_byte {
    public void f(short[] xs) { A.a("C_short_char_byte-short"); }
    
    public C_short_char_byte() { super(); }
}
class C_int_char_byte extends C_char_byte {
    public void f(int[] xs) { A.a("C_int_char_byte-int"); }
    
    public C_int_char_byte() { super(); }
}
class C_long_char_byte extends C_char_byte {
    public void f(long[] xs) { A.a("C_long_char_byte-long"); }
    
    public C_long_char_byte() { super(); }
}
class C_float_char_byte extends C_char_byte {
    public void f(float[] xs) { A.a("C_float_char_byte-float"); }
    
    public C_float_char_byte() { super(); }
}
class C_double_char_byte extends C_char_byte {
    public void f(double[] xs) { A.a("C_double_char_byte-double"); }
    
    public C_double_char_byte() { super(); }
}
class C_boolean_char_short extends C_char_short {
    public void f(boolean[] xs) {
        A.a("C_boolean_char_short-boolean");
    }
    
    public C_boolean_char_short() { super(); }
}
class C_byte_char_short extends C_char_short {
    public void f(byte[] xs) { A.a("C_byte_char_short-byte"); }
    
    public C_byte_char_short() { super(); }
}
class C_int_char_short extends C_char_short {
    public void f(int[] xs) { A.a("C_int_char_short-int"); }
    
    public C_int_char_short() { super(); }
}
class C_long_char_short extends C_char_short {
    public void f(long[] xs) { A.a("C_long_char_short-long"); }
    
    public C_long_char_short() { super(); }
}
class C_float_char_short extends C_char_short {
    public void f(float[] xs) { A.a("C_float_char_short-float"); }
    
    public C_float_char_short() { super(); }
}
class C_double_char_short extends C_char_short {
    public void f(double[] xs) { A.a("C_double_char_short-double"); }
    
    public C_double_char_short() { super(); }
}
class C_boolean_char_int extends C_char_int {
    public void f(boolean[] xs) { A.a("C_boolean_char_int-boolean"); }
    
    public C_boolean_char_int() { super(); }
}
class C_byte_char_int extends C_char_int {
    public void f(byte[] xs) { A.a("C_byte_char_int-byte"); }
    
    public C_byte_char_int() { super(); }
}
class C_short_char_int extends C_char_int {
    public void f(short[] xs) { A.a("C_short_char_int-short"); }
    
    public C_short_char_int() { super(); }
}
class C_long_char_int extends C_char_int {
    public void f(long[] xs) { A.a("C_long_char_int-long"); }
    
    public C_long_char_int() { super(); }
}
class C_float_char_int extends C_char_int {
    public void f(float[] xs) { A.a("C_float_char_int-float"); }
    
    public C_float_char_int() { super(); }
}
class C_double_char_int extends C_char_int {
    public void f(double[] xs) { A.a("C_double_char_int-double"); }
    
    public C_double_char_int() { super(); }
}
class C_boolean_char_long extends C_char_long {
    public void f(boolean[] xs) {
        A.a("C_boolean_char_long-boolean");
    }
    
    public C_boolean_char_long() { super(); }
}
class C_byte_char_long extends C_char_long {
    public void f(byte[] xs) { A.a("C_byte_char_long-byte"); }
    
    public C_byte_char_long() { super(); }
}
class C_short_char_long extends C_char_long {
    public void f(short[] xs) { A.a("C_short_char_long-short"); }
    
    public C_short_char_long() { super(); }
}
class C_int_char_long extends C_char_long {
    public void f(int[] xs) { A.a("C_int_char_long-int"); }
    
    public C_int_char_long() { super(); }
}
class C_float_char_long extends C_char_long {
    public void f(float[] xs) { A.a("C_float_char_long-float"); }
    
    public C_float_char_long() { super(); }
}
class C_double_char_long extends C_char_long {
    public void f(double[] xs) { A.a("C_double_char_long-double"); }
    
    public C_double_char_long() { super(); }
}
class C_boolean_char_float extends C_char_float {
    public void f(boolean[] xs) {
        A.a("C_boolean_char_float-boolean");
    }
    
    public C_boolean_char_float() { super(); }
}
class C_byte_char_float extends C_char_float {
    public void f(byte[] xs) { A.a("C_byte_char_float-byte"); }
    
    public C_byte_char_float() { super(); }
}
class C_short_char_float extends C_char_float {
    public void f(short[] xs) { A.a("C_short_char_float-short"); }
    
    public C_short_char_float() { super(); }
}
class C_int_char_float extends C_char_float {
    public void f(int[] xs) { A.a("C_int_char_float-int"); }
    
    public C_int_char_float() { super(); }
}
class C_long_char_float extends C_char_float {
    public void f(long[] xs) { A.a("C_long_char_float-long"); }
    
    public C_long_char_float() { super(); }
}
class C_double_char_float extends C_char_float {
    public void f(double[] xs) { A.a("C_double_char_float-double"); }
    
    public C_double_char_float() { super(); }
}
class C_boolean_char_double extends C_char_double {
    public void f(boolean[] xs) {
        A.a("C_boolean_char_double-boolean");
    }
    
    public C_boolean_char_double() { super(); }
}
class C_byte_char_double extends C_char_double {
    public void f(byte[] xs) { A.a("C_byte_char_double-byte"); }
    
    public C_byte_char_double() { super(); }
}
class C_short_char_double extends C_char_double {
    public void f(short[] xs) { A.a("C_short_char_double-short"); }
    
    public C_short_char_double() { super(); }
}
class C_int_char_double extends C_char_double {
    public void f(int[] xs) { A.a("C_int_char_double-int"); }
    
    public C_int_char_double() { super(); }
}
class C_long_char_double extends C_char_double {
    public void f(long[] xs) { A.a("C_long_char_double-long"); }
    
    public C_long_char_double() { super(); }
}
class C_float_char_double extends C_char_double {
    public void f(float[] xs) { A.a("C_float_char_double-float"); }
    
    public C_float_char_double() { super(); }
}
class C_char_byte_boolean extends C_byte_boolean {
    public void f(char[] xs) { A.a("C_char_byte_boolean-char"); }
    
    public C_char_byte_boolean() { super(); }
}
class C_short_byte_boolean extends C_byte_boolean {
    public void f(short[] xs) { A.a("C_short_byte_boolean-short"); }
    
    public C_short_byte_boolean() { super(); }
}
class C_int_byte_boolean extends C_byte_boolean {
    public void f(int[] xs) { A.a("C_int_byte_boolean-int"); }
    
    public C_int_byte_boolean() { super(); }
}
class C_long_byte_boolean extends C_byte_boolean {
    public void f(long[] xs) { A.a("C_long_byte_boolean-long"); }
    
    public C_long_byte_boolean() { super(); }
}
class C_float_byte_boolean extends C_byte_boolean {
    public void f(float[] xs) { A.a("C_float_byte_boolean-float"); }
    
    public C_float_byte_boolean() { super(); }
}
class C_double_byte_boolean extends C_byte_boolean {
    public void f(double[] xs) {
        A.a("C_double_byte_boolean-double");
    }
    
    public C_double_byte_boolean() { super(); }
}
class C_boolean_byte_char extends C_byte_char {
    public void f(boolean[] xs) {
        A.a("C_boolean_byte_char-boolean");
    }
    
    public C_boolean_byte_char() { super(); }
}
class C_short_byte_char extends C_byte_char {
    public void f(short[] xs) { A.a("C_short_byte_char-short"); }
    
    public C_short_byte_char() { super(); }
}
class C_int_byte_char extends C_byte_char {
    public void f(int[] xs) { A.a("C_int_byte_char-int"); }
    
    public C_int_byte_char() { super(); }
}
class C_long_byte_char extends C_byte_char {
    public void f(long[] xs) { A.a("C_long_byte_char-long"); }
    
    public C_long_byte_char() { super(); }
}
class C_float_byte_char extends C_byte_char {
    public void f(float[] xs) { A.a("C_float_byte_char-float"); }
    
    public C_float_byte_char() { super(); }
}
class C_double_byte_char extends C_byte_char {
    public void f(double[] xs) { A.a("C_double_byte_char-double"); }
    
    public C_double_byte_char() { super(); }
}
class C_boolean_byte_short extends C_byte_short {
    public void f(boolean[] xs) {
        A.a("C_boolean_byte_short-boolean");
    }
    
    public C_boolean_byte_short() { super(); }
}
class C_char_byte_short extends C_byte_short {
    public void f(char[] xs) { A.a("C_char_byte_short-char"); }
    
    public C_char_byte_short() { super(); }
}
class C_int_byte_short extends C_byte_short {
    public void f(int[] xs) { A.a("C_int_byte_short-int"); }
    
    public C_int_byte_short() { super(); }
}
class C_long_byte_short extends C_byte_short {
    public void f(long[] xs) { A.a("C_long_byte_short-long"); }
    
    public C_long_byte_short() { super(); }
}
class C_float_byte_short extends C_byte_short {
    public void f(float[] xs) { A.a("C_float_byte_short-float"); }
    
    public C_float_byte_short() { super(); }
}
class C_double_byte_short extends C_byte_short {
    public void f(double[] xs) { A.a("C_double_byte_short-double"); }
    
    public C_double_byte_short() { super(); }
}
class C_boolean_byte_int extends C_byte_int {
    public void f(boolean[] xs) { A.a("C_boolean_byte_int-boolean"); }
    
    public C_boolean_byte_int() { super(); }
}
class C_char_byte_int extends C_byte_int {
    public void f(char[] xs) { A.a("C_char_byte_int-char"); }
    
    public C_char_byte_int() { super(); }
}
class C_short_byte_int extends C_byte_int {
    public void f(short[] xs) { A.a("C_short_byte_int-short"); }
    
    public C_short_byte_int() { super(); }
}
class C_long_byte_int extends C_byte_int {
    public void f(long[] xs) { A.a("C_long_byte_int-long"); }
    
    public C_long_byte_int() { super(); }
}
class C_float_byte_int extends C_byte_int {
    public void f(float[] xs) { A.a("C_float_byte_int-float"); }
    
    public C_float_byte_int() { super(); }
}
class C_double_byte_int extends C_byte_int {
    public void f(double[] xs) { A.a("C_double_byte_int-double"); }
    
    public C_double_byte_int() { super(); }
}
class C_boolean_byte_long extends C_byte_long {
    public void f(boolean[] xs) {
        A.a("C_boolean_byte_long-boolean");
    }
    
    public C_boolean_byte_long() { super(); }
}
class C_char_byte_long extends C_byte_long {
    public void f(char[] xs) { A.a("C_char_byte_long-char"); }
    
    public C_char_byte_long() { super(); }
}
class C_short_byte_long extends C_byte_long {
    public void f(short[] xs) { A.a("C_short_byte_long-short"); }
    
    public C_short_byte_long() { super(); }
}
class C_int_byte_long extends C_byte_long {
    public void f(int[] xs) { A.a("C_int_byte_long-int"); }
    
    public C_int_byte_long() { super(); }
}
class C_float_byte_long extends C_byte_long {
    public void f(float[] xs) { A.a("C_float_byte_long-float"); }
    
    public C_float_byte_long() { super(); }
}
class C_double_byte_long extends C_byte_long {
    public void f(double[] xs) { A.a("C_double_byte_long-double"); }
    
    public C_double_byte_long() { super(); }
}
class C_boolean_byte_float extends C_byte_float {
    public void f(boolean[] xs) {
        A.a("C_boolean_byte_float-boolean");
    }
    
    public C_boolean_byte_float() { super(); }
}
class C_char_byte_float extends C_byte_float {
    public void f(char[] xs) { A.a("C_char_byte_float-char"); }
    
    public C_char_byte_float() { super(); }
}
class C_short_byte_float extends C_byte_float {
    public void f(short[] xs) { A.a("C_short_byte_float-short"); }
    
    public C_short_byte_float() { super(); }
}
class C_int_byte_float extends C_byte_float {
    public void f(int[] xs) { A.a("C_int_byte_float-int"); }
    
    public C_int_byte_float() { super(); }
}
class C_long_byte_float extends C_byte_float {
    public void f(long[] xs) { A.a("C_long_byte_float-long"); }
    
    public C_long_byte_float() { super(); }
}
class C_double_byte_float extends C_byte_float {
    public void f(double[] xs) { A.a("C_double_byte_float-double"); }
    
    public C_double_byte_float() { super(); }
}
class C_boolean_byte_double extends C_byte_double {
    public void f(boolean[] xs) {
        A.a("C_boolean_byte_double-boolean");
    }
    
    public C_boolean_byte_double() { super(); }
}
class C_char_byte_double extends C_byte_double {
    public void f(char[] xs) { A.a("C_char_byte_double-char"); }
    
    public C_char_byte_double() { super(); }
}
class C_short_byte_double extends C_byte_double {
    public void f(short[] xs) { A.a("C_short_byte_double-short"); }
    
    public C_short_byte_double() { super(); }
}
class C_int_byte_double extends C_byte_double {
    public void f(int[] xs) { A.a("C_int_byte_double-int"); }
    
    public C_int_byte_double() { super(); }
}
class C_long_byte_double extends C_byte_double {
    public void f(long[] xs) { A.a("C_long_byte_double-long"); }
    
    public C_long_byte_double() { super(); }
}
class C_float_byte_double extends C_byte_double {
    public void f(float[] xs) { A.a("C_float_byte_double-float"); }
    
    public C_float_byte_double() { super(); }
}
class C_byte_boolean_double extends C_boolean_double {
    public void f(byte[] xs) { A.a("C_byte_boolean_double-byte"); }
    
    public C_byte_boolean_double() { super(); }
}
class C_char_boolean_double extends C_boolean_double {
    public void f(char[] xs) { A.a("C_char_boolean_double-char"); }
    
    public C_char_boolean_double() { super(); }
}
class C_short_boolean_double extends C_boolean_double {
    public void f(short[] xs) { A.a("C_short_boolean_double-short"); }
    
    public C_short_boolean_double() { super(); }
}
class C_int_boolean_double extends C_boolean_double {
    public void f(int[] xs) { A.a("C_int_boolean_double-int"); }
    
    public C_int_boolean_double() { super(); }
}
class C_long_boolean_double extends C_boolean_double {
    public void f(long[] xs) { A.a("C_long_boolean_double-long"); }
    
    public C_long_boolean_double() { super(); }
}
class C_float_boolean_double extends C_boolean_double {
    public void f(float[] xs) { A.a("C_float_boolean_double-float"); }
    
    public C_float_boolean_double() { super(); }
}
class C_byte_boolean_float extends C_boolean_float {
    public void f(byte[] xs) { A.a("C_byte_boolean_float-byte"); }
    
    public C_byte_boolean_float() { super(); }
}
class C_char_boolean_float extends C_boolean_float {
    public void f(char[] xs) { A.a("C_char_boolean_float-char"); }
    
    public C_char_boolean_float() { super(); }
}
class C_short_boolean_float extends C_boolean_float {
    public void f(short[] xs) { A.a("C_short_boolean_float-short"); }
    
    public C_short_boolean_float() { super(); }
}
class C_int_boolean_float extends C_boolean_float {
    public void f(int[] xs) { A.a("C_int_boolean_float-int"); }
    
    public C_int_boolean_float() { super(); }
}
class C_long_boolean_float extends C_boolean_float {
    public void f(long[] xs) { A.a("C_long_boolean_float-long"); }
    
    public C_long_boolean_float() { super(); }
}
class C_double_boolean_float extends C_boolean_float {
    public void f(double[] xs) {
        A.a("C_double_boolean_float-double");
    }
    
    public C_double_boolean_float() { super(); }
}
class C_byte_boolean_long extends C_boolean_long {
    public void f(byte[] xs) { A.a("C_byte_boolean_long-byte"); }
    
    public C_byte_boolean_long() { super(); }
}
class C_char_boolean_long extends C_boolean_long {
    public void f(char[] xs) { A.a("C_char_boolean_long-char"); }
    
    public C_char_boolean_long() { super(); }
}
class C_short_boolean_long extends C_boolean_long {
    public void f(short[] xs) { A.a("C_short_boolean_long-short"); }
    
    public C_short_boolean_long() { super(); }
}
class C_int_boolean_long extends C_boolean_long {
    public void f(int[] xs) { A.a("C_int_boolean_long-int"); }
    
    public C_int_boolean_long() { super(); }
}
class C_float_boolean_long extends C_boolean_long {
    public void f(float[] xs) { A.a("C_float_boolean_long-float"); }
    
    public C_float_boolean_long() { super(); }
}
class C_double_boolean_long extends C_boolean_long {
    public void f(double[] xs) {
        A.a("C_double_boolean_long-double");
    }
    
    public C_double_boolean_long() { super(); }
}
class C_byte_boolean_int extends C_boolean_int {
    public void f(byte[] xs) { A.a("C_byte_boolean_int-byte"); }
    
    public C_byte_boolean_int() { super(); }
}
class C_char_boolean_int extends C_boolean_int {
    public void f(char[] xs) { A.a("C_char_boolean_int-char"); }
    
    public C_char_boolean_int() { super(); }
}
class C_short_boolean_int extends C_boolean_int {
    public void f(short[] xs) { A.a("C_short_boolean_int-short"); }
    
    public C_short_boolean_int() { super(); }
}
class C_long_boolean_int extends C_boolean_int {
    public void f(long[] xs) { A.a("C_long_boolean_int-long"); }
    
    public C_long_boolean_int() { super(); }
}
class C_float_boolean_int extends C_boolean_int {
    public void f(float[] xs) { A.a("C_float_boolean_int-float"); }
    
    public C_float_boolean_int() { super(); }
}
class C_double_boolean_int extends C_boolean_int {
    public void f(double[] xs) { A.a("C_double_boolean_int-double"); }
    
    public C_double_boolean_int() { super(); }
}
class C_byte_boolean_short extends C_boolean_short {
    public void f(byte[] xs) { A.a("C_byte_boolean_short-byte"); }
    
    public C_byte_boolean_short() { super(); }
}
class C_char_boolean_short extends C_boolean_short {
    public void f(char[] xs) { A.a("C_char_boolean_short-char"); }
    
    public C_char_boolean_short() { super(); }
}
class C_int_boolean_short extends C_boolean_short {
    public void f(int[] xs) { A.a("C_int_boolean_short-int"); }
    
    public C_int_boolean_short() { super(); }
}
class C_long_boolean_short extends C_boolean_short {
    public void f(long[] xs) { A.a("C_long_boolean_short-long"); }
    
    public C_long_boolean_short() { super(); }
}
class C_float_boolean_short extends C_boolean_short {
    public void f(float[] xs) { A.a("C_float_boolean_short-float"); }
    
    public C_float_boolean_short() { super(); }
}
class C_double_boolean_short extends C_boolean_short {
    public void f(double[] xs) {
        A.a("C_double_boolean_short-double");
    }
    
    public C_double_boolean_short() { super(); }
}
class C_byte_boolean_char extends C_boolean_char {
    public void f(byte[] xs) { A.a("C_byte_boolean_char-byte"); }
    
    public C_byte_boolean_char() { super(); }
}
class C_short_boolean_char extends C_boolean_char {
    public void f(short[] xs) { A.a("C_short_boolean_char-short"); }
    
    public C_short_boolean_char() { super(); }
}
class C_int_boolean_char extends C_boolean_char {
    public void f(int[] xs) { A.a("C_int_boolean_char-int"); }
    
    public C_int_boolean_char() { super(); }
}
class C_long_boolean_char extends C_boolean_char {
    public void f(long[] xs) { A.a("C_long_boolean_char-long"); }
    
    public C_long_boolean_char() { super(); }
}
class C_float_boolean_char extends C_boolean_char {
    public void f(float[] xs) { A.a("C_float_boolean_char-float"); }
    
    public C_float_boolean_char() { super(); }
}
class C_double_boolean_char extends C_boolean_char {
    public void f(double[] xs) {
        A.a("C_double_boolean_char-double");
    }
    
    public C_double_boolean_char() { super(); }
}
class C_char_boolean_byte extends C_boolean_byte {
    public void f(char[] xs) { A.a("C_char_boolean_byte-char"); }
    
    public C_char_boolean_byte() { super(); }
}
class C_short_boolean_byte extends C_boolean_byte {
    public void f(short[] xs) { A.a("C_short_boolean_byte-short"); }
    
    public C_short_boolean_byte() { super(); }
}
class C_int_boolean_byte extends C_boolean_byte {
    public void f(int[] xs) { A.a("C_int_boolean_byte-int"); }
    
    public C_int_boolean_byte() { super(); }
}
class C_long_boolean_byte extends C_boolean_byte {
    public void f(long[] xs) { A.a("C_long_boolean_byte-long"); }
    
    public C_long_boolean_byte() { super(); }
}
class C_float_boolean_byte extends C_boolean_byte {
    public void f(float[] xs) { A.a("C_float_boolean_byte-float"); }
    
    public C_float_boolean_byte() { super(); }
}
class C_double_boolean_byte extends C_boolean_byte {
    public void f(double[] xs) {
        A.a("C_double_boolean_byte-double");
    }
    
    public C_double_boolean_byte() { super(); }
}
class C_boolean_double extends C_double {
    public void f(boolean[] xs) { A.a("C_boolean_double-boolean"); }
    
    public C_boolean_double() { super(); }
}
class C_byte_double extends C_double {
    public void f(byte[] xs) { A.a("C_byte_double-byte"); }
    
    public C_byte_double() { super(); }
}
class C_char_double extends C_double {
    public void f(char[] xs) { A.a("C_char_double-char"); }
    
    public C_char_double() { super(); }
}
class C_short_double extends C_double {
    public void f(short[] xs) { A.a("C_short_double-short"); }
    
    public C_short_double() { super(); }
}
class C_int_double extends C_double {
    public void f(int[] xs) { A.a("C_int_double-int"); }
    
    public C_int_double() { super(); }
}
class C_long_double extends C_double {
    public void f(long[] xs) { A.a("C_long_double-long"); }
    
    public C_long_double() { super(); }
}
class C_float_double extends C_double {
    public void f(float[] xs) { A.a("C_float_double-float"); }
    
    public C_float_double() { super(); }
}
class C_boolean_float extends C_float {
    public void f(boolean[] xs) { A.a("C_boolean_float-boolean"); }
    
    public C_boolean_float() { super(); }
}
class C_byte_float extends C_float {
    public void f(byte[] xs) { A.a("C_byte_float-byte"); }
    
    public C_byte_float() { super(); }
}
class C_char_float extends C_float {
    public void f(char[] xs) { A.a("C_char_float-char"); }
    
    public C_char_float() { super(); }
}
class C_short_float extends C_float {
    public void f(short[] xs) { A.a("C_short_float-short"); }
    
    public C_short_float() { super(); }
}
class C_int_float extends C_float {
    public void f(int[] xs) { A.a("C_int_float-int"); }
    
    public C_int_float() { super(); }
}
class C_long_float extends C_float {
    public void f(long[] xs) { A.a("C_long_float-long"); }
    
    public C_long_float() { super(); }
}
class C_double_float extends C_float {
    public void f(double[] xs) { A.a("C_double_float-double"); }
    
    public C_double_float() { super(); }
}
class C_boolean_long extends C_long {
    public void f(boolean[] xs) { A.a("C_boolean_long-boolean"); }
    
    public C_boolean_long() { super(); }
}
class C_byte_long extends C_long {
    public void f(byte[] xs) { A.a("C_byte_long-byte"); }
    
    public C_byte_long() { super(); }
}
class C_char_long extends C_long {
    public void f(char[] xs) { A.a("C_char_long-char"); }
    
    public C_char_long() { super(); }
}
class C_short_long extends C_long {
    public void f(short[] xs) { A.a("C_short_long-short"); }
    
    public C_short_long() { super(); }
}
class C_int_long extends C_long {
    public void f(int[] xs) { A.a("C_int_long-int"); }
    
    public C_int_long() { super(); }
}
class C_float_long extends C_long {
    public void f(float[] xs) { A.a("C_float_long-float"); }
    
    public C_float_long() { super(); }
}
class C_double_long extends C_long {
    public void f(double[] xs) { A.a("C_double_long-double"); }
    
    public C_double_long() { super(); }
}
class C_boolean_int extends C_int {
    public void f(boolean[] xs) { A.a("C_boolean_int-boolean"); }
    
    public C_boolean_int() { super(); }
}
class C_byte_int extends C_int {
    public void f(byte[] xs) { A.a("C_byte_int-byte"); }
    
    public C_byte_int() { super(); }
}
class C_char_int extends C_int {
    public void f(char[] xs) { A.a("C_char_int-char"); }
    
    public C_char_int() { super(); }
}
class C_short_int extends C_int {
    public void f(short[] xs) { A.a("C_short_int-short"); }
    
    public C_short_int() { super(); }
}
class C_long_int extends C_int {
    public void f(long[] xs) { A.a("C_long_int-long"); }
    
    public C_long_int() { super(); }
}
class C_float_int extends C_int {
    public void f(float[] xs) { A.a("C_float_int-float"); }
    
    public C_float_int() { super(); }
}
class C_double_int extends C_int {
    public void f(double[] xs) { A.a("C_double_int-double"); }
    
    public C_double_int() { super(); }
}
class C_boolean_short extends C_short {
    public void f(boolean[] xs) { A.a("C_boolean_short-boolean"); }
    
    public C_boolean_short() { super(); }
}
class C_byte_short extends C_short {
    public void f(byte[] xs) { A.a("C_byte_short-byte"); }
    
    public C_byte_short() { super(); }
}
class C_char_short extends C_short {
    public void f(char[] xs) { A.a("C_char_short-char"); }
    
    public C_char_short() { super(); }
}
class C_int_short extends C_short {
    public void f(int[] xs) { A.a("C_int_short-int"); }
    
    public C_int_short() { super(); }
}
class C_long_short extends C_short {
    public void f(long[] xs) { A.a("C_long_short-long"); }
    
    public C_long_short() { super(); }
}
class C_float_short extends C_short {
    public void f(float[] xs) { A.a("C_float_short-float"); }
    
    public C_float_short() { super(); }
}
class C_double_short extends C_short {
    public void f(double[] xs) { A.a("C_double_short-double"); }
    
    public C_double_short() { super(); }
}
class C_boolean_char extends C_char {
    public void f(boolean[] xs) { A.a("C_boolean_char-boolean"); }
    
    public C_boolean_char() { super(); }
}
class C_byte_char extends C_char {
    public void f(byte[] xs) { A.a("C_byte_char-byte"); }
    
    public C_byte_char() { super(); }
}
class C_short_char extends C_char {
    public void f(short[] xs) { A.a("C_short_char-short"); }
    
    public C_short_char() { super(); }
}
class C_int_char extends C_char {
    public void f(int[] xs) { A.a("C_int_char-int"); }
    
    public C_int_char() { super(); }
}
class C_long_char extends C_char {
    public void f(long[] xs) { A.a("C_long_char-long"); }
    
    public C_long_char() { super(); }
}
class C_float_char extends C_char {
    public void f(float[] xs) { A.a("C_float_char-float"); }
    
    public C_float_char() { super(); }
}
class C_double_char extends C_char {
    public void f(double[] xs) { A.a("C_double_char-double"); }
    
    public C_double_char() { super(); }
}
class C_boolean_byte extends C_byte {
    public void f(boolean[] xs) { A.a("C_boolean_byte-boolean"); }
    
    public C_boolean_byte() { super(); }
}
class C_char_byte extends C_byte {
    public void f(char[] xs) { A.a("C_char_byte-char"); }
    
    public C_char_byte() { super(); }
}
class C_short_byte extends C_byte {
    public void f(short[] xs) { A.a("C_short_byte-short"); }
    
    public C_short_byte() { super(); }
}
class C_int_byte extends C_byte {
    public void f(int[] xs) { A.a("C_int_byte-int"); }
    
    public C_int_byte() { super(); }
}
class C_long_byte extends C_byte {
    public void f(long[] xs) { A.a("C_long_byte-long"); }
    
    public C_long_byte() { super(); }
}
class C_float_byte extends C_byte {
    public void f(float[] xs) { A.a("C_float_byte-float"); }
    
    public C_float_byte() { super(); }
}
class C_double_byte extends C_byte {
    public void f(double[] xs) { A.a("C_double_byte-double"); }
    
    public C_double_byte() { super(); }
}
class C_byte_boolean extends C_boolean {
    public void f(byte[] xs) { A.a("C_byte_boolean-byte"); }
    
    public C_byte_boolean() { super(); }
}
class C_char_boolean extends C_boolean {
    public void f(char[] xs) { A.a("C_char_boolean-char"); }
    
    public C_char_boolean() { super(); }
}
class C_short_boolean extends C_boolean {
    public void f(short[] xs) { A.a("C_short_boolean-short"); }
    
    public C_short_boolean() { super(); }
}
class C_int_boolean extends C_boolean {
    public void f(int[] xs) { A.a("C_int_boolean-int"); }
    
    public C_int_boolean() { super(); }
}
class C_long_boolean extends C_boolean {
    public void f(long[] xs) { A.a("C_long_boolean-long"); }
    
    public C_long_boolean() { super(); }
}
class C_float_boolean extends C_boolean {
    public void f(float[] xs) { A.a("C_float_boolean-float"); }
    
    public C_float_boolean() { super(); }
}
class C_double_boolean extends C_boolean {
    public void f(double[] xs) { A.a("C_double_boolean-double"); }
    
    public C_double_boolean() { super(); }
}
retrieve <ResolvingArrayParameters: void main(java.lang.String[])> from ResolvingArrayParameters
retrieve <ResolvingArrayParameters: void realMain(java.lang.String[])> from ResolvingArrayParameters
retrieve <ResolvingArrayParameters: void m(java.lang.String)> from ResolvingArrayParameters
retrieve <ResolvingArrayParameters: void wants()> from ResolvingArrayParameters
retrieve <ResolvingArrayParameters: void <init>()> from ResolvingArrayParameters
retrieve <C_boolean: void <init>()> from C_boolean
retrieve <C_boolean: void f(boolean[])> from C_boolean
retrieve <C_byte: void <init>()> from C_byte
retrieve <C_byte: void f(byte[])> from C_byte
retrieve <C_char: void f(char[])> from C_char
retrieve <C_char: void <init>()> from C_char
retrieve <C_short: void <init>()> from C_short
retrieve <C_short: void f(short[])> from C_short
retrieve <C_int: void f(int[])> from C_int
retrieve <C_int: void <init>()> from C_int
retrieve <C_long: void <init>()> from C_long
retrieve <C_long: void f(long[])> from C_long
retrieve <C_float: void <init>()> from C_float
retrieve <C_float: void f(float[])> from C_float
retrieve <C_double: void f(double[])> from C_double
retrieve <C_double: void <init>()> from C_double
retrieve <CC_boolean: void <init>()> from CC_boolean
retrieve <CC_boolean: void f(boolean[])> from CC_boolean
retrieve <CC_byte: void <init>()> from CC_byte
retrieve <CC_byte: void f(byte[])> from CC_byte
retrieve <CC_char: void f(char[])> from CC_char
retrieve <CC_char: void <init>()> from CC_char
retrieve <CC_short: void <init>()> from CC_short
retrieve <CC_short: void f(short[])> from CC_short
retrieve <CC_int: void f(int[])> from CC_int
retrieve <CC_int: void <init>()> from CC_int
retrieve <CC_long: void <init>()> from CC_long
retrieve <CC_long: void f(long[])> from CC_long
retrieve <CC_float: void <init>()> from CC_float
retrieve <CC_float: void f(float[])> from CC_float
retrieve <CC_double: void f(double[])> from CC_double
retrieve <CC_double: void <init>()> from CC_double
retrieve <A: void <init>()> from A
retrieve <A: void a(java.lang.String)> from A
retrieve <C_byte_double_boolean: void <init>()> from C_byte_double_boolean
retrieve <C_byte_double_boolean: void f(byte[])> from C_byte_double_boolean
retrieve <C_char_double_boolean: void f(char[])> from C_char_double_boolean
retrieve <C_char_double_boolean: void <init>()> from C_char_double_boolean
retrieve <C_short_double_boolean: void <init>()> from C_short_double_boolean
retrieve <C_short_double_boolean: void f(short[])> from C_short_double_boolean
retrieve <C_int_double_boolean: void f(int[])> from C_int_double_boolean
retrieve <C_int_double_boolean: void <init>()> from C_int_double_boolean
retrieve <C_long_double_boolean: void <init>()> from C_long_double_boolean
retrieve <C_long_double_boolean: void f(long[])> from C_long_double_boolean
retrieve <C_float_double_boolean: void <init>()> from C_float_double_boolean
retrieve <C_float_double_boolean: void f(float[])> from C_float_double_boolean
retrieve <C_boolean_double_byte: void <init>()> from C_boolean_double_byte
retrieve <C_boolean_double_byte: void f(boolean[])> from C_boolean_double_byte
retrieve <C_char_double_byte: void f(char[])> from C_char_double_byte
retrieve <C_char_double_byte: void <init>()> from C_char_double_byte
retrieve <C_short_double_byte: void <init>()> from C_short_double_byte
retrieve <C_short_double_byte: void f(short[])> from C_short_double_byte
retrieve <C_int_double_byte: void f(int[])> from C_int_double_byte
retrieve <C_int_double_byte: void <init>()> from C_int_double_byte
retrieve <C_long_double_byte: void <init>()> from C_long_double_byte
retrieve <C_long_double_byte: void f(long[])> from C_long_double_byte
retrieve <C_float_double_byte: void <init>()> from C_float_double_byte
retrieve <C_float_double_byte: void f(float[])> from C_float_double_byte
retrieve <C_boolean_double_char: void <init>()> from C_boolean_double_char
retrieve <C_boolean_double_char: void f(boolean[])> from C_boolean_double_char
retrieve <C_byte_double_char: void <init>()> from C_byte_double_char
retrieve <C_byte_double_char: void f(byte[])> from C_byte_double_char
retrieve <C_short_double_char: void <init>()> from C_short_double_char
retrieve <C_short_double_char: void f(short[])> from C_short_double_char
retrieve <C_int_double_char: void f(int[])> from C_int_double_char
retrieve <C_int_double_char: void <init>()> from C_int_double_char
retrieve <C_long_double_char: void <init>()> from C_long_double_char
retrieve <C_long_double_char: void f(long[])> from C_long_double_char
retrieve <C_float_double_char: void <init>()> from C_float_double_char
retrieve <C_float_double_char: void f(float[])> from C_float_double_char
retrieve <C_boolean_double_short: void <init>()> from C_boolean_double_short
retrieve <C_boolean_double_short: void f(boolean[])> from C_boolean_double_short
retrieve <C_byte_double_short: void <init>()> from C_byte_double_short
retrieve <C_byte_double_short: void f(byte[])> from C_byte_double_short
retrieve <C_char_double_short: void f(char[])> from C_char_double_short
retrieve <C_char_double_short: void <init>()> from C_char_double_short
retrieve <C_int_double_short: void f(int[])> from C_int_double_short
retrieve <C_int_double_short: void <init>()> from C_int_double_short
retrieve <C_long_double_short: void <init>()> from C_long_double_short
retrieve <C_long_double_short: void f(long[])> from C_long_double_short
retrieve <C_float_double_short: void <init>()> from C_float_double_short
retrieve <C_float_double_short: void f(float[])> from C_float_double_short
retrieve <C_boolean_double_int: void <init>()> from C_boolean_double_int
retrieve <C_boolean_double_int: void f(boolean[])> from C_boolean_double_int
retrieve <C_byte_double_int: void <init>()> from C_byte_double_int
retrieve <C_byte_double_int: void f(byte[])> from C_byte_double_int
retrieve <C_char_double_int: void f(char[])> from C_char_double_int
retrieve <C_char_double_int: void <init>()> from C_char_double_int
retrieve <C_short_double_int: void <init>()> from C_short_double_int
retrieve <C_short_double_int: void f(short[])> from C_short_double_int
retrieve <C_long_double_int: void <init>()> from C_long_double_int
retrieve <C_long_double_int: void f(long[])> from C_long_double_int
retrieve <C_float_double_int: void <init>()> from C_float_double_int
retrieve <C_float_double_int: void f(float[])> from C_float_double_int
retrieve <C_boolean_double_long: void <init>()> from C_boolean_double_long
retrieve <C_boolean_double_long: void f(boolean[])> from C_boolean_double_long
retrieve <C_byte_double_long: void <init>()> from C_byte_double_long
retrieve <C_byte_double_long: void f(byte[])> from C_byte_double_long
retrieve <C_char_double_long: void f(char[])> from C_char_double_long
retrieve <C_char_double_long: void <init>()> from C_char_double_long
retrieve <C_short_double_long: void <init>()> from C_short_double_long
retrieve <C_short_double_long: void f(short[])> from C_short_double_long
retrieve <C_int_double_long: void f(int[])> from C_int_double_long
retrieve <C_int_double_long: void <init>()> from C_int_double_long
retrieve <C_float_double_long: void <init>()> from C_float_double_long
retrieve <C_float_double_long: void f(float[])> from C_float_double_long
retrieve <C_boolean_double_float: void <init>()> from C_boolean_double_float
retrieve <C_boolean_double_float: void f(boolean[])> from C_boolean_double_float
retrieve <C_byte_double_float: void <init>()> from C_byte_double_float
retrieve <C_byte_double_float: void f(byte[])> from C_byte_double_float
retrieve <C_char_double_float: void f(char[])> from C_char_double_float
retrieve <C_char_double_float: void <init>()> from C_char_double_float
retrieve <C_short_double_float: void <init>()> from C_short_double_float
retrieve <C_short_double_float: void f(short[])> from C_short_double_float
retrieve <C_int_double_float: void f(int[])> from C_int_double_float
retrieve <C_int_double_float: void <init>()> from C_int_double_float
retrieve <C_long_double_float: void <init>()> from C_long_double_float
retrieve <C_long_double_float: void f(long[])> from C_long_double_float
retrieve <C_byte_float_boolean: void <init>()> from C_byte_float_boolean
retrieve <C_byte_float_boolean: void f(byte[])> from C_byte_float_boolean
retrieve <C_char_float_boolean: void f(char[])> from C_char_float_boolean
retrieve <C_char_float_boolean: void <init>()> from C_char_float_boolean
retrieve <C_short_float_boolean: void <init>()> from C_short_float_boolean
retrieve <C_short_float_boolean: void f(short[])> from C_short_float_boolean
retrieve <C_int_float_boolean: void f(int[])> from C_int_float_boolean
retrieve <C_int_float_boolean: void <init>()> from C_int_float_boolean
retrieve <C_long_float_boolean: void <init>()> from C_long_float_boolean
retrieve <C_long_float_boolean: void f(long[])> from C_long_float_boolean
retrieve <C_double_float_boolean: void f(double[])> from C_double_float_boolean
retrieve <C_double_float_boolean: void <init>()> from C_double_float_boolean
retrieve <C_boolean_float_byte: void <init>()> from C_boolean_float_byte
retrieve <C_boolean_float_byte: void f(boolean[])> from C_boolean_float_byte
retrieve <C_char_float_byte: void f(char[])> from C_char_float_byte
retrieve <C_char_float_byte: void <init>()> from C_char_float_byte
retrieve <C_short_float_byte: void <init>()> from C_short_float_byte
retrieve <C_short_float_byte: void f(short[])> from C_short_float_byte
retrieve <C_int_float_byte: void f(int[])> from C_int_float_byte
retrieve <C_int_float_byte: void <init>()> from C_int_float_byte
retrieve <C_long_float_byte: void <init>()> from C_long_float_byte
retrieve <C_long_float_byte: void f(long[])> from C_long_float_byte
retrieve <C_double_float_byte: void f(double[])> from C_double_float_byte
retrieve <C_double_float_byte: void <init>()> from C_double_float_byte
retrieve <C_boolean_float_char: void <init>()> from C_boolean_float_char
retrieve <C_boolean_float_char: void f(boolean[])> from C_boolean_float_char
retrieve <C_byte_float_char: void <init>()> from C_byte_float_char
retrieve <C_byte_float_char: void f(byte[])> from C_byte_float_char
retrieve <C_short_float_char: void <init>()> from C_short_float_char
retrieve <C_short_float_char: void f(short[])> from C_short_float_char
retrieve <C_int_float_char: void f(int[])> from C_int_float_char
retrieve <C_int_float_char: void <init>()> from C_int_float_char
retrieve <C_long_float_char: void <init>()> from C_long_float_char
retrieve <C_long_float_char: void f(long[])> from C_long_float_char
retrieve <C_double_float_char: void f(double[])> from C_double_float_char
retrieve <C_double_float_char: void <init>()> from C_double_float_char
retrieve <C_boolean_float_short: void <init>()> from C_boolean_float_short
retrieve <C_boolean_float_short: void f(boolean[])> from C_boolean_float_short
retrieve <C_byte_float_short: void <init>()> from C_byte_float_short
retrieve <C_byte_float_short: void f(byte[])> from C_byte_float_short
retrieve <C_char_float_short: void f(char[])> from C_char_float_short
retrieve <C_char_float_short: void <init>()> from C_char_float_short
retrieve <C_int_float_short: void f(int[])> from C_int_float_short
retrieve <C_int_float_short: void <init>()> from C_int_float_short
retrieve <C_long_float_short: void <init>()> from C_long_float_short
retrieve <C_long_float_short: void f(long[])> from C_long_float_short
retrieve <C_double_float_short: void f(double[])> from C_double_float_short
retrieve <C_double_float_short: void <init>()> from C_double_float_short
retrieve <C_boolean_float_int: void <init>()> from C_boolean_float_int
retrieve <C_boolean_float_int: void f(boolean[])> from C_boolean_float_int
retrieve <C_byte_float_int: void <init>()> from C_byte_float_int
retrieve <C_byte_float_int: void f(byte[])> from C_byte_float_int
retrieve <C_char_float_int: void f(char[])> from C_char_float_int
retrieve <C_char_float_int: void <init>()> from C_char_float_int
retrieve <C_short_float_int: void <init>()> from C_short_float_int
retrieve <C_short_float_int: void f(short[])> from C_short_float_int
retrieve <C_long_float_int: void <init>()> from C_long_float_int
retrieve <C_long_float_int: void f(long[])> from C_long_float_int
retrieve <C_double_float_int: void f(double[])> from C_double_float_int
retrieve <C_double_float_int: void <init>()> from C_double_float_int
retrieve <C_boolean_float_long: void <init>()> from C_boolean_float_long
retrieve <C_boolean_float_long: void f(boolean[])> from C_boolean_float_long
retrieve <C_byte_float_long: void <init>()> from C_byte_float_long
retrieve <C_byte_float_long: void f(byte[])> from C_byte_float_long
retrieve <C_char_float_long: void f(char[])> from C_char_float_long
retrieve <C_char_float_long: void <init>()> from C_char_float_long
retrieve <C_short_float_long: void <init>()> from C_short_float_long
retrieve <C_short_float_long: void f(short[])> from C_short_float_long
retrieve <C_long_float_long: void <init>()> from C_long_float_long
retrieve <C_long_float_long: void f(long[])> from C_long_float_long
retrieve <C_double_float_long: void f(double[])> from C_double_float_long
retrieve <C_double_float_long: void <init>()> from C_double_float_long
retrieve <C_boolean_float_double: void <init>()> from C_boolean_float_double
retrieve <C_boolean_float_double: void f(boolean[])> from C_boolean_float_double
retrieve <C_byte_float_double: void <init>()> from C_byte_float_double
retrieve <C_byte_float_double: void f(byte[])> from C_byte_float_double
retrieve <C_char_float_double: void f(char[])> from C_char_float_double
retrieve <C_char_float_double: void <init>()> from C_char_float_double
retrieve <C_short_float_double: void <init>()> from C_short_float_double
retrieve <C_short_float_double: void f(short[])> from C_short_float_double
retrieve <C_int_float_double: void f(int[])> from C_int_float_double
retrieve <C_int_float_double: void <init>()> from C_int_float_double
retrieve <C_long_float_double: void <init>()> from C_long_float_double
retrieve <C_long_float_double: void f(long[])> from C_long_float_double
retrieve <C_byte_int_boolean: void <init>()> from C_byte_int_boolean
retrieve <C_byte_int_boolean: void f(byte[])> from C_byte_int_boolean
retrieve <C_char_int_boolean: void f(char[])> from C_char_int_boolean
retrieve <C_char_int_boolean: void <init>()> from C_char_int_boolean
retrieve <C_short_int_boolean: void <init>()> from C_short_int_boolean
retrieve <C_short_int_boolean: void f(short[])> from C_short_int_boolean
retrieve <C_long_int_boolean: void <init>()> from C_long_int_boolean
retrieve <C_long_int_boolean: void f(long[])> from C_long_int_boolean
retrieve <C_float_int_boolean: void <init>()> from C_float_int_boolean
retrieve <C_float_int_boolean: void f(float[])> from C_float_int_boolean
retrieve <C_double_int_boolean: void f(double[])> from C_double_int_boolean
retrieve <C_double_int_boolean: void <init>()> from C_double_int_boolean
retrieve <C_boolean_int_byte: void <init>()> from C_boolean_int_byte
retrieve <C_boolean_int_byte: void f(boolean[])> from C_boolean_int_byte
retrieve <C_char_int_byte: void f(char[])> from C_char_int_byte
retrieve <C_char_int_byte: void <init>()> from C_char_int_byte
retrieve <C_short_int_byte: void <init>()> from C_short_int_byte
retrieve <C_short_int_byte: void f(short[])> from C_short_int_byte
retrieve <C_long_int_byte: void <init>()> from C_long_int_byte
retrieve <C_long_int_byte: void f(long[])> from C_long_int_byte
retrieve <C_float_int_byte: void <init>()> from C_float_int_byte
retrieve <C_float_int_byte: void f(float[])> from C_float_int_byte
retrieve <C_double_int_byte: void f(double[])> from C_double_int_byte
retrieve <C_double_int_byte: void <init>()> from C_double_int_byte
retrieve <C_boolean_int_char: void <init>()> from C_boolean_int_char
retrieve <C_boolean_int_char: void f(boolean[])> from C_boolean_int_char
retrieve <C_byte_int_char: void <init>()> from C_byte_int_char
retrieve <C_byte_int_char: void f(byte[])> from C_byte_int_char
retrieve <C_short_int_char: void <init>()> from C_short_int_char
retrieve <C_short_int_char: void f(short[])> from C_short_int_char
retrieve <C_long_int_char: void <init>()> from C_long_int_char
retrieve <C_long_int_char: void f(long[])> from C_long_int_char
retrieve <C_float_int_char: void <init>()> from C_float_int_char
retrieve <C_float_int_char: void f(float[])> from C_float_int_char
retrieve <C_double_int_char: void f(double[])> from C_double_int_char
retrieve <C_double_int_char: void <init>()> from C_double_int_char
retrieve <C_boolean_int_short: void <init>()> from C_boolean_int_short
retrieve <C_boolean_int_short: void f(boolean[])> from C_boolean_int_short
retrieve <C_byte_int_short: void <init>()> from C_byte_int_short
retrieve <C_byte_int_short: void f(byte[])> from C_byte_int_short
retrieve <C_char_int_short: void f(char[])> from C_char_int_short
retrieve <C_char_int_short: void <init>()> from C_char_int_short
retrieve <C_long_int_short: void <init>()> from C_long_int_short
retrieve <C_long_int_short: void f(long[])> from C_long_int_short
retrieve <C_float_int_short: void <init>()> from C_float_int_short
retrieve <C_float_int_short: void f(float[])> from C_float_int_short
retrieve <C_double_int_short: void f(double[])> from C_double_int_short
retrieve <C_double_int_short: void <init>()> from C_double_int_short
retrieve <C_boolean_int_long: void <init>()> from C_boolean_int_long
retrieve <C_boolean_int_long: void f(boolean[])> from C_boolean_int_long
retrieve <C_byte_int_long: void <init>()> from C_byte_int_long
retrieve <C_byte_int_long: void f(byte[])> from C_byte_int_long
retrieve <C_char_int_long: void f(char[])> from C_char_int_long
retrieve <C_char_int_long: void <init>()> from C_char_int_long
retrieve <C_short_int_long: void <init>()> from C_short_int_long
retrieve <C_short_int_long: void f(short[])> from C_short_int_long
retrieve <C_float_int_long: void <init>()> from C_float_int_long
retrieve <C_float_int_long: void f(float[])> from C_float_int_long
retrieve <C_double_int_long: void f(double[])> from C_double_int_long
retrieve <C_double_int_long: void <init>()> from C_double_int_long
retrieve <C_boolean_int_float: void <init>()> from C_boolean_int_float
retrieve <C_boolean_int_float: void f(boolean[])> from C_boolean_int_float
retrieve <C_byte_int_float: void <init>()> from C_byte_int_float
retrieve <C_byte_int_float: void f(byte[])> from C_byte_int_float
retrieve <C_char_int_float: void f(char[])> from C_char_int_float
retrieve <C_char_int_float: void <init>()> from C_char_int_float
retrieve <C_short_int_float: void <init>()> from C_short_int_float
retrieve <C_short_int_float: void f(short[])> from C_short_int_float
retrieve <C_long_int_float: void <init>()> from C_long_int_float
retrieve <C_long_int_float: void f(long[])> from C_long_int_float
retrieve <C_double_int_float: void f(double[])> from C_double_int_float
retrieve <C_double_int_float: void <init>()> from C_double_int_float
retrieve <C_boolean_int_double: void <init>()> from C_boolean_int_double
retrieve <C_boolean_int_double: void f(boolean[])> from C_boolean_int_double
retrieve <C_byte_int_double: void <init>()> from C_byte_int_double
retrieve <C_byte_int_double: void f(byte[])> from C_byte_int_double
retrieve <C_char_int_double: void f(char[])> from C_char_int_double
retrieve <C_char_int_double: void <init>()> from C_char_int_double
retrieve <C_short_int_double: void <init>()> from C_short_int_double
retrieve <C_short_int_double: void f(short[])> from C_short_int_double
retrieve <C_long_int_double: void <init>()> from C_long_int_double
retrieve <C_long_int_double: void f(long[])> from C_long_int_double
retrieve <C_float_int_double: void <init>()> from C_float_int_double
retrieve <C_float_int_double: void f(float[])> from C_float_int_double
retrieve <C_byte_short_boolean: void <init>()> from C_byte_short_boolean
retrieve <C_byte_short_boolean: void f(byte[])> from C_byte_short_boolean
retrieve <C_char_short_boolean: void f(char[])> from C_char_short_boolean
retrieve <C_char_short_boolean: void <init>()> from C_char_short_boolean
retrieve <C_int_short_boolean: void f(int[])> from C_int_short_boolean
retrieve <C_int_short_boolean: void <init>()> from C_int_short_boolean
retrieve <C_long_short_boolean: void <init>()> from C_long_short_boolean
retrieve <C_long_short_boolean: void f(long[])> from C_long_short_boolean
retrieve <C_float_short_boolean: void <init>()> from C_float_short_boolean
retrieve <C_float_short_boolean: void f(float[])> from C_float_short_boolean
retrieve <C_double_short_boolean: void f(double[])> from C_double_short_boolean
retrieve <C_double_short_boolean: void <init>()> from C_double_short_boolean
retrieve <C_boolean_short_byte: void <init>()> from C_boolean_short_byte
retrieve <C_boolean_short_byte: void f(boolean[])> from C_boolean_short_byte
retrieve <C_char_short_byte: void f(char[])> from C_char_short_byte
retrieve <C_char_short_byte: void <init>()> from C_char_short_byte
retrieve <C_int_short_byte: void f(int[])> from C_int_short_byte
retrieve <C_int_short_byte: void <init>()> from C_int_short_byte
retrieve <C_long_short_byte: void <init>()> from C_long_short_byte
retrieve <C_long_short_byte: void f(long[])> from C_long_short_byte
retrieve <C_float_short_byte: void <init>()> from C_float_short_byte
retrieve <C_float_short_byte: void f(float[])> from C_float_short_byte
retrieve <C_double_short_byte: void f(double[])> from C_double_short_byte
retrieve <C_double_short_byte: void <init>()> from C_double_short_byte
retrieve <C_boolean_short_char: void <init>()> from C_boolean_short_char
retrieve <C_boolean_short_char: void f(boolean[])> from C_boolean_short_char
retrieve <C_byte_short_char: void <init>()> from C_byte_short_char
retrieve <C_byte_short_char: void f(byte[])> from C_byte_short_char
retrieve <C_int_short_char: void f(int[])> from C_int_short_char
retrieve <C_int_short_char: void <init>()> from C_int_short_char
retrieve <C_long_short_char: void <init>()> from C_long_short_char
retrieve <C_long_short_char: void f(long[])> from C_long_short_char
retrieve <C_float_short_char: void <init>()> from C_float_short_char
retrieve <C_float_short_char: void f(float[])> from C_float_short_char
retrieve <C_double_short_char: void f(double[])> from C_double_short_char
retrieve <C_double_short_char: void <init>()> from C_double_short_char
retrieve <C_boolean_short_int: void <init>()> from C_boolean_short_int
retrieve <C_boolean_short_int: void f(boolean[])> from C_boolean_short_int
retrieve <C_byte_short_int: void <init>()> from C_byte_short_int
retrieve <C_byte_short_int: void f(byte[])> from C_byte_short_int
retrieve <C_char_short_int: void f(char[])> from C_char_short_int
retrieve <C_char_short_int: void <init>()> from C_char_short_int
retrieve <C_long_short_int: void <init>()> from C_long_short_int
retrieve <C_long_short_int: void f(long[])> from C_long_short_int
retrieve <C_float_short_int: void <init>()> from C_float_short_int
retrieve <C_float_short_int: void f(float[])> from C_float_short_int
retrieve <C_double_short_int: void f(double[])> from C_double_short_int
retrieve <C_double_short_int: void <init>()> from C_double_short_int
retrieve <C_boolean_short_long: void <init>()> from C_boolean_short_long
retrieve <C_boolean_short_long: void f(boolean[])> from C_boolean_short_long
retrieve <C_byte_short_long: void <init>()> from C_byte_short_long
retrieve <C_byte_short_long: void f(byte[])> from C_byte_short_long
retrieve <C_char_short_long: void f(char[])> from C_char_short_long
retrieve <C_char_short_long: void <init>()> from C_char_short_long
retrieve <C_int_short_long: void f(int[])> from C_int_short_long
retrieve <C_int_short_long: void <init>()> from C_int_short_long
retrieve <C_float_short_long: void <init>()> from C_float_short_long
retrieve <C_float_short_long: void f(float[])> from C_float_short_long
retrieve <C_double_short_long: void f(double[])> from C_double_short_long
retrieve <C_double_short_long: void <init>()> from C_double_short_long
retrieve <C_boolean_short_float: void <init>()> from C_boolean_short_float
retrieve <C_boolean_short_float: void f(boolean[])> from C_boolean_short_float
retrieve <C_byte_short_float: void <init>()> from C_byte_short_float
retrieve <C_byte_short_float: void f(byte[])> from C_byte_short_float
retrieve <C_char_short_float: void f(char[])> from C_char_short_float
retrieve <C_char_short_float: void <init>()> from C_char_short_float
retrieve <C_int_short_float: void f(int[])> from C_int_short_float
retrieve <C_int_short_float: void <init>()> from C_int_short_float
retrieve <C_long_short_float: void <init>()> from C_long_short_float
retrieve <C_long_short_float: void f(long[])> from C_long_short_float
retrieve <C_double_short_float: void f(double[])> from C_double_short_float
retrieve <C_double_short_float: void <init>()> from C_double_short_float
retrieve <C_boolean_short_double: void <init>()> from C_boolean_short_double
retrieve <C_boolean_short_double: void f(boolean[])> from C_boolean_short_double
retrieve <C_byte_short_double: void <init>()> from C_byte_short_double
retrieve <C_byte_short_double: void f(byte[])> from C_byte_short_double
retrieve <C_char_short_double: void f(char[])> from C_char_short_double
retrieve <C_char_short_double: void <init>()> from C_char_short_double
retrieve <C_int_short_double: void f(int[])> from C_int_short_double
retrieve <C_int_short_double: void <init>()> from C_int_short_double
retrieve <C_long_short_double: void <init>()> from C_long_short_double
retrieve <C_long_short_double: void f(long[])> from C_long_short_double
retrieve <C_float_short_double: void <init>()> from C_float_short_double
retrieve <C_float_short_double: void f(float[])> from C_float_short_double
retrieve <C_byte_char_boolean: void <init>()> from C_byte_char_boolean
retrieve <C_byte_char_boolean: void f(byte[])> from C_byte_char_boolean
retrieve <C_short_char_boolean: void <init>()> from C_short_char_boolean
retrieve <C_short_char_boolean: void f(short[])> from C_short_char_boolean
retrieve <C_int_char_boolean: void f(int[])> from C_int_char_boolean
retrieve <C_int_char_boolean: void <init>()> from C_int_char_boolean
retrieve <C_long_char_boolean: void <init>()> from C_long_char_boolean
retrieve <C_long_char_boolean: void f(long[])> from C_long_char_boolean
retrieve <C_float_char_boolean: void <init>()> from C_float_char_boolean
retrieve <C_float_char_boolean: void f(float[])> from C_float_char_boolean
retrieve <C_double_char_boolean: void f(double[])> from C_double_char_boolean
retrieve <C_double_char_boolean: void <init>()> from C_double_char_boolean
retrieve <C_boolean_char_byte: void <init>()> from C_boolean_char_byte
retrieve <C_boolean_char_byte: void f(boolean[])> from C_boolean_char_byte
retrieve <C_short_char_byte: void <init>()> from C_short_char_byte
retrieve <C_short_char_byte: void f(short[])> from C_short_char_byte
retrieve <C_int_char_byte: void f(int[])> from C_int_char_byte
retrieve <C_int_char_byte: void <init>()> from C_int_char_byte
retrieve <C_long_char_byte: void <init>()> from C_long_char_byte
retrieve <C_long_char_byte: void f(long[])> from C_long_char_byte
retrieve <C_float_char_byte: void <init>()> from C_float_char_byte
retrieve <C_float_char_byte: void f(float[])> from C_float_char_byte
retrieve <C_double_char_byte: void f(double[])> from C_double_char_byte
retrieve <C_double_char_byte: void <init>()> from C_double_char_byte
retrieve <C_boolean_char_short: void <init>()> from C_boolean_char_short
retrieve <C_boolean_char_short: void f(boolean[])> from C_boolean_char_short
retrieve <C_byte_char_short: void <init>()> from C_byte_char_short
retrieve <C_byte_char_short: void f(byte[])> from C_byte_char_short
retrieve <C_int_char_short: void f(int[])> from C_int_char_short
retrieve <C_int_char_short: void <init>()> from C_int_char_short
retrieve <C_long_char_short: void <init>()> from C_long_char_short
retrieve <C_long_char_short: void f(long[])> from C_long_char_short
retrieve <C_float_char_short: void <init>()> from C_float_char_short
retrieve <C_float_char_short: void f(float[])> from C_float_char_short
retrieve <C_double_char_short: void f(double[])> from C_double_char_short
retrieve <C_double_char_short: void <init>()> from C_double_char_short
retrieve <C_boolean_char_int: void <init>()> from C_boolean_char_int
retrieve <C_boolean_char_int: void f(boolean[])> from C_boolean_char_int
retrieve <C_byte_char_int: void <init>()> from C_byte_char_int
retrieve <C_byte_char_int: void f(byte[])> from C_byte_char_int
retrieve <C_short_char_int: void <init>()> from C_short_char_int
retrieve <C_short_char_int: void f(short[])> from C_short_char_int
retrieve <C_long_char_int: void <init>()> from C_long_char_int
retrieve <C_long_char_int: void f(long[])> from C_long_char_int
retrieve <C_float_char_int: void <init>()> from C_float_char_int
retrieve <C_float_char_int: void f(float[])> from C_float_char_int
retrieve <C_double_char_int: void f(double[])> from C_double_char_int
retrieve <C_double_char_int: void <init>()> from C_double_char_int
retrieve <C_boolean_char_long: void <init>()> from C_boolean_char_long
retrieve <C_boolean_char_long: void f(boolean[])> from C_boolean_char_long
retrieve <C_byte_char_long: void <init>()> from C_byte_char_long
retrieve <C_byte_char_long: void f(byte[])> from C_byte_char_long
retrieve <C_short_char_long: void <init>()> from C_short_char_long
retrieve <C_short_char_long: void f(short[])> from C_short_char_long
retrieve <C_int_char_long: void f(int[])> from C_int_char_long
retrieve <C_int_char_long: void <init>()> from C_int_char_long
retrieve <C_float_char_long: void <init>()> from C_float_char_long
retrieve <C_float_char_long: void f(float[])> from C_float_char_long
retrieve <C_double_char_long: void f(double[])> from C_double_char_long
retrieve <C_double_char_long: void <init>()> from C_double_char_long
retrieve <C_boolean_char_float: void <init>()> from C_boolean_char_float
retrieve <C_boolean_char_float: void f(boolean[])> from C_boolean_char_float
retrieve <C_byte_char_float: void <init>()> from C_byte_char_float
retrieve <C_byte_char_float: void f(byte[])> from C_byte_char_float
retrieve <C_short_char_float: void <init>()> from C_short_char_float
retrieve <C_short_char_float: void f(short[])> from C_short_char_float
retrieve <C_int_char_float: void f(int[])> from C_int_char_float
retrieve <C_int_char_float: void <init>()> from C_int_char_float
retrieve <C_long_char_float: void <init>()> from C_long_char_float
retrieve <C_long_char_float: void f(long[])> from C_long_char_float
retrieve <C_double_char_float: void f(double[])> from C_double_char_float
retrieve <C_double_char_float: void <init>()> from C_double_char_float
retrieve <C_boolean_char_double: void <init>()> from C_boolean_char_double
retrieve <C_boolean_char_double: void f(boolean[])> from C_boolean_char_double
retrieve <C_byte_char_double: void <init>()> from C_byte_char_double
retrieve <C_byte_char_double: void f(byte[])> from C_byte_char_double
retrieve <C_short_char_double: void <init>()> from C_short_char_double
retrieve <C_short_char_double: void f(short[])> from C_short_char_double
retrieve <C_int_char_double: void f(int[])> from C_int_char_double
retrieve <C_int_char_double: void <init>()> from C_int_char_double
retrieve <C_long_char_double: void <init>()> from C_long_char_double
retrieve <C_long_char_double: void f(long[])> from C_long_char_double
retrieve <C_float_char_double: void <init>()> from C_float_char_double
retrieve <C_float_char_double: void f(float[])> from C_float_char_double
retrieve <C_char_byte_boolean: void f(char[])> from C_char_byte_boolean
retrieve <C_char_byte_boolean: void <init>()> from C_char_byte_boolean
retrieve <C_short_byte_boolean: void <init>()> from C_short_byte_boolean
retrieve <C_short_byte_boolean: void f(short[])> from C_short_byte_boolean
retrieve <C_int_byte_boolean: void f(int[])> from C_int_byte_boolean
retrieve <C_int_byte_boolean: void <init>()> from C_int_byte_boolean
retrieve <C_long_byte_boolean: void <init>()> from C_long_byte_boolean
retrieve <C_long_byte_boolean: void f(long[])> from C_long_byte_boolean
retrieve <C_float_byte_boolean: void <init>()> from C_float_byte_boolean
retrieve <C_float_byte_boolean: void f(float[])> from C_float_byte_boolean
retrieve <C_double_byte_boolean: void f(double[])> from C_double_byte_boolean
retrieve <C_double_byte_boolean: void <init>()> from C_double_byte_boolean
retrieve <C_boolean_byte_char: void <init>()> from C_boolean_byte_char
retrieve <C_boolean_byte_char: void f(boolean[])> from C_boolean_byte_char
retrieve <C_short_byte_char: void <init>()> from C_short_byte_char
retrieve <C_short_byte_char: void f(short[])> from C_short_byte_char
retrieve <C_int_byte_char: void f(int[])> from C_int_byte_char
retrieve <C_int_byte_char: void <init>()> from C_int_byte_char
retrieve <C_long_byte_char: void <init>()> from C_long_byte_char
retrieve <C_long_byte_char: void f(long[])> from C_long_byte_char
retrieve <C_float_byte_char: void <init>()> from C_float_byte_char
retrieve <C_float_byte_char: void f(float[])> from C_float_byte_char
retrieve <C_double_byte_char: void f(double[])> from C_double_byte_char
retrieve <C_double_byte_char: void <init>()> from C_double_byte_char
retrieve <C_boolean_byte_short: void <init>()> from C_boolean_byte_short
retrieve <C_boolean_byte_short: void f(boolean[])> from C_boolean_byte_short
retrieve <C_char_byte_short: void f(char[])> from C_char_byte_short
retrieve <C_char_byte_short: void <init>()> from C_char_byte_short
retrieve <C_int_byte_short: void f(int[])> from C_int_byte_short
retrieve <C_int_byte_short: void <init>()> from C_int_byte_short
retrieve <C_long_byte_short: void <init>()> from C_long_byte_short
retrieve <C_long_byte_short: void f(long[])> from C_long_byte_short
retrieve <C_float_byte_short: void <init>()> from C_float_byte_short
retrieve <C_float_byte_short: void f(float[])> from C_float_byte_short
retrieve <C_double_byte_short: void f(double[])> from C_double_byte_short
retrieve <C_double_byte_short: void <init>()> from C_double_byte_short
retrieve <C_boolean_byte_int: void <init>()> from C_boolean_byte_int
retrieve <C_boolean_byte_int: void f(boolean[])> from C_boolean_byte_int
retrieve <C_char_byte_int: void f(char[])> from C_char_byte_int
retrieve <C_char_byte_int: void <init>()> from C_char_byte_int
retrieve <C_short_byte_int: void <init>()> from C_short_byte_int
retrieve <C_short_byte_int: void f(short[])> from C_short_byte_int
retrieve <C_long_byte_int: void <init>()> from C_long_byte_int
retrieve <C_long_byte_int: void f(long[])> from C_long_byte_int
retrieve <C_float_byte_int: void <init>()> from C_float_byte_int
retrieve <C_float_byte_int: void f(float[])> from C_float_byte_int
retrieve <C_double_byte_int: void f(double[])> from C_double_byte_int
retrieve <C_double_byte_int: void <init>()> from C_double_byte_int
retrieve <C_boolean_byte_long: void <init>()> from C_boolean_byte_long
retrieve <C_boolean_byte_long: void f(boolean[])> from C_boolean_byte_long
retrieve <C_char_byte_long: void f(char[])> from C_char_byte_long
retrieve <C_char_byte_long: void <init>()> from C_char_byte_long
retrieve <C_short_byte_long: void <init>()> from C_short_byte_long
retrieve <C_short_byte_long: void f(short[])> from C_short_byte_long
retrieve <C_int_byte_long: void f(int[])> from C_int_byte_long
retrieve <C_int_byte_long: void <init>()> from C_int_byte_long
retrieve <C_float_byte_long: void <init>()> from C_float_byte_long
retrieve <C_float_byte_long: void f(float[])> from C_float_byte_long
retrieve <C_double_byte_long: void f(double[])> from C_double_byte_long
retrieve <C_double_byte_long: void <init>()> from C_double_byte_long
retrieve <C_boolean_byte_float: void <init>()> from C_boolean_byte_float
retrieve <C_boolean_byte_float: void f(boolean[])> from C_boolean_byte_float
retrieve <C_char_byte_float: void f(char[])> from C_char_byte_float
retrieve <C_char_byte_float: void <init>()> from C_char_byte_float
retrieve <C_short_byte_float: void <init>()> from C_short_byte_float
retrieve <C_short_byte_float: void f(short[])> from C_short_byte_float
retrieve <C_int_byte_float: void f(int[])> from C_int_byte_float
retrieve <C_int_byte_float: void <init>()> from C_int_byte_float
retrieve <C_long_byte_float: void <init>()> from C_long_byte_float
retrieve <C_long_byte_float: void f(long[])> from C_long_byte_float
retrieve <C_double_byte_float: void f(double[])> from C_double_byte_float
retrieve <C_double_byte_float: void <init>()> from C_double_byte_float
retrieve <C_boolean_byte_double: void <init>()> from C_boolean_byte_double
retrieve <C_boolean_byte_double: void f(boolean[])> from C_boolean_byte_double
retrieve <C_char_byte_double: void f(char[])> from C_char_byte_double
retrieve <C_char_byte_double: void <init>()> from C_char_byte_double
retrieve <C_short_byte_double: void <init>()> from C_short_byte_double
retrieve <C_short_byte_double: void f(short[])> from C_short_byte_double
retrieve <C_int_byte_double: void f(int[])> from C_int_byte_double
retrieve <C_int_byte_double: void <init>()> from C_int_byte_double
retrieve <C_long_byte_double: void <init>()> from C_long_byte_double
retrieve <C_long_byte_double: void f(long[])> from C_long_byte_double
retrieve <C_float_byte_double: void <init>()> from C_float_byte_double
retrieve <C_float_byte_double: void f(float[])> from C_float_byte_double
retrieve <C_byte_boolean_double: void <init>()> from C_byte_boolean_double
retrieve <C_byte_boolean_double: void f(byte[])> from C_byte_boolean_double
retrieve <C_char_boolean_double: void f(char[])> from C_char_boolean_double
retrieve <C_char_boolean_double: void <init>()> from C_char_boolean_double
retrieve <C_short_boolean_double: void <init>()> from C_short_boolean_double
retrieve <C_short_boolean_double: void f(short[])> from C_short_boolean_double
retrieve <C_int_boolean_double: void f(int[])> from C_int_boolean_double
retrieve <C_int_boolean_double: void <init>()> from C_int_boolean_double
retrieve <C_long_boolean_double: void <init>()> from C_long_boolean_double
retrieve <C_long_boolean_double: void f(long[])> from C_long_boolean_double
retrieve <C_float_boolean_double: void <init>()> from C_float_boolean_double
retrieve <C_float_boolean_double: void f(float[])> from C_float_boolean_double
retrieve <C_byte_boolean_float: void <init>()> from C_byte_boolean_float
retrieve <C_byte_boolean_float: void f(byte[])> from C_byte_boolean_float
retrieve <C_char_boolean_float: void f(char[])> from C_char_boolean_float
retrieve <C_char_boolean_float: void <init>()> from C_char_boolean_float
retrieve <C_short_boolean_float: void <init>()> from C_short_boolean_float
retrieve <C_short_boolean_float: void f(short[])> from C_short_boolean_float
retrieve <C_int_boolean_float: void f(int[])> from C_int_boolean_float
retrieve <C_int_boolean_float: void <init>()> from C_int_boolean_float
retrieve <C_long_boolean_float: void <init>()> from C_long_boolean_float
retrieve <C_long_boolean_float: void f(long[])> from C_long_boolean_float
retrieve <C_double_boolean_float: void f(double[])> from C_double_boolean_float
retrieve <C_double_boolean_float: void <init>()> from C_double_boolean_float
retrieve <C_byte_boolean_long: void <init>()> from C_byte_boolean_long
retrieve <C_byte_boolean_long: void f(byte[])> from C_byte_boolean_long
retrieve <C_char_boolean_long: void f(char[])> from C_char_boolean_long
retrieve <C_char_boolean_long: void <init>()> from C_char_boolean_long
retrieve <C_short_boolean_long: void <init>()> from C_short_boolean_long
retrieve <C_short_boolean_long: void f(short[])> from C_short_boolean_long
retrieve <C_int_boolean_long: void f(int[])> from C_int_boolean_long
retrieve <C_int_boolean_long: void <init>()> from C_int_boolean_long
retrieve <C_float_boolean_long: void <init>()> from C_float_boolean_long
retrieve <C_float_boolean_long: void f(float[])> from C_float_boolean_long
retrieve <C_double_boolean_long: void f(double[])> from C_double_boolean_long
retrieve <C_double_boolean_long: void <init>()> from C_double_boolean_long
retrieve <C_byte_boolean_int: void <init>()> from C_byte_boolean_int
retrieve <C_byte_boolean_int: void f(byte[])> from C_byte_boolean_int
retrieve <C_char_boolean_int: void f(char[])> from C_char_boolean_int
retrieve <C_char_boolean_int: void <init>()> from C_char_boolean_int
retrieve <C_short_boolean_int: void <init>()> from C_short_boolean_int
retrieve <C_short_boolean_int: void f(short[])> from C_short_boolean_int
retrieve <C_long_boolean_int: void <init>()> from C_long_boolean_int
retrieve <C_long_boolean_int: void f(long[])> from C_long_boolean_int
retrieve <C_float_boolean_int: void <init>()> from C_float_boolean_int
retrieve <C_float_boolean_int: void f(float[])> from C_float_boolean_int
retrieve <C_double_boolean_int: void f(double[])> from C_double_boolean_int
retrieve <C_double_boolean_int: void <init>()> from C_double_boolean_int
retrieve <C_byte_boolean_short: void <init>()> from C_byte_boolean_short
retrieve <C_byte_boolean_short: void f(byte[])> from C_byte_boolean_short
retrieve <C_char_boolean_short: void f(char[])> from C_char_boolean_short
retrieve <C_char_boolean_short: void <init>()> from C_char_boolean_short
retrieve <C_int_boolean_short: void f(int[])> from C_int_boolean_short
retrieve <C_int_boolean_short: void <init>()> from C_int_boolean_short
retrieve <C_long_boolean_short: void <init>()> from C_long_boolean_short
retrieve <C_long_boolean_short: void f(long[])> from C_long_boolean_short
retrieve <C_float_boolean_short: void <init>()> from C_float_boolean_short
retrieve <C_float_boolean_short: void f(float[])> from C_float_boolean_short
retrieve <C_double_boolean_short: void f(double[])> from C_double_boolean_short
retrieve <C_double_boolean_short: void <init>()> from C_double_boolean_short
retrieve <C_byte_boolean_char: void <init>()> from C_byte_boolean_char
retrieve <C_byte_boolean_char: void f(byte[])> from C_byte_boolean_char
retrieve <C_short_boolean_char: void <init>()> from C_short_boolean_char
retrieve <C_short_boolean_char: void f(short[])> from C_short_boolean_char
retrieve <C_int_boolean_char: void f(int[])> from C_int_boolean_char
retrieve <C_int_boolean_char: void <init>()> from C_int_boolean_char
retrieve <C_long_boolean_char: void <init>()> from C_long_boolean_char
retrieve <C_long_boolean_char: void f(long[])> from C_long_boolean_char
retrieve <C_float_boolean_char: void <init>()> from C_float_boolean_char
retrieve <C_float_boolean_char: void f(float[])> from C_float_boolean_char
retrieve <C_double_boolean_char: void f(double[])> from C_double_boolean_char
retrieve <C_double_boolean_char: void <init>()> from C_double_boolean_char
retrieve <C_char_boolean_byte: void f(char[])> from C_char_boolean_byte
retrieve <C_char_boolean_byte: void <init>()> from C_char_boolean_byte
retrieve <C_short_boolean_byte: void <init>()> from C_short_boolean_byte
retrieve <C_short_boolean_byte: void f(short[])> from C_short_boolean_byte
retrieve <C_int_boolean_byte: void f(int[])> from C_int_boolean_byte
retrieve <C_int_boolean_byte: void <init>()> from C_int_boolean_byte
retrieve <C_long_boolean_byte: void <init>()> from C_long_boolean_byte
retrieve <C_long_boolean_byte: void f(long[])> from C_long_boolean_byte
retrieve <C_float_boolean_byte: void <init>()> from C_float_boolean_byte
retrieve <C_float_boolean_byte: void f(float[])> from C_float_boolean_byte
retrieve <C_double_boolean_byte: void f(double[])> from C_double_boolean_byte
retrieve <C_double_boolean_byte: void <init>()> from C_double_boolean_byte
retrieve <C_boolean_double: void <init>()> from C_boolean_double
retrieve <C_boolean_double: void f(boolean[])> from C_boolean_double
retrieve <C_byte_double: void <init>()> from C_byte_double
retrieve <C_byte_double: void f(byte[])> from C_byte_double
retrieve <C_char_double: void f(char[])> from C_char_double
retrieve <C_char_double: void <init>()> from C_char_double
retrieve <C_short_double: void <init>()> from C_short_double
retrieve <C_short_double: void f(short[])> from C_short_double
retrieve <C_int_double: void f(int[])> from C_int_double
retrieve <C_int_double: void <init>()> from C_int_double
retrieve <C_long_double: void <init>()> from C_long_double
retrieve <C_long_double: void f(long[])> from C_long_double
retrieve <C_float_double: void <init>()> from C_float_double
retrieve <C_float_double: void f(float[])> from C_float_double
retrieve <C_boolean_float: void <init>()> from C_boolean_float
retrieve <C_boolean_float: void f(boolean[])> from C_boolean_float
retrieve <C_byte_float: void <init>()> from C_byte_float
retrieve <C_byte_float: void f(byte[])> from C_byte_float
retrieve <C_char_float: void f(char[])> from C_char_float
retrieve <C_char_float: void <init>()> from C_char_float
retrieve <C_short_float: void <init>()> from C_short_float
retrieve <C_short_float: void f(short[])> from C_short_float
retrieve <C_int_float: void f(int[])> from C_int_float
retrieve <C_int_float: void <init>()> from C_int_float
retrieve <C_long_float: void <init>()> from C_long_float
retrieve <C_long_float: void f(long[])> from C_long_float
retrieve <C_double_float: void f(double[])> from C_double_float
retrieve <C_double_float: void <init>()> from C_double_float
retrieve <C_boolean_long: void <init>()> from C_boolean_long
retrieve <C_boolean_long: void f(boolean[])> from C_boolean_long
retrieve <C_byte_long: void <init>()> from C_byte_long
retrieve <C_byte_long: void f(byte[])> from C_byte_long
retrieve <C_char_long: void f(char[])> from C_char_long
retrieve <C_char_long: void <init>()> from C_char_long
retrieve <C_short_long: void <init>()> from C_short_long
retrieve <C_short_long: void f(short[])> from C_short_long
retrieve <C_int_long: void f(int[])> from C_int_long
retrieve <C_int_long: void <init>()> from C_int_long
retrieve <C_float_long: void <init>()> from C_float_long
retrieve <C_float_long: void f(float[])> from C_float_long
retrieve <C_double_long: void f(double[])> from C_double_long
retrieve <C_double_long: void <init>()> from C_double_long
retrieve <C_boolean_int: void <init>()> from C_boolean_int
retrieve <C_boolean_int: void f(boolean[])> from C_boolean_int
retrieve <C_byte_int: void <init>()> from C_byte_int
retrieve <C_byte_int: void f(byte[])> from C_byte_int
retrieve <C_char_int: void f(char[])> from C_char_int
retrieve <C_char_int: void <init>()> from C_char_int
retrieve <C_short_int: void <init>()> from C_short_int
retrieve <C_short_int: void f(short[])> from C_short_int
retrieve <C_long_int: void <init>()> from C_long_int
retrieve <C_long_int: void f(long[])> from C_long_int
retrieve <C_float_int: void <init>()> from C_float_int
retrieve <C_float_int: void f(float[])> from C_float_int
retrieve <C_double_int: void f(double[])> from C_double_int
retrieve <C_double_int: void <init>()> from C_double_int
retrieve <C_boolean_short: void <init>()> from C_boolean_short
retrieve <C_boolean_short: void f(boolean[])> from C_boolean_short
retrieve <C_byte_short: void <init>()> from C_byte_short
retrieve <C_byte_short: void f(byte[])> from C_byte_short
retrieve <C_char_short: void f(char[])> from C_char_short
retrieve <C_char_short: void <init>()> from C_char_short
retrieve <C_int_short: void f(int[])> from C_int_short
retrieve <C_int_short: void <init>()> from C_int_short
retrieve <C_long_short: void <init>()> from C_long_short
retrieve <C_long_short: void f(long[])> from C_long_short
retrieve <C_float_short: void <init>()> from C_float_short
retrieve <C_float_short: void f(float[])> from C_float_short
retrieve <C_double_short: void f(double[])> from C_double_short
retrieve <C_double_short: void <init>()> from C_double_short
retrieve <C_boolean_char: void <init>()> from C_boolean_char
retrieve <C_boolean_char: void f(boolean[])> from C_boolean_char
retrieve <C_byte_char: void <init>()> from C_byte_char
retrieve <C_byte_char: void f(byte[])> from C_byte_char
retrieve <C_short_char: void <init>()> from C_short_char
retrieve <C_short_char: void f(short[])> from C_short_char
retrieve <C_int_char: void f(int[])> from C_int_char
retrieve <C_int_char: void <init>()> from C_int_char
retrieve <C_long_char: void <init>()> from C_long_char
retrieve <C_long_char: void f(long[])> from C_long_char
retrieve <C_float_char: void <init>()> from C_float_char
retrieve <C_float_char: void f(float[])> from C_float_char
retrieve <C_double_char: void f(double[])> from C_double_char
retrieve <C_double_char: void <init>()> from C_double_char
retrieve <C_boolean_byte: void <init>()> from C_boolean_byte
retrieve <C_boolean_byte: void f(boolean[])> from C_boolean_byte
retrieve <C_char_byte: void f(char[])> from C_char_byte
retrieve <C_char_byte: void <init>()> from C_char_byte
retrieve <C_short_byte: void <init>()> from C_short_byte
retrieve <C_short_byte: void f(short[])> from C_short_byte
retrieve <C_int_byte: void f(int[])> from C_int_byte
retrieve <C_int_byte: void <init>()> from C_int_byte
retrieve <C_long_byte: void <init>()> from C_long_byte
retrieve <C_long_byte: void f(long[])> from C_long_byte
retrieve <C_float_byte: void <init>()> from C_float_byte
retrieve <C_float_byte: void f(float[])> from C_float_byte
retrieve <C_double_byte: void f(double[])> from C_double_byte
retrieve <C_double_byte: void <init>()> from C_double_byte
retrieve <C_byte_boolean: void <init>()> from C_byte_boolean
retrieve <C_byte_boolean: void f(byte[])> from C_byte_boolean
retrieve <C_char_boolean: void f(char[])> from C_char_boolean
retrieve <C_char_boolean: void <init>()> from C_char_boolean
retrieve <C_short_boolean: void <init>()> from C_short_boolean
retrieve <C_short_boolean: void f(short[])> from C_short_boolean
retrieve <C_int_boolean: void f(int[])> from C_int_boolean
retrieve <C_int_boolean: void <init>()> from C_int_boolean
retrieve <C_long_boolean: void <init>()> from C_long_boolean
retrieve <C_long_boolean: void f(long[])> from C_long_boolean
retrieve <C_float_boolean: void <init>()> from C_float_boolean
retrieve <C_float_boolean: void f(float[])> from C_float_boolean
retrieve <C_double_boolean: void f(double[])> from C_double_boolean
retrieve <C_double_boolean: void <init>()> from C_double_boolean
Transforming C_double_short_byte... 
Transforming C_double_byte... 
Transforming C_long_boolean_byte... 
Transforming C_byte_char_boolean... 
Transforming C_float_char_boolean... 
Transforming C_boolean_short_char... 
Transforming C_short_double_byte... 
Transforming C_int_short_long... 
Transforming C_float_double_char... 
Transforming C_int_double_byte... 
Transforming C_int_short_byte... 
Transforming C_char_byte_int... 
Transforming C_byte_char_float... 
Transforming C_long_short_int... 
Transforming C_boolean_float_int... 
Transforming C_float_int... 
Transforming C_boolean_float_double... 
Transforming C_double_short_int... 
Transforming C_int_float_char... 
Transforming C_long_byte_int... 
Transforming C_int_short_boolean... 
Transforming C_short_float_boolean... 
Transforming C_char_int... 
Transforming C_boolean_float_byte... 
Transforming C_int_boolean_long... 
Transforming C_byte_long... 
Transforming C_char... 
Transforming C_float_byte_boolean... 
Transforming C_float_short_long... 
Transforming C_short_boolean_float... 
Transforming C_long_byte_float... 
Transforming C_char_double_byte... 
Transforming C_float_boolean_double... 
Transforming CC_double... 
Transforming C_long_double_byte... 
Transforming C_byte_short_int... 
Transforming C_float_char_byte... 
Transforming C_long_boolean_char... 
Transforming C_short_byte_long... 
Transforming C_byte_float... 
Transforming C_long_boolean_int... 
Transforming C_long_int_byte... 
Transforming C_byte_int... 
Transforming C_long_double... 
Transforming C_boolean_byte_short... 
Transforming C_int_boolean_double... 
Transforming C_char_byte_float... 
Transforming C_byte_double_boolean... 
Transforming C_byte_short_long... 
Transforming C_boolean_byte_long... 
Transforming C_double_char_boolean... 
Transforming C_float_int_char... 
Transforming C_short_char... 
Transforming C_double_byte_char... 
Transforming C_byte_boolean_int... 
Transforming C_long_float_short... 
Transforming C_float_double_byte... 
Transforming C_byte_boolean... 
Transforming C_int_byte_long... 
Transforming C_long_short_float... 
Transforming C_boolean_float_long... 
Transforming C_int_boolean_byte... 
Transforming C_boolean_long... 
Transforming C_int_byte_char... 
Transforming C_char_int_byte... 
Transforming C_boolean_float_short... 
Transforming C_float_byte_long... 
Transforming C_double_float_char... 
Transforming C_double_char_short... 
Transforming C_boolean_byte_double... 
Transforming C_float_byte_int... 
Transforming C_char_boolean_float... 
Transforming C_short_byte_double... 
Transforming C_char_float_int... 
Transforming C_boolean_double_short... 
Transforming C_double_byte_long... 
Transforming CC_boolean... 
Transforming C_double_float_short... 
Transforming C_float_long... 
Transforming C_long_float_long... 
Transforming C_double_int_byte... 
Transforming C_short_byte_boolean... 
Transforming C_int_char_byte... 
Transforming C_char_byte_long... 
Transforming C_double_int_char... 
Transforming C_byte_int_boolean... 
Transforming C_int_char_boolean... 
Transforming C_boolean_short_long... 
Transforming C_double_float_byte... 
Transforming C_short_double... 
Transforming C_long_float_int... 
Transforming C_boolean_double... 
Transforming C_float_boolean_short... 
Transforming C_byte_char... 
Transforming C_boolean_byte_int... 
Transforming C_byte_double_int... 
Transforming C_short_char_double... 
Transforming C_boolean_float_char... 
Transforming CC_char... 
Transforming C_short_char_int... 
Transforming C_short_boolean_double... 
Transforming C_int_byte_double... 
Transforming C_boolean_char_byte... 
Transforming C_int_long... 
Transforming C_double_byte_float... 
Transforming C_float_short_boolean... 
Transforming ResolvingArrayParameters... 
Transforming C_long_char_short... 
Transforming C_double_char... 
Transforming C_int_char_float... 
Transforming C_short_boolean... 
Transforming C_float_double_short... 
Transforming C_int_byte_boolean... 
Transforming C_double_boolean_float... 
Transforming C_long_float_byte... 
Transforming C_boolean_char_int... 
Transforming C_boolean_int... 
Transforming C_byte_double_float... 
Transforming C_float_int_short... 
Transforming C_byte_double_char... 
Transforming C_float_byte... 
Transforming C_boolean_int_double... 
Transforming C_byte_float_double... 
Transforming CC_byte... 
Transforming C_long_double_int... 
Transforming C_double_char_float... 
Transforming C_float_char_short... 
Transforming C_char_byte_double... 
Transforming C_double_int_short... 
Transforming C_short_int... 
Transforming C_double_int_long... 
Transforming C_boolean_int_long... 
Transforming C_byte_float_boolean... 
Transforming C_boolean_double_byte... 
Transforming C_char_boolean_long... 
Transforming C_byte_int_short... 
Transforming C_char_float_long... 
Transforming C_int_double_boolean... 
Transforming C_byte_short_char... 
Transforming C_byte_boolean_double... 
Transforming C_double_short_char... 
Transforming C_boolean_byte_float... 
Transforming C_float_double_long... 
Transforming C_short_boolean_byte... 
Transforming C_short_int_float... 
Transforming C_int_float_short... 
Transforming C_char_int_long... 
Transforming C_long_int_char... 
Transforming C_long_short_double... 
Transforming C_float_char_int... 
Transforming C_short_double_char... 
Transforming C_byte_short... 
Transforming C_byte_double_long... 
Transforming C_long_double_float... 
Transforming C_boolean_char_double... 
Transforming C_byte_char_long... 
Transforming C_boolean_int_byte... 
Transforming C_byte_int_long... 
Transforming C_long_char_double... 
Transforming C_float_int_double... 
Transforming C_short_double_float... 
Transforming C_double_char_byte... 
Transforming C_short_float_int... 
Transforming C_byte_float_short... 
Transforming C_long_char_boolean... 
Transforming C_short_double_int... 
Transforming C_double_boolean_long... 
Transforming C_float_short_int... 
Transforming C_int_byte_short... 
Transforming C_char_double_short... 
Transforming C_char_float_short... 
Transforming C_short_byte_char... 
Transforming C_int_char... 
Transforming C_long_char_int... 
Transforming C_long_char... 
Transforming C_short_int_double... 
Transforming CC_long... 
Transforming C_long... 
Transforming C_int_double_long... 
Transforming C_double_int_boolean... 
Transforming C_float... 
Transforming C_double_float_int... 
Transforming C_boolean_double_float... 
Transforming C_float_char... 
Transforming C_boolean_char_short... 
Transforming C_int_boolean... 
Transforming C_int_float... 
Transforming C_short_char_byte... 
Transforming C_int_short_double... 
Transforming C_boolean_char_long... 
Transforming C_char_boolean... 
Transforming C_char_int_short... 
Transforming C_short_float_char... 
Transforming C_byte_short_boolean... 
Transforming C_byte_float_long... 
Transforming C_double_short_boolean... 
Transforming C_float_byte_short... 
Transforming C_float_short_byte... 
Transforming C_float_boolean... 
Transforming C_boolean_char_float... 
Transforming CC_float... 
Transforming C_byte_boolean_char... 
Transforming C_float_boolean_byte... 
Transforming C_long_float_boolean... 
Transforming C_boolean_short... 
Transforming C_double_char_int... 
Transforming C_long_short_byte... 
Transforming C_char_int_double... 
Transforming C_short_int_byte... 
Transforming C_short_float_double... 
Transforming C_float_boolean_int... 
Transforming C_int_boolean_short... 
Transforming C_int_boolean_float... 
Transforming C_int_short_float... 
Transforming C_long_short_char... 
Transforming C_boolean_double_int... 
Transforming C_double_boolean... 
Transforming C_short_boolean_long... 
Transforming C_byte... 
Transforming C_float_double_int... 
Transforming C_int_char_long... 
Transforming C_byte_short_float... 
Transforming C_long_int_double... 
Transforming C_float_int_byte... 
Transforming C_char_double_float... 
Transforming C_char_byte... 
Transforming C_long_short... 
Transforming C_double_boolean_byte... 
Transforming C_short_long... 
Transforming C_double... 
Transforming C_long_byte... 
Transforming C_char_long... 
Transforming C_boolean_int_char... 
Transforming C_boolean_short_int... 
Transforming C_byte_boolean_short... 
Transforming C_char_double... 
Transforming C_char_short_double... 
Transforming C_boolean_double_long... 
Transforming C_long_float... 
Transforming C_float_short_char... 
Transforming C_boolean_byte... 
Transforming C_long_float_double... 
Transforming C_int_boolean_char... 
Transforming C_long_float_char... 
Transforming C_byte_int_float... 
Transforming C_byte_float_char... 
Transforming C_short_char_long... 
Transforming C_char_int_boolean... 
Transforming C_double_byte_short... 
Transforming C_short_int_char... 
Transforming C_char_boolean_double... 
Transforming C_byte_char_int... 
Transforming C_int_short... 
Transforming C_short_char_boolean... 
Transforming C_long_int_short... 
Transforming C_byte_double... 
Transforming C_long_char_byte... 
Transforming C_char_boolean_byte... 
Transforming C_short_byte_float... 
Transforming C_long_double_short... 
Transforming C_short_int_boolean... 
Transforming C_double_float_long... 
Transforming C_double_float_boolean... 
Transforming C_short_int_long... 
Transforming CC_short... 
Transforming C_int_char_double... 
Transforming C_short_byte_int... 
Transforming C_short_float_byte... 
Transforming C_long_boolean_double... 
Transforming C_long_byte_boolean... 
Transforming C_float_char_long... 
Transforming C_int_float_byte... 
Transforming C_short... 
Transforming C_char_float_double... 
Transforming C_short_boolean_int... 
Transforming C_short_byte... 
Transforming C_long_short_boolean... 
Transforming C_double_boolean_short... 
Transforming C_char_byte_short... 
Transforming C_char_short_int... 
Transforming C_int_double_float... 
Transforming C_boolean_short_double... 
Transforming C_long_double_boolean... 
Transforming C_char_boolean_int... 
Transforming C_boolean... 
Transforming C_double_long... 
Transforming CC_int... 
Transforming C_char_float_boolean... 
Transforming C_double_byte_boolean... 
Transforming C_double_float... 
Transforming C_char_double_int... 
Transforming C_int_byte... 
Transforming C_float_boolean_char... 
Transforming C_byte_boolean_float... 
Transforming C_double_int... 
Transforming C_short_float_long... 
Transforming C_char_short_byte... 
Transforming C_boolean_double_char... 
Transforming C_long_byte_char... 
Transforming C_byte_boolean_long... 
Transforming C_long_int_boolean... 
Transforming C_char_short_boolean... 
Transforming C_short_double_long... 
Transforming C_double_char_long... 
Transforming C_char_boolean_short... 
Transforming C_double_short_float... 
Transforming C_boolean_float... 
Transforming C_double_boolean_char... 
Transforming C_byte_int_double... 
Transforming C_float_short... 
Transforming C_long_byte_short... 
Transforming C_float_double_boolean... 
Transforming C_byte_double_short... 
Transforming C_boolean_byte_char... 
Transforming A... 
Transforming C_byte_char_double... 
Transforming C_char_double_long... 
Transforming C_char_byte_boolean... 
Transforming C_char_float_byte... 
Transforming C_int_float_boolean... 
Transforming C_float_int_long... 
Transforming C_long_boolean_float... 
Transforming C_long_int... 
Transforming C_int_char_short... 
Transforming C_char_double_boolean... 
Transforming C_boolean_char... 
Transforming C_double_short_long... 
Transforming C_char_int_float... 
Transforming C_float_char_double... 
Transforming C_boolean_int_short... 
Transforming C_int_float_double... 
Transforming C_byte_float_int... 
Transforming C_int_double... 
Transforming C_float_byte_double... 
Transforming C_boolean_short_float... 
Transforming C_boolean_short_byte... 
Transforming C_float_boolean_long... 
Transforming C_short_float... 
Transforming C_long_byte_double... 
Transforming C_float_int_boolean... 
Transforming C_double_short... 
Transforming C_byte_char_short... 
Transforming C_char_short_long... 
Transforming C_int_double_short... 
Transforming C_long_double_char... 
Transforming C_short_boolean_char... 
Transforming C_char_short_float... 
Transforming C_float_short_double... 
Transforming C_double_boolean_int... 
Transforming C_float_byte_char... 
Transforming C_int... 
Transforming C_short_double_boolean... 
Transforming C_char_short... 
Transforming C_char_float... 
Transforming C_boolean_int_float... 
Transforming C_byte_short_double... 
Transforming C_long_int_float... 
Transforming C_long_char_float... 
Transforming C_double_int_float... 
Transforming C_int_byte_float... 
Transforming C_int_double_char... 
Transforming C_double_byte_int... 
Transforming C_long_boolean_short... 
Transforming C_short_char_float... 
Transforming C_float_double... 
Transforming C_int_short_char... 
Transforming C_byte_int_char... 
Transforming C_long_boolean... 
Abc finished on Thu Jun 24 08:26:00 BST 2004. ( 1 min. 37 sec. )
PASS: Resolving extended classes with array parameters()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 98 seconds
Passed. Current status: 13 failed (check: 0), 91 passed (check: 0), 0 skipped.
Executing test 105 (pureJava): Assignments as second arguments in ternary operators.
================================================
Breakdown of abc phases  (total: 7230 millisec.)
------------------------------------------------
[ 00.512% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 78.008% ] Polyglot phases:  5640
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.456% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 06.515% ] Intertype Adjuster:  471
[ 06.653% ] Retrieving bodies:  481
[ 00.000% ] Weave Initializers:  0
[ 00.318% ] Load shadow types:  23
[ 02.006% ] Compute advice lists:  145
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.180% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.517% ] Soot Packs:  182
[ 02.586% ] Soot Writing Output:  187
================================================
Abc started on Thu Jun 24 08:26:03 BST 2004
<<<< TernaryAssignments.java >>>>
public class TernaryAssignments {
    public static void main(java.lang.String[] args) {
        new TernaryAssignments().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        boolean t = true;
        java.lang.String v =
          v =
          (v = (v = (v = (v = (v = (v = (v = (v = "s"))))))));
        java.lang.String s = t ? s = "s" : "unset";
        org.aspectj.testing.Tester.checkEqual(s, "s");
    }
    
    public TernaryAssignments() { super(); }
}
retrieve <TernaryAssignments: void main(java.lang.String[])> from TernaryAssignments
retrieve <TernaryAssignments: void realMain(java.lang.String[])> from TernaryAssignments
retrieve <TernaryAssignments: void <init>()> from TernaryAssignments
Transforming TernaryAssignments... 
Abc finished on Thu Jun 24 08:26:11 BST 2004. ( 0 min. 7 sec. )
PASS: Assignments as second arguments in ternary operators.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 13 failed (check: 0), 92 passed (check: 0), 0 skipped.
Executing test 106 (pureJava): Using 'aspect' as identifier is legal TODO
Failed. Current status: 14 failed (check: 0), 92 passed (check: 0), 0 skipped.
Executing test 107 (pureJava): Using 'pointcut' as identifier is legal TODO
Failed. Current status: 15 failed (check: 0), 92 passed (check: 0), 0 skipped.
Executing test 108 (pureJava): Conflicting inner classes with interfaces.
================================================
Breakdown of abc phases  (total: 7314 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  38
[ 00.055% ] Loading Jars:  4
[ 76.401% ] Polyglot phases:  5588
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.656% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.547% ] Intertype Adjuster:  40
[ 12.155% ] Retrieving bodies:  889
[ 00.014% ] Weave Initializers:  1
[ 00.301% ] Load shadow types:  22
[ 01.518% ] Compute advice lists:  111
[ 00.041% ] Intertype weave:  3
[ 00.109% ] Add aspect code:  8
[ 00.219% ] Weaving advice:  16
[ 00.000% ] Validate jimple:  0
[ 03.842% ] Soot Packs:  281
[ 03.596% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 08:26:21 BST 2004
<<<< PR413.java >>>>
public class PR413 {
    public static void main(java.lang.String[] args) {
        new PR413().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {  }
    
    public PR413() { super(); }
}
interface Interface {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    int field = 2;
}
abstract class Abstract {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    public static double field = 3.14;
    
    public Abstract() { super(); }
}
abstract class AbstractConflictingClass extends Abstract implements Interface {
    public AbstractConflictingClass() { super(); }
}
class NonAbstractConflictingClass extends Abstract implements Interface {
    public NonAbstractConflictingClass() { super(); }
}
class NonAbstractClass implements Interface {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    public NonAbstractClass() { super(); }
}
class NonAbstractExtendingClass extends Abstract {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    public NonAbstractExtendingClass() { super(); }
}
abstract class AbstractConflictingClassThatRedefinesInnerClass extends Abstract implements Interface {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    public AbstractConflictingClassThatRedefinesInnerClass() {
        super();
    }
}
class NonAbstractConflictingClassThatRedefinesInnerClass extends Abstract implements Interface {
    public static class InnerClass {
        public InnerClass() { super(); }
    }
    
    
    public NonAbstractConflictingClassThatRedefinesInnerClass() {
        super();
    }
}
retrieve <PR413: void <init>()> from PR413
retrieve <PR413: void main(java.lang.String[])> from PR413
retrieve <PR413: void realMain(java.lang.String[])> from PR413
retrieve <Interface: void <clinit>()> from Interface
retrieve <Interface$InnerClass: void <init>()> from Interface$InnerClass
retrieve <Abstract: void <init>()> from Abstract
retrieve <Abstract: void <clinit>()> from Abstract
retrieve <Abstract$InnerClass: void <init>()> from Abstract$InnerClass
retrieve <AbstractConflictingClass: void <init>()> from AbstractConflictingClass
retrieve <NonAbstractConflictingClass: void <init>()> from NonAbstractConflictingClass
retrieve <NonAbstractClass: void <init>()> from NonAbstractClass
retrieve <NonAbstractClass$InnerClass: void <init>()> from NonAbstractClass$InnerClass
retrieve <NonAbstractExtendingClass: void <init>()> from NonAbstractExtendingClass
retrieve <NonAbstractExtendingClass$InnerClass: void <init>()> from NonAbstractExtendingClass$InnerClass
retrieve <AbstractConflictingClassThatRedefinesInnerClass: void <init>()> from AbstractConflictingClassThatRedefinesInnerClass
retrieve <AbstractConflictingClassThatRedefinesInnerClass$InnerClass: void <init>()> from AbstractConflictingClassThatRedefinesInnerClass$InnerClass
retrieve <NonAbstractConflictingClassThatRedefinesInnerClass: void <init>()> from NonAbstractConflictingClassThatRedefinesInnerClass
retrieve <NonAbstractConflictingClassThatRedefinesInnerClass$InnerClass: void <init>()> from NonAbstractConflictingClassThatRedefinesInnerClass$InnerClass
Transforming AbstractConflictingClassThatRedefinesInnerClass... 
Transforming Abstract... 
Transforming Abstract$InnerClass... 
Transforming NonAbstractConflictingClassThatRedefinesInnerClass... 
Transforming NonAbstractConflictingClassThatRedefinesInnerClass$InnerClass... 
Transforming Interface... 
Transforming NonAbstractClass... 
Transforming NonAbstractExtendingClass... 
Transforming NonAbstractExtendingClass$InnerClass... 
Transforming AbstractConflictingClass... 
Transforming NonAbstractConflictingClass... 
Transforming PR413... 
Transforming Interface$InnerClass... 
Transforming NonAbstractClass$InnerClass... 
Transforming AbstractConflictingClassThatRedefinesInnerClass$InnerClass... 
Abc finished on Thu Jun 24 08:26:28 BST 2004. ( 0 min. 7 sec. )
PASS: Conflicting inner classes with interfaces.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 15 failed (check: 0), 93 passed (check: 0), 0 skipped.
Executing test 109 (new): Not binding constructor when using more than one compilation
================================================
Breakdown of abc phases  (total: 7166 millisec.)
------------------------------------------------
[ 00.530% ] Init. of Soot:  38
[ 00.056% ] Loading Jars:  4
[ 77.951% ] Polyglot phases:  5586
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.474% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.893% ] Intertype Adjuster:  64
[ 12.266% ] Retrieving bodies:  879
[ 00.000% ] Weave Initializers:  0
[ 00.321% ] Load shadow types:  23
[ 01.772% ] Compute advice lists:  127
[ 00.042% ] Intertype weave:  3
[ 00.126% ] Add aspect code:  9
[ 00.349% ] Weaving advice:  25
[ 00.000% ] Validate jimple:  0
[ 02.428% ] Soot Packs:  174
[ 02.763% ] Soot Writing Output:  198
================================================
Failed. Current status: 16 failed (check: 0), 93 passed (check: 0), 0 skipped.
Executing test 110 (pureJava): confusions of casts and parens
================================================
Breakdown of abc phases  (total: 6783 millisec.)
------------------------------------------------
[ 00.560% ] Init. of Soot:  38
[ 00.044% ] Loading Jars:  3
[ 78.785% ] Polyglot phases:  5344
[ 00.015% ] Resolve class names:  1
[ 00.015% ] Declare Parents:  1
[ 00.472% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 00.929% ] Intertype Adjuster:  63
[ 12.723% ] Retrieving bodies:  863
[ 00.000% ] Weave Initializers:  0
[ 00.324% ] Load shadow types:  22
[ 00.708% ] Compute advice lists:  48
[ 00.044% ] Intertype weave:  3
[ 00.133% ] Add aspect code:  9
[ 00.177% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.565% ] Soot Packs:  174
[ 02.506% ] Soot Writing Output:  170
================================================
Abc started on Thu Jun 24 08:26:40 BST 2004
<<<< CastVsParen.java >>>>
import org.aspectj.testing.Tester;

public class CastVsParen {
    public static void main(java.lang.String[] args) {
        int N = 1;
        boolean T = true;
        int i = N;
        i = N;
        i = (T ? N : 2);
    }
    
    public CastVsParen() { super(); }
}
retrieve <CastVsParen: void main(java.lang.String[])> from CastVsParen
retrieve <CastVsParen: void <init>()> from CastVsParen
Transforming CastVsParen... 
Abc finished on Thu Jun 24 08:26:47 BST 2004. ( 0 min. 6 sec. )
PASS: confusions of casts and parens()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 16 failed (check: 0), 94 passed (check: 0), 0 skipped.
Executing test 111 (pureJava): default constructors seen by inner classes subtyping outers
================================================
Breakdown of abc phases  (total: 7132 millisec.)
------------------------------------------------
[ 00.533% ] Init. of Soot:  38
[ 00.056% ] Loading Jars:  4
[ 77.440% ] Polyglot phases:  5523
[ 00.000% ] Resolve class names:  0
[ 00.042% ] Declare Parents:  3
[ 00.687% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.533% ] Intertype Adjuster:  38
[ 12.633% ] Retrieving bodies:  901
[ 00.000% ] Weave Initializers:  0
[ 00.322% ] Load shadow types:  23
[ 01.795% ] Compute advice lists:  128
[ 00.042% ] Intertype weave:  3
[ 00.112% ] Add aspect code:  8
[ 00.322% ] Weaving advice:  23
[ 00.000% ] Validate jimple:  0
[ 02.622% ] Soot Packs:  187
[ 02.860% ] Soot Writing Output:  204
================================================
Abc started on Thu Jun 24 08:26:50 BST 2004
<<<< DefaultConsAndInner.java >>>>
import org.aspectj.testing.Tester;

public class DefaultConsAndInner {
    public static void main(java.lang.String[] args) {
        new Outer.Inner("test");
        org.aspectj.testing.Tester.check("test");
    }
    
    public DefaultConsAndInner() { super(); }
}
class Outer {
    static class Inner extends Outer {
        public Inner(java.lang.String s) {
            super();
            org.aspectj.testing.Tester.note(s);
        }
    }
    
    
    public Outer() { super(); }
}
retrieve <DefaultConsAndInner: void main(java.lang.String[])> from DefaultConsAndInner
retrieve <DefaultConsAndInner: void <init>()> from DefaultConsAndInner
retrieve <Outer: void <init>()> from Outer
retrieve <Outer$Inner: void <init>(java.lang.String)> from Outer$Inner
Transforming DefaultConsAndInner... 
Transforming Outer... 
Transforming Outer$Inner... 
Abc finished on Thu Jun 24 08:26:57 BST 2004. ( 0 min. 7 sec. )
PASS: default constructors seen by inner classes subtyping outers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 16 failed (check: 0), 95 passed (check: 0), 0 skipped.
Executing test 112 (pureJava): folding fields set to anonymous instances containing self-references
================================================
Breakdown of abc phases  (total: 7612 millisec.)
------------------------------------------------
[ 00.486% ] Init. of Soot:  37
[ 00.053% ] Loading Jars:  4
[ 77.969% ] Polyglot phases:  5935
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.696% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 06.266% ] Intertype Adjuster:  477
[ 06.293% ] Retrieving bodies:  479
[ 00.000% ] Weave Initializers:  0
[ 00.289% ] Load shadow types:  22
[ 02.312% ] Compute advice lists:  176
[ 00.039% ] Intertype weave:  3
[ 00.105% ] Add aspect code:  8
[ 00.171% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.759% ] Soot Packs:  210
[ 02.535% ] Soot Writing Output:  193
================================================
Abc started on Thu Jun 24 08:27:00 BST 2004
<<<< AnonFolding.java >>>>
import org.aspectj.testing.Tester;

public class AnonFolding {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(AnonFolding/*AnonFolding*/.ANON.toString(),
                                              "ANON");
    }
    
    public static java.lang.Object ANON =
      new java.lang.Object() {
        public Object m() { return ANON; }
        
        public String toString() {
            Tester.checkEqual(ANON, m(), "reference to itself");
            return "ANON";
        }
    };
    
    public AnonFolding() { super(); }
}
retrieve <AnonFolding: void main(java.lang.String[])> from AnonFolding
retrieve <AnonFolding: void <init>()> from AnonFolding
retrieve <AnonFolding: void <clinit>()> from AnonFolding
retrieve <AnonFolding$1: void <init>()> from AnonFolding$1
retrieve <AnonFolding$1: java.lang.String toString()> from AnonFolding$1
retrieve <AnonFolding$1: java.lang.Object m()> from AnonFolding$1
Transforming AnonFolding... 
Transforming AnonFolding$1... 
Abc finished on Thu Jun 24 08:27:07 BST 2004. ( 0 min. 7 sec. )
PASS: folding fields set to anonymous instances containing self-references()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 16 failed (check: 0), 96 passed (check: 0), 0 skipped.
Executing test 113 (pureJava): finally at the end of a method that needs to return
================================================
Breakdown of abc phases  (total: 7328 millisec.)
------------------------------------------------
[ 00.532% ] Init. of Soot:  39
[ 00.041% ] Loading Jars:  3
[ 75.791% ] Polyglot phases:  5554
[ 00.014% ] Resolve class names:  1
[ 00.014% ] Declare Parents:  1
[ 00.710% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.532% ] Intertype Adjuster:  39
[ 13.360% ] Retrieving bodies:  979
[ 00.000% ] Weave Initializers:  0
[ 00.300% ] Load shadow types:  22
[ 03.002% ] Compute advice lists:  220
[ 00.041% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  9
[ 00.164% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.675% ] Soot Packs:  196
[ 02.702% ] Soot Writing Output:  198
================================================
Failed. Current status: 17 failed (check: 0), 96 passed (check: 0), 0 skipped.
Executing test 114 (pureJava): return;;; is not really legal
Abc started on Thu Jun 24 08:27:20 BST 2004
<<<< ReachableEmpty.java >>>>
public class ReachableEmpty {
    public static void main(java.lang.String[] args) {  }
    
    public void m() {
        return;
        ;
    }
    
    public int m1() {
        return 2;
        ;
    }
    
    public void m2() {
        throw new java.lang.Error();
        ;
    }
    
    public void m3() {
        return;
        ;
        ;
        ;
        ;
        ;
    }
    
    public ReachableEmpty() { super(); }
}
PASS: return;;; is not really legal()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 17 failed (check: 0), 97 passed (check: 1), 0 skipped.
Executing test 115 (new): ajc treating Throwable as checked, issuing error if not found
================================================
Breakdown of abc phases  (total: 7267 millisec.)
------------------------------------------------
[ 00.523% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 76.152% ] Polyglot phases:  5534
[ 00.014% ] Resolve class names:  1
[ 00.028% ] Declare Parents:  2
[ 00.757% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.550% ] Intertype Adjuster:  40
[ 13.431% ] Retrieving bodies:  976
[ 00.000% ] Weave Initializers:  0
[ 00.316% ] Load shadow types:  23
[ 02.656% ] Compute advice lists:  193
[ 00.041% ] Intertype weave:  3
[ 00.110% ] Add aspect code:  8
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.477% ] Soot Packs:  180
[ 02.725% ] Soot Writing Output:  198
================================================
Abc started on Thu Jun 24 08:27:24 BST 2004
<<<< FalseThrowsCE.java >>>>
import org.aspectj.testing.Tester;

public class FalseThrowsCE {
    public static void main(java.lang.String[] args) {
        try {
            java.lang.System.getProperty("").toString();
        }
        catch (java.lang.Throwable e) {
            java.lang.String s = "got " + e;
        }
        org.aspectj.testing.Tester.check(true,
                                         "ok - compiled without error");
    }
    
    public FalseThrowsCE() { super(); }
}
retrieve <FalseThrowsCE: void main(java.lang.String[])> from FalseThrowsCE
retrieve <FalseThrowsCE: void <init>()> from FalseThrowsCE
Transforming FalseThrowsCE... 
Abc finished on Thu Jun 24 08:27:31 BST 2004. ( 0 min. 7 sec. )
PASS: ajc treating Throwable as checked, issuing error if not found()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 98 passed (check: 1), 0 skipped.
Executing test 116 (pureJava): overriding methods from object in interfaces and multiple-inheritance
================================================
Breakdown of abc phases  (total: 13053 millisec.)
------------------------------------------------
[ 00.291% ] Init. of Soot:  38
[ 00.023% ] Loading Jars:  3
[ 83.498% ] Polyglot phases:  10899
[ 00.000% ] Resolve class names:  0
[ 00.015% ] Declare Parents:  2
[ 00.743% ] Recompute name pattern matches:  97
[ 00.000% ] Compute precedence relation:  0
[ 06.757% ] Intertype Adjuster:  882
[ 03.578% ] Retrieving bodies:  467
[ 00.000% ] Weave Initializers:  0
[ 00.176% ] Load shadow types:  23
[ 01.218% ] Compute advice lists:  159
[ 00.031% ] Intertype weave:  4
[ 00.061% ] Add aspect code:  8
[ 00.107% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 01.724% ] Soot Packs:  225
[ 01.777% ] Soot Writing Output:  232
================================================
Abc started on Thu Jun 24 08:27:34 BST 2004
<<<< InterfaceAndObject.java >>>>
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.FontUIResource;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.util.EventObject;
import java.util.Vector;

public class InterfaceAndObject {
    javax.swing.Timer t = null;
    
    public static void main(java.lang.String[] args) {
        I i = new I() {};
        java.lang.System/*java.lang.System*/.out.println(i);
    }
    
    public InterfaceAndObject() { super(); }
}
class Root {
    public java.lang.String toString() { return "root"; }
    
    public Root() { super(); }
}
class C extends Root implements I {
    public C() { super(); }
}
class C1 extends Root implements I1 {
    public java.lang.Object clone() { return null; }
    
    public C1() { super(); }
}
interface I0 {
    public abstract java.lang.Object clone();
}
interface I {
    public abstract boolean equals(java.lang.Object o);
}
interface I1 extends I, I0 {}
retrieve <InterfaceAndObject: void main(java.lang.String[])> from InterfaceAndObject
retrieve <InterfaceAndObject: void <init>()> from InterfaceAndObject
retrieve <InterfaceAndObject$1: void <init>()> from InterfaceAndObject$1
retrieve <Root: java.lang.String toString()> from Root
retrieve <Root: void <init>()> from Root
retrieve <C: void <init>()> from C
retrieve <C1: java.lang.Object clone()> from C1
retrieve <C1: void <init>()> from C1
Transforming I... 
Transforming C1... 
Transforming I0... 
Transforming InterfaceAndObject... 
Transforming InterfaceAndObject$1... 
Transforming I1... 
Transforming Root... 
Transforming C... 
Abc finished on Thu Jun 24 08:27:47 BST 2004. ( 0 min. 13 sec. )
InterfaceAndObject$1@df46a
PASS: overriding methods from object in interfaces and multiple-inheritance()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 17 failed (check: 0), 99 passed (check: 1), 0 skipped.
Executing test 117 (pureJava): private fields in an outer class accessed by an inner which also extends the outer
================================================
Breakdown of abc phases  (total: 6959 millisec.)
------------------------------------------------
[ 00.546% ] Init. of Soot:  38
[ 00.057% ] Loading Jars:  4
[ 77.813% ] Polyglot phases:  5415
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.445% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.877% ] Intertype Adjuster:  61
[ 12.401% ] Retrieving bodies:  863
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  23
[ 01.365% ] Compute advice lists:  95
[ 00.043% ] Intertype weave:  3
[ 00.129% ] Add aspect code:  9
[ 00.187% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.860% ] Soot Packs:  199
[ 02.917% ] Soot Writing Output:  203
================================================
Abc started on Thu Jun 24 08:27:49 BST 2004
<<<< PrivateFields.java >>>>
public class PrivateFields {
    public static void main(java.lang.String[] args) {  }
    
    public PrivateFields() { super(); }
}
class Outer {
    private static int one = 1;
    
    static class Inner extends Outer {
        private static int two = 2;
        
        int m() { return Outer/*Outer*/.one; }
        
        public Inner() { super(); }
    }
    
    
    public Outer() { super(); }
}
retrieve <PrivateFields: void main(java.lang.String[])> from PrivateFields
retrieve <PrivateFields: void <init>()> from PrivateFields
retrieve <Outer: void <init>()> from Outer
retrieve <Outer: int access$000()> from Outer
retrieve <Outer: void <clinit>()> from Outer
retrieve <Outer$Inner: void <init>()> from Outer$Inner
retrieve <Outer$Inner: void <clinit>()> from Outer$Inner
retrieve <Outer$Inner: int m()> from Outer$Inner
Transforming PrivateFields... 
Transforming Outer... 
Transforming Outer$Inner... 
Abc finished on Thu Jun 24 08:27:56 BST 2004. ( 0 min. 7 sec. )
PASS: private fields in an outer class accessed by an inner which also extends...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 100 passed (check: 1), 0 skipped.
Executing test 118 (pureJava): breaking out of a labeled block inside of an if
================================================
Breakdown of abc phases  (total: 7734 millisec.)
------------------------------------------------
[ 00.504% ] Init. of Soot:  39
[ 00.052% ] Loading Jars:  4
[ 77.786% ] Polyglot phases:  6016
[ 00.013% ] Resolve class names:  1
[ 00.013% ] Declare Parents:  1
[ 00.763% ] Recompute name pattern matches:  59
[ 00.013% ] Compute precedence relation:  1
[ 06.103% ] Intertype Adjuster:  472
[ 06.504% ] Retrieving bodies:  503
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  23
[ 02.444% ] Compute advice lists:  189
[ 00.039% ] Intertype weave:  3
[ 00.116% ] Add aspect code:  9
[ 00.155% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.521% ] Soot Packs:  195
[ 02.676% ] Soot Writing Output:  207
================================================
Abc started on Thu Jun 24 08:27:59 BST 2004
<<<< Breaks.java >>>>
import org.aspectj.testing.Tester;

public class Breaks {
    static boolean sawTrue;
    
    static boolean sawFalse;
    
    public static void main(java.lang.String[] args) {
        m(true);
        org.aspectj.testing.Tester.check(Breaks/*Breaks*/.sawTrue,
                                         "true");
        org.aspectj.testing.Tester.check(!Breaks/*Breaks*/.sawFalse,
                                         "!false");
    }
    
    static void m(boolean t) {
        BLOCK: {
            if (t) {
                Breaks/*Breaks*/.sawTrue = true;
                java.lang.System/*java.lang.System*/.out.println("true");
                break BLOCK;
            } else {
                Breaks/*Breaks*/.sawFalse = true;
                java.lang.System/*java.lang.System*/.out.println("false");
            }
        }
    }
    
    static int m1(boolean t) {
        loop: while (true) { if (t) break loop; }
        return 1;
    }
    
    static int m2(boolean t) {
        while (true) { if (t) break; }
        return 1;
    }
    
    public Breaks() { super(); }
}
retrieve <Breaks: void main(java.lang.String[])> from Breaks
retrieve <Breaks: void m(boolean)> from Breaks
retrieve <Breaks: int m1(boolean)> from Breaks
retrieve <Breaks: int m2(boolean)> from Breaks
retrieve <Breaks: void <init>()> from Breaks
Transforming Breaks... 
Abc finished on Thu Jun 24 08:28:07 BST 2004. ( 0 min. 7 sec. )
true
PASS: breaking out of a labeled block inside of an if()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 17 failed (check: 0), 101 passed (check: 1), 0 skipped.
Executing test 119 (pureJava): abstractifying a method and getting it back through super
================================================
Breakdown of abc phases  (total: 7366 millisec.)
------------------------------------------------
[ 00.516% ] Init. of Soot:  38
[ 00.054% ] Loading Jars:  4
[ 76.473% ] Polyglot phases:  5633
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.652% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.529% ] Intertype Adjuster:  39
[ 12.381% ] Retrieving bodies:  912
[ 00.000% ] Weave Initializers:  0
[ 00.312% ] Load shadow types:  23
[ 02.973% ] Compute advice lists:  219
[ 00.041% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  9
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.769% ] Soot Packs:  204
[ 02.973% ] Soot Writing Output:  219
================================================
Abc started on Thu Jun 24 08:28:09 BST 2004
<<<< Abstracts.java >>>>
import org.aspectj.testing.Tester;

public class Abstracts {
    static java.lang.StringBuffer log = new java.lang.StringBuffer();
    
    public static void main(java.lang.String[] args) {
        new D().m();
        org.aspectj.testing.Tester.checkEqual(Abstracts/*Abstracts*/.log.toString(),
                                              "D.m(), A.m(), A.m(), ");
    }
    
    public void m() { Abstracts/*Abstracts*/.log.append("A.m(), "); }
    
    public Abstracts() { super(); }
}
abstract class C extends Abstracts {
    public abstract void m();
    
    public void n() { super.m(); }
    
    public C() { super(); }
}
class D extends C {
    public void m() {
        Abstracts/*Abstracts*/.log.append("D.m(), ");
        super.n();
        n();
    }
    
    public D() { super(); }
}
retrieve <Abstracts: void m()> from Abstracts
retrieve <Abstracts: void <init>()> from Abstracts
retrieve <Abstracts: void main(java.lang.String[])> from Abstracts
retrieve <Abstracts: void <clinit>()> from Abstracts
retrieve <C: void <init>()> from C
retrieve <C: void n()> from C
retrieve <D: void m()> from D
retrieve <D: void <init>()> from D
Transforming D... 
Transforming Abstracts... 
Transforming C... 
Abc finished on Thu Jun 24 08:28:17 BST 2004. ( 0 min. 7 sec. )
PASS: abstractifying a method and getting it back through super()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 102 passed (check: 1), 0 skipped.
Executing test 120 (new): package protected classes becoming public
================================================
Breakdown of abc phases  (total: 7254 millisec.)
------------------------------------------------
[ 00.524% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 80.397% ] Polyglot phases:  5832
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.469% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.882% ] Intertype Adjuster:  64
[ 07.927% ] Retrieving bodies:  575
[ 00.000% ] Weave Initializers:  0
[ 00.317% ] Load shadow types:  23
[ 03.143% ] Compute advice lists:  228
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.936% ] Soot Packs:  213
[ 02.991% ] Soot Writing Output:  217
================================================
Abc started on Thu Jun 24 08:28:19 BST 2004
<<<< PR328.java >>>>
import java.lang.reflect.*;

public class PR328 {
    public static void main(java.lang.String[] args) {
        new PR328().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        try {
            java.lang.Class modest =
              java.lang.Class.forName("Modest");
            int modifiers = modest.getModifiers();
            boolean isPublic =
              (modifiers &
               java.lang.reflect.Modifier/*java.lang.reflect.Modifier*/.PUBLIC) !=
            0;
            org.aspectj.testing.Tester.check(!isPublic,
                                             "Modest shouldn\'t be public");
        }
        catch (java.lang.Throwable t) {
            org.aspectj.testing.Tester.check(false, "Thrown: " + t);
        }
    }
    
    public PR328() { super(); }
}
class Modest {
    public Modest() { super(); }
}
retrieve <PR328: void main(java.lang.String[])> from PR328
retrieve <PR328: void realMain(java.lang.String[])> from PR328
retrieve <PR328: void <init>()> from PR328
retrieve <Modest: void <init>()> from Modest
Transforming PR328... 
Transforming Modest... 
Abc finished on Thu Jun 24 08:28:27 BST 2004. ( 0 min. 7 sec. )
PASS: package protected classes becoming public()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 103 passed (check: 1), 0 skipped.
Executing test 121 (pureJava): Packages and static classes with the same name produce compile errors.
================================================
Breakdown of abc phases  (total: 7291 millisec.)
------------------------------------------------
[ 00.507% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 80.400% ] Polyglot phases:  5862
[ 00.014% ] Resolve class names:  1
[ 00.027% ] Declare Parents:  2
[ 00.453% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.549% ] Intertype Adjuster:  40
[ 07.214% ] Retrieving bodies:  526
[ 00.000% ] Weave Initializers:  0
[ 00.329% ] Load shadow types:  24
[ 03.909% ] Compute advice lists:  285
[ 00.041% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.004% ] Soot Packs:  219
[ 03.196% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 08:28:29 BST 2004
<<<< PackagesAndStaticClassesWithTheSameName.java >>>>
import org.aspectj.testing.*;

public class PackagesAndStaticClassesWithTheSameName {
    public static void main(java.lang.String[] args) {
        java.lang.String string = "string";
        PackagesAndStaticClassesWithTheSameName.java.lang.Str str =
          new PackagesAndStaticClassesWithTheSameName.java.lang.Str(string);
        org.aspectj.testing.Tester.checkEqual(string + ":" +
                                              string,
                                              str +
                                              "");
    }
    
    static class java {
        static class lang {
            static class Str {
                private java.lang.String str;
                
                Str(java.lang.String str) {
                    super();
                    this/*<unknown>*/.str = str;
                }
                
                public java.lang.String toString() {
                    return this/*null*/.str + ":" + this/*null*/.str;
                }
            }
            
            
            public lang() { super(); }
        }
        
        
        public java() { super(); }
    }
    
    
    public PackagesAndStaticClassesWithTheSameName() { super(); }
}
retrieve <PackagesAndStaticClassesWithTheSameName: void main(java.lang.String[])> from PackagesAndStaticClassesWithTheSameName
retrieve <PackagesAndStaticClassesWithTheSameName: void <init>()> from PackagesAndStaticClassesWithTheSameName
retrieve <PackagesAndStaticClassesWithTheSameName$java: void <init>()> from PackagesAndStaticClassesWithTheSameName$java
retrieve <PackagesAndStaticClassesWithTheSameName$java$lang: void <init>()> from PackagesAndStaticClassesWithTheSameName$java$lang
retrieve <PackagesAndStaticClassesWithTheSameName$java$lang$Str: void <init>(java.lang.String)> from PackagesAndStaticClassesWithTheSameName$java$lang$Str
retrieve <PackagesAndStaticClassesWithTheSameName$java$lang$Str: java.lang.String toString()> from PackagesAndStaticClassesWithTheSameName$java$lang$Str
Transforming PackagesAndStaticClassesWithTheSameName... 
Transforming PackagesAndStaticClassesWithTheSameName$java... 
Transforming PackagesAndStaticClassesWithTheSameName$java$lang... 
Transforming PackagesAndStaticClassesWithTheSameName$java$lang$Str... 
Abc finished on Thu Jun 24 08:28:37 BST 2004. ( 0 min. 7 sec. )
PASS: Packages and static classes with the same name produce compile errors.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 104 passed (check: 1), 0 skipped.
Executing test 122 (pureJava/innerTypeModifiers): Inner types must generate classfiles with only Public/Default access flags.
================================================
Breakdown of abc phases  (total: 6983 millisec.)
------------------------------------------------
[ 00.530% ] Init. of Soot:  37
[ 00.057% ] Loading Jars:  4
[ 78.863% ] Polyglot phases:  5507
[ 00.014% ] Resolve class names:  1
[ 00.014% ] Declare Parents:  1
[ 00.444% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.888% ] Intertype Adjuster:  62
[ 12.215% ] Retrieving bodies:  853
[ 00.000% ] Weave Initializers:  0
[ 00.315% ] Load shadow types:  22
[ 00.816% ] Compute advice lists:  57
[ 00.057% ] Intertype weave:  4
[ 00.115% ] Add aspect code:  8
[ 00.200% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.678% ] Soot Packs:  187
[ 02.792% ] Soot Writing Output:  195
================================================
Abc started on Thu Jun 24 08:28:39 BST 2004
<<<< Main.java >>>>
package pkg1;

public class Main extends pkg2.Foo {
    static class Noo extends pkg2.Foo.Goo {
        public Noo() { super(); }
    }
    
    
    public static void main(java.lang.String[] args) {
        new pkg1.Main.Noo();
    }
    
    public Main() { super(); }
}
<<<< Foo.java >>>>
package pkg2;

public class Foo {
    protected static class Goo {
        public Goo() { super(); }
    }
    
    
    public Foo() { super(); }
}
retrieve <pkg1.Main: void main(java.lang.String[])> from pkg1.Main
retrieve <pkg1.Main: void <init>()> from pkg1.Main
retrieve <pkg1.Main$Noo: void <init>()> from pkg1.Main$Noo
retrieve <pkg2.Foo: void <init>()> from pkg2.Foo
retrieve <pkg2.Foo$Goo: void <init>()> from pkg2.Foo$Goo
Transforming pkg1.Main... 
Transforming pkg2.Foo... 
Transforming pkg1.Main$Noo... 
Transforming pkg2.Foo$Goo... 
Abc finished on Thu Jun 24 08:28:46 BST 2004. ( 0 min. 7 sec. )
PASS: Inner types must generate classfiles with only Public/Default access fla...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 17 failed (check: 0), 105 passed (check: 1), 0 skipped.
Executing test 123 (pureJava/innerDefaultConstructors): Default constructors have same access as their enclosing type
================================================
Breakdown of abc phases  (total: 6889 millisec.)
------------------------------------------------
[ 00.639% ] Init. of Soot:  44
[ 00.073% ] Loading Jars:  5
[ 78.778% ] Polyglot phases:  5427
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.697% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.566% ] Intertype Adjuster:  39
[ 12.440% ] Retrieving bodies:  857
[ 00.000% ] Weave Initializers:  0
[ 00.334% ] Load shadow types:  23
[ 00.798% ] Compute advice lists:  55
[ 00.044% ] Intertype weave:  3
[ 00.116% ] Add aspect code:  8
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.526% ] Soot Packs:  174
[ 02.773% ] Soot Writing Output:  191
================================================
Failed. Current status: 18 failed (check: 1), 105 passed (check: 1), 0 skipped.
Executing test 124 (pureJava): Returning primitive values matching method return type (minimal)
================================================
Breakdown of abc phases  (total: 7459 millisec.)
------------------------------------------------
[ 00.509% ] Init. of Soot:  38
[ 00.054% ] Loading Jars:  4
[ 78.509% ] Polyglot phases:  5856
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.456% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 06.516% ] Intertype Adjuster:  486
[ 06.475% ] Retrieving bodies:  483
[ 00.000% ] Weave Initializers:  0
[ 00.308% ] Load shadow types:  23
[ 01.850% ] Compute advice lists:  138
[ 00.054% ] Intertype weave:  4
[ 00.107% ] Add aspect code:  8
[ 00.174% ] Weaving advice:  13
[ 00.013% ] Validate jimple:  1
[ 02.494% ] Soot Packs:  186
[ 02.453% ] Soot Writing Output:  183
================================================
Abc started on Thu Jun 24 08:28:58 BST 2004
<<<< ReturnTypes.java >>>>
import org.aspectj.testing.Tester;

public class ReturnTypes {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(convertDouble("2") ==
                                         0.0,
                                         "return types");
    }
    
    static double convertDouble(java.lang.Object o) { return 0; }
    
    public ReturnTypes() { super(); }
}
retrieve <ReturnTypes: void main(java.lang.String[])> from ReturnTypes
retrieve <ReturnTypes: double convertDouble(java.lang.Object)> from ReturnTypes
retrieve <ReturnTypes: void <init>()> from ReturnTypes
Transforming ReturnTypes... 
Abc finished on Thu Jun 24 08:29:06 BST 2004. ( 0 min. 7 sec. )
PASS: Returning primitive values matching method return type (minimal)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 18 failed (check: 1), 106 passed (check: 1), 0 skipped.
Executing test 125 (pureJava): Flow analysis and if(true)
================================================
Breakdown of abc phases  (total: 7119 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  37
[ 00.056% ] Loading Jars:  4
[ 77.413% ] Polyglot phases:  5511
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.660% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.562% ] Intertype Adjuster:  40
[ 12.811% ] Retrieving bodies:  912
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  22
[ 02.304% ] Compute advice lists:  164
[ 00.042% ] Intertype weave:  3
[ 00.126% ] Add aspect code:  9
[ 00.169% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.613% ] Soot Packs:  186
[ 02.388% ] Soot Writing Output:  170
================================================
Abc started on Thu Jun 24 08:29:08 BST 2004
<<<< Flow.java >>>>
import org.aspectj.testing.Tester;

public class Flow {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(m(), 42, "m()");
        org.aspectj.testing.Tester.checkEqual(n(), 42, "n()");
    }
    
    static int m() {
        if (true) return 42;
        return 3;
    }
    
    static int n() {
        { if (true) return 42; }
        return 4;
    }
    
    public Flow() { super(); }
}
retrieve <Flow: void main(java.lang.String[])> from Flow
retrieve <Flow: int m()> from Flow
retrieve <Flow: int n()> from Flow
retrieve <Flow: void <init>()> from Flow
Transforming Flow... 
Abc finished on Thu Jun 24 08:29:16 BST 2004. ( 0 min. 7 sec. )
PASS: Flow analysis and if(true)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 18 failed (check: 1), 107 passed (check: 1), 0 skipped.
Executing test 126 (pureJava): packages and generated inner types (for I.class)
Failed. Current status: 19 failed (check: 1), 107 passed (check: 1), 0 skipped.
Executing test 127 (pureJava): A.this exprs match by exact type matching
Failed. Current status: 20 failed (check: 2), 107 passed (check: 1), 0 skipped.
Executing test 128 (pureJava): Implicit this for new inner instance must be avaliable
Abc started on Thu Jun 24 08:29:37 BST 2004
<<<< ImplicitThisMissing.java >>>>
public class ImplicitThisMissing {
    class B {
        public B() { super(); }
    }
    
    
    public static void main(java.lang.String[] args) {
        this.new ImplicitThisMissing.B();
        java.lang.System/*java.lang.System*/.err.println("shouldn\'t compile!!!");
    }
    
    public ImplicitThisMissing() { super(); }
}
PASS: Implicit this for new inner instance must be avaliable()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 20 failed (check: 2), 108 passed (check: 2), 0 skipped.
Executing test 129 (pureJava): Inners can reference protected fields of their outer's super.
================================================
Breakdown of abc phases  (total: 6585 millisec.)
------------------------------------------------
[ 00.562% ] Init. of Soot:  37
[ 00.061% ] Loading Jars:  4
[ 80.896% ] Polyglot phases:  5327
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.744% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.592% ] Intertype Adjuster:  39
[ 07.502% ] Retrieving bodies:  494
[ 00.000% ] Weave Initializers:  0
[ 00.349% ] Load shadow types:  23
[ 02.339% ] Compute advice lists:  154
[ 00.046% ] Intertype weave:  3
[ 00.137% ] Add aspect code:  9
[ 00.182% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.219% ] Soot Packs:  212
[ 03.341% ] Soot Writing Output:  220
================================================
Failed. Current status: 21 failed (check: 2), 108 passed (check: 2), 0 skipped.
Executing test 130 (new): IOException on windows if nul used as identifier
Failed. Current status: 22 failed (check: 3), 108 passed (check: 2), 0 skipped.
Executing test 131 (new): NullPointerException (not compiler error) when extending non-static inner class
Abc started on Thu Jun 24 08:29:54 BST 2004
PASS: NullPointerException (not compiler error) when extending non-static inne...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 22 failed (check: 3), 109 passed (check: 3), 0 skipped.
Executing test 132 (new): compiler flags final static variable as indefinite in member assignment.
================================================
Breakdown of abc phases  (total: 7070 millisec.)
------------------------------------------------
[ 00.537% ] Init. of Soot:  38
[ 00.057% ] Loading Jars:  4
[ 78.798% ] Polyglot phases:  5571
[ 00.014% ] Resolve class names:  1
[ 00.014% ] Declare Parents:  1
[ 00.438% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.877% ] Intertype Adjuster:  62
[ 12.362% ] Retrieving bodies:  874
[ 00.000% ] Weave Initializers:  0
[ 00.339% ] Load shadow types:  24
[ 00.806% ] Compute advice lists:  57
[ 00.042% ] Intertype weave:  3
[ 00.127% ] Add aspect code:  9
[ 00.184% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.758% ] Soot Packs:  195
[ 02.645% ] Soot Writing Output:  187
================================================
Abc started on Thu Jun 24 08:29:57 BST 2004
<<<< DefiniteStatic.java >>>>
class Type {
    public Type() { super(); }
}
class bat {
    public static final Type SOURCE = new Type();
    
    public bat() { super(); }
}
public class DefiniteStatic {
    protected static final Type SINK = bat/*bat*/.SOURCE;
    
    public Type sink = DefiniteStatic/*DefiniteStatic*/.SINK;
    
    public static void main(java.lang.String[] args) {  }
    
    public DefiniteStatic() { super(); }
}
retrieve <Type: void <init>()> from Type
retrieve <bat: void <init>()> from bat
retrieve <bat: void <clinit>()> from bat
retrieve <DefiniteStatic: void <init>()> from DefiniteStatic
retrieve <DefiniteStatic: void <clinit>()> from DefiniteStatic
retrieve <DefiniteStatic: void main(java.lang.String[])> from DefiniteStatic
Transforming Type... 
Transforming bat... 
Transforming DefiniteStatic... 
Abc finished on Thu Jun 24 08:30:05 BST 2004. ( 0 min. 7 sec. )
PASS: compiler flags final static variable as indefinite in member assignment.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 22 failed (check: 3), 110 passed (check: 3), 0 skipped.
Executing test 133 (new): confirm no IOException on windows if nul used as identifier
================================================
Breakdown of abc phases  (total: 7256 millisec.)
------------------------------------------------
[ 00.524% ] Init. of Soot:  38
[ 00.055% ] Loading Jars:  4
[ 77.550% ] Polyglot phases:  5627
[ 00.014% ] Resolve class names:  1
[ 00.028% ] Declare Parents:  2
[ 00.730% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 06.533% ] Intertype Adjuster:  474
[ 06.629% ] Retrieving bodies:  481
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  22
[ 02.026% ] Compute advice lists:  147
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.536% ] Soot Packs:  184
[ 02.729% ] Soot Writing Output:  198
================================================
Abc started on Thu Jun 24 08:30:07 BST 2004
<<<< NulIOException2.java >>>>
import org.aspectj.testing.Tester;

class Super {
    Super(java.lang.Object o) { super(); }
}
public class NulIOException2 extends Super {
    public static void main(java.lang.String[] args) {
        java.lang.Object nul = new java.lang.Object();
        java.lang.Object p = new NulIOException2(nul);
        org.aspectj.testing.Tester.check(null != nul, "null nul");
        org.aspectj.testing.Tester.check(null !=
                                         p,
                                         "null NulIOException2");
    }
    
    NulIOException2(java.lang.Object o) { super(o); }
}
retrieve <Super: void <init>(java.lang.Object)> from Super
retrieve <NulIOException2: void main(java.lang.String[])> from NulIOException2
retrieve <NulIOException2: void <init>(java.lang.Object)> from NulIOException2
Transforming NulIOException2... 
Transforming Super... 
Abc finished on Thu Jun 24 08:30:14 BST 2004. ( 0 min. 7 sec. )
PASS: confirm no IOException on windows if nul used as identifier()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 22 failed (check: 3), 111 passed (check: 3), 0 skipped.
Executing test 134 (pureJava): Primitives that special case for a constant arm should work
================================================
Breakdown of abc phases  (total: 17939 millisec.)
------------------------------------------------
[ 00.212% ] Init. of Soot:  38
[ 00.017% ] Loading Jars:  3
[ 39.584% ] Polyglot phases:  7101
[ 00.006% ] Resolve class names:  1
[ 00.006% ] Declare Parents:  1
[ 02.821% ] Recompute name pattern matches:  506
[ 00.000% ] Compute precedence relation:  0
[ 02.553% ] Intertype Adjuster:  458
[ 06.979% ] Retrieving bodies:  1252
[ 00.000% ] Weave Initializers:  0
[ 00.128% ] Load shadow types:  23
[ 38.893% ] Compute advice lists:  6977
[ 00.022% ] Intertype weave:  4
[ 00.045% ] Add aspect code:  8
[ 00.078% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 04.532% ] Soot Packs:  813
[ 04.125% ] Soot Writing Output:  740
================================================
Failed. Current status: 23 failed (check: 3), 111 passed (check: 3), 0 skipped.
Executing test 135 (pureJava): Parenthesized true and false don't parse
================================================
Breakdown of abc phases  (total: 7185 millisec.)
------------------------------------------------
[ 00.543% ] Init. of Soot:  39
[ 00.042% ] Loading Jars:  3
[ 77.175% ] Polyglot phases:  5545
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.626% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 06.736% ] Intertype Adjuster:  484
[ 06.736% ] Retrieving bodies:  484
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  23
[ 02.352% ] Compute advice lists:  169
[ 00.056% ] Intertype weave:  4
[ 00.111% ] Add aspect code:  8
[ 00.181% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.714% ] Soot Packs:  195
[ 02.380% ] Soot Writing Output:  171
================================================
Abc started on Thu Jun 24 08:30:38 BST 2004
<<<< ParenKeywords.java >>>>
import org.aspectj.testing.Tester;

public class ParenKeywords {
    public static void main(java.lang.String[] args) {
        if (false || true) { new ParenKeywords().foo(); }
        org.aspectj.testing.Tester.checkEvents("foo");
    }
    
    void foo() {
        if (this == null) {
            java.lang.System/*java.lang.System*/.err.println("shouldn\'t happen");
        } else {
            org.aspectj.testing.Tester.event("foo");
        }
    }
    
    public ParenKeywords() { super(); }
}
retrieve <ParenKeywords: void main(java.lang.String[])> from ParenKeywords
retrieve <ParenKeywords: void foo()> from ParenKeywords
retrieve <ParenKeywords: void <init>()> from ParenKeywords
Transforming ParenKeywords... 
Abc finished on Thu Jun 24 08:30:45 BST 2004. ( 0 min. 7 sec. )
PASS: Parenthesized true and false don't parse()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 23 failed (check: 3), 112 passed (check: 3), 0 skipped.
Executing test 136 (pureJava): Field sets to public fields of private fields of enclosing types
================================================
Breakdown of abc phases  (total: 7155 millisec.)
------------------------------------------------
[ 00.545% ] Init. of Soot:  39
[ 00.056% ] Loading Jars:  4
[ 76.520% ] Polyglot phases:  5475
[ 00.014% ] Resolve class names:  1
[ 00.028% ] Declare Parents:  2
[ 00.419% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 06.513% ] Intertype Adjuster:  466
[ 06.695% ] Retrieving bodies:  479
[ 00.000% ] Weave Initializers:  0
[ 00.321% ] Load shadow types:  23
[ 02.320% ] Compute advice lists:  166
[ 00.042% ] Intertype weave:  3
[ 00.112% ] Add aspect code:  8
[ 00.182% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.145% ] Soot Packs:  225
[ 03.089% ] Soot Writing Output:  221
================================================
Abc started on Thu Jun 24 08:30:47 BST 2004
<<<< InnerFieldRef.java >>>>
public class InnerFieldRef {
    private Foo foo = new Foo();
    
    private static int x;
    
    public static void main(java.lang.String[] args) {
        new InnerFieldRef().new Inner().m();
    }
    
    private class Inner {
        public void m() {
            InnerFieldRef.this/*null*/.foo/*null*/.b = true;
            new InnerFieldRef()/*<unknown>*/.x = 3;
        }
        
        public Inner() { super(); }
    }
    
    
    public InnerFieldRef() { super(); }
}
class Foo {
    public boolean b;
    
    public Foo() { super(); }
}
retrieve <InnerFieldRef: void main(java.lang.String[])> from InnerFieldRef
retrieve <InnerFieldRef: void <init>()> from InnerFieldRef
retrieve <InnerFieldRef: Foo access$000(InnerFieldRef)> from InnerFieldRef
retrieve <InnerFieldRef: int access$100()> from InnerFieldRef
retrieve <InnerFieldRef$Inner: void <init>(InnerFieldRef)> from InnerFieldRef$Inner
retrieve <InnerFieldRef$Inner: void m()> from InnerFieldRef$Inner
fieldRef: <InnerFieldRef: int x> assignLocal: $i0
retrieve <Foo: void <init>()> from Foo
Transforming InnerFieldRef... 
Transforming Foo... 
Transforming InnerFieldRef$Inner... 
Abc finished on Thu Jun 24 08:30:55 BST 2004. ( 0 min. 7 sec. )
PASS: Field sets to public fields of private fields of enclosing types()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 23 failed (check: 3), 113 passed (check: 3), 0 skipped.
Executing test 137 (pureJava): Constant values should be stored with the correct type of their fields
================================================
Breakdown of abc phases  (total: 7008 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  38
[ 00.043% ] Loading Jars:  3
[ 79.951% ] Polyglot phases:  5603
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.428% ] Recompute name pattern matches:  30
[ 00.014% ] Compute precedence relation:  1
[ 00.870% ] Intertype Adjuster:  61
[ 12.186% ] Retrieving bodies:  854
[ 00.000% ] Weave Initializers:  0
[ 00.342% ] Load shadow types:  24
[ 00.671% ] Compute advice lists:  47
[ 00.043% ] Intertype weave:  3
[ 00.114% ] Add aspect code:  8
[ 00.186% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.297% ] Soot Packs:  161
[ 02.283% ] Soot Writing Output:  160
================================================
Abc started on Thu Jun 24 08:30:57 BST 2004
<<<< ConstantValueConversion.java >>>>
public class ConstantValueConversion {
    public static final long FOO = 3;
    
    public static void main(java.lang.String[] args) {  }
    
    public ConstantValueConversion() { super(); }
}
retrieve <ConstantValueConversion: void main(java.lang.String[])> from ConstantValueConversion
retrieve <ConstantValueConversion: void <init>()> from ConstantValueConversion
retrieve <ConstantValueConversion: void <clinit>()> from ConstantValueConversion
Transforming ConstantValueConversion... 
Abc finished on Thu Jun 24 08:31:04 BST 2004. ( 0 min. 7 sec. )
PASS: Constant values should be stored with the correct type of their fields()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 23 failed (check: 3), 114 passed (check: 3), 0 skipped.
Executing test 138 (pureJava): Local variables in initializers should not be treated as blank final fields
================================================
Breakdown of abc phases  (total: 11697 millisec.)
------------------------------------------------
[ 00.325% ] Init. of Soot:  38
[ 00.026% ] Loading Jars:  3
[ 88.493% ] Polyglot phases:  10351
[ 00.000% ] Resolve class names:  0
[ 00.017% ] Declare Parents:  2
[ 00.932% ] Recompute name pattern matches:  109
[ 00.009% ] Compute precedence relation:  1
[ 00.470% ] Intertype Adjuster:  55
[ 04.523% ] Retrieving bodies:  529
[ 00.000% ] Weave Initializers:  0
[ 00.188% ] Load shadow types:  22
[ 01.291% ] Compute advice lists:  151
[ 00.034% ] Intertype weave:  4
[ 00.077% ] Add aspect code:  9
[ 00.120% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 01.847% ] Soot Packs:  216
[ 01.650% ] Soot Writing Output:  193
================================================
Abc started on Thu Jun 24 08:31:07 BST 2004
<<<< LocalInitializerVariableNotBlank.java >>>>
import java.awt.Color;

public class LocalInitializerVariableNotBlank {
    static java.awt.Color[] greys;
    
    static {
               LocalInitializerVariableNotBlank/*LocalInitializerVariableNotBlank*/.greys =
                 (new java.awt.Color[16]);
               int gr;
               for (int i = 0;
                    i <
                    LocalInitializerVariableNotBlank/*LocalInitializerVariableNotBlank*/.greys/*null*/.length;
                    i++) {
                   gr =
                     (int)
                       (170.0 *
                        (1.0 - java.lang.Math.pow(i / 15.0, 2.3)));
                   LocalInitializerVariableNotBlank/*LocalInitializerVariableNotBlank*/.greys[i] =
                     new java.awt.Color(gr, gr, gr);
               }
           }
    
    public static void main(java.lang.String[] args) {  }
    
    public LocalInitializerVariableNotBlank() { super(); }
}
retrieve <LocalInitializerVariableNotBlank: void main(java.lang.String[])> from LocalInitializerVariableNotBlank
retrieve <LocalInitializerVariableNotBlank: void <init>()> from LocalInitializerVariableNotBlank
retrieve <LocalInitializerVariableNotBlank: void <clinit>()> from LocalInitializerVariableNotBlank
Transforming LocalInitializerVariableNotBlank... 
Abc finished on Thu Jun 24 08:31:19 BST 2004. ( 0 min. 11 sec. )
PASS: Local variables in initializers should not be treated as blank final fie...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 23 failed (check: 3), 115 passed (check: 3), 0 skipped.
Executing test 139 (pureJava): Binops aren't allowed as update stmts in for loops
Abc started on Thu Jun 24 08:31:21 BST 2004
PASS: Binops aren't allowed as update stmts in for loops()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 23 failed (check: 3), 116 passed (check: 4), 0 skipped.
Executing test 140 (pureJava): Can't avoid doing division in case of div by zero
================================================
Breakdown of abc phases  (total: 6732 millisec.)
------------------------------------------------
[ 00.564% ] Init. of Soot:  38
[ 00.045% ] Loading Jars:  3
[ 82.100% ] Polyglot phases:  5527
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.817% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.609% ] Intertype Adjuster:  41
[ 07.977% ] Retrieving bodies:  537
[ 00.000% ] Weave Initializers:  0
[ 00.342% ] Load shadow types:  23
[ 01.530% ] Compute advice lists:  103
[ 00.045% ] Intertype weave:  3
[ 00.134% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.807% ] Soot Packs:  189
[ 02.822% ] Soot Writing Output:  190
================================================
Abc started on Thu Jun 24 08:31:25 BST 2004
<<<< DivOpMustHappen.java >>>>
import org.aspectj.testing.Tester;

public class DivOpMustHappen {
    static int i = 0;
    
    static int j = 1;
    
    public static void main(java.lang.String[] args) {
        boolean threw = false;
        try {
            switch (DivOpMustHappen/*DivOpMustHappen*/.j /
                    DivOpMustHappen/*DivOpMustHappen*/.i) {
                
            }
        }
        catch (java.lang.Exception e) { threw = true; }
        org.aspectj.testing.Tester.check(threw,
                                         "didn\'t throw divbyzero exception");
    }
    
    public DivOpMustHappen() { super(); }
}
retrieve <DivOpMustHappen: void main(java.lang.String[])> from DivOpMustHappen
retrieve <DivOpMustHappen: void <init>()> from DivOpMustHappen
retrieve <DivOpMustHappen: void <clinit>()> from DivOpMustHappen
Transforming DivOpMustHappen... 
Abc finished on Thu Jun 24 08:31:32 BST 2004. ( 0 min. 6 sec. )
PASS: Can't avoid doing division in case of div by zero()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 23 failed (check: 3), 117 passed (check: 4), 0 skipped.
Executing test 141 (pureJava): Testing frames w/greater than FF locals and 7F incs (i.e., WIDE instruction)
================================================
Breakdown of abc phases  (total: 7916 millisec.)
------------------------------------------------
[ 00.467% ] Init. of Soot:  37
[ 00.051% ] Loading Jars:  4
[ 77.855% ] Polyglot phases:  6163
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.695% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 07.428% ] Intertype Adjuster:  588
[ 06.152% ] Retrieving bodies:  487
[ 00.000% ] Weave Initializers:  0
[ 00.278% ] Load shadow types:  22
[ 02.046% ] Compute advice lists:  162
[ 00.038% ] Intertype weave:  3
[ 00.101% ] Add aspect code:  8
[ 00.164% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.388% ] Soot Packs:  189
[ 02.312% ] Soot Writing Output:  183
================================================
Abc started on Thu Jun 24 08:31:34 BST 2004
<<<< BigFrameTest.java >>>>
import org.aspectj.testing.Tester;

public class BigFrameTest {
    public static void main(java.lang.String[] args) {
        foo();
        goo();
    }
    
    static void goo() {
        int i = 10;
        i += 128;
        org.aspectj.testing.Tester.checkEqual(i, 138, "bad juju");
    }
    
    static void foo() {
        int x000;
        int x001;
        int x002;
        int x003;
        int x004;
        int x005;
        int x006;
        int x007;
        int x010;
        int x011;
        int x012;
        int x013;
        int x014;
        int x015;
        int x016;
        int x017;
        int x020;
        int x021;
        int x022;
        int x023;
        int x024;
        int x025;
        int x026;
        int x027;
        int x030;
        int x031;
        int x032;
        int x033;
        int x034;
        int x035;
        int x036;
        int x037;
        int x040;
        int x041;
        int x042;
        int x043;
        int x044;
        int x045;
        int x046;
        int x047;
        int x050;
        int x051;
        int x052;
        int x053;
        int x054;
        int x055;
        int x056;
        int x057;
        int x060;
        int x061;
        int x062;
        int x063;
        int x064;
        int x065;
        int x066;
        int x067;
        int x070;
        int x071;
        int x072;
        int x073;
        int x074;
        int x075;
        int x076;
        int x077;
        int x100;
        int x101;
        int x102;
        int x103;
        int x104;
        int x105;
        int x106;
        int x107;
        int x110;
        int x111;
        int x112;
        int x113;
        int x114;
        int x115;
        int x116;
        int x117;
        int x120;
        int x121;
        int x122;
        int x123;
        int x124;
        int x125;
        int x126;
        int x127;
        int x130;
        int x131;
        int x132;
        int x133;
        int x134;
        int x135;
        int x136;
        int x137;
        int x140;
        int x141;
        int x142;
        int x143;
        int x144;
        int x145;
        int x146;
        int x147;
        int x150;
        int x151;
        int x152;
        int x153;
        int x154;
        int x155;
        int x156;
        int x157;
        int x160;
        int x161;
        int x162;
        int x163;
        int x164;
        int x165;
        int x166;
        int x167;
        int x170;
        int x171;
        int x172;
        int x173;
        int x174;
        int x175;
        int x176;
        int x177;
        int x200;
        int x201;
        int x202;
        int x203;
        int x204;
        int x205;
        int x206;
        int x207;
        int x210;
        int x211;
        int x212;
        int x213;
        int x214;
        int x215;
        int x216;
        int x217;
        int x220;
        int x221;
        int x222;
        int x223;
        int x224;
        int x225;
        int x226;
        int x227;
        int x230;
        int x231;
        int x232;
        int x233;
        int x234;
        int x235;
        int x236;
        int x237;
        int x240;
        int x241;
        int x242;
        int x243;
        int x244;
        int x245;
        int x246;
        int x247;
        int x250;
        int x251;
        int x252;
        int x253;
        int x254;
        int x255;
        int x256;
        int x257;
        int x260;
        int x261;
        int x262;
        int x263;
        int x264;
        int x265;
        int x266;
        int x267;
        int x270;
        int x271;
        int x272;
        int x273;
        int x274;
        int x275;
        int x276;
        int x277;
        int x300;
        int x301;
        int x302;
        int x303;
        int x304;
        int x305;
        int x306;
        int x307;
        int x310;
        int x311;
        int x312;
        int x313;
        int x314;
        int x315;
        int x316;
        int x317;
        int x320;
        int x321;
        int x322;
        int x323;
        int x324;
        int x325;
        int x326;
        int x327;
        int x330;
        int x331;
        int x332;
        int x333;
        int x334;
        int x335;
        int x336;
        int x337;
        int x340;
        int x341;
        int x342;
        int x343;
        int x344;
        int x345;
        int x346;
        int x347;
        int x350;
        int x351;
        int x352;
        int x353;
        int x354;
        int x355;
        int x356;
        int x357;
        int x360;
        int x361;
        int x362;
        int x363;
        int x364;
        int x365;
        int x366;
        int x367;
        int x370;
        int x371;
        int x372;
        int x373;
        int x374;
        int x375;
        int x376;
        int x377;
        int x;
        int y;
        int z = 3;
        z += 4;
        z = z * z;
        ++z;
        org.aspectj.testing.Tester.checkEqual(z, 50, "something odd");
    }
    
    public BigFrameTest() { super(); }
}
retrieve <BigFrameTest: void main(java.lang.String[])> from BigFrameTest
retrieve <BigFrameTest: void goo()> from BigFrameTest
retrieve <BigFrameTest: void foo()> from BigFrameTest
retrieve <BigFrameTest: void <init>()> from BigFrameTest
Transforming BigFrameTest... 
Abc finished on Thu Jun 24 08:31:42 BST 2004. ( 0 min. 8 sec. )
PASS: Testing frames w/greater than FF locals and 7F incs (i.e., WIDE instruct...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 23 failed (check: 3), 118 passed (check: 4), 0 skipped.
Executing test 142 (pureJava): correct numeric literals
================================================
Breakdown of abc phases  (total: 7646 millisec.)
------------------------------------------------
[ 00.497% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 77.243% ] Polyglot phases:  5906
[ 00.013% ] Resolve class names:  1
[ 00.013% ] Declare Parents:  1
[ 00.798% ] Recompute name pattern matches:  61
[ 00.000% ] Compute precedence relation:  0
[ 00.523% ] Intertype Adjuster:  40
[ 07.259% ] Retrieving bodies:  555
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  22
[ 06.539% ] Compute advice lists:  500
[ 00.039% ] Intertype weave:  3
[ 00.118% ] Add aspect code:  9
[ 00.183% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.374% ] Soot Packs:  258
[ 03.074% ] Soot Writing Output:  235
================================================
Abc started on Thu Jun 24 08:31:45 BST 2004
<<<< LiteralsCp.java >>>>
import org.aspectj.testing.Tester;

public class LiteralsCp {
    public static void main(java.lang.String[] args) {
        float f;
        double d;
        f = 0;
        f = 0.0F;
        f = 0.0F;
        f = 9.8E-45F;
        f = 3.4028235E38F;
        f = 1.4E-45F;
        d = 0.0;
        d = 1.7976931348623157E308;
        d = 4.9E-324;
        int i;
        int i1;
        int i2;
        int i3;
        long l;
        long l1;
        long l2;
        long l3;
        i1 = 2147483647;
        i2 = 2147483647;
        i3 = 2147483647;
        checkEqual(i1, i2, i3, "MAX_INT");
        i1 = -(-2147483648);
        i2 = -2147483648;
        i3 = -2147483648;
        checkEqual(i1, i2, i3, "MIN_INT");
        i1 = -1;
        i2 = -1;
        i3 = -1;
        checkEqual(i1, i2, i3, "-1");
        l1 = 9223372036854775807L;
        l2 = 9223372036854775807L;
        l3 = 9223372036854775807L;
        checkEqual(l1, l2, l3, "MAX_LONG");
        l1 = -(-9223372036854775808L);
        l2 = -9223372036854775808L;
        l3 = -9223372036854775808L;
        checkEqual(l1, l2, l3, "MIN_LONG");
        l1 = -1L;
        l2 = -1L;
        l3 = -1L;
        checkEqual(l1, l2, l3, "-1L");
    }
    
    static void checkEqual(long i1,
                           long i2,
                           long i3,
                           java.lang.String msg) {
        org.aspectj.testing.Tester.check(i1 ==
                                         i2,
                                         msg + ": " + i1 + " == " +
                                         i2);
        org.aspectj.testing.Tester.check(i1 ==
                                         i3,
                                         msg + ": " + i1 + " == " +
                                         i3);
        org.aspectj.testing.Tester.check(i2 ==
                                         i3,
                                         msg + ": " + i2 + " == " +
                                         i3);
    }
    
    public LiteralsCp() { super(); }
}
retrieve <LiteralsCp: void main(java.lang.String[])> from LiteralsCp
retrieve <LiteralsCp: void checkEqual(long,long,long,java.lang.String)> from LiteralsCp
retrieve <LiteralsCp: void <init>()> from LiteralsCp
Transforming LiteralsCp... 
Abc finished on Thu Jun 24 08:31:53 BST 2004. ( 0 min. 7 sec. )
PASS: correct numeric literals()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 23 failed (check: 3), 119 passed (check: 4), 0 skipped.
Executing test 143 (pureJava): invalid numeric literals
Failed. Current status: 24 failed (check: 4), 119 passed (check: 4), 0 skipped.
Executing test 144 (pureJava): inner types can't have the same simple name as an enclosing type
Abc started on Thu Jun 24 08:31:59 BST 2004
<<<< InnerNameConflictsCf.java >>>>
public class InnerNameConflictsCf {
    class Inner {
        public Inner() { super(); }
    }
    
    
    public static void main(java.lang.String[] args) {
        this.new InnerNameConflictsCf.Inner();
    }
    
    public InnerNameConflictsCf() { super(); }
}
class Base {
    static class Base {
        public Base() { super(); }
    }
    
    
    public Base() { super(); }
}
class Outer {
    class Inner {
        class Inner2 {
            class Outer {
                public Outer() { super(); }
            }
            
            
            class Inner {
                public Inner() { super(); }
            }
            
            
            public Inner2() { super(); }
        }
        
        
        public Inner() { super(); }
    }
    
    
    public Outer() { super(); }
}
PASS: inner types can't have the same simple name as an enclosing type()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 24 failed (check: 4), 120 passed (check: 5), 0 skipped.
Executing test 145 (pureJava): test the unops and binops with various values
Failed. Current status: 25 failed (check: 4), 120 passed (check: 5), 0 skipped.
Executing test 146 (pureJava): test + and += for strings and variously typed values
================================================
Breakdown of abc phases  (total: 196014 millisec.)
------------------------------------------------
[ 00.019% ] Init. of Soot:  38
[ 00.002% ] Loading Jars:  4
[ 05.210% ] Polyglot phases:  10212
[ 00.000% ] Resolve class names:  0
[ 00.001% ] Declare Parents:  2
[ 00.023% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.020% ] Intertype Adjuster:  39
[ 02.412% ] Retrieving bodies:  4727
[ 00.000% ] Weave Initializers:  0
[ 00.014% ] Load shadow types:  27
[ 86.889% ] Compute advice lists:  170315
[ 00.002% ] Intertype weave:  3
[ 00.004% ] Add aspect code:  8
[ 00.007% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.457% ] Soot Packs:  6776
[ 01.941% ] Soot Writing Output:  3805
================================================
Failed. Current status: 26 failed (check: 4), 120 passed (check: 5), 0 skipped.
Executing test 147 (pureJava): test try/catch/finally statements
================================================
Breakdown of abc phases  (total: 8434 millisec.)
------------------------------------------------
[ 00.439% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  4
[ 73.050% ] Polyglot phases:  6161
[ 00.000% ] Resolve class names:  0
[ 00.036% ] Declare Parents:  3
[ 00.581% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 05.668% ] Intertype Adjuster:  478
[ 08.537% ] Retrieving bodies:  720
[ 00.000% ] Weave Initializers:  0
[ 00.273% ] Load shadow types:  23
[ 05.075% ] Compute advice lists:  428
[ 00.036% ] Intertype weave:  3
[ 00.095% ] Add aspect code:  8
[ 00.154% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.201% ] Soot Packs:  270
[ 02.810% ] Soot Writing Output:  237
================================================
Failed. Current status: 27 failed (check: 4), 120 passed (check: 5), 0 skipped.
Executing test 148 (pureJava): local types can be bound in the signatures of other local types
================================================
Breakdown of abc phases  (total: 6877 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  38
[ 00.044% ] Loading Jars:  3
[ 77.228% ] Polyglot phases:  5311
[ 00.015% ] Resolve class names:  1
[ 00.029% ] Declare Parents:  2
[ 00.669% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.567% ] Intertype Adjuster:  39
[ 12.578% ] Retrieving bodies:  865
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  22
[ 01.919% ] Compute advice lists:  132
[ 00.044% ] Intertype weave:  3
[ 00.116% ] Add aspect code:  8
[ 00.204% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.719% ] Soot Packs:  187
[ 02.995% ] Soot Writing Output:  206
================================================
Abc started on Thu Jun 24 08:37:11 BST 2004
<<<< LocalInners.java >>>>
public class LocalInners {
    public static void main(java.lang.String[] args) {
        class Local1 {
            public java.lang.String getL() {
                return this/*null*/.l.toString();
            }
            
            private Local1 l;
            
            public Local1() { super(); }
        }
        ;
        Local1 lt = new Local1();
        class Local2 extends Local1 {
            private Local1 t;
            
            public Local2() { super(); }
        }
        ;
    }
    
    public LocalInners() { super(); }
}
retrieve <LocalInners: void main(java.lang.String[])> from LocalInners
retrieve <LocalInners: void <init>()> from LocalInners
retrieve <LocalInners$1Local1: void <init>()> from LocalInners$1Local1
retrieve <LocalInners$1Local1: java.lang.String getL()> from LocalInners$1Local1
retrieve <LocalInners$1Local2: void <init>()> from LocalInners$1Local2
retrieve <LocalInners$1Local1: void <init>()> from LocalInners$1Local1
retrieve <LocalInners$1Local1: java.lang.String getL()> from LocalInners$1Local1
retrieve <LocalInners$1Local2: void <init>()> from LocalInners$1Local2
Transforming LocalInners... 
Transforming LocalInners$1Local1... 
Transforming LocalInners$1Local2... 
Abc finished on Thu Jun 24 08:37:18 BST 2004. ( 0 min. 6 sec. )
PASS: local types can be bound in the signatures of other local types()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 27 failed (check: 4), 121 passed (check: 5), 0 skipped.
Executing test 149 (new): final constructor parameter causes incorrect compiler error
================================================
Breakdown of abc phases  (total: 7145 millisec.)
------------------------------------------------
[ 00.532% ] Init. of Soot:  38
[ 00.056% ] Loading Jars:  4
[ 75.689% ] Polyglot phases:  5408
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.490% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 06.508% ] Intertype Adjuster:  465
[ 08.565% ] Retrieving bodies:  612
[ 00.000% ] Weave Initializers:  0
[ 00.322% ] Load shadow types:  23
[ 01.917% ] Compute advice lists:  137
[ 00.042% ] Intertype weave:  3
[ 00.140% ] Add aspect code:  10
[ 00.168% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.743% ] Soot Packs:  196
[ 02.799% ] Soot Writing Output:  200
================================================
Abc started on Thu Jun 24 08:37:20 BST 2004
<<<< FinalConstructorParm.java >>>>
import org.aspectj.testing.Tester;

public class FinalConstructorParm {
    int i;
    
    public FinalConstructorParm(final int i) {
        super();
        this/*<unknown>*/.i = i;
    }
    
    public int lessOne() { return this/*null*/.i - 1; }
    
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(1 ==
                                         new FinalConstructorParm(2).lessOne(),
                                         "final failed");
    }
}
retrieve <FinalConstructorParm: void <init>(int)> from FinalConstructorParm
retrieve <FinalConstructorParm: int lessOne()> from FinalConstructorParm
retrieve <FinalConstructorParm: void main(java.lang.String[])> from FinalConstructorParm
Transforming FinalConstructorParm... 
Abc finished on Thu Jun 24 08:37:27 BST 2004. ( 0 min. 7 sec. )
PASS: final constructor parameter causes incorrect compiler error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 27 failed (check: 4), 122 passed (check: 5), 0 skipped.
Executing test 150 (new): Error expected for field of type void
Failed. Current status: 28 failed (check: 5), 122 passed (check: 5), 0 skipped.
Executing test 151 (new): Error expected for constructor in interfaces
Failed. Current status: 29 failed (check: 6), 122 passed (check: 5), 0 skipped.
Executing test 152 (new): class name for identifier as String should provoke error
Abc started on Thu Jun 24 08:37:37 BST 2004
PASS: class name for identifier as String should provoke error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 29 failed (check: 6), 123 passed (check: 6), 0 skipped.
Executing test 153 (new): cyclic interface inheritance not detected if no classes implement the interfaces
Failed. Current status: 30 failed (check: 7), 123 passed (check: 6), 0 skipped.
Executing test 154 (new): cyclic class inheritance
Failed. Current status: 31 failed (check: 8), 123 passed (check: 6), 0 skipped.
Executing test 155 (pureJava): Type names are not expressions on their own
Failed. Current status: 32 failed (check: 9), 123 passed (check: 6), 0 skipped.
Executing test 156 (pureJava/nameConflicts): type and package name conflicts are resolved happily (1a)
================================================
Breakdown of abc phases  (total: 7451 millisec.)
------------------------------------------------
[ 00.523% ] Init. of Soot:  39
[ 00.054% ] Loading Jars:  4
[ 77.117% ] Polyglot phases:  5746
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.765% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.523% ] Intertype Adjuster:  39
[ 12.374% ] Retrieving bodies:  922
[ 00.000% ] Weave Initializers:  0
[ 00.295% ] Load shadow types:  22
[ 02.617% ] Compute advice lists:  195
[ 00.040% ] Intertype weave:  3
[ 00.121% ] Add aspect code:  9
[ 00.174% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.631% ] Soot Packs:  196
[ 02.738% ] Soot Writing Output:  204
================================================
Abc started on Thu Jun 24 08:37:53 BST 2004
<<<< Main1.java >>>>
package p1;

import org.aspectj.testing.Tester;

public class Main1 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new p1.Foo().getClass().getName(),
                                              "p1.Foo");
        org.aspectj.testing.Tester.checkEqual(new p1.p2.Foo().getClass().getName(),
                                              "p1.p2$Foo");
    }
    
    public Main1() { super(); }
}
<<<< p2.java >>>>
package p1;

public class p2 {
    public static class Foo {
        public Foo() { super(); }
    }
    
    
    public p2() { super(); }
}
<<<< Foo.java >>>>
package p1;

public class Foo {
    public Foo() { super(); }
}
retrieve <p1.Main1: void main(java.lang.String[])> from p1.Main1
retrieve <p1.Main1: void <init>()> from p1.Main1
retrieve <p1.p2: void <init>()> from p1.p2
retrieve <p1.p2$Foo: void <init>()> from p1.p2$Foo
retrieve <p1.Foo: void <init>()> from p1.Foo
Transforming p1.Main1... 
Transforming p1.Foo... 
Transforming p1.p2... 
Transforming p1.p2$Foo... 
Abc finished on Thu Jun 24 08:38:01 BST 2004. ( 0 min. 7 sec. )
PASS: type and package name conflicts are resolved happily (1a)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 32 failed (check: 9), 124 passed (check: 6), 0 skipped.
Executing test 157 (pureJava/nameConflicts): (fails in USEJAVAC) type and package name conflicts are resolved happily (1b)
================================================
Breakdown of abc phases  (total: 6745 millisec.)
------------------------------------------------
[ 00.563% ] Init. of Soot:  38
[ 00.059% ] Loading Jars:  4
[ 79.422% ] Polyglot phases:  5357
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.697% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.593% ] Intertype Adjuster:  40
[ 11.950% ] Retrieving bodies:  806
[ 00.015% ] Weave Initializers:  1
[ 00.578% ] Load shadow types:  39
[ 00.697% ] Compute advice lists:  47
[ 00.044% ] Intertype weave:  3
[ 00.133% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.254% ] Soot Packs:  152
[ 02.787% ] Soot Writing Output:  188
================================================
================================================
Breakdown of abc phases  (total: 3464 millisec.)
------------------------------------------------
[ 00.000% ] Init. of Soot:  0
[ 00.000% ] Loading Jars:  0
[ 89.867% ] Polyglot phases:  3113
[ 00.000% ] Resolve class names:  0
[ 00.000% ] Declare Parents:  0
[ 01.039% ] Recompute name pattern matches:  36
[ 00.000% ] Compute precedence relation:  0
[ 00.346% ] Intertype Adjuster:  12
[ 01.270% ] Retrieving bodies:  44
[ 00.000% ] Weave Initializers:  0
[ 00.000% ] Load shadow types:  0
[ 04.503% ] Compute advice lists:  156
[ 00.000% ] Intertype weave:  0
[ 00.000% ] Add aspect code:  0
[ 00.029% ] Weaving advice:  1
[ 00.000% ] Validate jimple:  0
[ 01.617% ] Soot Packs:  56
[ 01.328% ] Soot Writing Output:  46
================================================
Abc started on Thu Jun 24 08:38:03 BST 2004
<<<< p1.java >>>>
public class p1 {
    public static class Foo {
        public Foo() { super(); }
    }
    
    
    public p1() { super(); }
}
<<<< Foo.java >>>>
package p1.p2;

public class Foo {
    public Foo() { super(); }
}
retrieve <p1: void <init>()> from p1
retrieve <p1$Foo: void <init>()> from p1$Foo
retrieve <p1.p2.Foo: void <init>()> from p1.p2.Foo
Transforming p1.p2.Foo... 
Transforming p1... 
Transforming p1$Foo... 
Abc finished on Thu Jun 24 08:38:10 BST 2004. ( 0 min. 6 sec. )
Abc started on Thu Jun 24 08:38:10 BST 2004
<<<< Main1.java >>>>
package p1;

import org.aspectj.testing.Tester;

public class Main1 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new p1.Foo().getClass().getName(),
                                              "p1.Foo");
        org.aspectj.testing.Tester.checkEqual(new p1.p2.Foo().getClass().getName(),
                                              "p1.p2$Foo");
    }
    
    public Main1() { super(); }
}
<<<< p2.java >>>>
package p1;

public class p2 {
    public static class Foo {
        public Foo() { super(); }
    }
    
    
    public p2() { super(); }
}
<<<< Foo.java >>>>
package p1;

public class Foo {
    public Foo() { super(); }
}
retrieve <p1.Main1: void main(java.lang.String[])> from p1.Main1
retrieve <p1.Main1: void <init>()> from p1.Main1
retrieve <p1.p2: void <init>()> from p1.p2
retrieve <p1.p2$Foo: void <init>()> from p1.p2$Foo
retrieve <p1.Foo: void <init>()> from p1.Foo
Transforming p1.Main1... 
Transforming p1.p2... 
Transforming p1.p2$Foo... 
Transforming p1.Foo... 
Abc finished on Thu Jun 24 08:38:14 BST 2004. ( 0 min. 3 sec. )
PASS: (fails in USEJAVAC) type and package name conflicts are resolved happily...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 32 failed (check: 9), 125 passed (check: 6), 0 skipped.
Executing test 158 (pureJava/nameConflicts): type and package name conflicts are resolved happily (2)
================================================
Breakdown of abc phases  (total: 7276 millisec.)
------------------------------------------------
[ 00.509% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 78.312% ] Polyglot phases:  5698
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.756% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.536% ] Intertype Adjuster:  39
[ 12.177% ] Retrieving bodies:  886
[ 00.000% ] Weave Initializers:  0
[ 00.302% ] Load shadow types:  22
[ 02.007% ] Compute advice lists:  146
[ 00.041% ] Intertype weave:  3
[ 00.110% ] Add aspect code:  8
[ 00.192% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.419% ] Soot Packs:  176
[ 02.556% ] Soot Writing Output:  186
================================================
Abc started on Thu Jun 24 08:38:16 BST 2004
<<<< Main2.java >>>>
package p1;

import org.aspectj.testing.Tester;

public class Main2 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new p1.p2.Foo().getClass().getName(),
                                              "p1.p2.Foo");
    }
    
    public Main2() { super(); }
}
<<<< Foo.java >>>>
package p1.p2;

public class Foo {
    public Foo() { super(); }
}
retrieve <p1.Main2: void <init>()> from p1.Main2
retrieve <p1.Main2: void main(java.lang.String[])> from p1.Main2
retrieve <p1.p2.Foo: void <init>()> from p1.p2.Foo
Transforming p1.p2.Foo... 
Transforming p1.Main2... 
Abc finished on Thu Jun 24 08:38:24 BST 2004. ( 0 min. 7 sec. )
PASS: type and package name conflicts are resolved happily (2)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 32 failed (check: 9), 126 passed (check: 6), 0 skipped.
Executing test 159 (pureJava/nameConflicts): type and package name conflicts caught as errors (1)
================================================
Breakdown of abc phases  (total: 7262 millisec.)
------------------------------------------------
[ 00.496% ] Init. of Soot:  36
[ 00.041% ] Loading Jars:  3
[ 77.059% ] Polyglot phases:  5596
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.689% ] Recompute name pattern matches:  50
[ 00.014% ] Compute precedence relation:  1
[ 00.537% ] Intertype Adjuster:  39
[ 12.324% ] Retrieving bodies:  895
[ 00.000% ] Weave Initializers:  0
[ 00.317% ] Load shadow types:  23
[ 02.561% ] Compute advice lists:  186
[ 00.041% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  9
[ 00.179% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.727% ] Soot Packs:  198
[ 02.864% ] Soot Writing Output:  208
================================================
Failed. Current status: 33 failed (check: 10), 126 passed (check: 6), 0 skipped.
Executing test 160 (pureJava): flow analysis where final variable set in another constructor
================================================
Breakdown of abc phases  (total: 7568 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  38
[ 00.053% ] Loading Jars:  4
[ 76.163% ] Polyglot phases:  5764
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.621% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 06.025% ] Intertype Adjuster:  456
[ 07.334% ] Retrieving bodies:  555
[ 00.000% ] Weave Initializers:  0
[ 00.304% ] Load shadow types:  23
[ 02.973% ] Compute advice lists:  225
[ 00.040% ] Intertype weave:  3
[ 00.106% ] Add aspect code:  8
[ 00.172% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.735% ] Soot Packs:  207
[ 02.947% ] Soot Writing Output:  223
================================================
Abc started on Thu Jun 24 08:38:36 BST 2004
<<<< ConstructorFlow.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class ConstructorFlow {
    final java.lang.Runnable runner;
    
    java.lang.Runnable nonfinal;
    
    java.lang.String one;
    
    public ConstructorFlow(java.lang.String one,
                           java.lang.String two) {
        this(one);
        this/*null*/.runner.run();
        this/*null*/.nonfinal.run();
    }
    
    public ConstructorFlow(java.lang.String one) {
        super();
        this/*<unknown>*/.one = one;
        this/*null*/.runner =
          new java.lang.Runnable() {
              public void run() { Tester.event("runner.run()"); }
          };
    }
    
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("NullPointerException");
        org.aspectj.testing.Tester.expectEvent("runner.run()");
        try {
            new ConstructorFlow("one", "two");
            org.aspectj.testing.Tester.check(false, "expected NPE");
        }
        catch (java.lang.NullPointerException npe) {
            org.aspectj.testing.Tester.event("NullPointerException");
        }
        org.aspectj.testing.Tester.checkAllEvents();
    }
}
retrieve <ConstructorFlow: void <init>(java.lang.String,java.lang.String)> from ConstructorFlow
retrieve <ConstructorFlow: void <init>(java.lang.String)> from ConstructorFlow
retrieve <ConstructorFlow: void main(java.lang.String[])> from ConstructorFlow
retrieve <ConstructorFlow$1: void run()> from ConstructorFlow$1
retrieve <ConstructorFlow$1: void <init>(ConstructorFlow)> from ConstructorFlow$1
Transforming ConstructorFlow... 
Transforming ConstructorFlow$1... 
Abc finished on Thu Jun 24 08:38:44 BST 2004. ( 0 min. 7 sec. )
PASS: flow analysis where final variable set in another constructor()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 33 failed (check: 10), 127 passed (check: 6), 0 skipped.
Executing test 161 (new): Can construct inner classes using qualified expressions
================================================
Breakdown of abc phases  (total: 7792 millisec.)
------------------------------------------------
[ 00.488% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 73.075% ] Polyglot phases:  5694
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.590% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.501% ] Intertype Adjuster:  39
[ 07.033% ] Retrieving bodies:  548
[ 00.000% ] Weave Initializers:  0
[ 00.282% ] Load shadow types:  22
[ 04.851% ] Compute advice lists:  378
[ 00.039% ] Intertype weave:  3
[ 00.103% ] Add aspect code:  8
[ 00.180% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 09.715% ] Soot Packs:  757
[ 03.080% ] Soot Writing Output:  240
================================================
Abc started on Thu Jun 24 08:38:46 BST 2004
<<<< PR584.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class PR584 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("foo ok");
        org.aspectj.testing.Tester.expectEvent("foo test2");
        Foo foo = new Foo("foo");
        Foo.Test test1 = foo.new Test();
        Foo.Test test2 =
          foo.new Test() {
            public void foo() {
                Tester.event(getFoo()/*<unknown>*/.baz + " test2");
            }
        };
        test1.foo();
        test2.foo();
        Foo.StaticTest test3 = new Foo.StaticTest();
        org.aspectj.testing.Tester.expectEvent("static foo");
        test3/*null*/.staticBaz = "static foo";
        test3.staticFoo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PR584() { super(); }
}
class Foo {
    public java.lang.String baz;
    
    public Foo(java.lang.String baz) {
        super();
        this/*<unknown>*/.baz = baz;
    }
    
    public static class StaticTest {
        static java.lang.String staticBaz;
        
        public void staticFoo() {
            org.aspectj.testing.Tester.event(Foo.StaticTest/*Foo.StaticTest*/.staticBaz);
        }
        
        public StaticTest() { super(); }
    }
    
    
    public class Test {
        public Foo getFoo() { return Foo.this; }
        
        public void foo() {
            org.aspectj.testing.Tester.event(Foo.this/*null*/.baz +
                                             " ok");
        }
        
        public Test() { super(); }
    }
    
}
retrieve <PR584: void <init>()> from PR584
retrieve <PR584: void main(java.lang.String[])> from PR584
retrieve <PR584$1: void <init>(Foo)> from PR584$1
super outer type: Foo
outer local: r0
retrieve <PR584$1: void foo()> from PR584$1
retrieve <Foo: void <init>(java.lang.String)> from Foo
retrieve <Foo$StaticTest: void staticFoo()> from Foo$StaticTest
retrieve <Foo$StaticTest: void <init>()> from Foo$StaticTest
retrieve <Foo$Test: Foo getFoo()> from Foo$Test
retrieve <Foo$Test: void <init>(Foo)> from Foo$Test
retrieve <Foo$Test: void foo()> from Foo$Test
Transforming Foo... 
Transforming Foo$StaticTest... 
Transforming PR584... 
Transforming PR584$1... 
Transforming Foo$Test... 
Abc finished on Thu Jun 24 08:38:54 BST 2004. ( 0 min. 7 sec. )
PASS: Can construct inner classes using qualified expressions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 33 failed (check: 10), 128 passed (check: 6), 0 skipped.
Executing test 162 (new/protectedStatic): subclass unable to access protected static methods using type-qualified references
================================================
Breakdown of abc phases  (total: 8342 millisec.)
------------------------------------------------
[ 00.444% ] Init. of Soot:  37
[ 00.036% ] Loading Jars:  3
[ 68.808% ] Polyglot phases:  5740
[ 00.000% ] Resolve class names:  0
[ 00.024% ] Declare Parents:  2
[ 00.563% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.456% ] Intertype Adjuster:  38
[ 12.059% ] Retrieving bodies:  1006
[ 00.000% ] Weave Initializers:  0
[ 00.264% ] Load shadow types:  22
[ 10.705% ] Compute advice lists:  893
[ 00.036% ] Intertype weave:  3
[ 00.096% ] Add aspect code:  8
[ 00.144% ] Weaving advice:  12
[ 00.012% ] Validate jimple:  1
[ 03.021% ] Soot Packs:  252
[ 03.333% ] Soot Writing Output:  278
================================================
Abc started on Thu Jun 24 08:38:57 BST 2004
<<<< SubClass.java >>>>
import pack.SuperClass;
import org.aspectj.testing.Tester;

public class SubClass extends pack.SuperClass {
    private static int i;
    
    static {
               while (SubClass/*SubClass*/.i < 6) {
                   org.aspectj.testing.Tester.expectEvent(label() +
                                                          pack.SuperClass/*pack.SuperClass*/.SUPERCLASS);
               }
               SubClass/*SubClass*/.i = 0;
           }
    
    static void register(java.lang.Object o) {
        org.aspectj.testing.Tester.event("" + o);
    }
    
    public static java.lang.String label() {
        return "label() " + SubClass/*SubClass*/.i++;
    }
    
    public static void main(java.lang.String[] args) {
        java.lang.Object o =
          pack.SuperClass/*pack.SuperClass*/.protectedStaticObject;
        register("" + protectedStatic(label() + o));
        register("" + pack.SuperClass.protectedStatic(label() + o));
        register("" + pack.SuperClass.protectedStatic(label() + o));
        new SubClass().run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void run() {
        java.lang.Object o = this/*null*/.protectedObject;
        register(label() + this/*null*/.protectedObject);
        register("" + protectedMethod(label() + o));
        register("" + this.protectedMethod(label() + o));
    }
    
    public SubClass() { super(); }
}
<<<< SuperClass.java >>>>
package pack;

public class SuperClass {
    public static final java.lang.String SUPERCLASS = "SuperClass";
    
    private static java.lang.String superClass() {
        return pack.SuperClass/*pack.SuperClass*/.SUPERCLASS;
    }
    
    protected static java.lang.Object protectedStaticObject =
      superClass();
    
    protected static java.lang.Object protectedStatic(java.lang.String s) {
        return s;
    }
    
    protected java.lang.Object protectedObject = superClass();
    
    protected java.lang.Object protectedMethod(java.lang.String s) {
        return s;
    }
    
    public java.lang.String toString() { return superClass(); }
    
    public SuperClass() { super(); }
}
retrieve <SubClass: void run()> from SubClass
retrieve <SubClass: void main(java.lang.String[])> from SubClass
retrieve <SubClass: void <init>()> from SubClass
retrieve <SubClass: void <clinit>()> from SubClass
retrieve <SubClass: void register(java.lang.Object)> from SubClass
retrieve <SubClass: java.lang.String label()> from SubClass
retrieve <pack.SuperClass: java.lang.String superClass()> from pack.SuperClass
retrieve <pack.SuperClass: java.lang.Object protectedStatic(java.lang.String)> from pack.SuperClass
retrieve <pack.SuperClass: java.lang.Object protectedMethod(java.lang.String)> from pack.SuperClass
retrieve <pack.SuperClass: java.lang.String toString()> from pack.SuperClass
retrieve <pack.SuperClass: void <init>()> from pack.SuperClass
retrieve <pack.SuperClass: void <clinit>()> from pack.SuperClass
Transforming pack.SuperClass... 
Transforming SubClass... 
Abc finished on Thu Jun 24 08:39:05 BST 2004. ( 0 min. 8 sec. )
PASS: subclass unable to access protected static methods using type-qualified ...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 33 failed (check: 10), 129 passed (check: 6), 0 skipped.
Executing test 163 (new): Undefined inner class constructor
Abc started on Thu Jun 24 08:39:08 BST 2004
PASS: Undefined inner class constructor()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 33 failed (check: 10), 130 passed (check: 7), 0 skipped.
Executing test 164 (pureJava): try statements work sorta like scoped items for exception flow control
================================================
Breakdown of abc phases  (total: 6558 millisec.)
------------------------------------------------
[ 00.549% ] Init. of Soot:  36
[ 00.061% ] Loading Jars:  4
[ 76.426% ] Polyglot phases:  5012
[ 00.015% ] Resolve class names:  1
[ 00.015% ] Declare Parents:  1
[ 00.732% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.564% ] Intertype Adjuster:  37
[ 13.510% ] Retrieving bodies:  886
[ 00.000% ] Weave Initializers:  0
[ 00.335% ] Load shadow types:  22
[ 01.525% ] Compute advice lists:  100
[ 00.046% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  8
[ 00.183% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.019% ] Soot Packs:  198
[ 02.897% ] Soot Writing Output:  190
================================================
Abc started on Thu Jun 24 08:39:11 BST 2004
<<<< TryWorksLikeEnvironment.java >>>>
import java.io.*;

public class TryWorksLikeEnvironment {
    static int i;
    
    public static void main(java.lang.String[] args) {
        try {
            foo();
            try {
                TryWorksLikeEnvironment/*TryWorksLikeEnvironment*/.i++;
            }
            finally {
                TryWorksLikeEnvironment/*TryWorksLikeEnvironment*/.i++;
            }
        }
        catch (java.io.FileNotFoundException e) {  }
    }
    
    static void foo() throws java.io.FileNotFoundException {  }
    
    public TryWorksLikeEnvironment() { super(); }
}
retrieve <TryWorksLikeEnvironment: void main(java.lang.String[])> from TryWorksLikeEnvironment
retrieve <TryWorksLikeEnvironment: void foo()> from TryWorksLikeEnvironment
retrieve <TryWorksLikeEnvironment: void <init>()> from TryWorksLikeEnvironment
Transforming TryWorksLikeEnvironment... 
Abc finished on Thu Jun 24 08:39:18 BST 2004. ( 0 min. 6 sec. )
PASS: try statements work sorta like scoped items for exception flow control()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 33 failed (check: 10), 131 passed (check: 7), 0 skipped.
Executing test 165 (pureJava): qualified this must work exactly, not based on subtypes
Abc started on Thu Jun 24 08:39:20 BST 2004
<<<< QualifiedThisExactness.java >>>>
class Nimbo {
    public Nimbo() { super(); }
}
public class QualifiedThisExactness extends Nimbo {
    class Goo {
        void main() {
            java.lang.System/*java.lang.System*/.err.println(Nimbo.this);
        }
        
        public Goo() { super(); }
    }
    
    
    public QualifiedThisExactness() { super(); }
}
PASS: qualified this must work exactly, not based on subtypes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 33 failed (check: 10), 132 passed (check: 8), 0 skipped.
Executing test 166 (new/packagePrefix): classes that are package prefixes are illegal
Failed. Current status: 34 failed (check: 11), 132 passed (check: 8), 0 skipped.
Executing test 167 (new/introTypeMissing): valid type expressions for introduced type testing
Failed. Current status: 35 failed (check: 11), 132 passed (check: 8), 0 skipped.
Executing test 168 (new/introTypeMissing): CF expected when enclosing class superclass used as this qualifier in inner class
Failed. Current status: 36 failed (check: 12), 132 passed (check: 8), 0 skipped.
Executing test 169 (new/introTypeMissing): enclosing class may be used as this qualifier in inner class
Failed. Current status: 37 failed (check: 12), 132 passed (check: 8), 0 skipped.
Executing test 170 (new): PR591 compiler error expected when directly calling unimplemented abstract method using super
================================================
Breakdown of abc phases  (total: 6510 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  36
[ 00.046% ] Loading Jars:  3
[ 77.358% ] Polyglot phases:  5036
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.707% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.584% ] Intertype Adjuster:  38
[ 12.427% ] Retrieving bodies:  809
[ 00.000% ] Weave Initializers:  0
[ 00.338% ] Load shadow types:  22
[ 01.767% ] Compute advice lists:  115
[ 00.046% ] Intertype weave:  3
[ 00.276% ] Add aspect code:  18
[ 00.184% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.688% ] Soot Packs:  175
[ 02.995% ] Soot Writing Output:  195
================================================
Failed. Current status: 38 failed (check: 13), 132 passed (check: 8), 0 skipped.
Executing test 171 (pureJava): suggested by Jacks 15.28-qualified-namestr tests
Failed. Current status: 39 failed (check: 14), 132 passed (check: 8), 0 skipped.
Executing test 172 (pureJava): nested finally blocks have interesting frame location problems
Failed. Current status: 40 failed (check: 14), 132 passed (check: 8), 0 skipped.
Executing test 173 (pureJava): suggested by jacks 3.7-15 all comments must be closed
================================================
Breakdown of abc phases  (total: 6291 millisec.)
------------------------------------------------
[ 00.572% ] Init. of Soot:  36
[ 00.048% ] Loading Jars:  3
[ 79.526% ] Polyglot phases:  5003
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.445% ] Recompute name pattern matches:  28
[ 00.016% ] Compute precedence relation:  1
[ 00.922% ] Intertype Adjuster:  58
[ 12.335% ] Retrieving bodies:  776
[ 00.000% ] Weave Initializers:  0
[ 00.350% ] Load shadow types:  22
[ 00.715% ] Compute advice lists:  45
[ 00.048% ] Intertype weave:  3
[ 00.127% ] Add aspect code:  8
[ 00.191% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.241% ] Soot Packs:  141
[ 02.432% ] Soot Writing Output:  153
================================================
Failed. Current status: 41 failed (check: 15), 132 passed (check: 8), 0 skipped.
Executing test 174 (pureJava): nested synchronized blocks have interesting frame location problems
================================================
Breakdown of abc phases  (total: 6479 millisec.)
------------------------------------------------
[ 00.571% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  3
[ 76.262% ] Polyglot phases:  4941
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.448% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.926% ] Intertype Adjuster:  60
[ 13.567% ] Retrieving bodies:  879
[ 00.000% ] Weave Initializers:  0
[ 00.340% ] Load shadow types:  22
[ 01.590% ] Compute advice lists:  103
[ 00.046% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  8
[ 00.201% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.902% ] Soot Packs:  188
[ 02.948% ] Soot Writing Output:  191
================================================
Abc started on Thu Jun 24 08:40:15 BST 2004
<<<< NestedSynchronized.java >>>>
public class NestedSynchronized {
    static java.lang.Object lockA = new java.lang.Object();
    
    static java.lang.Object lockB = new java.lang.Object();
    
    static int bug() {
        synchronized (NestedSynchronized/*NestedSynchronized*/.lockA)  {
            synchronized (NestedSynchronized/*NestedSynchronized*/.lockB)  {
                return 0;
            }
        }
    }
    
    public static void main(java.lang.String[] args) { bug(); }
    
    public NestedSynchronized() { super(); }
}
retrieve <NestedSynchronized: int bug()> from NestedSynchronized
retrieve <NestedSynchronized: void main(java.lang.String[])> from NestedSynchronized
retrieve <NestedSynchronized: void <init>()> from NestedSynchronized
retrieve <NestedSynchronized: void <clinit>()> from NestedSynchronized
Transforming NestedSynchronized... 
Abc finished on Thu Jun 24 08:40:21 BST 2004. ( 0 min. 6 sec. )
PASS: nested synchronized blocks have interesting frame location problems()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 41 failed (check: 15), 133 passed (check: 8), 0 skipped.
Executing test 175 (new/classaccess): package class access not enforced outside of package
================================================
Breakdown of abc phases  (total: 6406 millisec.)
------------------------------------------------
[ 00.562% ] Init. of Soot:  36
[ 00.047% ] Loading Jars:  3
[ 78.520% ] Polyglot phases:  5030
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.702% ] Recompute name pattern matches:  45
[ 00.016% ] Compute precedence relation:  1
[ 00.593% ] Intertype Adjuster:  38
[ 12.301% ] Retrieving bodies:  788
[ 00.000% ] Weave Initializers:  0
[ 00.343% ] Load shadow types:  22
[ 01.296% ] Compute advice lists:  83
[ 00.062% ] Intertype weave:  4
[ 00.125% ] Add aspect code:  8
[ 00.187% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.482% ] Soot Packs:  159
[ 02.732% ] Soot Writing Output:  175
================================================
Failed. Current status: 42 failed (check: 16), 133 passed (check: 8), 0 skipped.
Executing test 176 (new): expecting CE for ambiguous reference
Abc started on Thu Jun 24 08:40:32 BST 2004
PASS: expecting CE for ambiguous reference()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 42 failed (check: 16), 134 passed (check: 9), 0 skipped.
Executing test 177 (new): try without catch or finally
Abc started on Thu Jun 24 08:40:36 BST 2004
PASS: try without catch or finally()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 42 failed (check: 16), 135 passed (check: 10), 0 skipped.
Executing test 178 (new): invalid floating-point constant
Abc started on Thu Jun 24 08:40:40 BST 2004
PASS: invalid floating-point constant()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 42 failed (check: 16), 136 passed (check: 11), 0 skipped.
Executing test 179 (pureJava): anonymous inner classes with inner types
================================================
Breakdown of abc phases  (total: 7368 millisec.)
------------------------------------------------
[ 00.489% ] Init. of Soot:  36
[ 00.054% ] Loading Jars:  4
[ 72.761% ] Polyglot phases:  5361
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.556% ] Recompute name pattern matches:  41
[ 00.014% ] Compute precedence relation:  1
[ 00.787% ] Intertype Adjuster:  58
[ 06.718% ] Retrieving bodies:  495
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 11.591% ] Compute advice lists:  854
[ 00.041% ] Intertype weave:  3
[ 00.109% ] Add aspect code:  8
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.203% ] Soot Packs:  236
[ 03.176% ] Soot Writing Output:  234
================================================
Abc started on Thu Jun 24 08:40:43 BST 2004
<<<< AnonymousWithInner.java >>>>
import org.aspectj.testing.Tester;

public class AnonymousWithInner {
    public static void main(java.lang.String[] args) {
        new AnonymousWithInner().foo();
        org.aspectj.testing.Tester.checkEvents(new java.lang.String[] { "x = 37", "x = 37" });
    }
    
    int x = 37;
    
    void foo() {
        java.lang.Object inner =
          new java.lang.Object() {
              class Inner {
                  void m() { Tester.event("x = " + x); }
                  
                  public String toString() {
                      m();
                      return "Inner";
                  }
              }
              
              
              Object m2() { return new Inner(); }
          }.m2();
        inner.toString();
        org.aspectj.testing.Tester.checkEqual(inner.toString(),
                                              "Inner");
    }
    
    public AnonymousWithInner() { super(); }
}
retrieve <AnonymousWithInner: void main(java.lang.String[])> from AnonymousWithInner
retrieve <AnonymousWithInner: void foo()> from AnonymousWithInner
retrieve <AnonymousWithInner: void <init>()> from AnonymousWithInner
retrieve <AnonymousWithInner$1: java.lang.Object m2()> from AnonymousWithInner$1
retrieve <AnonymousWithInner$1: void <init>(AnonymousWithInner)> from AnonymousWithInner$1
retrieve <AnonymousWithInner$1$Inner: java.lang.String toString()> from AnonymousWithInner$1$Inner
retrieve <AnonymousWithInner$1$Inner: void <init>(AnonymousWithInner$1)> from AnonymousWithInner$1$Inner
retrieve <AnonymousWithInner$1$Inner: void m()> from AnonymousWithInner$1$Inner
retrieve <AnonymousWithInner$1$Inner: java.lang.String toString()> from AnonymousWithInner$1$Inner
retrieve <AnonymousWithInner$1$Inner: void <init>(AnonymousWithInner$1)> from AnonymousWithInner$1$Inner
retrieve <AnonymousWithInner$1$Inner: void m()> from AnonymousWithInner$1$Inner
Transforming AnonymousWithInner... 
Transforming AnonymousWithInner$1... 
Transforming AnonymousWithInner$1$Inner... 
Abc finished on Thu Jun 24 08:40:51 BST 2004. ( 0 min. 7 sec. )
PASS: anonymous inner classes with inner types()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 42 failed (check: 16), 137 passed (check: 11), 0 skipped.
Executing test 180 (pureJava): qualified super call expr
================================================
Breakdown of abc phases  (total: 7342 millisec.)
------------------------------------------------
[ 00.504% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 74.462% ] Polyglot phases:  5467
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.436% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 05.870% ] Intertype Adjuster:  431
[ 06.742% ] Retrieving bodies:  495
[ 00.000% ] Weave Initializers:  0
[ 00.300% ] Load shadow types:  22
[ 04.386% ] Compute advice lists:  322
[ 00.054% ] Intertype weave:  4
[ 00.109% ] Add aspect code:  8
[ 00.177% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.582% ] Soot Packs:  263
[ 03.310% ] Soot Writing Output:  243
================================================
Abc started on Thu Jun 24 08:40:53 BST 2004
<<<< QualifiedSuperCall.java >>>>
import org.aspectj.testing.Tester;

class PackageSuper {
    java.lang.String field = "PackageSuper";
    
    void m() { org.aspectj.testing.Tester.event("PackageSuper.m()"); }
    
    public PackageSuper() { super(); }
}
public class QualifiedSuperCall extends PackageSuper {
    java.lang.String field = "Package";
    
    class InnerSuper {
        java.lang.String field = "InnerSuper";
        
        void m() {
            org.aspectj.testing.Tester.event("InnerSuper.m()");
        }
        
        public InnerSuper() { super(); }
    }
    
    
    class Inner {
        java.lang.String field = "Inner";
        
        Inner() {
            super();
            QualifiedSuperCall.super.m();
            org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "PackageSuper.m()" });
        }
        
        void m() {
            org.aspectj.testing.Tester.event("Inner.m()");
            org.aspectj.testing.Tester.event("QualifiedSuperCall.super.field = " +
                                             QualifiedSuperCall.super/*<unknown>*/.field);
            QualifiedSuperCall.super.m();
        }
    }
    
    
    public static void main(java.lang.String[] args) {
        new QualifiedSuperCall().new Inner().m();
        org.aspectj.testing.Tester.checkEvents(new java.lang.String[] { "Inner.m()", "PackageSuper.m()", "QualifiedSuperCall.super.field = PackageSuper" });
    }
    
    void m() { org.aspectj.testing.Tester.event("Package.m()"); }
    
    public QualifiedSuperCall() { super(); }
}
retrieve <PackageSuper: void m()> from PackageSuper
retrieve <PackageSuper: void <init>()> from PackageSuper
retrieve <QualifiedSuperCall: void m()> from QualifiedSuperCall
retrieve <QualifiedSuperCall: void <init>()> from QualifiedSuperCall
retrieve <QualifiedSuperCall: void main(java.lang.String[])> from QualifiedSuperCall
retrieve <QualifiedSuperCall$InnerSuper: void m()> from QualifiedSuperCall$InnerSuper
retrieve <QualifiedSuperCall$InnerSuper: void <init>(QualifiedSuperCall)> from QualifiedSuperCall$InnerSuper
retrieve <QualifiedSuperCall$Inner: void m()> from QualifiedSuperCall$Inner
next paramType: QualifiedSuperCall
meth param types: []
retrieve <QualifiedSuperCall$Inner: void <init>(QualifiedSuperCall)> from QualifiedSuperCall$Inner
next paramType: QualifiedSuperCall
meth param types: []
Transforming PackageSuper... 
Transforming QualifiedSuperCall... 
Transforming QualifiedSuperCall$InnerSuper... 
Transforming QualifiedSuperCall$Inner... 
Abc finished on Thu Jun 24 08:41:01 BST 2004. ( 0 min. 7 sec. )
PASS: qualified super call expr()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 42 failed (check: 16), 138 passed (check: 11), 0 skipped.
Executing test 181 (new/subaspects): concrete aspect unable to access abstract package-private method in parent for overriding
================================================
Breakdown of abc phases  (total: 6994 millisec.)
------------------------------------------------
[ 00.500% ] Init. of Soot:  35
[ 00.057% ] Loading Jars:  4
[ 77.381% ] Polyglot phases:  5412
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.458% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 00.886% ] Intertype Adjuster:  62
[ 11.953% ] Retrieving bodies:  836
[ 00.000% ] Weave Initializers:  0
[ 00.315% ] Load shadow types:  22
[ 02.302% ] Compute advice lists:  161
[ 00.043% ] Intertype weave:  3
[ 00.114% ] Add aspect code:  8
[ 00.186% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.888% ] Soot Packs:  202
[ 02.888% ] Soot Writing Output:  202
================================================
Failed. Current status: 43 failed (check: 17), 138 passed (check: 11), 0 skipped.
Executing test 182 (new): super reference used to disambiguate names of different but compatible types
================================================
Breakdown of abc phases  (total: 7647 millisec.)
------------------------------------------------
[ 00.484% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 72.303% ] Polyglot phases:  5529
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.562% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 00.497% ] Intertype Adjuster:  38
[ 07.428% ] Retrieving bodies:  568
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  22
[ 10.972% ] Compute advice lists:  839
[ 00.039% ] Intertype weave:  3
[ 00.118% ] Add aspect code:  9
[ 00.170% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.688% ] Soot Packs:  282
[ 03.387% ] Soot Writing Output:  259
================================================
Abc started on Thu Jun 24 08:41:12 BST 2004
<<<< SuperDisambiguatingType.java >>>>
import org.aspectj.testing.*;

public class SuperDisambiguatingType {
    public static void main(java.lang.String[] args) {
        new Sub().test();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static { org.aspectj.testing.Tester.expectEvent("test"); }
    
    public SuperDisambiguatingType() { super(); }
}
interface I {}
class C {
    public C() { super(); }
}
class IClass implements I {
    public IClass() { super(); }
}
class CClass extends C {
    public CClass() { super(); }
}
class Super {
    protected C fieldC;
    
    protected I fieldI;
    
    public Super() { super(); }
}
class Sub extends Super {
    protected CClass fieldC;
    
    protected IClass fieldI;
    
    protected java.lang.Integer intField;
    
    public void test() {
        testC();
        testI();
        org.aspectj.testing.Tester.event("test");
    }
    
    public void testC() {
        super/*<unknown>*/.fieldC =
          (C) (this/*null*/.fieldC = new CClass());
        checkC("super.fieldC = (C) (fieldC = new CClass())");
        super/*<unknown>*/.fieldC = (C) this/*null*/.fieldC;
        checkC("super.fieldC = (C) fieldC");
        super/*<unknown>*/.fieldC = this/*null*/.fieldC;
        checkC("super.fieldC = fieldC");
    }
    
    private final void checkC(java.lang.String label) {
        org.aspectj.testing.Tester.check(null !=
                                         this/*null*/.fieldC,
                                         label +
                                         "null != fieldC");
        org.aspectj.testing.Tester.check(super/*<unknown>*/.fieldC ==
                                         this/*null*/.fieldC,
                                         label +
                                         "super.fieldC == fieldC");
    }
    
    public void testI() {
        super/*<unknown>*/.fieldI =
          (I) (this/*null*/.fieldI = new IClass());
        checkI("super.fieldI = (I) (fieldI = new IClass())");
        super/*<unknown>*/.fieldI = (I) this/*null*/.fieldI;
        checkI("super.fieldI = (I) fieldI");
        super/*<unknown>*/.fieldI = this/*null*/.fieldI;
        checkI("super.fieldI = fieldI");
    }
    
    private final void checkI(java.lang.String label) {
        org.aspectj.testing.Tester.check(null !=
                                         this/*null*/.fieldI,
                                         label +
                                         "null != fieldI");
        org.aspectj.testing.Tester.check(super/*<unknown>*/.fieldI ==
                                         this/*null*/.fieldI,
                                         label +
                                         "super.fieldI == fieldI");
    }
    
    public Sub() { super(); }
}
retrieve <SuperDisambiguatingType: void <init>()> from SuperDisambiguatingType
retrieve <SuperDisambiguatingType: void main(java.lang.String[])> from SuperDisambiguatingType
retrieve <SuperDisambiguatingType: void <clinit>()> from SuperDisambiguatingType
retrieve <C: void <init>()> from C
retrieve <IClass: void <init>()> from IClass
retrieve <CClass: void <init>()> from CClass
retrieve <Super: void <init>()> from Super
retrieve <Sub: void checkI(java.lang.String)> from Sub
retrieve <Sub: void <init>()> from Sub
retrieve <Sub: void test()> from Sub
retrieve <Sub: void testC()> from Sub
retrieve <Sub: void checkC(java.lang.String)> from Sub
retrieve <Sub: void testI()> from Sub
Transforming CClass... 
Transforming IClass... 
Transforming SuperDisambiguatingType... 
Transforming C... 
Transforming Sub... 
Transforming Super... 
Transforming I... 
Abc finished on Thu Jun 24 08:41:20 BST 2004. ( 0 min. 7 sec. )
PASS: super reference used to disambiguate names of different but compatible t...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 43 failed (check: 17), 139 passed (check: 11), 0 skipped.
Executing test 183 (pureJava): anonymous explicit inner constructors
================================================
Breakdown of abc phases  (total: 7010 millisec.)
------------------------------------------------
[ 00.528% ] Init. of Soot:  37
[ 00.057% ] Loading Jars:  4
[ 74.551% ] Polyglot phases:  5226
[ 00.014% ] Resolve class names:  1
[ 00.157% ] Declare Parents:  11
[ 00.414% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 05.849% ] Intertype Adjuster:  410
[ 06.933% ] Retrieving bodies:  486
[ 00.000% ] Weave Initializers:  0
[ 00.314% ] Load shadow types:  22
[ 03.695% ] Compute advice lists:  259
[ 00.043% ] Intertype weave:  3
[ 00.128% ] Add aspect code:  9
[ 00.185% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.738% ] Soot Packs:  262
[ 03.395% ] Soot Writing Output:  238
================================================
Abc started on Thu Jun 24 08:41:23 BST 2004
<<<< QualifiedNewCP.java >>>>
public class QualifiedNewCP {
    public static void main(java.lang.String[] args) {
        Base b = new Base();
        I o = b.new Inner();
        o.m();
        o =
          b.new AbstractInner() {
              public void m() {
                  System.out.println("mi");
                  helper();
              }
          };
        o.m();
        o =
          b.new Inner() {
              public void m() { System.out.println("mi"); }
          };
        o.m();
    }
    
    public QualifiedNewCP() { super(); }
}
class Base {
    class Inner implements I {
        public void m() {
            java.lang.System/*java.lang.System*/.out.println("m");
        }
        
        public Inner() { super(); }
    }
    
    
    abstract class AbstractInner implements I {
        protected void helper() {
            java.lang.System/*java.lang.System*/.out.println("helper");
        }
        
        public AbstractInner() { super(); }
    }
    
    
    protected void foo() {
        java.lang.System/*java.lang.System*/.out.println("foo");
    }
    
    public Base() { super(); }
}
interface I {
    public abstract void m();
}
retrieve <QualifiedNewCP: void main(java.lang.String[])> from QualifiedNewCP
retrieve <QualifiedNewCP: void <init>()> from QualifiedNewCP
retrieve <QualifiedNewCP$2: void m()> from QualifiedNewCP$2
retrieve <QualifiedNewCP$2: void <init>(Base)> from QualifiedNewCP$2
super outer type: Base
outer local: r0
retrieve <QualifiedNewCP$1: void m()> from QualifiedNewCP$1
retrieve <QualifiedNewCP$1: void <init>(Base)> from QualifiedNewCP$1
super outer type: Base
outer local: r0
retrieve <Base: void <init>()> from Base
retrieve <Base: void foo()> from Base
retrieve <Base$Inner: void m()> from Base$Inner
retrieve <Base$Inner: void <init>(Base)> from Base$Inner
retrieve <Base$AbstractInner: void <init>(Base)> from Base$AbstractInner
retrieve <Base$AbstractInner: void helper()> from Base$AbstractInner
Transforming I... 
Transforming QualifiedNewCP... 
Transforming QualifiedNewCP$1... 
Transforming Base... 
Transforming Base$Inner... 
Transforming QualifiedNewCP$2... 
Transforming Base$AbstractInner... 
Abc finished on Thu Jun 24 08:41:30 BST 2004. ( 0 min. 7 sec. )
m
mi
helper
mi
PASS: anonymous explicit inner constructors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 43 failed (check: 17), 140 passed (check: 11), 0 skipped.
Executing test 184 (pureJava): interfaces with non-explicitly static inner classes
================================================
Breakdown of abc phases  (total: 6128 millisec.)
------------------------------------------------
[ 00.604% ] Init. of Soot:  37
[ 00.065% ] Loading Jars:  4
[ 78.851% ] Polyglot phases:  4832
[ 00.000% ] Resolve class names:  0
[ 00.033% ] Declare Parents:  2
[ 00.473% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.946% ] Intertype Adjuster:  58
[ 12.451% ] Retrieving bodies:  763
[ 00.000% ] Weave Initializers:  0
[ 00.636% ] Load shadow types:  39
[ 00.734% ] Compute advice lists:  45
[ 00.049% ] Intertype weave:  3
[ 00.131% ] Add aspect code:  8
[ 00.212% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.268% ] Soot Packs:  139
[ 02.546% ] Soot Writing Output:  156
================================================
Failed. Current status: 44 failed (check: 17), 140 passed (check: 11), 0 skipped.
Executing test 185 (pureJava): Overruning the lineStarts buffer, DO NOT EDIT THIS FILE!!!!
================================================
Breakdown of abc phases  (total: 6300 millisec.)
------------------------------------------------
[ 00.571% ] Init. of Soot:  36
[ 00.063% ] Loading Jars:  4
[ 79.476% ] Polyglot phases:  5007
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.730% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.603% ] Intertype Adjuster:  38
[ 12.302% ] Retrieving bodies:  775
[ 00.000% ] Weave Initializers:  0
[ 00.476% ] Load shadow types:  30
[ 00.714% ] Compute advice lists:  45
[ 00.048% ] Intertype weave:  3
[ 00.127% ] Add aspect code:  8
[ 00.190% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.222% ] Soot Packs:  140
[ 02.444% ] Soot Writing Output:  154
================================================
Abc started on Thu Jun 24 08:41:41 BST 2004
<<<< AJError.java >>>>
public class AJError {
    public static void main(java.lang.String[] args) {  }
    
    public AJError() { super(); }
}
retrieve <AJError: void main(java.lang.String[])> from AJError
retrieve <AJError: void <init>()> from AJError
Transforming AJError... 
Abc finished on Thu Jun 24 08:41:47 BST 2004. ( 0 min. 6 sec. )
PASS: Overruning the lineStarts buffer, DO NOT EDIT THIS FILE!!!!()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 44 failed (check: 17), 141 passed (check: 11), 0 skipped.
Executing test 186 (new): no CE for unambiguous type reference
================================================
Breakdown of abc phases  (total: 6639 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  36
[ 00.060% ] Loading Jars:  4
[ 76.578% ] Polyglot phases:  5084
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.633% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.557% ] Intertype Adjuster:  37
[ 12.984% ] Retrieving bodies:  862
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  22
[ 02.380% ] Compute advice lists:  158
[ 00.045% ] Intertype weave:  3
[ 00.136% ] Add aspect code:  9
[ 00.181% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.847% ] Soot Packs:  189
[ 02.696% ] Soot Writing Output:  179
================================================
Abc started on Thu Jun 24 08:41:50 BST 2004
<<<< UnambiguousClassReference3CP.java >>>>
import java.sql.Array;
import org.aspectj.testing.Tester;

public class UnambiguousClassReference3CP {
    public static void main(java.lang.String[] args) {
        int[] gh = new int[5];
        int len = java.lang.reflect.Array.getLength(gh);
        org.aspectj.testing.Tester.check(5 ==
                                         len,
                                         "Array.getLength failed: " +
                                         len);
    }
    
    public UnambiguousClassReference3CP() { super(); }
}
retrieve <UnambiguousClassReference3CP: void main(java.lang.String[])> from UnambiguousClassReference3CP
retrieve <UnambiguousClassReference3CP: void <init>()> from UnambiguousClassReference3CP
Transforming UnambiguousClassReference3CP... 
Abc finished on Thu Jun 24 08:41:57 BST 2004. ( 0 min. 6 sec. )
PASS: no CE for unambiguous type reference()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 44 failed (check: 17), 142 passed (check: 11), 0 skipped.
Executing test 187 (new): CE for ambiguous type reference (imports)
Failed. Current status: 45 failed (check: 18), 142 passed (check: 11), 0 skipped.
Executing test 188 (new): CE for ambiguous type reference (two type declarations)
Abc started on Thu Jun 24 08:42:03 BST 2004
<<<< AmbiguousClassReference3CE.java >>>>
public class AmbiguousClassReference3CE {
    public static void main(java.lang.String[] args) {
        throw new java.lang.Error("Expecting compiler error, not compile/run");
    }
    
    public AmbiguousClassReference3CE() { super(); }
}
class Foo {
    public Foo() { super(); }
}
interface Foo {}
class Bar {
    Foo f;
    
    public Bar() { super(); }
}
PASS: CE for ambiguous type reference (two type declarations)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 45 failed (check: 18), 143 passed (check: 12), 0 skipped.
Executing test 189 (new): CE for ambiguous type reference (two inner types)
================================================
Breakdown of abc phases  (total: 6453 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  35
[ 00.046% ] Loading Jars:  3
[ 78.367% ] Polyglot phases:  5057
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.449% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.589% ] Intertype Adjuster:  38
[ 12.971% ] Retrieving bodies:  837
[ 00.000% ] Weave Initializers:  0
[ 00.325% ] Load shadow types:  21
[ 00.821% ] Compute advice lists:  53
[ 00.046% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  8
[ 00.201% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.898% ] Soot Packs:  187
[ 02.588% ] Soot Writing Output:  167
================================================
Failed. Current status: 46 failed (check: 19), 143 passed (check: 12), 0 skipped.
Executing test 190 (new): final assignment in loop
================================================
Breakdown of abc phases  (total: 6732 millisec.)
------------------------------------------------
[ 00.550% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 77.614% ] Polyglot phases:  5225
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.683% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 06.328% ] Intertype Adjuster:  426
[ 06.967% ] Retrieving bodies:  469
[ 00.000% ] Weave Initializers:  0
[ 00.327% ] Load shadow types:  22
[ 01.931% ] Compute advice lists:  130
[ 00.045% ] Intertype weave:  3
[ 00.119% ] Add aspect code:  8
[ 00.208% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.585% ] Soot Packs:  174
[ 02.570% ] Soot Writing Output:  173
================================================
Abc started on Thu Jun 24 08:42:15 BST 2004
<<<< FinalInLoop.java >>>>
import org.aspectj.testing.Tester;

public class FinalInLoop {
    public static void main(java.lang.String[] args) {
        for (int i = 0; i < 1; i++) {
            final java.lang.String s;
            if (true) { s = "true"; } else { s = "false"; }
            org.aspectj.testing.Tester.check("true".equals(s),
                                             "s not true");
        }
    }
    
    public FinalInLoop() { super(); }
}
retrieve <FinalInLoop: void main(java.lang.String[])> from FinalInLoop
retrieve <FinalInLoop: void <init>()> from FinalInLoop
Transforming FinalInLoop... 
Abc finished on Thu Jun 24 08:42:22 BST 2004. ( 0 min. 6 sec. )
PASS: final assignment in loop()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 46 failed (check: 19), 144 passed (check: 12), 0 skipped.
Executing test 191 (pureJava): private super access in inners
================================================
Breakdown of abc phases  (total: 6559 millisec.)
------------------------------------------------
[ 00.549% ] Init. of Soot:  36
[ 00.061% ] Loading Jars:  4
[ 76.429% ] Polyglot phases:  5013
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.656% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 06.175% ] Intertype Adjuster:  405
[ 07.089% ] Retrieving bodies:  465
[ 00.000% ] Weave Initializers:  0
[ 00.335% ] Load shadow types:  22
[ 01.997% ] Compute advice lists:  131
[ 00.046% ] Intertype weave:  3
[ 00.122% ] Add aspect code:  8
[ 00.198% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.217% ] Soot Packs:  211
[ 03.095% ] Soot Writing Output:  203
================================================
Failed. Current status: 47 failed (check: 19), 144 passed (check: 12), 0 skipped.
Executing test 192 (pureJava): nested interface does not require new qualifier (8)
Abc started on Thu Jun 24 08:42:34 BST 2004
PASS: nested interface does not require new qualifier (8)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 145 passed (check: 13), 0 skipped.
Executing test 193 (pureJava): nested interface does not require new qualifier (9)
Abc started on Thu Jun 24 08:42:37 BST 2004
PASS: nested interface does not require new qualifier (9)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 146 passed (check: 14), 0 skipped.
Executing test 194 (pureJava): nested interface does not require new qualifier (10)
Abc started on Thu Jun 24 08:42:41 BST 2004
PASS: nested interface does not require new qualifier (10)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 147 passed (check: 15), 0 skipped.
Executing test 195 (pureJava): nested interface does not require new qualifier (14)
Abc started on Thu Jun 24 08:42:44 BST 2004
PASS: nested interface does not require new qualifier (14)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 148 passed (check: 16), 0 skipped.
Executing test 196 (pureJava): nested interface does not require new qualifier (15)
Abc started on Thu Jun 24 08:42:48 BST 2004
PASS: nested interface does not require new qualifier (15)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 149 passed (check: 17), 0 skipped.
Executing test 197 (pureJava): nested interface does not require new qualifier (16)
Abc started on Thu Jun 24 08:42:51 BST 2004
PASS: nested interface does not require new qualifier (16)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 47 failed (check: 19), 150 passed (check: 18), 0 skipped.
Executing test 198 (pureJava): Operands work correctly
================================================
Breakdown of abc phases  (total: 18041 millisec.)
------------------------------------------------
[ 00.200% ] Init. of Soot:  36
[ 00.022% ] Loading Jars:  4
[ 45.064% ] Polyglot phases:  8130
[ 00.000% ] Resolve class names:  0
[ 00.011% ] Declare Parents:  2
[ 00.261% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.211% ] Intertype Adjuster:  38
[ 06.624% ] Retrieving bodies:  1195
[ 00.000% ] Weave Initializers:  0
[ 00.116% ] Load shadow types:  21
[ 38.507% ] Compute advice lists:  6947
[ 00.017% ] Intertype weave:  3
[ 00.050% ] Add aspect code:  9
[ 00.067% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 05.493% ] Soot Packs:  991
[ 03.359% ] Soot Writing Output:  606
================================================
Failed. Current status: 48 failed (check: 19), 150 passed (check: 18), 0 skipped.
Executing test 199 (errors): reasonable error for crosscut reference with no formals specified
Failed. Current status: 49 failed (check: 20), 150 passed (check: 18), 0 skipped.
Executing test 200 (errors): reasonable error for introduction on type whose source isn't found
Abc started on Thu Jun 24 08:43:19 BST 2004
PASS: reasonable error for introduction on type whose source isn't found()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 49 failed (check: 20), 151 passed (check: 19), 0 skipped.
Executing test 201 (errors): check that constructor name's match the enclosing type
Abc started on Thu Jun 24 08:43:23 BST 2004
<<<< BadConstructorName.java >>>>
import org.aspectj.testing.Tester;

class BadConstructorName {
    public FooBar() { super(); }
}
PASS: check that constructor name's match the enclosing type()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 49 failed (check: 20), 152 passed (check: 20), 0 skipped.
Executing test 202 (errors): handle errors in crosscut designators, insist that they end with a semicolon
Abc started on Thu Jun 24 08:43:26 BST 2004
PASS: handle errors in crosscut designators, insist that they end with a semic...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 49 failed (check: 20), 153 passed (check: 21), 0 skipped.
Executing test 203 (errors): errors for not applicable or accessible methods
Abc started on Thu Jun 24 08:43:30 BST 2004
<<<< MethodsNotFound.java >>>>
public class MethodsNotFound {
    public void foo() { "a".bar(); }
    
    public void foo(int x) { new Ha().foo(); }
    
    public void bar() { new MethodsNotFound().foo("hi"); }
    
    public MethodsNotFound() { super(); }
}
class Ha {
    private void foo() {  }
    
    public Ha() { super(); }
}
PASS: errors for not applicable or accessible methods()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 49 failed (check: 20), 154 passed (check: 22), 0 skipped.
Executing test 204 (errors): try to return from a before, after, after throwing and after returning
Failed. Current status: 50 failed (check: 21), 154 passed (check: 22), 0 skipped.
Executing test 205 (errors): the designator has a wildcard for method name but no return type specified
Abc started on Thu Jun 24 08:43:37 BST 2004
PASS: the designator has a wildcard for method name but no return type specifi...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 50 failed (check: 21), 155 passed (check: 23), 0 skipped.
Executing test 206 (errors): the designator for the introduction has no type after the | charcter
Abc started on Thu Jun 24 08:43:41 BST 2004
PASS: the designator for the introduction has no type after the | charcter()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 50 failed (check: 21), 156 passed (check: 24), 0 skipped.
Executing test 207 (errors): crosscut signature does not match
Abc started on Thu Jun 24 08:43:44 BST 2004
<<<< BadCCutSig.java >>>>
package errors;

aspect BadCCutSig {
    int bar(int a, int b, int c) { return 0; }
    
    pointcut cut(errors.BadCCutSig b) :
    target(b) &&
      call(int (*).bar(int, int, int));
    
    before(BadCCutSig b): cut() {  }
    
    public static errors.BadCCutSig aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public BadCCutSig() { super(); }
}
PASS: crosscut signature does not match()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 50 failed (check: 21), 157 passed (check: 25), 0 skipped.
Executing test 208 (errors): proper exit conditions when errors fall through to javac
Abc started on Thu Jun 24 08:43:48 BST 2004
<<<< FromJavac.java >>>>
public class FromJavac {
    public static void foo() {
        int x;
        int y = x;
    }
    
    public FromJavac() { super(); }
}
PASS: proper exit conditions when errors fall through to javac()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 50 failed (check: 21), 158 passed (check: 26), 0 skipped.
Executing test 209 (errors): mismatched parens on advice (wasn't binding Tester)
Failed. Current status: 51 failed (check: 22), 158 passed (check: 26), 0 skipped.
Executing test 210 (errors): Non-static advice silently ignored
Abc started on Thu Jun 24 08:43:56 BST 2004
<<<< BadPointcutName.java >>>>
import org.aspectj.testing.Tester;

public aspect BadPointcutName {
    private static java.util.Vector v = new java.util.Vector();
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.check(true, "");
    }
    
    after() returning: noSuchCut() {  }
    
    public static BadPointcutName aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public BadPointcutName() { super(); }
}
PASS: Non-static advice silently ignored()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 51 failed (check: 22), 159 passed (check: 27), 0 skipped.
Executing test 211 (errors): import statement within class body crashes compiler
Abc started on Thu Jun 24 08:44:00 BST 2004
PASS: import statement within class body crashes compiler()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 51 failed (check: 22), 160 passed (check: 28), 0 skipped.
Executing test 212 (errors): extra closing brace
java.util.EmptyStackException
	at java.util.Stack.peek(Stack.java:79)
	at abc.aspectj.parse.Lexer_c.nextToken(Lexer_c.java:2683)
	at polyglot.parse.BaseParser.nextSymbol(BaseParser.java:35)
	at abc.aspectj.parse.Grm.scan(Grm.java:12932)
	at java_cup.runtime.lr_parser.parse(lr_parser.java:562)
	at polyglot.frontend.CupParser.parse(CupParser.java:24)
	at polyglot.frontend.ParserPass.run(ParserPass.java:36)
	at polyglot.frontend.AbstractExtensionInfo.runPass(AbstractExtensionInfo.java:287)
	at polyglot.frontend.AbstractExtensionInfo.runToPass(AbstractExtensionInfo.java:223)
	at polyglot.frontend.AbstractExtensionInfo.runAllPasses(AbstractExtensionInfo.java:191)
	at polyglot.frontend.AbstractExtensionInfo.runToCompletion(AbstractExtensionInfo.java:110)
	at polyglot.frontend.Compiler.compile(Compiler.java:95)
	at abc.main.Main.compile(Main.java:283)
	at abc.main.Main.run(Main.java:191)
	at abc.bridge.AbcMain.compile(AbcMain.java:13)
	at abc.bridge.AbcCompiler.compile(AbcCompiler.java:71)
	at abc.bridge.AbcBuildManager.performCompilation(AbcBuildManager.java:86)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
	at abc.bridge.AbcCommand.doCommand(AbcCommand.java:102)
	at abc.bridge.AbcCommand.runCommand(AbcCommand.java:51)
	at org.aspectj.testing.harness.bridge.CompilerRun.run(CompilerRun.java:544)
	at org.aspectj.testing.run.Runner.runPrivate(Runner.java:359)
	at org.aspectj.testing.run.Runner.runChild(Runner.java:159)
	at org.aspectj.testing.run.Runner.runChild(Runner.java:118)
	at org.aspectj.testing.run.Runner$IteratorWrapper.run(Runner.java:438)
	at org.aspectj.testing.run.Runner.runPrivate(Runner.java:359)
	at org.aspectj.testing.run.Runner.runChild(Runner.java:159)
	at org.aspectj.testing.run.Runner.runChild(Runner.java:118)
	at org.aspectj.testing.run.Runner$IteratorWrapper.run(Runner.java:438)
	at org.aspectj.testing.run.Runner.runPrivate(Runner.java:359)
	at org.aspectj.testing.run.Runner.run(Runner.java:106)
	at org.aspectj.testing.run.Runner.run(Runner.java:97)
	at org.aspectj.testing.run.Runner.runIterator(Runner.java:220)
	at org.aspectj.testing.drivers.Harness.run(Harness.java:360)
	at org.aspectj.testing.drivers.FeatureHarness.run(Harness.java:657)
	at org.aspectj.testing.drivers.Harness.runMain(Harness.java:288)
	at org.aspectj.testing.drivers.Harness.main(Harness.java:124)
	at org.aspectj.testing.Harness.main(Harness.java:37)
Failed. Current status: 52 failed (check: 23), 160 passed (check: 28), 0 skipped.
Executing test 213 (errors): decent errors for around return type not matching target point
Failed. Current status: 53 failed (check: 24), 160 passed (check: 28), 0 skipped.
Executing test 214 (errors): eachobject: can't call new on an aspect of
================================================
Breakdown of abc phases  (total: 6535 millisec.)
------------------------------------------------
[ 00.536% ] Init. of Soot:  35
[ 00.046% ] Loading Jars:  3
[ 76.710% ] Polyglot phases:  5013
[ 00.031% ] Resolve class names:  2
[ 00.015% ] Declare Parents:  1
[ 00.673% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.566% ] Intertype Adjuster:  37
[ 12.425% ] Retrieving bodies:  812
[ 00.000% ] Weave Initializers:  0
[ 00.337% ] Load shadow types:  22
[ 00.689% ] Compute advice lists:  45
[ 00.046% ] Intertype weave:  3
[ 00.597% ] Add aspect code:  39
[ 00.199% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.902% ] Soot Packs:  255
[ 03.229% ] Soot Writing Output:  211
================================================
Failed. Current status: 54 failed (check: 25), 160 passed (check: 28), 0 skipped.
Executing test 215 (errors): eachobject: only zero-argument constructors allowed in an aspect
Failed. Current status: 55 failed (check: 26), 160 passed (check: 28), 0 skipped.
Executing test 216 (errors): eachobject: can't extend a concrete aspect
Abc started on Thu Jun 24 08:44:33 BST 2004
<<<< SubAspectsCantExtendNonAbstractAspects.java >>>>
public class SubAspectsCantExtendNonAbstractAspects {
    public static void main(java.lang.String[] args) {  }
    
    public SubAspectsCantExtendNonAbstractAspects() { super(); }
}
class C {
    public C() { super(); }
}
aspect A {
    before(): call(* (*).*(..)) {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
aspect SubA extends A {
    public static SubA aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public SubA() { super(); }
}
PASS: eachobject: can't extend a concrete aspect()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 161 passed (check: 29), 0 skipped.
Executing test 217 (errors): instanceof used without a class
Abc started on Thu Jun 24 08:44:36 BST 2004
PASS: instanceof used without a class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 162 passed (check: 30), 0 skipped.
Executing test 218 (errors): wildcard used for returns clause
Abc started on Thu Jun 24 08:44:40 BST 2004
PASS: wildcard used for returns clause()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 163 passed (check: 31), 0 skipped.
Executing test 219 (errors): no return statement in around advice
Abc started on Thu Jun 24 08:44:43 BST 2004
<<<< NoReturnStatement.java >>>>
import org.aspectj.testing.Tester;

public aspect NoReturnStatement {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.check(true, "passed");
    }
    
    public int m() { return 1; }
    
    int around (C t):
    target(t) &&
      call(int (*).m()) {
        int x = this.proceed(t);
    }
    
    public static NoReturnStatement aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public NoReturnStatement() { super(); }
}
class C {
    public int m() { return 1; }
    
    public C() { super(); }
}
PASS: no return statement in around advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 164 passed (check: 32), 0 skipped.
Executing test 220 (errors): inner aspects must be static (no longer matches PR#286)
Abc started on Thu Jun 24 08:44:47 BST 2004
<<<< AbstractAspectOf.java >>>>
import org.aspectj.testing.Tester;

public class AbstractAspectOf {
    public AbstractAspectOf() { super(); }
}
abstract aspect AbstractAspect {
    public AbstractAspect() { super(); }
}
class C {
    aspect InnerAspect {
        public static C.InnerAspect aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public InnerAspect() { super(); }
    }
    
    
    public C() { super(); }
}
PASS: inner aspects must be static (no longer matches PR#286)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 165 passed (check: 33), 0 skipped.
Executing test 221 (errors): Casting class declarations as interfaces
Abc started on Thu Jun 24 08:44:51 BST 2004
PASS: Casting class declarations as interfaces()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 166 passed (check: 34), 0 skipped.
Executing test 222 (errors): omits a variable name and crashes with a null pointer
Abc started on Thu Jun 24 08:44:55 BST 2004
<<<< BindingNullPointer.java >>>>
import org.aspectj.testing.*;

public class BindingNullPointer {
    boolean ran = false;
    
    final java.lang.String s1 = new java.lang.String("s1");
    
    java.lang.Runnable r1 =
      new java.lang.Runnable() {
        public void run() {
            String = s1;
            ran = true;
        }
    };
    
    void go() {
        this/*null*/.r1.run();
        org.aspectj.testing.Tester.check(this/*null*/.ran,
                                         "r1.run did not run");
    }
    
    public static void main(java.lang.String[] args) {
        new BindingNullPointer().go();
    }
    
    public BindingNullPointer() { super(); }
}
PASS: omits a variable name and crashes with a null pointer()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 167 passed (check: 35), 0 skipped.
Executing test 223 (errors): Not generating an error for using new as a method name
Abc started on Thu Jun 24 08:44:59 BST 2004
PASS: Not generating an error for using new as a method name()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 168 passed (check: 36), 0 skipped.
Executing test 224 (errors): ClassCastException on the int literal
Abc started on Thu Jun 24 08:45:02 BST 2004
PASS: ClassCastException on the int literal()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 55 failed (check: 26), 169 passed (check: 37), 0 skipped.
Executing test 225 (new): Wrong strictfp keyword usage in interface function prototype [TODO: move to errors]
================================================
Breakdown of abc phases  (total: 6019 millisec.)
------------------------------------------------
[ 00.581% ] Init. of Soot:  35
[ 00.050% ] Loading Jars:  3
[ 81.492% ] Polyglot phases:  4905
[ 00.000% ] Resolve class names:  0
[ 00.033% ] Declare Parents:  2
[ 00.764% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.648% ] Intertype Adjuster:  39
[ 00.033% ] Retrieving bodies:  2
[ 00.000% ] Weave Initializers:  0
[ 00.366% ] Load shadow types:  22
[ 08.473% ] Compute advice lists:  510
[ 00.050% ] Intertype weave:  3
[ 00.150% ] Add aspect code:  9
[ 00.249% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 05.001% ] Soot Packs:  301
[ 02.110% ] Soot Writing Output:  127
================================================
Failed. Current status: 56 failed (check: 27), 169 passed (check: 37), 0 skipped.
Executing test 226 (new): Wrong strictfp keyword usage in field declaration [TODO: move to errors]
Abc started on Thu Jun 24 08:45:14 BST 2004
<<<< StrictFpCErr2.java >>>>
abstract strictfp class StrictClassBadField {
    strictfp float f;
    
    public StrictClassBadField() { super(); }
}
PASS: Wrong strictfp keyword usage in field declaration [TODO: move to errors]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 56 failed (check: 27), 170 passed (check: 38), 0 skipped.
Executing test 227 (new): Wrong strictfp keyword usage in constructor declaration [TODO: move to errors]
Abc started on Thu Jun 24 08:45:18 BST 2004
<<<< StrictFpCErr3.java >>>>
abstract strictfp class StrictClassBadConstructor {
    strictfp StrictClassBadConstructor() { super(); }
}
PASS: Wrong strictfp keyword usage in constructor declaration [TODO: move to e...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 56 failed (check: 27), 171 passed (check: 39), 0 skipped.
Executing test 228 (errors): Incorrect static casts to primitively foldable arguments should not crash the compiler.
Abc started on Thu Jun 24 08:45:22 BST 2004
<<<< BadStaticCast.java >>>>
public class BadStaticCast {
    public static int foo() { return 3 + (int) true; }
    
    public BadStaticCast() { super(); }
}
PASS: Incorrect static casts to primitively foldable arguments should not cras...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 56 failed (check: 27), 172 passed (check: 40), 0 skipped.
Executing test 229 (errors): Dominates with commas should signal an error.
Abc started on Thu Jun 24 08:45:25 BST 2004
PASS: Dominates with commas should signal an error.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 56 failed (check: 27), 173 passed (check: 41), 0 skipped.
Executing test 230 (errors): Accessing instance fields and instance methods statically.
Failed. Current status: 57 failed (check: 28), 173 passed (check: 41), 0 skipped.
Executing test 231 (errors): stack overflow with recursive crosscut specifier
Abc started on Thu Jun 24 08:45:33 BST 2004
PASS: stack overflow with recursive crosscut specifier()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 57 failed (check: 28), 174 passed (check: 42), 0 skipped.
Executing test 232 (errors): Throwing a NullPointerException when formals can't be bound in named pointcut
Abc started on Thu Jun 24 08:45:36 BST 2004
<<<< BadFormalsToCalls.java >>>>
import org.aspectj.testing.Tester;

public class BadFormalsToCalls {
    static boolean noargsCalled = false;
    
    public static void main(java.lang.String[] args) {
        new BadFormalsToCalls().go();
    }
    
    void go() {
        this.new BadFormalsToCalls.B().noargs();
        org.aspectj.testing.Tester.check(BadFormalsToCalls/*BadFormalsToCalls*/.noargsCalled,
                                         "noargs wasn\'t called");
    }
    
    class B {
        public void noargs() {  }
        
        public B() { super(); }
    }
    
    
    public BadFormalsToCalls() { super(); }
}
aspect CallsNoArgsAspect {
    pointcut noargs(BadFormalsToCalls.B b) : call(void (*).noargs());
    
    void around (BadFormalsToCalls.B b):
    noargs(b) {
        this.proceed(b);
    }
    
    public static CallsNoArgsAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public CallsNoArgsAspect() { super(); }
}
PASS: Throwing a NullPointerException when formals can't be bound in named poi...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 57 failed (check: 28), 175 passed (check: 43), 0 skipped.
Executing test 233 (errors): disallow defining more than one pointcut with the same name
================================================
Breakdown of abc phases  (total: 6413 millisec.)
------------------------------------------------
[ 00.546% ] Init. of Soot:  35
[ 00.047% ] Loading Jars:  3
[ 75.222% ] Polyglot phases:  4824
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.748% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.561% ] Intertype Adjuster:  36
[ 12.475% ] Retrieving bodies:  800
[ 00.000% ] Weave Initializers:  0
[ 00.343% ] Load shadow types:  22
[ 02.183% ] Compute advice lists:  140
[ 00.047% ] Intertype weave:  3
[ 00.795% ] Add aspect code:  51
[ 00.187% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.820% ] Soot Packs:  245
[ 02.963% ] Soot Writing Output:  190
================================================
Failed. Current status: 58 failed (check: 29), 175 passed (check: 43), 0 skipped.
Executing test 234 (errors): pre 0.7 introduction form outside aspect body causes an EmptyStackException
Abc started on Thu Jun 24 08:45:49 BST 2004
PASS: pre 0.7 introduction form outside aspect body causes an EmptyStackExcept...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 58 failed (check: 29), 176 passed (check: 44), 0 skipped.
Executing test 235 (errors): a class can't extend an aspect
================================================
Breakdown of abc phases  (total: 6973 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  35
[ 00.057% ] Loading Jars:  4
[ 74.301% ] Polyglot phases:  5181
[ 00.014% ] Resolve class names:  1
[ 00.029% ] Declare Parents:  2
[ 00.645% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.516% ] Intertype Adjuster:  36
[ 06.841% ] Retrieving bodies:  477
[ 00.000% ] Weave Initializers:  0
[ 00.402% ] Load shadow types:  28
[ 01.793% ] Compute advice lists:  125
[ 00.043% ] Intertype weave:  3
[ 00.459% ] Add aspect code:  32
[ 00.186% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.623% ] Soot Packs:  671
[ 04.589% ] Soot Writing Output:  320
================================================
Failed. Current status: 59 failed (check: 30), 176 passed (check: 44), 0 skipped.
Executing test 236 (errors): a before() clause at the class-level causes an EmptyStackException
Abc started on Thu Jun 24 08:46:02 BST 2004
PASS: a before() clause at the class-level causes an EmptyStackException()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 59 failed (check: 30), 177 passed (check: 45), 0 skipped.
Executing test 237 (errors): an after() clause at the class-level causes an EmptyStackException
Abc started on Thu Jun 24 08:46:06 BST 2004
PASS: an after() clause at the class-level causes an EmptyStackException()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 59 failed (check: 30), 178 passed (check: 46), 0 skipped.
Executing test 238 (errors): an around() clause at the class-level causes an EmptyStackException
Abc started on Thu Jun 24 08:46:09 BST 2004
PASS: an around() clause at the class-level causes an EmptyStackException()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 59 failed (check: 30), 179 passed (check: 47), 0 skipped.
Executing test 239 (errors): Crashes when a cast is within another cast
Abc started on Thu Jun 24 08:46:13 BST 2004
PASS: Crashes when a cast is within another cast()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 59 failed (check: 30), 180 passed (check: 48), 0 skipped.
Executing test 240 (errors): Crashes when a cast of the form )int) appears
Failed. Current status: 60 failed (check: 31), 180 passed (check: 48), 0 skipped.
Executing test 241 (errors): Crashes when the closing brace is reversed
Failed. Current status: 61 failed (check: 32), 180 passed (check: 48), 0 skipped.
Executing test 242 (errors): Crashes when a method name is missing in a call -- e.g. 'System.out.();'
Abc started on Thu Jun 24 08:46:23 BST 2004
PASS: Crashes when a method name is missing in a call -- e.g. 'System.out.();'()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 181 passed (check: 49), 0 skipped.
Executing test 243 (errors): Crashes when a bad r-value appears.
Abc started on Thu Jun 24 08:46:27 BST 2004
PASS: Crashes when a bad r-value appears.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 182 passed (check: 50), 0 skipped.
Executing test 244 (errors): Two underscores as a variables causes a crash
Abc started on Thu Jun 24 08:46:30 BST 2004
PASS: Two underscores as a variables causes a crash()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 183 passed (check: 51), 0 skipped.
Executing test 245 (errors): Crashes when assigning to a final static in an intializer and declaration
Abc started on Thu Jun 24 08:46:34 BST 2004
<<<< FinalStatic.java >>>>
import org.aspectj.testing.*;

public class FinalStatic {
    public static void main(java.lang.String[] args) {
        new FinalStatic().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(false,
                                         "Shouldn\'t have compiled");
    }
    
    static final int i = -1;
    
    { FinalStatic/*FinalStatic*/.i = 13; }
    
    public FinalStatic() { super(); }
}
PASS: Crashes when assigning to a final static in an intializer and declaration()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 184 passed (check: 52), 0 skipped.
Executing test 246 (errors): Crashes when two dots appear instead of one
Abc started on Thu Jun 24 08:46:38 BST 2004
PASS: Crashes when two dots appear instead of one()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 185 passed (check: 53), 0 skipped.
Executing test 247 (errors): Crashes when there're stray dots
Abc started on Thu Jun 24 08:46:41 BST 2004
PASS: Crashes when there're stray dots()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 61 failed (check: 32), 186 passed (check: 54), 0 skipped.
Executing test 248 (errors): Stray characters cause a crash
Failed. Current status: 62 failed (check: 33), 186 passed (check: 54), 0 skipped.
Executing test 249 (errors): Colon instead of a semi-colon causes a crash
Abc started on Thu Jun 24 08:46:49 BST 2004
PASS: Colon instead of a semi-colon causes a crash()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 62 failed (check: 33), 187 passed (check: 55), 0 skipped.
Executing test 250 (errors): type error in initializer caught by ajc, not javac
Abc started on Thu Jun 24 08:46:52 BST 2004
<<<< ArrayInitializerType.java >>>>
class ArrayInitializerType {
    int[] i = { 3, "xxx" };
    
    public ArrayInitializerType() { super(); }
}
PASS: type error in initializer caught by ajc, not javac()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 62 failed (check: 33), 188 passed (check: 56), 0 skipped.
Executing test 251 (errors): Circular inheritance with classes causes a stack overflow.
Abc started on Thu Jun 24 08:46:56 BST 2004
PASS: Circular inheritance with classes causes a stack overflow.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 62 failed (check: 33), 189 passed (check: 57), 0 skipped.
Executing test 252 (errors): Doesn't detect cyclic inheritance of aspects.
Abc started on Thu Jun 24 08:47:00 BST 2004
PASS: Doesn't detect cyclic inheritance of aspects.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 62 failed (check: 33), 190 passed (check: 58), 0 skipped.
Executing test 253 (errors): Binds the pointcut formals to member variables instead of pointcut formals.
Failed. Current status: 63 failed (check: 34), 190 passed (check: 58), 0 skipped.
Executing test 254 (errors): ambiguous formal in formals pattern
Abc started on Thu Jun 24 08:47:06 BST 2004
<<<< AmbiguousFormal.java >>>>
public class AmbiguousFormal {
    public void m(int x, int y) {  }
    
    public AmbiguousFormal() { super(); }
}
aspect A {
    before(int n):
    execution (void (*).m(.., n, ..)) {
        java.lang.System/*java.lang.System*/.out.println(n);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: ambiguous formal in formals pattern()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 63 failed (check: 34), 191 passed (check: 59), 0 skipped.
Executing test 255 (errors): Missing ;
Abc started on Thu Jun 24 08:47:10 BST 2004
PASS: Missing ;()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 63 failed (check: 34), 192 passed (check: 60), 0 skipped.
Executing test 256 (errors): cast expressions should not allow casts between ifaces and array types
Failed. Current status: 64 failed (check: 35), 192 passed (check: 60), 0 skipped.
Executing test 257 (errors): parsing errors for various bad forms of NewArrayExprs.
Failed. Current status: 65 failed (check: 36), 192 passed (check: 60), 0 skipped.
Executing test 258 (errors): good error for field name instead of type name
Failed. Current status: 66 failed (check: 37), 192 passed (check: 60), 0 skipped.
Executing test 259 (errors): good error for bad field and inner class references
================================================
Breakdown of abc phases  (total: 6637 millisec.)
------------------------------------------------
[ 00.527% ] Init. of Soot:  35
[ 00.045% ] Loading Jars:  3
[ 76.315% ] Polyglot phases:  5065
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.693% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 06.012% ] Intertype Adjuster:  399
[ 06.840% ] Retrieving bodies:  454
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  22
[ 00.814% ] Compute advice lists:  54
[ 00.045% ] Intertype weave:  3
[ 00.557% ] Add aspect code:  37
[ 00.196% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.008% ] Soot Packs:  266
[ 03.556% ] Soot Writing Output:  236
================================================
Failed. Current status: 67 failed (check: 38), 192 passed (check: 60), 0 skipped.
Executing test 260 (errors): errors in aspect inheritance - 1
Abc started on Thu Jun 24 08:47:34 BST 2004
PASS: errors in aspect inheritance - 1()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 67 failed (check: 38), 193 passed (check: 61), 0 skipped.
Executing test 261 (errors): errors in aspect inheritance - 2
Failed. Current status: 68 failed (check: 39), 193 passed (check: 61), 0 skipped.
Executing test 262 (errors): errors in aspect inheritance - 3
Failed. Current status: 69 failed (check: 40), 193 passed (check: 61), 0 skipped.
Executing test 263 (errors): errors in aspect inheritance - 4
Failed. Current status: 70 failed (check: 41), 193 passed (check: 61), 0 skipped.
Executing test 264 (errors): Implementing a non-interface used to crash the compiler.
Abc started on Thu Jun 24 08:47:54 BST 2004
PASS: Implementing a non-interface used to crash the compiler.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 70 failed (check: 41), 194 passed (check: 62), 0 skipped.
Executing test 265 (errors): circular dominates leading to irresolvable advice precedence
Failed. Current status: 71 failed (check: 42), 194 passed (check: 62), 0 skipped.
Executing test 266 (errors): Should issue an error for using 'class' instead of 'aspect'
Abc started on Thu Jun 24 08:48:06 BST 2004
PASS: Should issue an error for using 'class' instead of 'aspect'()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 71 failed (check: 42), 195 passed (check: 63), 0 skipped.
Executing test 267 (errors): Should signal an error when we need an exposed value but don't provide it
Abc started on Thu Jun 24 08:48:10 BST 2004
<<<< MissingExposure.java >>>>
public class MissingExposure {
    public static void main(java.lang.String[] args) {
        C c = new C();
        org.aspectj.testing.Tester.check(false,
                                         "shouldn\'t have compiled");
    }
    
    public MissingExposure() { super(); }
}
class C {
    int _int = 13;
    
    public C() { super(); }
}
aspect Aspect {
    pointcut crash(byte _new) : set( int (C)._int) && args(int);
    
    before(byte _new): crash(_new) {  }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
PASS: Should signal an error when we need an exposed value but don't provide it()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 71 failed (check: 42), 196 passed (check: 64), 0 skipped.
Executing test 268 (errors): StackOverFlowException with circular +implements's.
Failed. Current status: 72 failed (check: 43), 196 passed (check: 64), 0 skipped.
Executing test 269 (errors): Introducing protected methods is causing a crash
Abc started on Thu Jun 24 08:48:17 BST 2004
<<<< ProtectedIntro.java >>>>
public class ProtectedIntro {
    public static void main(java.lang.String[] args) {
        new ProtectedIntro().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(false,
                                         "shouldn\'t have compiled");
    }
    
    public ProtectedIntro() { super(); }
}
class C {
    public C() { super(); }
}
aspect A {
    protected intertype void C.foo() {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: Introducing protected methods is causing a crash()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 72 failed (check: 43), 197 passed (check: 65), 0 skipped.
Executing test 270 (errors): Introducing protected fields is causing a crash
Abc started on Thu Jun 24 08:48:21 BST 2004
<<<< ProtectedFieldIntro.java >>>>
public class ProtectedFieldIntro {
    public static void main(java.lang.String[] args) {
        new ProtectedFieldIntro().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(false,
                                         "shouldn\'t have compiled");
    }
    
    public ProtectedFieldIntro() { super(); }
}
class C {
    public C() { super(); }
}
aspect A {
    protected int C.i = 13;
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: Introducing protected fields is causing a crash()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 72 failed (check: 43), 198 passed (check: 66), 0 skipped.
Executing test 271 (errors): two classes with the same fully-qualified names [eachjvm]
Failed. Current status: 73 failed (check: 44), 198 passed (check: 66), 0 skipped.
Executing test 272 (errors): Undefined pointcuts were throwing exceptions in 07b11 [callsto]
Abc started on Thu Jun 24 08:48:29 BST 2004
PASS: Undefined pointcuts were throwing exceptions in 07b11 [callsto]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 73 failed (check: 44), 199 passed (check: 67), 0 skipped.
Executing test 273 (errors): advice on abstract pointcuts
Failed. Current status: 74 failed (check: 45), 199 passed (check: 67), 0 skipped.
Executing test 274 (errors): Whoops, I forgot to put a class in the field access PCD.
Abc started on Thu Jun 24 08:48:41 BST 2004
PASS: Whoops, I forgot to put a class in the field access PCD.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 74 failed (check: 45), 200 passed (check: 68), 0 skipped.
Executing test 275 (errors): the arounds return something but there is no returns statement
Abc started on Thu Jun 24 08:48:44 BST 2004
<<<< MissingReturns.java >>>>
import org.aspectj.testing.Tester;

aspect MissingReturns {
    int baz(int a) { return 1; }
    
    void around ():
    this(MissingReturns) &&
      call(int (*).baz(int)) {
        return this.proceed();
    }
    
    pointcut cut() : this(MissingReturns) && call(int (*).baz(int));
    
    void around ():
    cut() {
        this.proceed();
        return 2;
    }
    
    public static MissingReturns aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MissingReturns() { super(); }
}
PASS: the arounds return something but there is no returns statement()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 74 failed (check: 45), 201 passed (check: 69), 0 skipped.
Executing test 276 (pureJava): simple tests of throws and for stmt typing
Abc started on Thu Jun 24 08:48:48 BST 2004
<<<< SimpleSpec.java >>>>
public class SimpleSpec {
    public void m() {
        throw new java.lang.RuntimeException();
        throw new java.lang.Integer(1);
        for (; ; ) {
            java.lang.System/*java.lang.System*/.out.println("hi");
        }
        for (; 1; ) {
            java.lang.System/*java.lang.System*/.out.println("hi");
        }
    }
    
    public SimpleSpec() { super(); }
}
PASS: simple tests of throws and for stmt typing()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 74 failed (check: 45), 202 passed (check: 70), 0 skipped.
Executing test 277 (errors): checking the contra-variant errors for typing of proceed
================================================
Breakdown of abc phases  (total: 6349 millisec.)
------------------------------------------------
[ 00.551% ] Init. of Soot:  35
[ 00.047% ] Loading Jars:  3
[ 80.154% ] Polyglot phases:  5089
[ 00.032% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  1
[ 00.788% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.567% ] Intertype Adjuster:  36
[ 07.529% ] Retrieving bodies:  478
[ 00.000% ] Weave Initializers:  0
[ 00.347% ] Load shadow types:  22
[ 01.166% ] Compute advice lists:  74
[ 00.047% ] Intertype weave:  3
[ 00.551% ] Add aspect code:  35
[ 00.205% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.536% ] Soot Packs:  288
[ 03.465% ] Soot Writing Output:  220
================================================
Failed. Current status: 75 failed (check: 46), 202 passed (check: 70), 0 skipped.
Executing test 278 (errors): error of no return statement detected not by ajc but by javac (line 4)
Abc started on Thu Jun 24 08:49:01 BST 2004
<<<< NoReturnStatementSimple.java >>>>
public class NoReturnStatementSimple {
    static java.lang.String noReturn() {  }
    
    public static void main(java.lang.String[] args) {  }
    
    public NoReturnStatementSimple() { super(); }
}
PASS: error of no return statement detected not by ajc but by javac (line 4)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 75 failed (check: 46), 203 passed (check: 71), 0 skipped.
Executing test 279 (errors): class and interface extension
Failed. Current status: 76 failed (check: 47), 203 passed (check: 71), 0 skipped.
Executing test 280 (errors): multiple conflicting introductions
Failed. Current status: 77 failed (check: 48), 203 passed (check: 71), 0 skipped.
Executing test 281 (errors): types in throws clauses
Abc started on Thu Jun 24 08:49:12 BST 2004
<<<< ThrowsClause.java >>>>
class C {
    public void m() throws java.lang.Integer {  }
    
    public C() throws C { super(); }
}
class Sup {
    public void m() {  }
    
    public Sup() { super(); }
}
class Sub extends Sup {
    public void m() throws java.lang.Exception {  }
    
    public Sub() { super(); }
}
PASS: types in throws clauses()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 77 failed (check: 48), 204 passed (check: 72), 0 skipped.
Executing test 282 (errors): referencing non-static pointcuts in outer aspects
Failed. Current status: 78 failed (check: 49), 204 passed (check: 72), 0 skipped.
Executing test 283 (errors): bad switch syntax
Abc started on Thu Jun 24 08:49:25 BST 2004
PASS: bad switch syntax()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 78 failed (check: 49), 205 passed (check: 73), 0 skipped.
Executing test 284 (new): javac correct compiler error if there is no return in around returning result
Abc started on Thu Jun 24 08:49:28 BST 2004
<<<< NoReturnInProceed.java >>>>
class BaseApp {
    int i;
    
    int get() { return this/*null*/.i; }
    
    public BaseApp() { super(); }
}
public class NoReturnInProceed {
    public static void main(java.lang.String[] args) {
        BaseApp target = new BaseApp();
        target.get();
    }
    
    public NoReturnInProceed() { super(); }
}
aspect Aspect {
    int around (): get( int (BaseApp).i) { this.proceed(); }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
PASS: javac correct compiler error if there is no return in around returning r...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 78 failed (check: 49), 206 passed (check: 74), 0 skipped.
Executing test 285 (errors): should give an error for introducing two members with the same name
Failed. Current status: 79 failed (check: 50), 206 passed (check: 74), 0 skipped.
Executing test 286 (errors): wimpy test for undeclared and uncaught exceptions
Failed. Current status: 80 failed (check: 51), 206 passed (check: 74), 0 skipped.
Executing test 287 (pureJava): test for not folding circular constants
Abc started on Thu Jun 24 08:49:40 BST 2004
<<<< CircularFolding.java >>>>
public class CircularFolding {
    static final int x = Hoo/*Hoo*/.x * 8;
    
    public static void main(java.lang.String[] args) {
        switch (args/*null*/.length) {
            case CircularFolding/*CircularFolding*/.x:
                java.lang.System/*java.lang.System*/.err.println("this");
            case Hoo/*Hoo*/.x:
                java.lang.System/*java.lang.System*/.err.println("shouldn\'t");
            case Goo/*Goo*/.x:
                java.lang.System/*java.lang.System*/.err.println("compile");
        }
    }
    
    public CircularFolding() { super(); }
}
class Hoo {
    static final int x = Goo/*Goo*/.x - 3;
    
    public Hoo() { super(); }
}
class Goo {
    static final int x = 2 + CircularFolding/*CircularFolding*/.x;
    
    public Goo() { super(); }
}
PASS: test for not folding circular constants()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 80 failed (check: 51), 207 passed (check: 75), 0 skipped.
Executing test 288 (pureJava): continue targets must be continuable
Failed. Current status: 81 failed (check: 52), 207 passed (check: 75), 0 skipped.
Executing test 289 (pureJava): qualified this to non-inner should be caught
Abc started on Thu Jun 24 08:49:48 BST 2004
<<<< BadQualifiedNew.java >>>>
public class BadQualifiedNew {
    public static void main(java.lang.String[] args) {
        new BadQualifiedNew().new Test();
    }
    
    static class Test {
        public Test() { super(); }
    }
    
    
    public BadQualifiedNew() { super(); }
}
PASS: qualified this to non-inner should be caught()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 81 failed (check: 52), 208 passed (check: 76), 0 skipped.
Executing test 290 (pureJava): Referencing various things from static contexts
Failed. Current status: 82 failed (check: 53), 208 passed (check: 76), 0 skipped.
Executing test 291 (new): Given non-matching TypePattern, CE flags use of non-introduced method rather than failure to introduce
Failed. Current status: 83 failed (check: 54), 208 passed (check: 76), 0 skipped.
Executing test 292 (new): Compiler should suggest using aspect when advice, pointcuts, or introduction is in a class
Failed. Current status: 84 failed (check: 55), 208 passed (check: 76), 0 skipped.
Executing test 293 (errors): Some expressions are illegal expression statements
Abc started on Thu Jun 24 08:50:04 BST 2004
PASS: Some expressions are illegal expression statements()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 84 failed (check: 55), 209 passed (check: 77), 0 skipped.
Executing test 294 (pureJava): illegal forward reference
================================================
Breakdown of abc phases  (total: 7312 millisec.)
------------------------------------------------
[ 00.492% ] Init. of Soot:  36
[ 00.041% ] Loading Jars:  3
[ 77.448% ] Polyglot phases:  5663
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.670% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 06.209% ] Intertype Adjuster:  454
[ 06.578% ] Retrieving bodies:  481
[ 00.000% ] Weave Initializers:  0
[ 00.315% ] Load shadow types:  23
[ 02.708% ] Compute advice lists:  198
[ 00.041% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.434% ] Soot Packs:  178
[ 02.735% ] Soot Writing Output:  200
================================================
Failed. Current status: 85 failed (check: 56), 209 passed (check: 77), 0 skipped.
Executing test 295 (errors): declare error working with pointcut and-not (amp,amp,bang)
================================================
Breakdown of abc phases  (total: 7122 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  37
[ 00.056% ] Loading Jars:  4
[ 74.530% ] Polyglot phases:  5308
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.730% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.534% ] Intertype Adjuster:  38
[ 06.908% ] Retrieving bodies:  492
[ 00.000% ] Weave Initializers:  0
[ 00.323% ] Load shadow types:  23
[ 02.148% ] Compute advice lists:  153
[ 00.042% ] Intertype weave:  3
[ 00.576% ] Add aspect code:  41
[ 00.197% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.917% ] Soot Packs:  279
[ 09.478% ] Soot Writing Output:  675
================================================
Failed. Current status: 86 failed (check: 57), 209 passed (check: 77), 0 skipped.
Executing test 296 (errors): protected accessibility
Failed. Current status: 87 failed (check: 58), 209 passed (check: 77), 0 skipped.
Executing test 297 (errors): parse-time illegal modifiers
Failed. Current status: 88 failed (check: 59), 209 passed (check: 77), 0 skipped.
Executing test 298 (errors): check-time illegal modifiers
Failed. Current status: 89 failed (check: 60), 209 passed (check: 77), 0 skipped.
Executing test 299 (errors): illegal synchronized stmts
Abc started on Thu Jun 24 08:50:39 BST 2004
PASS: illegal synchronized stmts()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 89 failed (check: 60), 210 passed (check: 78), 0 skipped.
Executing test 300 (pureJava): modifiers on interface members
Failed. Current status: 90 failed (check: 61), 210 passed (check: 78), 0 skipped.
Executing test 301 (new): aspect as member of interface (private and protected)
================================================
Breakdown of abc phases  (total: 7562 millisec.)
------------------------------------------------
[ 00.476% ] Init. of Soot:  36
[ 00.053% ] Loading Jars:  4
[ 75.099% ] Polyglot phases:  5679
[ 00.040% ] Resolve class names:  3
[ 00.026% ] Declare Parents:  2
[ 00.741% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.503% ] Intertype Adjuster:  38
[ 06.268% ] Retrieving bodies:  474
[ 00.000% ] Weave Initializers:  0
[ 00.291% ] Load shadow types:  22
[ 08.186% ] Compute advice lists:  619
[ 00.040% ] Intertype weave:  3
[ 00.635% ] Add aspect code:  48
[ 00.476% ] Weaving advice:  36
[ 00.000% ] Validate jimple:  0
[ 03.941% ] Soot Packs:  298
[ 03.227% ] Soot Writing Output:  244
================================================
Failed. Current status: 91 failed (check: 62), 210 passed (check: 78), 0 skipped.
Executing test 302 (errors): good errors (and not too many) for missing members
Failed. Current status: 92 failed (check: 63), 210 passed (check: 78), 0 skipped.
Executing test 303 (new): expecting compile failures with subclass narrowing scope of superclass methods or accessing private superclass variables
Failed. Current status: 93 failed (check: 64), 210 passed (check: 78), 0 skipped.
Executing test 304 (new): introduced inner interfaces - compile should fail to bind interface name outside of Aspect or if implementing method is not public
Failed. Current status: 94 failed (check: 65), 210 passed (check: 78), 0 skipped.
Executing test 305 (errors): aspects may not implement Serializable or Cloneable
Failed. Current status: 95 failed (check: 66), 210 passed (check: 78), 0 skipped.
Executing test 306 (errors): inner classes may not have static non-constant members
Abc started on Thu Jun 24 08:51:12 BST 2004
<<<< InnerMembers.java >>>>
public class InnerMembers {
    static class StaticI {
        static int x;
        
        static java.lang.String foo() { return "foo"; }
        
        public StaticI() { super(); }
    }
    
    
    class Inner {
        static final int CONST = 10;
        
        static final int NOT_CONST =
          new java.lang.Integer(10).intValue();
        
        static int x;
        
        static java.lang.String foo() { return "foo"; }
        
        static interface I {}
        
        
        public Inner() { super(); }
    }
    
    
    public static void m() {
        class Inner {
            static final int CONST = 10;
            
            static int x;
            
            static java.lang.String foo() { return "foo"; }
            
            public Inner() { super(); }
        }
        ;
    }
    
    public InnerMembers() { super(); }
}
PASS: inner classes may not have static non-constant members()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 95 failed (check: 66), 211 passed (check: 79), 0 skipped.
Executing test 307 (errors): explicit constructor calls can throw exceptions
Abc started on Thu Jun 24 08:51:16 BST 2004
<<<< ExplicitConstructorThrows.java >>>>
import java.io.IOException;

public class ExplicitConstructorThrows extends Base {
    public ExplicitConstructorThrows() { super(); }
}
class Base {
    Base() throws java.io.IOException { super(); }
}
class Sub1 extends Base {
    Sub1() { super(); }
}
class Sub2 extends Base {
    Sub2(java.lang.String s) { this(); }
    
    Sub2() throws java.io.IOException { super(); }
}
PASS: explicit constructor calls can throw exceptions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 95 failed (check: 66), 212 passed (check: 80), 0 skipped.
Executing test 308 (pureJava): flow analysis with local types
Failed. Current status: 96 failed (check: 67), 212 passed (check: 80), 0 skipped.
Executing test 309 (errors): bad proceed args good error messages
Abc started on Thu Jun 24 08:51:24 BST 2004
<<<< ProceedArgsCE.java >>>>
public class ProceedArgsCE {
    public static void main(java.lang.String[] args) {
        new ProceedArgsCE().go();
    }
    
    void go() {
        java.lang.System/*java.lang.System*/.out.println("... ");
    }
    
    public ProceedArgsCE() { super(); }
}
aspect A {
    void around (Object o): this(o) { this.proceed(); }
    
    void around (Object o): this(o) { this.proceed(2); }
    
    void around (Object o): this(o) { this.proceed("hi", 2); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: bad proceed args good error messages()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 96 failed (check: 67), 213 passed (check: 81), 0 skipped.
Executing test 310 (design/intro): initial tests for new introduction style
================================================
Breakdown of abc phases  (total: 8633 millisec.)
------------------------------------------------
[ 00.440% ] Init. of Soot:  38
[ 00.035% ] Loading Jars:  3
[ 69.802% ] Polyglot phases:  6026
[ 00.035% ] Resolve class names:  3
[ 00.035% ] Declare Parents:  3
[ 00.776% ] Recompute name pattern matches:  67
[ 00.000% ] Compute precedence relation:  0
[ 02.097% ] Intertype Adjuster:  181
[ 05.363% ] Retrieving bodies:  463
[ 00.151% ] Weave Initializers:  13
[ 00.255% ] Load shadow types:  22
[ 12.012% ] Compute advice lists:  1037
[ 00.035% ] Intertype weave:  3
[ 00.440% ] Add aspect code:  38
[ 00.174% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.935% ] Soot Packs:  426
[ 03.417% ] Soot Writing Output:  295
================================================
Abc started on Thu Jun 24 08:51:28 BST 2004
<<<< Simple.java >>>>
import org.aspectj.testing.Tester;

public class Simple {
    public static void main(java.lang.String[] args) {
        C c = new C();
        I i = (I) new C("hi");
        org.aspectj.testing.Tester.checkEqual(c.foo(), "foo:bar");
        org.aspectj.testing.Tester.checkEqual(i.mumble(),
                                              "mumble:foo:bar");
        org.aspectj.testing.Tester.checkEqual(A.Cm(), "from A");
        org.aspectj.testing.Tester.checkEqual(B.Cm(), "from B");
        c/*null*/.idata = "c-mumble";
        org.aspectj.testing.Tester.checkEqual(c/*null*/.idata,
                                              "c-mumble");
        org.aspectj.testing.Tester.checkEqual(i/*null*/.idata,
                                              "mumble");
        org.aspectj.testing.Tester.check("new A.C");
        org.aspectj.testing.Tester.check("new B.C");
    }
    
    public Simple() { super(); }
}
class C {
    public C() { super(); }
    
    public java.lang.String bar() { return "bar"; }
}
interface I {
    public abstract java.lang.String foo();
    
    public abstract java.lang.String bar();
}
aspect A {
    private java.lang.String C.data = "foo";
    
    private java.lang.String C.data1 = hostCthis/*<unknown>*/.data;
    
    public java.lang.String I.idata = "mumble";
    
    public intertype java.lang.String C.foo() {
        java.lang.String s = hostCthis/*<unknown>*/.data;
        org.aspectj.testing.Tester.checkEqual(s,
                                              hostCthis/*null*/.data1);
        return hostCthis/*null*/.data + ":" + bar();
    }
    
    declare parents : C implements I;
    
    public intertype java.lang.String I.mumble() {
        return hostIthis/*null*/.idata + ":" + foo();
    }
    
    private intertype java.lang.String C.m() { return "from A"; }
    
    public static java.lang.String Cm() { return new C(2).m(); }
    
    public C.new(java.lang.String s) { super(); }
    
    private C.new(int i) {
        super();
        org.aspectj.testing.Tester.note("new A.C");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
aspect B {
    private java.lang.String C.data = "B";
    
    private intertype java.lang.String C.m() {
        return "from " + hostCthis/*null*/.data;
    }
    
    public static java.lang.String Cm() { return new C(2).m(); }
    
    private C.new(int i) {
        super();
        org.aspectj.testing.Tester.note("new B.C");
    }
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
retrieve <Simple: void main(java.lang.String[])> from Simple
retrieve <Simple: void <init>()> from Simple
retrieve <C: java.lang.String foo()> from C
retrieve <C: java.lang.String bar()> from C
retrieve <C: java.lang.String mumble()> from C
retrieve <C: java.lang.String A$m$21()> from C
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String B$m$27()> from C
retrieve <C: void <init>(int,A)> from C
retrieve <C: void <init>(int,B)> from C
retrieve <C: java.lang.String get$idata$17()> from C
retrieve <C: java.lang.String set$idata$16(java.lang.String)> from C
retrieve <C: void <init>(java.lang.String)> from C
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String Cm()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: java.lang.String foo(C)> from A
retrieve <A: java.lang.String mumble(I)> from A
retrieve <A: java.lang.String A$m$21(C)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: java.lang.String init$data$30(C)> from A
retrieve <A: java.lang.String init$data1$31(C)> from A
retrieve <A: java.lang.String init$idata$32(I)> from A
retrieve <A: void new$C$33(C,java.lang.String)> from A
retrieve <A: void new$C$35(C,int,A)> from A
retrieve <B: java.lang.String init$data$36(C)> from B
retrieve <B: void new$C$38(C,int,B)> from B
retrieve <B: void <init>()> from B
retrieve <B: java.lang.String B$m$27(C)> from B
retrieve <B: java.lang.String Cm()> from B
retrieve <B: B aspectOf()> from B
retrieve <B: boolean hasAspect()> from B
Transforming I... 
Transforming Simple... 
Transforming B... 
Transforming A... 
Transforming C... 
Abc finished on Thu Jun 24 08:51:37 BST 2004. ( 0 min. 8 sec. )
PASS: initial tests for new introduction style()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 96 failed (check: 67), 214 passed (check: 81), 0 skipped.
Executing test 311 (design/intro): overriding of introduced methods and accessibility
================================================
Breakdown of abc phases  (total: 8170 millisec.)
------------------------------------------------
[ 00.453% ] Init. of Soot:  37
[ 00.049% ] Loading Jars:  4
[ 75.116% ] Polyglot phases:  6137
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.636% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 01.983% ] Intertype Adjuster:  162
[ 05.398% ] Retrieving bodies:  441
[ 00.000% ] Weave Initializers:  0
[ 00.343% ] Load shadow types:  28
[ 04.186% ] Compute advice lists:  342
[ 00.037% ] Intertype weave:  3
[ 00.453% ] Add aspect code:  37
[ 00.208% ] Weaving advice:  17
[ 00.000% ] Validate jimple:  0
[ 06.463% ] Soot Packs:  528
[ 04.627% ] Soot Writing Output:  378
================================================
Abc started on Thu Jun 24 08:51:39 BST 2004
<<<< Overriding.java >>>>
import org.aspectj.testing.Tester;

public class Overriding {
    public static void main(java.lang.String[] args) {
        SuperC sc = new C();
        org.aspectj.testing.Tester.checkEqual(sc.m(), "A2");
        org.aspectj.testing.Tester.checkEqual(A3.getMi(sc), "A3.I2");
        org.aspectj.testing.Tester.checkEqual(A4.getMi(sc), "A4.I2");
        org.aspectj.testing.Tester.checkEqual(A3.getM2(sc),
                                              "A3.Inner");
        org.aspectj.testing.Tester.checkEqual(A4.getM2(sc),
                                              "A4.Inner");
    }
    
    public Overriding() { super(); }
}
abstract class SuperC {
    public SuperC() { super(); }
}
class C extends SuperC {
    public C() { super(); }
}
class SubC extends C {
    public SubC() { super(); }
}
aspect A1 {
    abstract intertype java.lang.String SuperC.m();
    
    public static A1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A1() { super(); }
}
aspect A2 {
    intertype java.lang.String C.m() { return "A2"; }
    
    public static A2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A2() { super(); }
}
class A3 {
    static aspect I1 {
        private abstract intertype java.lang.String SuperC.mi();
        
        public static A3.I1 aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public I1() { super(); }
    }
    
    
    static aspect I2 {
        private intertype java.lang.String C.mi() { return "A3.I2"; }
        
        public static A3.I2 aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public I2() { super(); }
    }
    
    
    public static java.lang.String getMi(SuperC sc) {
        return sc.mi();
    }
    
    static aspect Inner {
        private abstract intertype java.lang.String SuperC.m2();
        
        private intertype java.lang.String C.m2() {
            return "A3.Inner";
        }
        
        public static A3.Inner aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public Inner() { super(); }
    }
    
    
    public static java.lang.String getM2(SuperC sc) {
        return sc.m2();
    }
    
    public A3() { super(); }
}
class A4 {
    static aspect I1 {
        private abstract intertype java.lang.String SuperC.mi();
        
        public static A4.I1 aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public I1() { super(); }
    }
    
    
    static aspect I2 {
        private intertype java.lang.String C.mi() { return "A4.I2"; }
        
        public static A4.I2 aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public I2() { super(); }
    }
    
    
    public static java.lang.String getMi(SuperC sc) {
        return sc.mi();
    }
    
    static aspect Inner {
        private abstract intertype java.lang.String SuperC.m2();
        
        private intertype java.lang.String C.m2() {
            return "A4.Inner";
        }
        
        public static A4.Inner aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public Inner() { super(); }
    }
    
    
    public static java.lang.String getM2(SuperC sc) {
        return sc.m2();
    }
    
    public A4() { super(); }
}
retrieve <Overriding: void <init>()> from Overriding
retrieve <Overriding: void main(java.lang.String[])> from Overriding
retrieve <SuperC: void <init>()> from SuperC
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String A1$m$10()> from C
retrieve <C: java.lang.String A3$I1$mi$14()> from C
retrieve <C: java.lang.String A3$Inner$m2$18()> from C
retrieve <C: java.lang.String A4$I1$mi$22()> from C
retrieve <C: java.lang.String A4$Inner$m2$26()> from C
retrieve <SubC: void <init>()> from SubC
retrieve <A1: void <init>()> from A1
retrieve <A1: A1 aspectOf()> from A1
retrieve <A1: boolean hasAspect()> from A1
retrieve <A2: void <init>()> from A2
retrieve <A2: java.lang.String A1$m$10(C)> from A2
retrieve <A2: A2 aspectOf()> from A2
retrieve <A2: boolean hasAspect()> from A2
retrieve <A3: void <init>()> from A3
retrieve <A3: java.lang.String getMi(SuperC)> from A3
retrieve <A3: java.lang.String getM2(SuperC)> from A3
retrieve <A3$I1: void <init>()> from A3$I1
retrieve <A3$I1: A3$I1 aspectOf()> from A3$I1
retrieve <A3$I1: boolean hasAspect()> from A3$I1
retrieve <A3$I2: java.lang.String A3$I1$mi$14(C)> from A3$I2
retrieve <A3$I2: A3$I2 aspectOf()> from A3$I2
retrieve <A3$I2: void <init>()> from A3$I2
retrieve <A3$I2: boolean hasAspect()> from A3$I2
retrieve <A3$Inner: A3$Inner aspectOf()> from A3$Inner
retrieve <A3$Inner: void <init>()> from A3$Inner
retrieve <A3$Inner: boolean hasAspect()> from A3$Inner
retrieve <A3$Inner: java.lang.String A3$Inner$m2$18(C)> from A3$Inner
retrieve <A4: void <init>()> from A4
retrieve <A4: java.lang.String getMi(SuperC)> from A4
retrieve <A4: java.lang.String getM2(SuperC)> from A4
retrieve <A4$I1: void <init>()> from A4$I1
retrieve <A4$I1: A4$I1 aspectOf()> from A4$I1
retrieve <A4$I1: boolean hasAspect()> from A4$I1
retrieve <A4$I2: void <init>()> from A4$I2
retrieve <A4$I2: java.lang.String A4$I1$mi$22(C)> from A4$I2
retrieve <A4$I2: A4$I2 aspectOf()> from A4$I2
retrieve <A4$I2: boolean hasAspect()> from A4$I2
retrieve <A4$Inner: java.lang.String A4$Inner$m2$26(C)> from A4$Inner
retrieve <A4$Inner: A4$Inner aspectOf()> from A4$Inner
retrieve <A4$Inner: void <init>()> from A4$Inner
retrieve <A4$Inner: boolean hasAspect()> from A4$Inner
Transforming SubC... 
Transforming A1... 
Transforming A4... 
Transforming A4$Inner... 
Transforming SuperC... 
Transforming A3... 
Transforming A3$I1... 
Transforming A4$I1... 
Transforming A2... 
Transforming C... 
Transforming A3$Inner... 
Transforming A3$I2... 
Transforming A4$I2... 
Transforming Overriding... 
Abc finished on Thu Jun 24 08:51:48 BST 2004. ( 0 min. 8 sec. )
PASS: overriding of introduced methods and accessibility()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 96 failed (check: 67), 215 passed (check: 81), 0 skipped.
Executing test 312 (design/intro): within and introductions behaves correctly
================================================
Breakdown of abc phases  (total: 8834 millisec.)
------------------------------------------------
[ 00.441% ] Init. of Soot:  39
[ 00.136% ] Loading Jars:  12
[ 68.327% ] Polyglot phases:  6036
[ 00.023% ] Resolve class names:  2
[ 00.034% ] Declare Parents:  3
[ 00.781% ] Recompute name pattern matches:  69
[ 00.000% ] Compute precedence relation:  0
[ 01.653% ] Intertype Adjuster:  146
[ 05.320% ] Retrieving bodies:  470
[ 00.000% ] Weave Initializers:  0
[ 00.260% ] Load shadow types:  23
[ 14.625% ] Compute advice lists:  1292
[ 00.045% ] Intertype weave:  4
[ 00.396% ] Add aspect code:  35
[ 00.204% ] Weaving advice:  18
[ 00.000% ] Validate jimple:  0
[ 04.483% ] Soot Packs:  396
[ 03.271% ] Soot Writing Output:  289
================================================
Failed. Current status: 97 failed (check: 67), 215 passed (check: 81), 0 skipped.
Executing test 313 (design/intro): introduction of static methods and fields on classes and interfaces
Failed. Current status: 98 failed (check: 67), 215 passed (check: 81), 0 skipped.
Executing test 314 (design/intro): correct inheritance of multiple concrete methods
================================================
Breakdown of abc phases  (total: 7893 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  38
[ 00.051% ] Loading Jars:  4
[ 74.256% ] Polyglot phases:  5861
[ 00.025% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.443% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 07.298% ] Intertype Adjuster:  576
[ 04.992% ] Retrieving bodies:  394
[ 00.013% ] Weave Initializers:  1
[ 00.279% ] Load shadow types:  22
[ 03.408% ] Compute advice lists:  269
[ 00.038% ] Intertype weave:  3
[ 00.431% ] Add aspect code:  34
[ 00.177% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 04.726% ] Soot Packs:  373
[ 03.370% ] Soot Writing Output:  266
================================================
Abc started on Thu Jun 24 08:52:07 BST 2004
<<<< MultiInheritCP.java >>>>
import org.aspectj.testing.Tester;

public class MultiInheritCP {
    public static void main(java.lang.String[] args) {
        C c = new C();
        org.aspectj.testing.Tester.checkEqual(c.fromRoot(), "Root");
        org.aspectj.testing.Tester.checkEqual(c.toString(), "I1");
        org.aspectj.testing.Tester.checkEqual(c.fromI2(), "I2");
        org.aspectj.testing.Tester.checkEqual(c.fromIRoot0(),
                                              "IRoot");
        org.aspectj.testing.Tester.checkEqual(c.fromIRoot1(), "I1");
        org.aspectj.testing.Tester.checkEqual(c.fromIRoot2(), "I2");
    }
    
    public MultiInheritCP() { super(); }
}
abstract class Root {
    public java.lang.String fromRoot() { return "Root"; }
    
    public abstract java.lang.String fromI2();
    
    public Root() { super(); }
}
class C extends Root implements I1, I2 {
    public C() { super(); }
}
interface IRoot {}
interface I1 extends IRoot {
    public abstract java.lang.String fromRoot();
}
interface I2 extends IRoot {}
aspect A {
    public intertype java.lang.String IRoot.fromIRoot0() {
        return "IRoot";
    }
    
    public intertype java.lang.String IRoot.fromIRoot1() {
        return "IRoot";
    }
    
    public intertype java.lang.String IRoot.fromIRoot2() {
        return "IRoot";
    }
    
    public intertype java.lang.String I1.toString() { return "I1"; }
    
    public abstract intertype java.lang.String I2.toString();
    
    public intertype java.lang.String I2.fromI2() { return "I2"; }
    
    public intertype java.lang.String I1.fromIRoot1() { return "I1"; }
    
    public intertype java.lang.String I2.fromIRoot2() { return "I2"; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <MultiInheritCP: void main(java.lang.String[])> from MultiInheritCP
retrieve <MultiInheritCP: void <init>()> from MultiInheritCP
retrieve <Root: java.lang.String fromRoot()> from Root
retrieve <Root: void <init>()> from Root
retrieve <C: java.lang.String fromIRoot0()> from C
retrieve <C: java.lang.String fromIRoot2()> from C
retrieve <C: java.lang.String fromIRoot1()> from C
retrieve <C: java.lang.String toString()> from C
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String fromI2()> from C
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String fromIRoot0(IRoot)> from A
retrieve <A: java.lang.String fromIRoot1(IRoot)> from A
retrieve <A: java.lang.String fromIRoot2(IRoot)> from A
retrieve <A: java.lang.String toString(I1)> from A
retrieve <A: java.lang.String fromI2(I2)> from A
retrieve <A: java.lang.String fromIRoot1(I1)> from A
retrieve <A: java.lang.String fromIRoot2(I2)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming I1... 
Transforming Root... 
Transforming A... 
Transforming IRoot... 
Transforming I2... 
Transforming C... 
Transforming MultiInheritCP... 
Abc finished on Thu Jun 24 08:52:15 BST 2004. ( 0 min. 7 sec. )
PASS: correct inheritance of multiple concrete methods()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 98 failed (check: 67), 216 passed (check: 81), 0 skipped.
Executing test 315 (design/intro): errors in inheritance of multiple concrete methods
Failed. Current status: 99 failed (check: 68), 216 passed (check: 81), 0 skipped.
Executing test 316 (design/intro): declared exceptions are checked correctly on intros (errors)
Failed. Current status: 100 failed (check: 69), 216 passed (check: 81), 0 skipped.
Executing test 317 (design/intro): declared exceptions are checked correctly on intros
================================================
Breakdown of abc phases  (total: 7175 millisec.)
------------------------------------------------
[ 00.530% ] Init. of Soot:  38
[ 00.056% ] Loading Jars:  4
[ 75.819% ] Polyglot phases:  5440
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.432% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 07.498% ] Intertype Adjuster:  538
[ 06.160% ] Retrieving bodies:  442
[ 00.000% ] Weave Initializers:  0
[ 00.334% ] Load shadow types:  24
[ 01.895% ] Compute advice lists:  136
[ 00.042% ] Intertype weave:  3
[ 00.376% ] Add aspect code:  27
[ 00.181% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.401% ] Soot Packs:  244
[ 03.220% ] Soot Writing Output:  231
================================================
Abc started on Thu Jun 24 08:52:26 BST 2004
<<<< ExceptionsCP.java >>>>
import org.aspectj.testing.Tester;
import java.io.IOException;

public class ExceptionsCP {
    public static void main(java.lang.String[] args) {
        C c = new C();
        try {
            c.foo();
        }
        catch (java.io.IOException io) {  }
        c.bar();
    }
    
    public ExceptionsCP() { super(); }
}
class Root {
    public void bar() {  }
    
    public Root() { super(); }
}
class C extends Root {
    public C() { super(); }
}
aspect A {
    public intertype void C.foo() throws java.io.IOException {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ExceptionsCP: void main(java.lang.String[])> from ExceptionsCP
retrieve <ExceptionsCP: void <init>()> from ExceptionsCP
retrieve <Root: void bar()> from Root
retrieve <Root: void <init>()> from Root
retrieve <C: void <init>()> from C
retrieve <C: void foo()> from C
retrieve <A: void foo(C)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming ExceptionsCP... 
Transforming Root... 
Transforming C... 
Abc finished on Thu Jun 24 08:52:33 BST 2004. ( 0 min. 7 sec. )
PASS: declared exceptions are checked correctly on intros()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 100 failed (check: 69), 217 passed (check: 81), 0 skipped.
Executing test 318 (design/reflect): Joinpoint is not created for foo(String) when before() advice is present.
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 8497 millisec.)
------------------------------------------------
[ 00.447% ] Init. of Soot:  38
[ 00.035% ] Loading Jars:  3
[ 70.554% ] Polyglot phases:  5995
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.600% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.694% ] Intertype Adjuster:  59
[ 06.096% ] Retrieving bodies:  518
[ 00.000% ] Weave Initializers:  0
[ 00.271% ] Load shadow types:  23
[ 04.872% ] Compute advice lists:  414
[ 00.035% ] Intertype weave:  3
[ 00.424% ] Add aspect code:  36
[ 02.036% ] Weaving advice:  173
[ 00.000% ] Validate jimple:  0
[ 10.298% ] Soot Packs:  875
[ 03.590% ] Soot Writing Output:  305
================================================
Abc started on Thu Jun 24 08:52:35 BST 2004
<<<< SimpleAround1.java >>>>
import org.aspectj.testing.*;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import java.util.*;

public class SimpleAround1 {
    public static void main(java.lang.String[] args) {
        new SimpleAround1().go();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.ran,
                                              "foo:goo:boo:",
                                              "advice didn\'t run");
    }
    
    void go() {
        foo("1");
        goo("2");
        boo("3");
    }
    
    void foo(java.lang.String s) {
        new java.lang.Integer(2).toString();
    }
    
    void goo(java.lang.String s) {  }
    
    void boo(java.lang.String s) {  }
    
    public SimpleAround1() { super(); }
}
aspect A {
    void around (String s):
    execution (void (*).*oo(String)) &&
      args(s) {
        this.proceed(s);
        org.aspectj.lang.JoinPoint jp = thisJoinPoint;
        A/*A*/.ran += jp.getSignature().getName() + ":";
    }
    
    static java.lang.String ran = "";
    
    before(): execution (void (*).foo(String)) {  }
    
    before():
    execution (void (*).goo(String)) {
        thisJoinPoint.getThis();
    }
    
    before(): call(* (Integer).*(..)) { thisJoinPoint.getThis(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <SimpleAround1: void main(java.lang.String[])> from SimpleAround1
retrieve <SimpleAround1: void go()> from SimpleAround1
retrieve <SimpleAround1: void foo(java.lang.String)> from SimpleAround1
retrieve <SimpleAround1: void goo(java.lang.String)> from SimpleAround1
retrieve <SimpleAround1: void boo(java.lang.String)> from SimpleAround1
retrieve <SimpleAround1: void <init>()> from SimpleAround1
retrieve <A: void around$0(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$3(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void proceed$4(java.lang.String)> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming SimpleAround1... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 08:52:44 BST 2004. ( 0 min. 8 sec. )
PASS: Joinpoint is not created for foo(String) when before() advice is present.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 100 failed (check: 69), 218 passed (check: 81), 0 skipped.
Executing test 319 (design/eachobject): more tests of eachobject with some difficult typing issues
================================================
Breakdown of abc phases  (total: 7699 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  40
[ 00.052% ] Loading Jars:  4
[ 72.880% ] Polyglot phases:  5611
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.623% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.494% ] Intertype Adjuster:  38
[ 06.767% ] Retrieving bodies:  521
[ 00.000% ] Weave Initializers:  0
[ 00.364% ] Load shadow types:  28
[ 03.832% ] Compute advice lists:  295
[ 00.039% ] Intertype weave:  3
[ 00.675% ] Add aspect code:  52
[ 00.688% ] Weaving advice:  53
[ 00.000% ] Validate jimple:  0
[ 07.494% ] Soot Packs:  577
[ 05.520% ] Soot Writing Output:  425
================================================
Abc started on Thu Jun 24 08:52:46 BST 2004
<<<< Tricky3.java >>>>
import org.aspectj.testing.Tester;

public class Tricky3 {
    public static void main(java.lang.String[] args) {
        C c = new SubC();
    }
    
    public Tricky3() { super(); }
}
class C {
    public C() { super(); }
}
class SubC extends C {
    void m() {  }
    
    public SubC() { super(); }
}
aspect A1 {
    after() returning(SubC sub):
    call((*).new(..)) {
        java.lang.System/*java.lang.System*/.out.println("new " +
                                                         sub);
    }
    
    public static A1 aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A1() { super(); }
}
aspect A2 {
    after() returning(SubC sub):
    call((*).new(..)) {
        java.lang.System/*java.lang.System*/.out.println("new " +
                                                         sub);
    }
    
    public static A2 aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A2() { super(); }
}
aspect A3 {
    after() returning(SubC sub):
    call((*).new(..)) {
        java.lang.System/*java.lang.System*/.out.println("new " +
                                                         sub);
    }
    
    public static A3 aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A3() { super(); }
}
retrieve <Tricky3: void <init>()> from Tricky3
retrieve <Tricky3: void main(java.lang.String[])> from Tricky3
retrieve <C: void <init>()> from C
retrieve <SubC: void m()> from SubC
retrieve <SubC: void <init>()> from SubC
retrieve <A1: void <init>()> from A1
retrieve <A1: boolean hasAspect(java.lang.Object)> from A1
retrieve <A1: void afterReturning$0(SubC)> from A1
retrieve <A1: A1 aspectOf(java.lang.Object)> from A1
retrieve <A2: void <init>()> from A2
retrieve <A2: void afterReturning$1(SubC)> from A2
retrieve <A2: A2 aspectOf(java.lang.Object)> from A2
retrieve <A2: boolean hasAspect(java.lang.Object)> from A2
retrieve <A3: void afterReturning$2(SubC)> from A3
retrieve <A3: A3 aspectOf(java.lang.Object)> from A3
retrieve <A3: void <init>()> from A3
retrieve <A3: boolean hasAspect(java.lang.Object)> from A3
Transforming SubC... 
Transforming A2... 
Transforming A1... 
Transforming A3... 
Transforming C... 
Transforming Tricky3... 
Transforming A1$abc$PerTarget... 
Transforming A2$abc$PerTarget... 
Transforming A3$abc$PerTarget... 
Abc finished on Thu Jun 24 08:52:54 BST 2004. ( 0 min. 7 sec. )
PASS: more tests of eachobject with some difficult typing issues()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 100 failed (check: 69), 219 passed (check: 81), 0 skipped.
Executing test 320 (design/eachobject): eachobject: eachobject(receptions(...)) [eachobject]
Failed. Current status: 101 failed (check: 69), 219 passed (check: 81), 0 skipped.
Executing test 321 (design/reflect): Checking new joinpoints
Failed. Current status: 102 failed (check: 69), 219 passed (check: 81), 0 skipped.
Executing test 322 (design/eachobject): eachobject: simple test [eachobject] (still)
Failed. Current status: 103 failed (check: 69), 219 passed (check: 81), 0 skipped.
Executing test 323 (design/intro): scope issues with introduction (needs more work)
================================================
Breakdown of abc phases  (total: 7033 millisec.)
------------------------------------------------
[ 00.526% ] Init. of Soot:  37
[ 00.057% ] Loading Jars:  4
[ 80.705% ] Polyglot phases:  5676
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.796% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.540% ] Intertype Adjuster:  38
[ 06.924% ] Retrieving bodies:  487
[ 00.128% ] Weave Initializers:  9
[ 00.498% ] Load shadow types:  35
[ 01.891% ] Compute advice lists:  133
[ 00.043% ] Intertype weave:  3
[ 00.555% ] Add aspect code:  39
[ 00.199% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.825% ] Soot Packs:  269
[ 03.256% ] Soot Writing Output:  229
================================================
Abc started on Thu Jun 24 08:53:19 BST 2004
<<<< ScopeIssues.java >>>>
package p1;

import org.aspectj.testing.Tester;
import java.math.*;

public aspect ScopeIssues {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(p1.C1/*p1.C1*/.bi,
                                              java.math.BigInteger/*java.math.BigInteger*/.ONE);
        org.aspectj.testing.Tester.checkEqual(p1.Helper/*p1.Helper*/.bi,
                                              java.math.BigInteger/*java.math.BigInteger*/.ONE);
    }
    
    private static java.math.BigInteger p1.C1.bi =
      java.math.BigInteger/*java.math.BigInteger*/.ONE;
    
    private static java.math.BigInteger p1.Helper.bi =
      java.math.BigInteger/*java.math.BigInteger*/.ONE;
    
    public static p1.ScopeIssues aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ScopeIssues() { super(); }
}
<<<< C1.java >>>>
package p1;

import java.util.*;

public class C1 {
    java.util.Map map = new java.util.HashMap();
    
    public C1() { super(); }
}
class Helper {
    java.util.List l = new java.util.LinkedList();
    
    public Helper() { super(); }
}
retrieve <p1.ScopeIssues: void main(java.lang.String[])> from p1.ScopeIssues
retrieve <p1.ScopeIssues: p1.ScopeIssues aspectOf()> from p1.ScopeIssues
retrieve <p1.ScopeIssues: boolean hasAspect()> from p1.ScopeIssues
retrieve <p1.ScopeIssues: void <init>()> from p1.ScopeIssues
retrieve <p1.ScopeIssues: java.math.BigInteger init$bi$6()> from p1.ScopeIssues
retrieve <p1.ScopeIssues: java.math.BigInteger init$bi$7()> from p1.ScopeIssues
retrieve <p1.C1: void <init>()> from p1.C1
retrieve <p1.Helper: void <init>()> from p1.Helper
Transforming p1.ScopeIssues... 
Transforming p1.Helper... 
Transforming p1.C1... 
Abc finished on Thu Jun 24 08:53:26 BST 2004. ( 0 min. 7 sec. )
PASS: scope issues with introduction (needs more work)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 103 failed (check: 69), 220 passed (check: 81), 0 skipped.
Executing test 324 (new): properly make choice between cast and parenthesis in parser
================================================
Breakdown of abc phases  (total: 7942 millisec.)
------------------------------------------------
[ 00.466% ] Init. of Soot:  37
[ 00.050% ] Loading Jars:  4
[ 71.443% ] Polyglot phases:  5674
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.693% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.478% ] Intertype Adjuster:  38
[ 06.447% ] Retrieving bodies:  512
[ 00.000% ] Weave Initializers:  0
[ 00.290% ] Load shadow types:  23
[ 10.350% ] Compute advice lists:  822
[ 00.038% ] Intertype weave:  3
[ 00.466% ] Add aspect code:  37
[ 01.977% ] Weaving advice:  157
[ 00.000% ] Validate jimple:  0
[ 03.891% ] Soot Packs:  309
[ 03.362% ] Soot Writing Output:  267
================================================
Failed. Current status: 104 failed (check: 69), 220 passed (check: 81), 0 skipped.
Executing test 325 (new): field from implemented interface not found in advice
================================================
Breakdown of abc phases  (total: 7680 millisec.)
------------------------------------------------
[ 00.495% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 73.411% ] Polyglot phases:  5638
[ 00.026% ] Resolve class names:  2
[ 00.156% ] Declare Parents:  12
[ 00.521% ] Recompute name pattern matches:  40
[ 00.000% ] Compute precedence relation:  0
[ 00.768% ] Intertype Adjuster:  59
[ 06.432% ] Retrieving bodies:  494
[ 00.013% ] Weave Initializers:  1
[ 00.299% ] Load shadow types:  23
[ 10.443% ] Compute advice lists:  802
[ 00.065% ] Intertype weave:  5
[ 00.417% ] Add aspect code:  32
[ 00.299% ] Weaving advice:  23
[ 00.000% ] Validate jimple:  0
[ 03.568% ] Soot Packs:  274
[ 03.047% ] Soot Writing Output:  234
================================================
Abc started on Thu Jun 24 08:53:40 BST 2004
<<<< FieldFromImplementsNotFound.java >>>>
import org.aspectj.testing.Tester;
import java.io.*;

interface HttpConstants {
    java.lang.String s = "s";
}
public aspect FieldFromImplementsNotFound implements HttpConstants {
    public static void main(java.lang.String[] args) { test(); }
    
    pointcut sendHeader() : call(void (LocalFile).sendHeader());
    
    static java.lang.String aspectField = "t";
    
    before():
    sendHeader() {
        FieldFromImplementsNotFound/*FieldFromImplementsNotFound*/.aspectField +=
          HttpConstants/*HttpConstants*/.s;
    }
    
    public static void test() {
        new LocalFile().sendHeader();
        org.aspectj.testing.Tester.checkEqual(FieldFromImplementsNotFound/*FieldFromImplementsNotFound*/.aspectField,
                                              "ts",
                                              "field + constant");
    }
    
    public static FieldFromImplementsNotFound aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public FieldFromImplementsNotFound() { super(); }
}
class LocalFile {
    void sendHeader() {  }
    
    public LocalFile() { super(); }
}
retrieve <HttpConstants: void <clinit>()> from HttpConstants
retrieve <FieldFromImplementsNotFound: void <init>()> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: void main(java.lang.String[])> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: void before$0()> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: void test()> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: FieldFromImplementsNotFound aspectOf()> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: boolean hasAspect()> from FieldFromImplementsNotFound
retrieve <FieldFromImplementsNotFound: void <clinit>()> from FieldFromImplementsNotFound
retrieve <LocalFile: void sendHeader()> from LocalFile
retrieve <LocalFile: void <init>()> from LocalFile
Transforming LocalFile... 
Transforming FieldFromImplementsNotFound... 
Transforming HttpConstants... 
Abc finished on Thu Jun 24 08:53:47 BST 2004. ( 0 min. 7 sec. )
PASS: field from implemented interface not found in advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 104 failed (check: 69), 221 passed (check: 81), 0 skipped.
Executing test 326 (new): make sure advice affects introduced methods and constructors
================================================
Breakdown of abc phases  (total: 7591 millisec.)
------------------------------------------------
[ 00.514% ] Init. of Soot:  39
[ 00.053% ] Loading Jars:  4
[ 75.576% ] Polyglot phases:  5737
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.790% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 02.134% ] Intertype Adjuster:  162
[ 10.842% ] Retrieving bodies:  823
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  23
[ 02.213% ] Compute advice lists:  168
[ 00.053% ] Intertype weave:  4
[ 00.461% ] Add aspect code:  35
[ 00.158% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.820% ] Soot Packs:  290
[ 03.030% ] Soot Writing Output:  230
================================================
Failed. Current status: 105 failed (check: 69), 221 passed (check: 81), 0 skipped.
Executing test 327 (new): new around construct
================================================
Breakdown of abc phases  (total: 8419 millisec.)
------------------------------------------------
[ 00.499% ] Init. of Soot:  42
[ 00.048% ] Loading Jars:  4
[ 73.607% ] Polyglot phases:  6197
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.594% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.451% ] Intertype Adjuster:  38
[ 06.521% ] Retrieving bodies:  549
[ 00.000% ] Weave Initializers:  0
[ 00.273% ] Load shadow types:  23
[ 09.063% ] Compute advice lists:  763
[ 00.036% ] Intertype weave:  3
[ 00.261% ] Add aspect code:  22
[ 01.045% ] Weaving advice:  88
[ 00.000% ] Validate jimple:  0
[ 04.324% ] Soot Packs:  364
[ 03.231% ] Soot Writing Output:  272
================================================
Abc started on Thu Jun 24 08:54:00 BST 2004
<<<< AroundAdvice.java >>>>
import org.aspectj.testing.Tester;

public aspect AroundAdvice {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Foo().foo(5),
                                              1 + 2 + 3 + 4 +
                                              5,
                                              "sum");
        org.aspectj.testing.Tester.checkEqual(new Foo().bar(),
                                              "overridden",
                                              "bar()");
    }
    
    pointcut fooCut(int n) :
    target(Foo) && call(int (*).foo(int)) &&
      args(n);
    
    int around (int n):
    fooCut(n) {
        int N = n;
        int sum = 0;
        for (int i = 0; i < N; i++) {
            n = i;
            int ret = this.proceed(n);
            sum += ret;
        }
        return sum;
    }
    
    String around ():
    within(AroundAdvice) &&
      call(String (*).bar()) {
        return "overridden";
    }
    
    public static AroundAdvice aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AroundAdvice() { super(); }
}
class Foo {
    public int foo(int x) { return x + 1; }
    
    public java.lang.String bar() { return "bar()"; }
    
    public Foo() { super(); }
}
retrieve <AroundAdvice: void <init>()> from AroundAdvice
retrieve <AroundAdvice: void main(java.lang.String[])> from AroundAdvice
retrieve <AroundAdvice: void test()> from AroundAdvice
retrieve <AroundAdvice: int around$0(int)> from AroundAdvice
retrieve <AroundAdvice: java.lang.String around$1()> from AroundAdvice
retrieve <AroundAdvice: AroundAdvice aspectOf()> from AroundAdvice
retrieve <AroundAdvice: boolean hasAspect()> from AroundAdvice
retrieve <AroundAdvice: int proceed$2(int)> from AroundAdvice
retrieve <AroundAdvice: java.lang.String proceed$3()> from AroundAdvice
retrieve <Foo: int foo(int)> from Foo
retrieve <Foo: java.lang.String bar()> from Foo
retrieve <Foo: void <init>()> from Foo
Transforming Foo... 
Transforming AroundAdvice... 
Transforming abc$access$AroundAdvice$around$0... 
Transforming abc$access$AroundAdvice$around$1... 
Abc finished on Thu Jun 24 08:54:09 BST 2004. ( 0 min. 8 sec. )
PASS: new around construct()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 105 failed (check: 69), 222 passed (check: 81), 0 skipped.
Executing test 328 (new): aspect redefines a parameter
================================================
Breakdown of abc phases  (total: 7491 millisec.)
------------------------------------------------
[ 00.494% ] Init. of Soot:  37
[ 00.040% ] Loading Jars:  3
[ 74.209% ] Polyglot phases:  5559
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.761% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.494% ] Intertype Adjuster:  37
[ 12.241% ] Retrieving bodies:  917
[ 00.000% ] Weave Initializers:  0
[ 01.762% ] Load shadow types:  132
[ 02.670% ] Compute advice lists:  200
[ 00.040% ] Intertype weave:  3
[ 00.601% ] Add aspect code:  45
[ 00.174% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.578% ] Soot Packs:  268
[ 02.883% ] Soot Writing Output:  216
================================================
Abc started on Thu Jun 24 08:54:11 BST 2004
<<<< AspectRedefinesParam.java >>>>
import org.aspectj.testing.Tester;

public aspect AspectRedefinesParam {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Foo().b("a"),
                                              "a",
                                              "b(\'a\')");
    }
    
    pointcut ccut(java.lang.String s) :
    this(Foo) && call(String (*).b(String)) &&
      args(s);
    
    before(String methodString):
    ccut(methodString) {
        java.lang.String s;
        s = "b";
        methodString += s;
    }
    
    public static AspectRedefinesParam aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectRedefinesParam() { super(); }
}
class Foo {
    java.lang.String b(java.lang.String s) { return s; }
    
    public Foo() { super(); }
}
retrieve <AspectRedefinesParam: void main(java.lang.String[])> from AspectRedefinesParam
retrieve <AspectRedefinesParam: void test()> from AspectRedefinesParam
retrieve <AspectRedefinesParam: void before$0(java.lang.String)> from AspectRedefinesParam
retrieve <AspectRedefinesParam: AspectRedefinesParam aspectOf()> from AspectRedefinesParam
retrieve <AspectRedefinesParam: boolean hasAspect()> from AspectRedefinesParam
retrieve <AspectRedefinesParam: void <init>()> from AspectRedefinesParam
retrieve <Foo: java.lang.String b(java.lang.String)> from Foo
retrieve <Foo: void <init>()> from Foo
Transforming AspectRedefinesParam... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:54:19 BST 2004. ( 0 min. 7 sec. )
PASS: aspect redefines a parameter()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 105 failed (check: 69), 223 passed (check: 81), 0 skipped.
Executing test 329 (new): introducing extends and implements
Failed. Current status: 106 failed (check: 69), 223 passed (check: 81), 0 skipped.
Executing test 330 (new): (related) aspect on interface
================================================
Breakdown of abc phases  (total: 7707 millisec.)
------------------------------------------------
[ 00.480% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 73.881% ] Polyglot phases:  5694
[ 00.039% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.714% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.467% ] Intertype Adjuster:  36
[ 06.656% ] Retrieving bodies:  513
[ 00.000% ] Weave Initializers:  0
[ 00.298% ] Load shadow types:  23
[ 03.412% ] Compute advice lists:  263
[ 00.052% ] Intertype weave:  4
[ 00.506% ] Add aspect code:  39
[ 00.376% ] Weaving advice:  29
[ 00.000% ] Validate jimple:  0
[ 03.854% ] Soot Packs:  297
[ 09.212% ] Soot Writing Output:  710
================================================
Abc started on Thu Jun 24 08:54:25 BST 2004
<<<< AspectOnInterface.java >>>>
import org.aspectj.testing.Tester;

public aspect AspectOnInterface {
    before(I1 i1):
    target(i1) &&
      call(String (*).process()) {
        i1.addToS("-advised");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        ConcreteC1 c1 = new ConcreteC1();
        org.aspectj.testing.Tester.checkEqual(c1.process(),
                                              "foo-advised-processed",
                                              "");
    }
    
    public static AspectOnInterface aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectOnInterface() { super(); }
}
interface I1 {
    public abstract void addToS(java.lang.String newS);
    
    public abstract java.lang.String process();
}
class ConcreteC1 implements I1 {
    java.lang.String s = "foo";
    
    public void addToS(java.lang.String newS) {
        this/*null*/.s += newS;
    }
    
    public java.lang.String process() {
        return this/*null*/.s + "-processed";
    }
    
    public ConcreteC1() { super(); }
}
retrieve <AspectOnInterface: boolean hasAspect()> from AspectOnInterface
retrieve <AspectOnInterface: void <init>()> from AspectOnInterface
retrieve <AspectOnInterface: void before$0(I1)> from AspectOnInterface
retrieve <AspectOnInterface: void main(java.lang.String[])> from AspectOnInterface
retrieve <AspectOnInterface: void test()> from AspectOnInterface
retrieve <AspectOnInterface: AspectOnInterface aspectOf()> from AspectOnInterface
retrieve <ConcreteC1: void addToS(java.lang.String)> from ConcreteC1
retrieve <ConcreteC1: java.lang.String process()> from ConcreteC1
retrieve <ConcreteC1: void <init>()> from ConcreteC1
Transforming I1... 
Transforming ConcreteC1... 
Transforming AspectOnInterface... 
Abc finished on Thu Jun 24 08:54:33 BST 2004. ( 0 min. 7 sec. )
PASS: (related) aspect on interface()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 106 failed (check: 69), 224 passed (check: 81), 0 skipped.
Executing test 331 (new): advice and package visibility
Failed. Current status: 107 failed (check: 69), 224 passed (check: 81), 0 skipped.
Executing test 332 (new): advice and package visibility
Failed. Current status: 108 failed (check: 70), 224 passed (check: 81), 0 skipped.
Executing test 333 (new): advice on implied empty constructor
================================================
Breakdown of abc phases  (total: 7788 millisec.)
------------------------------------------------
[ 00.488% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 74.461% ] Polyglot phases:  5799
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.770% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 00.488% ] Intertype Adjuster:  38
[ 06.523% ] Retrieving bodies:  508
[ 00.000% ] Weave Initializers:  0
[ 00.295% ] Load shadow types:  23
[ 08.731% ] Compute advice lists:  680
[ 00.039% ] Intertype weave:  3
[ 00.745% ] Add aspect code:  58
[ 00.462% ] Weaving advice:  36
[ 00.000% ] Validate jimple:  0
[ 03.891% ] Soot Packs:  303
[ 03.017% ] Soot Writing Output:  235
================================================
Abc started on Thu Jun 24 08:54:41 BST 2004
<<<< AdviceOnEmptyConstructor.java >>>>
import org.aspectj.testing.Tester;

public aspect AdviceOnEmptyConstructor {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new C()/*<unknown>*/.value,
                                              "afterInit:foo",
                                              "new C");
        org.aspectj.testing.Tester.checkEqual(new C1(0)/*<unknown>*/.value,
                                              "foo",
                                              "new C1");
    }
    
    after() returning(C c):
    call((C).new()) {
        c/*null*/.value = "afterInit:" + c/*null*/.value;
    }
    
    after() returning(C1 c1):
    call((C1).new()) {
        c1/*null*/.value = "afterInit:" + c1/*null*/.value;
    }
    
    public static AdviceOnEmptyConstructor aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AdviceOnEmptyConstructor() { super(); }
}
class C {
    public java.lang.String value = "foo";
    
    public C() { super(); }
}
class C1 {
    public java.lang.String value = "foo";
    
    public C1(int dummy) { super(); }
}
retrieve <AdviceOnEmptyConstructor: void <init>()> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: void main(java.lang.String[])> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: void test()> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: void afterReturning$0(C)> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: void afterReturning$1(C1)> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: AdviceOnEmptyConstructor aspectOf()> from AdviceOnEmptyConstructor
retrieve <AdviceOnEmptyConstructor: boolean hasAspect()> from AdviceOnEmptyConstructor
retrieve <C: void <init>()> from C
retrieve <C1: void <init>(int)> from C1
Transforming C... 
Transforming AdviceOnEmptyConstructor... 
Transforming C1... 
Abc finished on Thu Jun 24 08:54:49 BST 2004. ( 0 min. 7 sec. )
PASS: advice on implied empty constructor()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 225 passed (check: 81), 0 skipped.
Executing test 334 (new): advice on * *(..) not mapping to initializers
================================================
Breakdown of abc phases  (total: 7187 millisec.)
------------------------------------------------
[ 00.529% ] Init. of Soot:  38
[ 00.056% ] Loading Jars:  4
[ 79.699% ] Polyglot phases:  5728
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.612% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.821% ] Intertype Adjuster:  59
[ 06.762% ] Retrieving bodies:  486
[ 00.000% ] Weave Initializers:  0
[ 00.306% ] Load shadow types:  22
[ 03.033% ] Compute advice lists:  218
[ 00.042% ] Intertype weave:  3
[ 00.501% ] Add aspect code:  36
[ 00.376% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 03.854% ] Soot Packs:  277
[ 03.353% ] Soot Writing Output:  241
================================================
Abc started on Thu Jun 24 08:54:51 BST 2004
<<<< InitializerAdvice.java >>>>
import org.aspectj.testing.Tester;

public aspect InitializerAdvice {
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(Foo.getStaticField(),
                                              "initialized",
                                              "static");
        org.aspectj.testing.Tester.checkEqual(new Foo().getInstanceField(),
                                              "initialized",
                                              "instance");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    before():
    call(* (*).*(..)) &&
      this(Foo) {
        java.lang.System/*java.lang.System*/.out.println("entering");
    }
    
    public static InitializerAdvice aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public InitializerAdvice() { super(); }
}
class Foo {
    static java.lang.String staticField = "";
    
    static { Foo/*Foo*/.staticField = "initialized"; }
    
    java.lang.String instanceField = "";
    
    { this/*null*/.instanceField = "initialized"; }
    
    public static java.lang.String getStaticField() {
        return Foo/*Foo*/.staticField;
    }
    
    public java.lang.String getInstanceField() {
        return this/*null*/.instanceField;
    }
    
    public Foo() { super(); }
}
retrieve <InitializerAdvice: void test()> from InitializerAdvice
retrieve <InitializerAdvice: void main(java.lang.String[])> from InitializerAdvice
retrieve <InitializerAdvice: void before$0()> from InitializerAdvice
retrieve <InitializerAdvice: InitializerAdvice aspectOf()> from InitializerAdvice
retrieve <InitializerAdvice: boolean hasAspect()> from InitializerAdvice
retrieve <InitializerAdvice: void <init>()> from InitializerAdvice
retrieve <Foo: java.lang.String getInstanceField()> from Foo
retrieve <Foo: void <clinit>()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: java.lang.String getStaticField()> from Foo
Transforming InitializerAdvice... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:54:58 BST 2004. ( 0 min. 7 sec. )
PASS: advice on * *(..) not mapping to initializers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 108 failed (check: 70), 226 passed (check: 81), 0 skipped.
Executing test 335 (new): three type declarations in the scope of an advice
================================================
Breakdown of abc phases  (total: 7606 millisec.)
------------------------------------------------
[ 00.486% ] Init. of Soot:  37
[ 00.053% ] Loading Jars:  4
[ 74.323% ] Polyglot phases:  5653
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.605% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.828% ] Intertype Adjuster:  63
[ 06.771% ] Retrieving bodies:  515
[ 00.000% ] Weave Initializers:  0
[ 00.316% ] Load shadow types:  24
[ 02.511% ] Compute advice lists:  191
[ 00.039% ] Intertype weave:  3
[ 00.592% ] Add aspect code:  45
[ 00.171% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.834% ] Soot Packs:  748
[ 03.418% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 08:55:01 BST 2004
<<<< TypeDeclInAdvice.java >>>>
import org.aspectj.testing.Tester;

public class TypeDeclInAdvice {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo foo = new Foo();
        foo.m();
    }
    
    public TypeDeclInAdvice() { super(); }
}
aspect A {
    void around ():
    this(Foo) &&
      call(void (*).m(..)) {
        class Internal {
            int val() { return 1; }
            
            public Internal() { super(); }
        }
        ;
        int i = 0;
        Internal j;
        i = 1;
        j = new Internal();
        this.proceed();
        org.aspectj.testing.Tester.checkEqual(i, 1, "i");
        org.aspectj.testing.Tester.checkEqual(j.val(), 1, "j.val()");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class Foo {
    Foo() { super(); }
    
    void m() {  }
}
retrieve <TypeDeclInAdvice: void main(java.lang.String[])> from TypeDeclInAdvice
retrieve <TypeDeclInAdvice: void test()> from TypeDeclInAdvice
retrieve <TypeDeclInAdvice: void <init>()> from TypeDeclInAdvice
retrieve <A: void around$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void proceed$1()> from A
retrieve <A$1Internal: void <init>(A)> from A$1Internal
retrieve <A$1Internal: int val()> from A$1Internal
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void m()> from Foo
retrieve <A$1Internal: void <init>(A)> from A$1Internal
retrieve <A$1Internal: int val()> from A$1Internal
Transforming TypeDeclInAdvice... 
Transforming A... 
Transforming Foo... 
Transforming A$1Internal... 
Abc finished on Thu Jun 24 08:55:09 BST 2004. ( 0 min. 7 sec. )
PASS: three type declarations in the scope of an advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 227 passed (check: 81), 0 skipped.
Executing test 336 (new): introduction fails on class with an inner class that extends or implements something
================================================
Breakdown of abc phases  (total: 7705 millisec.)
------------------------------------------------
[ 00.493% ] Init. of Soot:  38
[ 00.052% ] Loading Jars:  4
[ 73.861% ] Polyglot phases:  5691
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.714% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.493% ] Intertype Adjuster:  38
[ 06.321% ] Retrieving bodies:  487
[ 00.000% ] Weave Initializers:  0
[ 00.286% ] Load shadow types:  22
[ 07.982% ] Compute advice lists:  615
[ 00.052% ] Intertype weave:  4
[ 00.454% ] Add aspect code:  35
[ 00.558% ] Weaving advice:  43
[ 00.000% ] Validate jimple:  0
[ 05.360% ] Soot Packs:  413
[ 03.323% ] Soot Writing Output:  256
================================================
Abc started on Thu Jun 24 08:55:11 BST 2004
<<<< IntroductionFailsWithInnerClass.java >>>>
import org.aspectj.testing.Tester;

public aspect IntroductionFailsWithInnerClass {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new M()/*<unknown>*/.s,
                                              "m",
                                              "introduction");
    }
    
    public java.lang.String M.s;
    
    after(M m):
    target(m) &&
      execution ((*).new(..)) {
        m/*null*/.s = "m";
    }
    
    public static IntroductionFailsWithInnerClass aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public IntroductionFailsWithInnerClass() { super(); }
}
class M {
    class LabeledPairLayout extends java.lang.Object {
        public LabeledPairLayout() { super(); }
    }
    
    
    public M() { super(); }
}
retrieve <IntroductionFailsWithInnerClass: void main(java.lang.String[])> from IntroductionFailsWithInnerClass
retrieve <IntroductionFailsWithInnerClass: void test()> from IntroductionFailsWithInnerClass
retrieve <IntroductionFailsWithInnerClass: void after$1(M)> from IntroductionFailsWithInnerClass
retrieve <IntroductionFailsWithInnerClass: IntroductionFailsWithInnerClass aspectOf()> from IntroductionFailsWithInnerClass
retrieve <IntroductionFailsWithInnerClass: boolean hasAspect()> from IntroductionFailsWithInnerClass
retrieve <IntroductionFailsWithInnerClass: void <init>()> from IntroductionFailsWithInnerClass
retrieve <M: void <init>()> from M
retrieve <M$LabeledPairLayout: void <init>(M)> from M$LabeledPairLayout
Transforming IntroductionFailsWithInnerClass... 
Transforming M... 
Transforming M$LabeledPairLayout... 
Abc finished on Thu Jun 24 08:55:19 BST 2004. ( 0 min. 7 sec. )
PASS: introduction fails on class with an inner class that extends or implemen...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 228 passed (check: 81), 0 skipped.
Executing test 337 (new): checks that methods are introduced on the topmost class implemented
================================================
Breakdown of abc phases  (total: 7898 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 78.362% ] Polyglot phases:  6189
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.722% ] Recompute name pattern matches:  57
[ 00.013% ] Compute precedence relation:  1
[ 01.773% ] Intertype Adjuster:  140
[ 06.115% ] Retrieving bodies:  483
[ 00.000% ] Weave Initializers:  0
[ 00.291% ] Load shadow types:  23
[ 03.912% ] Compute advice lists:  309
[ 00.038% ] Intertype weave:  3
[ 00.355% ] Add aspect code:  28
[ 00.177% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 04.381% ] Soot Packs:  346
[ 03.292% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 08:55:22 BST 2004
<<<< TopmostImplements.java >>>>
import org.aspectj.testing.Tester;
import java.lang.reflect.Method;

public class TopmostImplements {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        BC1 bc1 = new BC1();
        BC2 bc2 = new BC2();
        java.lang.String m1 = "";
        java.lang.String m2 = "";
        try {
            m1 = bc1.getClass().getMethod("m1", null).toString();
            m2 = bc2.getClass().getMethod("m1", null).toString();
        }
        catch (java.lang.NoSuchMethodException nsme) {
            org.aspectj.testing.Tester.check(false,
                                             "method not found");
        }
        org.aspectj.testing.Tester.checkEqual(m1,
                                              "public java.lang.String B.m1()",
                                              "from extends, implements");
        org.aspectj.testing.Tester.checkEqual(m2,
                                              "public java.lang.String B.m1()",
                                              "from extends");
        org.aspectj.testing.Tester.checkEqual(bc1.m1(),
                                              "BC1",
                                              "from extends, implements");
        org.aspectj.testing.Tester.checkEqual(bc2.m1(),
                                              "BC2",
                                              "from extends");
    }
    
    public TopmostImplements() { super(); }
}
aspect Introducer {
    public intertype java.lang.String A.m1() { return getName(); }
    
    public static Introducer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Introducer() { super(); }
}
interface A {
    public abstract java.lang.String getName();
}
class B implements A {
    public java.lang.String getName() { return "B"; }
    
    public B() { super(); }
}
class BC1 extends B implements A {
    public java.lang.String getName() { return "BC1"; }
    
    public BC1() { super(); }
}
class BC2 extends B {
    public java.lang.String getName() { return "BC2"; }
    
    public BC2() { super(); }
}
retrieve <TopmostImplements: void main(java.lang.String[])> from TopmostImplements
retrieve <TopmostImplements: void test()> from TopmostImplements
retrieve <TopmostImplements: void <init>()> from TopmostImplements
retrieve <Introducer: void <init>()> from Introducer
retrieve <Introducer: java.lang.String m1(A)> from Introducer
retrieve <Introducer: Introducer aspectOf()> from Introducer
retrieve <Introducer: boolean hasAspect()> from Introducer
retrieve <B: java.lang.String getName()> from B
retrieve <B: void <init>()> from B
retrieve <B: java.lang.String m1()> from B
retrieve <BC1: java.lang.String getName()> from BC1
retrieve <BC1: void <init>()> from BC1
retrieve <BC2: java.lang.String getName()> from BC2
retrieve <BC2: void <init>()> from BC2
Transforming BC1... 
Transforming A... 
Transforming Introducer... 
Transforming BC2... 
Transforming B... 
Transforming TopmostImplements... 
Abc finished on Thu Jun 24 08:55:30 BST 2004. ( 0 min. 7 sec. )
PASS: checks that methods are introduced on the topmost class implemented()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 229 passed (check: 81), 0 skipped.
Executing test 338 (new/arndAdvRet): a couple different returns from around advice
================================================
Breakdown of abc phases  (total: 8006 millisec.)
------------------------------------------------
[ 00.475% ] Init. of Soot:  38
[ 00.050% ] Loading Jars:  4
[ 75.431% ] Polyglot phases:  6039
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.625% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.475% ] Intertype Adjuster:  38
[ 06.782% ] Retrieving bodies:  543
[ 00.000% ] Weave Initializers:  0
[ 00.350% ] Load shadow types:  28
[ 03.710% ] Compute advice lists:  297
[ 00.050% ] Intertype weave:  4
[ 00.462% ] Add aspect code:  37
[ 01.199% ] Weaving advice:  96
[ 00.012% ] Validate jimple:  1
[ 06.133% ] Soot Packs:  491
[ 04.197% ] Soot Writing Output:  336
================================================
Abc started on Thu Jun 24 08:55:32 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new Foo().doIt(),
                                              5,
                                              "min of 5 and 6");
        org.aspectj.testing.Tester.checkEqual(new Bar().doIt(),
                                              1,
                                              "min of 5 and 2");
    }
    
    public Driver() { super(); }
}
class Foo {
    public static int doIt() { return new Foo().bar(1, 2, 3); }
    
    int bar(int a, int b, int c) { return a * b * c; }
    
    public Foo() { super(); }
}
aspect FooAspect {
    pointcut cut() : target(Foo) && call(int (*).bar(int, int, int));
    
    int around ():
    cut() {
        int originalResult = this.proceed();
        return java.lang.Math.max(0,
                                  java.lang.Math.min(originalResult,
                                                     5));
    }
    
    public static FooAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public FooAspect() { super(); }
}
class Bar {
    public static int doIt() { return new Bar().bar(1, 2, 1); }
    
    int bar(int a, int b, int c) { return a * b * c; }
    
    public Bar() { super(); }
}
aspect BarAspect {
    pointcut cut(Bar b) :
    target(b) &&
      call(int (*).bar(int, int, int));
    
    int around (Bar b):
    cut(b) {
        int originalResult = this.proceed(b);
        return java.lang.Math.max(0,
                                  java.lang.Math.min(originalResult,
                                                     1));
    }
    
    public static BarAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public BarAspect() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Foo: int doIt()> from Foo
retrieve <Foo: int bar(int,int,int)> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <FooAspect: int around$0()> from FooAspect
retrieve <FooAspect: FooAspect aspectOf()> from FooAspect
retrieve <FooAspect: boolean hasAspect()> from FooAspect
retrieve <FooAspect: void <init>()> from FooAspect
retrieve <FooAspect: int proceed$2()> from FooAspect
retrieve <Bar: int doIt()> from Bar
retrieve <Bar: int bar(int,int,int)> from Bar
retrieve <Bar: void <init>()> from Bar
retrieve <BarAspect: int around$1(Bar)> from BarAspect
retrieve <BarAspect: BarAspect aspectOf()> from BarAspect
retrieve <BarAspect: boolean hasAspect()> from BarAspect
retrieve <BarAspect: void <init>()> from BarAspect
retrieve <BarAspect: int proceed$3(Bar)> from BarAspect
Transforming Foo... 
Transforming Bar... 
Transforming Driver... 
Transforming BarAspect... 
Transforming FooAspect... 
Transforming abc$access$FooAspect$around$0... 
Transforming abc$access$BarAspect$around$1... 
Abc finished on Thu Jun 24 08:55:40 BST 2004. ( 0 min. 8 sec. )
PASS: a couple different returns from around advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 230 passed (check: 81), 0 skipped.
Executing test 339 (new): member finally advice paired with signature advice
================================================
Breakdown of abc phases  (total: 7950 millisec.)
------------------------------------------------
[ 00.465% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 74.189% ] Polyglot phases:  5898
[ 00.038% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.642% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 06.365% ] Intertype Adjuster:  506
[ 07.597% ] Retrieving bodies:  604
[ 00.000% ] Weave Initializers:  0
[ 00.289% ] Load shadow types:  23
[ 02.289% ] Compute advice lists:  182
[ 00.038% ] Intertype weave:  3
[ 00.478% ] Add aspect code:  38
[ 00.629% ] Weaving advice:  50
[ 00.000% ] Validate jimple:  0
[ 03.799% ] Soot Packs:  302
[ 03.132% ] Soot Writing Output:  249
================================================
Abc started on Thu Jun 24 08:55:43 BST 2004
<<<< TryErrors.java >>>>
import org.aspectj.testing.Tester;

public class TryErrors {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Foo foo = new Foo();
        foo.bar();
        org.aspectj.testing.Tester.check(foo/*null*/.memberAdvised,
                                         "member advice happened");
        org.aspectj.testing.Tester.check(foo/*null*/.signatureAdvised,
                                         "signature advice happened");
    }
    
    public TryErrors() { super(); }
}
class Foo {
    boolean memberAdvised = false;
    
    boolean signatureAdvised = false;
    
    public void bar() { ; }
    
    public Foo() { super(); }
}
aspect A {
    after(Foo foo):
    target(foo) && within(Foo) &&
      execution (void (*).bar()) {
        foo/*null*/.memberAdvised = true;
    }
    
    before(Foo foo):
    target(foo) &&
      call(void (*).bar()) {
        foo/*null*/.signatureAdvised = true;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <TryErrors: void <init>()> from TryErrors
retrieve <TryErrors: void main(java.lang.String[])> from TryErrors
retrieve <TryErrors: void test()> from TryErrors
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void bar()> from Foo
retrieve <A: void after$0(Foo)> from A
retrieve <A: void before$1(Foo)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming TryErrors... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:55:51 BST 2004. ( 0 min. 8 sec. )
PASS: member finally advice paired with signature advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 231 passed (check: 81), 0 skipped.
Executing test 340 (new): aspect of eachobject(instanceof(Interface))
================================================
Breakdown of abc phases  (total: 7839 millisec.)
------------------------------------------------
[ 00.485% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 72.675% ] Polyglot phases:  5697
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.446% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.740% ] Intertype Adjuster:  58
[ 06.378% ] Retrieving bodies:  500
[ 00.000% ] Weave Initializers:  0
[ 00.293% ] Load shadow types:  23
[ 02.143% ] Compute advice lists:  168
[ 00.038% ] Intertype weave:  3
[ 00.421% ] Add aspect code:  33
[ 00.281% ] Weaving advice:  22
[ 00.000% ] Validate jimple:  0
[ 09.695% ] Soot Packs:  760
[ 06.315% ] Soot Writing Output:  495
================================================
Abc started on Thu Jun 24 08:55:54 BST 2004
<<<< AspectOfInterface.java >>>>
import org.aspectj.testing.Tester;

public class AspectOfInterface {
    public static void main(java.lang.String[] args) { test(); }
    
    public static boolean ranAdvice = false;
    
    public static void test() {
        new C().foo();
        org.aspectj.testing.Tester.check(AspectOfInterface/*AspectOfInterface*/.ranAdvice,
                                         "advice on interface");
    }
    
    public AspectOfInterface() { super(); }
}
interface I {
    public abstract void foo();
}
class C implements I {
    public void foo() {  }
    
    public C() { super(); }
}
aspect A {
    before():
    call(* (*).*(..)) {
        AspectOfInterface/*AspectOfInterface*/.ranAdvice = true;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AspectOfInterface: void main(java.lang.String[])> from AspectOfInterface
retrieve <AspectOfInterface: void test()> from AspectOfInterface
retrieve <AspectOfInterface: void <init>()> from AspectOfInterface
retrieve <AspectOfInterface: void <clinit>()> from AspectOfInterface
retrieve <C: void <init>()> from C
retrieve <C: void foo()> from C
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming AspectOfInterface... 
Transforming I... 
Transforming C... 
Transforming A... 
Abc finished on Thu Jun 24 08:56:02 BST 2004. ( 0 min. 7 sec. )
PASS: aspect of eachobject(instanceof(Interface))()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 232 passed (check: 81), 0 skipped.
Executing test 341 (new/finalMemInit): final member initialization broken with JDK before 1.1.8
================================================
Breakdown of abc phases  (total: 7530 millisec.)
------------------------------------------------
[ 00.505% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  3
[ 75.870% ] Polyglot phases:  5713
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.491% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 00.810% ] Intertype Adjuster:  61
[ 12.603% ] Retrieving bodies:  949
[ 00.000% ] Weave Initializers:  0
[ 00.292% ] Load shadow types:  22
[ 01.740% ] Compute advice lists:  131
[ 00.053% ] Intertype weave:  4
[ 00.664% ] Add aspect code:  50
[ 00.438% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 03.546% ] Soot Packs:  267
[ 02.895% ] Soot Writing Output:  218
================================================
Abc started on Thu Jun 24 08:56:04 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public aspect Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new C()/*<unknown>*/.fi,
                                              1,
                                              "");
    }
    
    pointcut install() : execution ((*).new()) && within(C);
    
    after(): install() {  }
    
    public static Driver aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Driver() { super(); }
}
class C {
    public final int fi;
    
    C() {
        super();
        this/*null*/.fi = 1;
    }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void after$0()> from Driver
retrieve <Driver: Driver aspectOf()> from Driver
retrieve <Driver: boolean hasAspect()> from Driver
retrieve <C: void <init>()> from C
Transforming C... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:56:12 BST 2004. ( 0 min. 7 sec. )
PASS: final member initialization broken with JDK before 1.1.8()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 108 failed (check: 70), 233 passed (check: 81), 0 skipped.
Executing test 342 (new/packageNameClash): same package and var name clash in preprocessed code when aspectOf is used
================================================
Breakdown of abc phases  (total: 7398 millisec.)
------------------------------------------------
[ 00.514% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 78.494% ] Polyglot phases:  5807
[ 00.027% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.649% ] Recompute name pattern matches:  48
[ 00.014% ] Compute precedence relation:  1
[ 00.487% ] Intertype Adjuster:  36
[ 08.381% ] Retrieving bodies:  620
[ 00.000% ] Weave Initializers:  0
[ 00.311% ] Load shadow types:  23
[ 03.866% ] Compute advice lists:  286
[ 00.041% ] Intertype weave:  3
[ 00.149% ] Add aspect code:  11
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.690% ] Soot Packs:  273
[ 03.149% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 08:56:14 BST 2004
<<<< Driver.java >>>>
package otherpkg;

import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() { new pkg.Class1().doIt(); }
    
    public Driver() { super(); }
}
<<<< Class1.java >>>>
package pkg;

public class Class1 {
    public java.lang.String doIt() {
        pkg.Aspect1 pkg = null;
        try {
            java.lang.reflect.Constructor c =
              pkg.Aspect1.class.getDeclaredConstructors()[0];
            c.setAccessible(true);
            pkg =
              (pkg.Aspect1)
                c.newInstance(new java.lang.Object[] {  });
        }
        catch (java.lang.Exception e) {
            throw new java.lang.Error(e + "");
        }
        return pkg.getClass().getName();
    }
    
    public Class1() { super(); }
}
<<<< Aspect1.java >>>>
package pkg;

aspect Aspect1 {
    public static pkg.Aspect1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect1() { super(); }
}
retrieve <otherpkg.Driver: void main(java.lang.String[])> from otherpkg.Driver
retrieve <otherpkg.Driver: void test()> from otherpkg.Driver
retrieve <otherpkg.Driver: void <init>()> from otherpkg.Driver
retrieve <pkg.Class1: java.lang.String doIt()> from pkg.Class1
retrieve <pkg.Class1: void <init>()> from pkg.Class1
retrieve <pkg.Class1: java.lang.Class class$(java.lang.String)> from pkg.Class1
retrieve <pkg.Aspect1: pkg.Aspect1 aspectOf()> from pkg.Aspect1
retrieve <pkg.Aspect1: boolean hasAspect()> from pkg.Aspect1
retrieve <pkg.Aspect1: void <init>()> from pkg.Aspect1
Transforming pkg.Aspect1... 
Transforming otherpkg.Driver... 
Transforming pkg.Class1... 
Abc finished on Thu Jun 24 08:56:22 BST 2004. ( 0 min. 7 sec. )
PASS: same package and var name clash in preprocessed code when aspectOf is us...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 108 failed (check: 70), 234 passed (check: 81), 0 skipped.
Executing test 343 (new/adviceOnStaticMeth): and PR#201 advice on static methods fails javac compile with this
================================================
Breakdown of abc phases  (total: 7759 millisec.)
------------------------------------------------
[ 00.490% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 74.056% ] Polyglot phases:  5746
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.799% ] Recompute name pattern matches:  62
[ 00.013% ] Compute precedence relation:  1
[ 00.490% ] Intertype Adjuster:  38
[ 06.354% ] Retrieving bodies:  493
[ 00.000% ] Weave Initializers:  0
[ 00.296% ] Load shadow types:  23
[ 08.738% ] Compute advice lists:  678
[ 00.052% ] Intertype weave:  4
[ 00.451% ] Add aspect code:  35
[ 01.791% ] Weaving advice:  139
[ 00.000% ] Validate jimple:  0
[ 03.377% ] Soot Packs:  262
[ 03.003% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 08:56:24 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static java.lang.String s = "s";
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(doIt(),
                                              Driver/*Driver*/.s,
                                              "advice worked");
    }
    
    public static java.lang.String doIt() {
        return Driver/*Driver*/.s;
    }
    
    public Driver() { super(); }
}
aspect Outer {
    pointcut staticMeth() :
    within(Driver) &&
      execution (String (*).doIt());
    
    before(): staticMeth() { Driver/*Driver*/.s += ":a"; }
    
    public static Outer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Outer() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: java.lang.String doIt()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
retrieve <Outer: boolean hasAspect()> from Outer
retrieve <Outer: void <init>()> from Outer
retrieve <Outer: void before$0()> from Outer
retrieve <Outer: Outer aspectOf()> from Outer
Transforming Driver... 
Transforming Outer... 
Abc finished on Thu Jun 24 08:56:32 BST 2004. ( 0 min. 7 sec. )
PASS: and PR#201 advice on static methods fails javac compile with this()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 108 failed (check: 70), 235 passed (check: 81), 0 skipped.
Executing test 344 (new): non-static advice on inner class defined inside of method body
getting SJPInfo for a untagged source line $i0 = this.<C$1Inner: int val$N>
getting SJPInfo for a untagged source line $i0 = this.<C$1Inner: int val$N>
================================================
Breakdown of abc phases  (total: 7526 millisec.)
------------------------------------------------
[ 00.518% ] Init. of Soot:  39
[ 00.053% ] Loading Jars:  4
[ 77.545% ] Polyglot phases:  5836
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.664% ] Recompute name pattern matches:  50
[ 00.013% ] Compute precedence relation:  1
[ 00.505% ] Intertype Adjuster:  38
[ 07.029% ] Retrieving bodies:  529
[ 00.000% ] Weave Initializers:  0
[ 00.292% ] Load shadow types:  22
[ 03.322% ] Compute advice lists:  250
[ 00.053% ] Intertype weave:  4
[ 00.452% ] Add aspect code:  34
[ 01.488% ] Weaving advice:  112
[ 00.000% ] Validate jimple:  0
[ 04.425% ] Soot Packs:  333
[ 03.588% ] Soot Writing Output:  270
================================================
Failed. Current status: 109 failed (check: 70), 235 passed (check: 81), 0 skipped.
Executing test 345 (new): simple single-threaded eachcflow test (includes aspectOf)
================================================
Breakdown of abc phases  (total: 8868 millisec.)
------------------------------------------------
[ 00.440% ] Init. of Soot:  39
[ 00.045% ] Loading Jars:  4
[ 68.539% ] Polyglot phases:  6078
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.429% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.710% ] Intertype Adjuster:  63
[ 06.631% ] Retrieving bodies:  588
[ 00.000% ] Weave Initializers:  0
[ 00.316% ] Load shadow types:  28
[ 11.074% ] Compute advice lists:  982
[ 00.034% ] Intertype weave:  3
[ 00.259% ] Add aspect code:  23
[ 01.669% ] Weaving advice:  148
[ 00.000% ] Validate jimple:  0
[ 05.334% ] Soot Packs:  473
[ 04.477% ] Soot Writing Output:  397
================================================
Abc started on Thu Jun 24 08:56:45 BST 2004
<<<< Client.java >>>>
import org.aspectj.testing.Tester;

aspect ClientFlow {
    pointcut entries(Client c) :
    this(c) &&
      (call(void (Server).doService1(Object)) ||
         call(void (Server).doService2()));
    
    Client client;
    
    before(Client c): entries(c) { this/*null*/.client = c; }
    
    pointcut workPoints() :
    this(ServiceWorker1) && call(void (*).doWorkItemA()) ||
      this(ServiceWorker2) && call(void (*).doWorkItemB()) ||
      this(ServiceWorker3) && call(void (*).doWorkItemC()) ||
      this(ServiceWorker4) && call(void (*).doWorkItemD());
    
    Object around ():
    workPoints() {
        this/*null*/.client/*null*/.count++;
        return this.proceed();
    }
    
    void util(Client c) {
        c/*null*/.count++;
        this/*null*/.client/*null*/.count++;
    }
    
    public static ClientFlow aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ClientFlow() { super(); }
}
public class Client {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Client c = new Client();
        Server s = new Server();
        c.requestServices(s);
        org.aspectj.testing.Tester.checkEqual(c/*null*/.count,
                                              5,
                                              "A+B+C+2*D");
        org.aspectj.testing.Tester.check("WorkA");
        org.aspectj.testing.Tester.check("WorkB");
        org.aspectj.testing.Tester.check("WorkC");
        org.aspectj.testing.Tester.check("WorkD");
    }
    
    int count;
    
    public void requestServices(Server s) {
        s.doService1("foo");
        s.doService2();
    }
    
    public Client() { super(); }
}
class Server {
    ServiceWorker1 worker1 = new ServiceWorker1();
    
    ServiceWorker2 worker2 = new ServiceWorker2();
    
    public void doService1(java.lang.Object data) {
        this/*null*/.worker1.doYourPart();
    }
    
    public void doService2() { this/*null*/.worker2.doYourPart(); }
    
    public Server() { super(); }
}
class ServiceWorker1 {
    void doYourPart() { doWorkItemA(); }
    
    void doWorkItemA() { org.aspectj.testing.Tester.note("WorkA"); }
    
    public ServiceWorker1() { super(); }
}
class ServiceWorker2 {
    ServiceWorker3 worker3 = new ServiceWorker3();
    
    ServiceWorker4 worker4 = new ServiceWorker4();
    
    void doYourPart() {
        this/*null*/.worker3.doYourPart();
        this/*null*/.worker4.doYourPart();
        doWorkItemB();
    }
    
    void doWorkItemB() { org.aspectj.testing.Tester.note("WorkB"); }
    
    public ServiceWorker2() { super(); }
}
class ServiceWorker3 {
    void doYourPart() { doWorkItemC(); }
    
    void doWorkItemC() { org.aspectj.testing.Tester.note("WorkC"); }
    
    public ServiceWorker3() { super(); }
}
class ServiceWorker4 {
    void doYourPart() { doWorkItemD(); }
    
    void doWorkItemD() {
        ClientFlow.aspectOf()/*<unknown>*/.client/*<unknown>*/.count++;
        org.aspectj.testing.Tester.note("WorkD");
    }
    
    public ServiceWorker4() { super(); }
}
retrieve <ClientFlow: void <init>()> from ClientFlow
retrieve <ClientFlow: void before$0(Client)> from ClientFlow
retrieve <ClientFlow: java.lang.Object around$1()> from ClientFlow
retrieve <ClientFlow: void util(Client)> from ClientFlow
retrieve <ClientFlow: ClientFlow aspectOf()> from ClientFlow
retrieve <ClientFlow: boolean hasAspect()> from ClientFlow
retrieve <ClientFlow: java.lang.Object proceed$2()> from ClientFlow
retrieve <Client: void main(java.lang.String[])> from Client
retrieve <Client: void test()> from Client
retrieve <Client: void requestServices(Server)> from Client
retrieve <Client: void <init>()> from Client
retrieve <Server: void <init>()> from Server
retrieve <Server: void doService1(java.lang.Object)> from Server
retrieve <Server: void doService2()> from Server
retrieve <ServiceWorker1: void doWorkItemA()> from ServiceWorker1
retrieve <ServiceWorker1: void <init>()> from ServiceWorker1
retrieve <ServiceWorker1: void doYourPart()> from ServiceWorker1
retrieve <ServiceWorker2: void doWorkItemB()> from ServiceWorker2
retrieve <ServiceWorker2: void <init>()> from ServiceWorker2
retrieve <ServiceWorker2: void doYourPart()> from ServiceWorker2
retrieve <ServiceWorker3: void doWorkItemC()> from ServiceWorker3
retrieve <ServiceWorker3: void <init>()> from ServiceWorker3
retrieve <ServiceWorker3: void doYourPart()> from ServiceWorker3
retrieve <ServiceWorker4: void doWorkItemD()> from ServiceWorker4
retrieve <ServiceWorker4: void <init>()> from ServiceWorker4
retrieve <ServiceWorker4: void doYourPart()> from ServiceWorker4
Transforming Client... 
Transforming Server... 
Transforming ServiceWorker2... 
Transforming ClientFlow... 
Transforming ServiceWorker1... 
Transforming ServiceWorker3... 
Transforming ServiceWorker4... 
Transforming abc$access$ClientFlow$around$1... 
Abc finished on Thu Jun 24 08:56:54 BST 2004. ( 0 min. 8 sec. )
PASS: simple single-threaded eachcflow test (includes aspectOf)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 109 failed (check: 70), 236 passed (check: 81), 0 skipped.
Executing test 346 (new/scopeTypingBug): bad type resolution when var reassigned in same scope
================================================
Breakdown of abc phases  (total: 7540 millisec.)
------------------------------------------------
[ 00.504% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  3
[ 78.183% ] Polyglot phases:  5895
[ 00.000% ] Resolve class names:  0
[ 00.159% ] Declare Parents:  12
[ 00.451% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 06.565% ] Intertype Adjuster:  495
[ 06.233% ] Retrieving bodies:  470
[ 00.000% ] Weave Initializers:  0
[ 00.305% ] Load shadow types:  23
[ 02.135% ] Compute advice lists:  161
[ 00.040% ] Intertype weave:  3
[ 00.106% ] Add aspect code:  8
[ 00.172% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.639% ] Soot Packs:  199
[ 02.467% ] Soot Writing Output:  186
================================================
Abc started on Thu Jun 24 08:56:57 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    private static java.util.Vector v = new java.util.Vector();
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        Driver/*Driver*/.v.addElement("foo");
        boolean containsFoo = Driver/*Driver*/.v.contains("foo");
        java.lang.Object v = new java.lang.Object();
        org.aspectj.testing.Tester.check(containsFoo,
                                         "Vector contains element added");
    }
    
    public Driver() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
Transforming Driver... 
Abc finished on Thu Jun 24 08:57:04 BST 2004. ( 0 min. 7 sec. )
PASS: bad type resolution when var reassigned in same scope()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 109 failed (check: 70), 237 passed (check: 81), 0 skipped.
Executing test 347 (new): generating the right throws clause for call-site advice (and around)
Failed. Current status: 110 failed (check: 70), 237 passed (check: 81), 0 skipped.
Executing test 348 (new): advice on calls to static methods using several syntax
Failed. Current status: 111 failed (check: 70), 237 passed (check: 81), 0 skipped.
Executing test 349 (new): , PR#249, PR#250 advice on constructor sites
Failed. Current status: 112 failed (check: 70), 237 passed (check: 81), 0 skipped.
Executing test 350 (new): test after throwing advice in several ways
Failed. Current status: 113 failed (check: 70), 237 passed (check: 81), 0 skipped.
Executing test 351 (new): fancy name patterns for method names
getting SJPInfo for a untagged source line $r0 = "get*"
getting SJPInfo for a untagged source line $r0 = "get*"
getting SJPInfo for a untagged source line $r0 = "*Getter"
getting SJPInfo for a untagged source line $r0 = "*Getter"
getting SJPInfo for a untagged source line $r0 = "prefix*Suffix"
getting SJPInfo for a untagged source line $r0 = "prefix*Suffix"
================================================
Breakdown of abc phases  (total: 8352 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  42
[ 00.048% ] Loading Jars:  4
[ 70.414% ] Polyglot phases:  5881
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.706% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.443% ] Intertype Adjuster:  37
[ 06.322% ] Retrieving bodies:  528
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  23
[ 11.398% ] Compute advice lists:  952
[ 00.048% ] Intertype weave:  4
[ 00.383% ] Add aspect code:  32
[ 01.233% ] Weaving advice:  103
[ 00.000% ] Validate jimple:  0
[ 04.813% ] Soot Packs:  402
[ 03.364% ] Soot Writing Output:  281
================================================
Abc started on Thu Jun 24 08:57:25 BST 2004
<<<< WildNames.java >>>>
import org.aspectj.testing.Tester;

public aspect WildNames {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        C c = new C();
        c.getFoo();
        c.getBar();
        org.aspectj.testing.Tester.check("getFoo");
        org.aspectj.testing.Tester.check("getBar");
        c.fooGetter();
        c.barGetter();
        org.aspectj.testing.Tester.check("fooGetter");
        org.aspectj.testing.Tester.check("barGetter");
        c.prefixFooSuffix();
        c.prefixBarSuffix();
        org.aspectj.testing.Tester.check("prefixFooSuffix");
        org.aspectj.testing.Tester.check("prefixBarSuffix");
    }
    
    after() returning(String s):
    execution (String (*).get*()) {
        org.aspectj.testing.Tester.checkEqual("get*", s);
        org.aspectj.testing.Tester.note(thisJoinPoint.getSignature().getName());
    }
    
    after() returning(String s):
    execution (String (*).*Getter()) {
        org.aspectj.testing.Tester.checkEqual("*Getter", s);
        org.aspectj.testing.Tester.note(thisJoinPoint.getSignature().getName());
    }
    
    after() returning(String s):
    execution (String (*).prefix*Suffix()) {
        org.aspectj.testing.Tester.checkEqual("prefix*Suffix", s);
        org.aspectj.testing.Tester.note(thisJoinPoint.getSignature().getName());
    }
    
    public static WildNames aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public WildNames() { super(); }
}
class C {
    public java.lang.String getFoo() { return "get*"; }
    
    public java.lang.String getBar() { return "get*"; }
    
    public java.lang.String fooGetter() { return "*Getter"; }
    
    public java.lang.String barGetter() { return "*Getter"; }
    
    public java.lang.String prefixFooSuffix() {
        return "prefix*Suffix";
    }
    
    public java.lang.String prefixBarSuffix() {
        return "prefix*Suffix";
    }
    
    public C() { super(); }
}
retrieve <WildNames: WildNames aspectOf()> from WildNames
retrieve <WildNames: boolean hasAspect()> from WildNames
retrieve <WildNames: void <init>()> from WildNames
retrieve <WildNames: void main(java.lang.String[])> from WildNames
retrieve <WildNames: void test()> from WildNames
retrieve <WildNames: void afterReturning$0(java.lang.String,org.aspectj.lang.JoinPoint)> from WildNames
retrieve <WildNames: void afterReturning$1(java.lang.String,org.aspectj.lang.JoinPoint)> from WildNames
retrieve <WildNames: void afterReturning$2(java.lang.String,org.aspectj.lang.JoinPoint)> from WildNames
retrieve <C: java.lang.String getFoo()> from C
retrieve <C: java.lang.String getBar()> from C
retrieve <C: java.lang.String fooGetter()> from C
retrieve <C: java.lang.String barGetter()> from C
retrieve <C: java.lang.String prefixFooSuffix()> from C
retrieve <C: java.lang.String prefixBarSuffix()> from C
retrieve <C: void <init>()> from C
Transforming C... 
Transforming WildNames... 
Abc finished on Thu Jun 24 08:57:33 BST 2004. ( 0 min. 8 sec. )
PASS: fancy name patterns for method names()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 113 failed (check: 70), 238 passed (check: 81), 0 skipped.
Executing test 352 (design/calls): calls: calls(...)
Failed. Current status: 114 failed (check: 70), 238 passed (check: 81), 0 skipped.
Executing test 353 (new/extraThrows): throws Exception clause is unnecessarily added to Driver.main method
Failed. Current status: 115 failed (check: 70), 238 passed (check: 81), 0 skipped.
Executing test 354 (new/thisUsedInMain): javac fails when this is referenced in the static main method
================================================
Breakdown of abc phases  (total: 7669 millisec.)
------------------------------------------------
[ 00.496% ] Init. of Soot:  38
[ 00.052% ] Loading Jars:  4
[ 74.182% ] Polyglot phases:  5689
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.743% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.482% ] Intertype Adjuster:  37
[ 13.809% ] Retrieving bodies:  1059
[ 00.013% ] Weave Initializers:  1
[ 00.287% ] Load shadow types:  22
[ 02.152% ] Compute advice lists:  165
[ 00.039% ] Intertype weave:  3
[ 00.443% ] Add aspect code:  34
[ 00.287% ] Weaving advice:  22
[ 00.000% ] Validate jimple:  0
[ 03.873% ] Soot Packs:  297
[ 03.090% ] Soot Writing Output:  237
================================================
Abc started on Thu Jun 24 08:57:43 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public aspect Driver {
    public static void test() { main(null); }
    
    public static void main(java.lang.String[] args) {
        CallsTo ct = new CallsTo();
        org.aspectj.testing.Tester.checkEqual(ct.a(),
                                              "s",
                                              "after calls");
    }
    
    pointcut call1() : call(* (CallsFrom).b(..)) && within(CallsTo);
    
    before(): call1() {  }
    
    public static Driver aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Driver() { super(); }
}
class CallsTo {
    public java.lang.String a() { return new CallsFrom().b("s"); }
    
    public CallsTo() { super(); }
}
class CallsFrom {
    public java.lang.String b(java.lang.String s) { return s; }
    
    public CallsFrom() { super(); }
}
retrieve <Driver: boolean hasAspect()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void before$0()> from Driver
retrieve <Driver: Driver aspectOf()> from Driver
retrieve <CallsTo: java.lang.String a()> from CallsTo
retrieve <CallsTo: void <init>()> from CallsTo
retrieve <CallsFrom: java.lang.String b(java.lang.String)> from CallsFrom
retrieve <CallsFrom: void <init>()> from CallsFrom
Transforming CallsFrom... 
Transforming CallsTo... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:57:51 BST 2004. ( 0 min. 7 sec. )
PASS: javac fails when this is referenced in the static main method()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 115 failed (check: 70), 239 passed (check: 81), 0 skipped.
Executing test 355 (new/badCast): and 276 cast error generated by ajc when type not in signature
================================================
Breakdown of abc phases  (total: 8375 millisec.)
------------------------------------------------
[ 00.454% ] Init. of Soot:  38
[ 00.048% ] Loading Jars:  4
[ 70.746% ] Polyglot phases:  5925
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.454% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.716% ] Intertype Adjuster:  60
[ 06.137% ] Retrieving bodies:  514
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  23
[ 09.039% ] Compute advice lists:  757
[ 00.036% ] Intertype weave:  3
[ 00.442% ] Add aspect code:  37
[ 01.266% ] Weaving advice:  106
[ 00.000% ] Validate jimple:  0
[ 07.057% ] Soot Packs:  591
[ 03.284% ] Soot Writing Output:  275
================================================
Abc started on Thu Jun 24 08:57:53 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new SourcePane().go(),
                                              -10);
    }
    
    public Driver() { super(); }
}
class SourcePane {
    public int go() {
        Location location = new Location();
        return location.lineNumber();
    }
    
    public SourcePane() { super(); }
}
class Location {
    public int lineNumber() { return 10; }
    
    public Location() { super(); }
}
aspect DriverAspect {
    pointcut locationLineNumber(Location loc) :
    target(loc) && call(int (Location).lineNumber()) &&
      within(SourcePane);
    
    int around (Location loc):
    locationLineNumber(loc) {
        int result = this.proceed(loc);
        return result * -1;
    }
    
    public static DriverAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public DriverAspect() { super(); }
}
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <SourcePane: int go()> from SourcePane
retrieve <SourcePane: void <init>()> from SourcePane
retrieve <Location: void <init>()> from Location
retrieve <Location: int lineNumber()> from Location
retrieve <DriverAspect: DriverAspect aspectOf()> from DriverAspect
retrieve <DriverAspect: boolean hasAspect()> from DriverAspect
retrieve <DriverAspect: void <init>()> from DriverAspect
retrieve <DriverAspect: int proceed$1(Location)> from DriverAspect
retrieve <DriverAspect: int around$0(Location)> from DriverAspect
Transforming SourcePane... 
Transforming DriverAspect... 
Transforming Driver... 
Transforming Location... 
Transforming abc$access$DriverAspect$around$0... 
Abc finished on Thu Jun 24 08:58:02 BST 2004. ( 0 min. 8 sec. )
PASS: and 276 cast error generated by ajc when type not in signature()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 115 failed (check: 70), 240 passed (check: 81), 0 skipped.
Executing test 356 (new): calls to methods to which we don't have source
================================================
Breakdown of abc phases  (total: 7882 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 71.987% ] Polyglot phases:  5674
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.799% ] Recompute name pattern matches:  63
[ 00.000% ] Compute precedence relation:  0
[ 00.495% ] Intertype Adjuster:  39
[ 11.951% ] Retrieving bodies:  942
[ 00.000% ] Weave Initializers:  0
[ 01.687% ] Load shadow types:  133
[ 02.398% ] Compute advice lists:  189
[ 00.038% ] Intertype weave:  3
[ 00.292% ] Add aspect code:  23
[ 01.764% ] Weaving advice:  139
[ 00.000% ] Validate jimple:  0
[ 04.529% ] Soot Packs:  357
[ 03.489% ] Soot Writing Output:  275
================================================
Abc started on Thu Jun 24 08:58:04 BST 2004
<<<< ExternalCalls.java >>>>
import org.aspectj.testing.Tester;

public class ExternalCalls {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new Test().go(), 1003);
        org.aspectj.testing.Tester.checkEqual(java.lang.Math.max(1,
                                                                 3),
                                              3);
    }
    
    public ExternalCalls() { super(); }
}
class Test {
    int go() { return java.lang.Math.max(1, 3); }
    
    public Test() { super(); }
}
aspect A {
    int around ():
    call(int (Math).*(..)) &&
      !call(* (Test).go()) {
        return this.proceed() + 1000;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ExternalCalls: void main(java.lang.String[])> from ExternalCalls
retrieve <ExternalCalls: void <init>()> from ExternalCalls
retrieve <Test: int go()> from Test
retrieve <Test: void <init>()> from Test
retrieve <A: int around$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: int proceed$1()> from A
Transforming A... 
Transforming Test... 
Transforming ExternalCalls... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 08:58:12 BST 2004. ( 0 min. 7 sec. )
PASS: calls to methods to which we don't have source()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 115 failed (check: 70), 241 passed (check: 81), 0 skipped.
Executing test 357 (new/beforeNotRun): more aspect inheritance
Failed. Current status: 116 failed (check: 70), 241 passed (check: 81), 0 skipped.
Executing test 358 (new): around and calls with both calling and called this params
================================================
Breakdown of abc phases  (total: 8013 millisec.)
------------------------------------------------
[ 00.487% ] Init. of Soot:  39
[ 00.037% ] Loading Jars:  3
[ 71.958% ] Polyglot phases:  5766
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.661% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.462% ] Intertype Adjuster:  37
[ 06.452% ] Retrieving bodies:  517
[ 00.000% ] Weave Initializers:  0
[ 00.362% ] Load shadow types:  29
[ 09.896% ] Compute advice lists:  793
[ 00.037% ] Intertype weave:  3
[ 00.449% ] Add aspect code:  36
[ 01.111% ] Weaving advice:  89
[ 00.000% ] Validate jimple:  0
[ 04.468% ] Soot Packs:  358
[ 03.569% ] Soot Writing Output:  286
================================================
Abc started on Thu Jun 24 08:58:25 BST 2004
<<<< AroundAndCalls.java >>>>
import org.aspectj.testing.Tester;

public class AroundAndCalls {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new CL().go(),
                                              "basic-advised");
    }
    
    public AroundAndCalls() { super(); }
}
aspect MustAspect {
    pointcut parseCalls(CP cp, java.lang.String cmd) :
    args(cmd) && target(cp) && call(String (CP).parse(String)) &&
      within(CL);
    
    String around (CP cp, String cmd):
    parseCalls(cp,
        cmd) {
        return this.proceed(cp, cmd + "-advised");
    }
    
    public static MustAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MustAspect() { super(); }
}
class CL {
    java.lang.String go() { return new CP().parse("basic"); }
    
    public CL() { super(); }
}
class CP {
    java.lang.String parse(java.lang.String cmd) { return cmd; }
    
    public CP() { super(); }
}
retrieve <AroundAndCalls: void main(java.lang.String[])> from AroundAndCalls
retrieve <AroundAndCalls: void <init>()> from AroundAndCalls
retrieve <MustAspect: java.lang.String around$0(CP,java.lang.String)> from MustAspect
retrieve <MustAspect: MustAspect aspectOf()> from MustAspect
retrieve <MustAspect: boolean hasAspect()> from MustAspect
retrieve <MustAspect: void <init>()> from MustAspect
retrieve <MustAspect: java.lang.String proceed$1(CP,java.lang.String)> from MustAspect
retrieve <CL: java.lang.String go()> from CL
retrieve <CL: void <init>()> from CL
retrieve <CP: void <init>()> from CP
retrieve <CP: java.lang.String parse(java.lang.String)> from CP
Transforming CL... 
Transforming CP... 
Transforming MustAspect... 
Transforming AroundAndCalls... 
Transforming abc$access$MustAspect$around$0... 
Abc finished on Thu Jun 24 08:58:33 BST 2004. ( 0 min. 8 sec. )
PASS: around and calls with both calling and called this params()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 116 failed (check: 70), 242 passed (check: 81), 0 skipped.
Executing test 359 (new/pointcutParameter): compiler crashes with eachobject and named pointcuts with parameters
================================================
Breakdown of abc phases  (total: 7805 millisec.)
------------------------------------------------
[ 00.487% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 72.761% ] Polyglot phases:  5679
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.717% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.487% ] Intertype Adjuster:  38
[ 06.393% ] Retrieving bodies:  499
[ 00.000% ] Weave Initializers:  0
[ 00.282% ] Load shadow types:  22
[ 10.519% ] Compute advice lists:  821
[ 00.038% ] Intertype weave:  3
[ 00.436% ] Add aspect code:  34
[ 00.474% ] Weaving advice:  37
[ 00.000% ] Validate jimple:  0
[ 04.061% ] Soot Packs:  317
[ 03.254% ] Soot Writing Output:  254
================================================
Abc started on Thu Jun 24 08:58:36 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static java.lang.String s = "";
    
    public static void main(java.lang.String[] args) {
        new C().go();
        org.aspectj.testing.Tester.checkEqual(Driver/*Driver*/.s,
                                              "-before-go",
                                              "");
    }
    
    public Driver() { super(); }
}
class C {
    int x;
    
    public void go() { Driver/*Driver*/.s += "-go"; }
    
    public C() { super(); }
}
aspect A {
    pointcut testPointcut(C c) : target(c);
    
    before(C c):
    target(c) &&
      call(* (*).*(..)) {
        Driver/*Driver*/.s += "-before";
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Driver: void <clinit>()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <C: void <init>()> from C
retrieve <C: void go()> from C
retrieve <A: void before$0(C)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Driver... 
Transforming C... 
Abc finished on Thu Jun 24 08:58:43 BST 2004. ( 0 min. 7 sec. )
PASS: compiler crashes with eachobject and named pointcuts with parameters()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 116 failed (check: 70), 243 passed (check: 81), 0 skipped.
Executing test 360 (new/unqualifiedPointcutName): lookup rules for unqualified pointcut names
================================================
Breakdown of abc phases  (total: 7998 millisec.)
------------------------------------------------
[ 00.463% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 74.181% ] Polyglot phases:  5933
[ 00.038% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.638% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.463% ] Intertype Adjuster:  37
[ 06.464% ] Retrieving bodies:  517
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  23
[ 03.151% ] Compute advice lists:  252
[ 00.038% ] Intertype weave:  3
[ 06.577% ] Add aspect code:  526
[ 00.325% ] Weaving advice:  26
[ 00.000% ] Validate jimple:  0
[ 04.076% ] Soot Packs:  326
[ 03.251% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 08:58:46 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class Driver {
    public static java.lang.String s = "";
    
    public static void main(java.lang.String[] args) {
        new MyObject().go();
        org.aspectj.testing.Tester.checkEqual(Driver/*Driver*/.s,
                                              "-before-new",
                                              "");
    }
    
    public Driver() { super(); }
}
aspect MyPointCuts {
    pointcut excludes() :
    call(* (*).equals(..)) || call(* (*).toString(..)) ||
      call(* (*).hashCode(..)) ||
      call(* (*).clone(..));
    
    pointcut allCalls() : call(* (*).*(..)) && !excludes();
    
    public static MyPointCuts aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MyPointCuts() { super(); }
}
aspect MyAspect {
    before():
    allCalls() &&
      target(MyObject) {
        Driver/*Driver*/.s += "-before";
    }
    
    public static MyAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MyAspect() { super(); }
}
class MyObject {
    public void go() { Driver/*Driver*/.s += "-new"; }
    
    public MyObject() { super(); }
}
retrieve <Driver: void <clinit>()> from Driver
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <MyPointCuts: MyPointCuts aspectOf()> from MyPointCuts
retrieve <MyPointCuts: boolean hasAspect()> from MyPointCuts
retrieve <MyPointCuts: void <init>()> from MyPointCuts
retrieve <MyAspect: boolean hasAspect()> from MyAspect
retrieve <MyAspect: void <init>()> from MyAspect
retrieve <MyAspect: void before$0()> from MyAspect
retrieve <MyAspect: MyAspect aspectOf()> from MyAspect
retrieve <MyObject: void <init>()> from MyObject
retrieve <MyObject: void go()> from MyObject
Transforming MyPointCuts... 
Transforming MyObject... 
Transforming MyAspect... 
Transforming Driver... 
Abc finished on Thu Jun 24 08:58:54 BST 2004. ( 0 min. 8 sec. )
PASS: lookup rules for unqualified pointcut names()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 116 failed (check: 70), 244 passed (check: 81), 0 skipped.
Executing test 361 (new): eachcflow only instantiated if the aspect has some advice in it
================================================
Breakdown of abc phases  (total: 7955 millisec.)
------------------------------------------------
[ 00.478% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 74.356% ] Polyglot phases:  5915
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.654% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.465% ] Intertype Adjuster:  37
[ 13.451% ] Retrieving bodies:  1070
[ 00.013% ] Weave Initializers:  1
[ 00.277% ] Load shadow types:  22
[ 02.150% ] Compute advice lists:  171
[ 00.038% ] Intertype weave:  3
[ 00.251% ] Add aspect code:  20
[ 00.654% ] Weaving advice:  52
[ 00.000% ] Validate jimple:  0
[ 03.985% ] Soot Packs:  317
[ 03.143% ] Soot Writing Output:  250
================================================
Abc started on Thu Jun 24 08:58:57 BST 2004
<<<< CFlowNoAdvice.java >>>>
import org.aspectj.testing.Tester;

public class CFlowNoAdvice {
    public static void main(java.lang.String[] args) {
        new Foo().bar();
        new Foo().bar();
    }
    
    public CFlowNoAdvice() { super(); }
}
class Foo {
    void bar() {
        org.aspectj.testing.Tester.check(CFlowAspect.aspectOf() !=
                                         null,
                                         "cflow created");
    }
    
    public Foo() { super(); }
}
aspect CFlowAspect {
    pointcut contexts() : target(Foo) && call(void (*).bar());
    
    public static CFlowAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public CFlowAspect() { super(); }
}
retrieve <CFlowNoAdvice: void main(java.lang.String[])> from CFlowNoAdvice
retrieve <CFlowNoAdvice: void <init>()> from CFlowNoAdvice
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void bar()> from Foo
retrieve <CFlowAspect: void <init>()> from CFlowAspect
retrieve <CFlowAspect: CFlowAspect aspectOf()> from CFlowAspect
retrieve <CFlowAspect: boolean hasAspect()> from CFlowAspect
Transforming CFlowNoAdvice... 
Transforming CFlowAspect... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:59:05 BST 2004. ( 0 min. 8 sec. )
PASS: eachcflow only instantiated if the aspect has some advice in it()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 116 failed (check: 70), 245 passed (check: 81), 0 skipped.
Executing test 362 (new): (DESIGN QUESTION) aspect of eachJVM advising its own initializer
Failed. Current status: 117 failed (check: 70), 245 passed (check: 81), 0 skipped.
Executing test 363 (new): after returning advice on calls to constructors
================================================
Breakdown of abc phases  (total: 7662 millisec.)
------------------------------------------------
[ 00.483% ] Init. of Soot:  37
[ 00.091% ] Loading Jars:  7
[ 74.680% ] Polyglot phases:  5722
[ 00.039% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.509% ] Recompute name pattern matches:  39
[ 00.000% ] Compute precedence relation:  0
[ 00.770% ] Intertype Adjuster:  59
[ 12.882% ] Retrieving bodies:  987
[ 00.000% ] Weave Initializers:  0
[ 00.313% ] Load shadow types:  24
[ 02.662% ] Compute advice lists:  204
[ 00.052% ] Intertype weave:  4
[ 00.248% ] Add aspect code:  19
[ 00.339% ] Weaving advice:  26
[ 00.000% ] Validate jimple:  0
[ 03.759% ] Soot Packs:  288
[ 03.158% ] Soot Writing Output:  242
================================================
Abc started on Thu Jun 24 08:59:11 BST 2004
<<<< AfterConstructorCalls.java >>>>
import org.aspectj.testing.Tester;

public class AfterConstructorCalls {
    public static void main(java.lang.String[] args) {
        new Foo().bar();
    }
    
    public AfterConstructorCalls() { super(); }
}
class Foo {
    int bar() { return 0; }
    
    public Foo() { super(); }
}
aspect A {
    pointcut nimboCut() : call((Foo).new(..));
    
    after() returning(Object o):
    nimboCut() {
        org.aspectj.testing.Tester.check(o != null &&
                                         o instanceof Foo,
                                         o +
                                         " !instanceof Foo");
    }
    
    after() returning(int i):
    call(int (Foo).*(..)) {
        org.aspectj.testing.Tester.checkEqual(i, 0);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AfterConstructorCalls: void main(java.lang.String[])> from AfterConstructorCalls
retrieve <AfterConstructorCalls: void <init>()> from AfterConstructorCalls
retrieve <Foo: int bar()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <A: void afterReturning$0(java.lang.Object)> from A
retrieve <A: void afterReturning$1(int)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming AfterConstructorCalls... 
Transforming Foo... 
Abc finished on Thu Jun 24 08:59:19 BST 2004. ( 0 min. 7 sec. )
PASS: after returning advice on calls to constructors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 117 failed (check: 70), 246 passed (check: 81), 0 skipped.
Executing test 364 (new): Does annotating 'new' with a type work as desired?
================================================
Breakdown of abc phases  (total: 7958 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  44
[ 00.050% ] Loading Jars:  4
[ 74.290% ] Polyglot phases:  5912
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.729% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.465% ] Intertype Adjuster:  37
[ 06.585% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.276% ] Load shadow types:  22
[ 02.601% ] Compute advice lists:  207
[ 00.038% ] Intertype weave:  3
[ 00.427% ] Add aspect code:  34
[ 06.471% ] Weaving advice:  515
[ 00.000% ] Validate jimple:  0
[ 04.310% ] Soot Packs:  343
[ 03.154% ] Soot Writing Output:  251
================================================
Abc started on Thu Jun 24 08:59:22 BST 2004
<<<< ConstructorSignatures.java >>>>
import org.aspectj.testing.Tester;

public class ConstructorSignatures {
    public static void main(java.lang.String[] args) {
        new A1();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.a0,
                                              2,
                                              "A0 advice overcalled");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.a1,
                                              1,
                                              "A1 advice overcalled");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.b,
                                              0,
                                              "B advice overcalled");
        A/*A*/.a0 = (A/*A*/.a1 = (A/*A*/.b = 0));
        new B();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.a0,
                                              0,
                                              "-A0 advice overcalled");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.a1,
                                              0,
                                              "-A1 advice overcalled");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.b,
                                              1,
                                              "-B advice overcalled");
    }
    
    public ConstructorSignatures() { super(); }
}
class A0 {
    public A0() { super(); }
}
class A1 extends A0 {
    public A1() { super(); }
}
class B {
    public B() { super(); }
}
aspect A {
    static int a0;
    
    static int a1;
    
    static int b;
    
    before(): execution ((A0+).new()) { A/*A*/.a0++; }
    
    before(): execution ((A1).new()) { A/*A*/.a1++; }
    
    before(): execution ((B).new()) { A/*A*/.b++; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ConstructorSignatures: void <init>()> from ConstructorSignatures
retrieve <ConstructorSignatures: void main(java.lang.String[])> from ConstructorSignatures
retrieve <A0: void <init>()> from A0
retrieve <A1: void <init>()> from A1
retrieve <B: void <init>()> from B
retrieve <A: void <init>()> from A
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming A0... 
Transforming ConstructorSignatures... 
Transforming A... 
Transforming B... 
Transforming A1... 
Abc finished on Thu Jun 24 08:59:30 BST 2004. ( 0 min. 8 sec. )
PASS: Does annotating 'new' with a type work as desired?()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 117 failed (check: 70), 247 passed (check: 81), 0 skipped.
Executing test 365 (new): Referring to inner classes as {super}.{inner} confused ajc.
================================================
Breakdown of abc phases  (total: 12687 millisec.)
------------------------------------------------
[ 00.300% ] Init. of Soot:  38
[ 00.032% ] Loading Jars:  4
[ 85.694% ] Polyglot phases:  10872
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 00.725% ] Recompute name pattern matches:  92
[ 00.000% ] Compute precedence relation:  0
[ 00.457% ] Intertype Adjuster:  58
[ 04.130% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.181% ] Load shadow types:  23
[ 03.318% ] Compute advice lists:  421
[ 00.024% ] Intertype weave:  3
[ 00.315% ] Add aspect code:  40
[ 00.489% ] Weaving advice:  62
[ 00.000% ] Validate jimple:  0
[ 02.412% ] Soot Packs:  306
[ 01.892% ] Soot Writing Output:  240
================================================
Abc started on Thu Jun 24 08:59:32 BST 2004
<<<< InnerClassNaming.java >>>>
import java.awt.*;
import java.awt.event.*;
import org.aspectj.testing.Tester;

public class InnerClassNaming {
    public static void main(java.lang.String[] args) {
        new InnerClassNaming();
    }
    
    InnerClassNaming() {
        super();
        java.awt.event.MouseListener listener =
          this.new InnerClassNaming.MyListener();
        addMouseListener(listener);
    }
    
    void addMouseListener(java.awt.event.MouseListener listener) {  }
    
    class MyListener extends java.awt.event.MouseAdapter {
        public void mousePressed(java.awt.event.MouseEvent e) {
            java.lang.System/*java.lang.System*/.out.println("mousPressed: " +
                                                             e);
        }
        
        public MyListener() { super(); }
    }
    
}
aspect MyAspect {
    pointcut pressed(InnerClassNaming.MyListener ls) :
    this(InnerClassNaming.MyListener) && target(ls) &&
      execution (* (*).mousePressed(..));
    
    before(InnerClassNaming.MyListener ls):
    pressed(ls) {
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
    }
    
    public static MyAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MyAspect() { super(); }
}
retrieve <InnerClassNaming: void addMouseListener(java.awt.event.MouseListener)> from InnerClassNaming
retrieve <InnerClassNaming: void <init>()> from InnerClassNaming
retrieve <InnerClassNaming: void main(java.lang.String[])> from InnerClassNaming
retrieve <InnerClassNaming$MyListener: void <init>(InnerClassNaming)> from InnerClassNaming$MyListener
retrieve <InnerClassNaming$MyListener: void mousePressed(java.awt.event.MouseEvent)> from InnerClassNaming$MyListener
retrieve <MyAspect: void before$0(InnerClassNaming$MyListener,org.aspectj.lang.JoinPoint)> from MyAspect
retrieve <MyAspect: MyAspect aspectOf()> from MyAspect
retrieve <MyAspect: boolean hasAspect()> from MyAspect
retrieve <MyAspect: void <init>()> from MyAspect
Transforming MyAspect... 
Transforming InnerClassNaming... 
Transforming InnerClassNaming$MyListener... 
Abc finished on Thu Jun 24 08:59:45 BST 2004. ( 0 min. 12 sec. )
PASS: Referring to inner classes as {super}.{inner} confused ajc.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 117 failed (check: 70), 248 passed (check: 81), 0 skipped.
Executing test 366 (new): Advice on advice
================================================
Breakdown of abc phases  (total: 8138 millisec.)
------------------------------------------------
[ 00.479% ] Init. of Soot:  39
[ 00.049% ] Loading Jars:  4
[ 73.716% ] Polyglot phases:  5999
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.467% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.750% ] Intertype Adjuster:  61
[ 06.193% ] Retrieving bodies:  504
[ 00.000% ] Weave Initializers:  0
[ 00.270% ] Load shadow types:  22
[ 02.089% ] Compute advice lists:  170
[ 00.037% ] Intertype weave:  3
[ 00.442% ] Add aspect code:  36
[ 01.180% ] Weaving advice:  96
[ 00.000% ] Validate jimple:  0
[ 10.752% ] Soot Packs:  875
[ 03.527% ] Soot Writing Output:  287
================================================
Abc started on Thu Jun 24 08:59:48 BST 2004
<<<< AdviceOnAdvice.java >>>>
import org.aspectj.testing.*;

public class AdviceOnAdvice {
    public static void main(java.lang.String[] args) {
        new Class1().a();
        org.aspectj.testing.Tester.check(Class1/*Class1*/.calledB,
                                         "Aspect2 did not get advice");
    }
    
    public AdviceOnAdvice() { super(); }
}
class Class1 {
    public void a() {  }
    
    public void b() {  }
    
    public static boolean calledA = false;
    
    public static boolean calledB = false;
    
    public Class1() { super(); }
}
aspect Aspect1 {
    pointcut a(Class1 c1) : target(c1) && call(public void (*).a());
    
    void around (Class1 c1):
    a(c1) {
        this.proceed(c1);
        c1.b();
    }
    
    public static Aspect1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect1() { super(); }
}
aspect Aspect2b {
    pointcut b() : call(public void (Class1).b()) && within(Aspect1);
    
    after(): b() { Class1/*Class1*/.calledB = true; }
    
    public static Aspect2b aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect2b() { super(); }
}
retrieve <AdviceOnAdvice: void main(java.lang.String[])> from AdviceOnAdvice
retrieve <AdviceOnAdvice: void <init>()> from AdviceOnAdvice
retrieve <Class1: void a()> from Class1
retrieve <Class1: void b()> from Class1
retrieve <Class1: void <init>()> from Class1
retrieve <Class1: void <clinit>()> from Class1
retrieve <Aspect1: Aspect1 aspectOf()> from Aspect1
retrieve <Aspect1: boolean hasAspect()> from Aspect1
retrieve <Aspect1: void proceed$2(Class1)> from Aspect1
retrieve <Aspect1: void <init>()> from Aspect1
retrieve <Aspect1: void around$0(Class1)> from Aspect1
retrieve <Aspect2b: boolean hasAspect()> from Aspect2b
retrieve <Aspect2b: void <init>()> from Aspect2b
retrieve <Aspect2b: void after$1()> from Aspect2b
retrieve <Aspect2b: Aspect2b aspectOf()> from Aspect2b
Transforming Class1... 
Transforming Aspect1... 
Transforming AdviceOnAdvice... 
Transforming Aspect2b... 
Transforming abc$access$Aspect1$around$0... 
Abc finished on Thu Jun 24 08:59:56 BST 2004. ( 0 min. 8 sec. )
PASS: Advice on advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 117 failed (check: 70), 249 passed (check: 81), 0 skipped.
Executing test 367 (new): Introductions on other introductions
Failed. Current status: 118 failed (check: 70), 249 passed (check: 81), 0 skipped.
Executing test 368 (new): Putting advice on array constructors.
================================================
Breakdown of abc phases  (total: 7037 millisec.)
------------------------------------------------
[ 00.526% ] Init. of Soot:  37
[ 00.043% ] Loading Jars:  3
[ 80.773% ] Polyglot phases:  5684
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.753% ] Recompute name pattern matches:  53
[ 00.014% ] Compute precedence relation:  1
[ 00.526% ] Intertype Adjuster:  37
[ 07.077% ] Retrieving bodies:  498
[ 00.000% ] Weave Initializers:  0
[ 00.412% ] Load shadow types:  29
[ 01.549% ] Compute advice lists:  109
[ 00.043% ] Intertype weave:  3
[ 00.497% ] Add aspect code:  35
[ 00.355% ] Weaving advice:  25
[ 00.000% ] Validate jimple:  0
[ 04.093% ] Soot Packs:  288
[ 03.283% ] Soot Writing Output:  231
================================================
Abc started on Thu Jun 24 09:00:07 BST 2004
<<<< Orleans.java >>>>
import org.aspectj.testing.*;

public class Orleans {
    static boolean called = false;
    
    public static void main(java.lang.String[] args) {
        java.lang.String[] hello =
          new java.lang.String[] { "h", "e", "l", "l", "o" };
        java.lang.Object o = new java.lang.Object();
        o = new Orleans(true);
        org.aspectj.testing.Tester.check(Orleans/*Orleans*/.called,
                                         "Advice was not called.");
    }
    
    public Orleans(boolean b) { super(); }
}
aspect ResourceAccounting {
    pointcut constructions() : call((*).new(..));
    
    before(): constructions() { Orleans/*Orleans*/.called = true; }
    
    public static ResourceAccounting aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ResourceAccounting() { super(); }
}
retrieve <Orleans: void <init>(boolean)> from Orleans
retrieve <Orleans: void <clinit>()> from Orleans
retrieve <Orleans: void main(java.lang.String[])> from Orleans
retrieve <ResourceAccounting: void before$0()> from ResourceAccounting
retrieve <ResourceAccounting: ResourceAccounting aspectOf()> from ResourceAccounting
retrieve <ResourceAccounting: boolean hasAspect()> from ResourceAccounting
retrieve <ResourceAccounting: void <init>()> from ResourceAccounting
Transforming ResourceAccounting... 
Transforming Orleans... 
Abc finished on Thu Jun 24 09:00:15 BST 2004. ( 0 min. 7 sec. )
PASS: Putting advice on array constructors.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 118 failed (check: 70), 250 passed (check: 81), 0 skipped.
Executing test 369 (new): call points within block inner classes are doubled
================================================
Breakdown of abc phases  (total: 7485 millisec.)
------------------------------------------------
[ 00.494% ] Init. of Soot:  37
[ 00.053% ] Loading Jars:  4
[ 75.110% ] Polyglot phases:  5622
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.508% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.802% ] Intertype Adjuster:  60
[ 06.667% ] Retrieving bodies:  499
[ 00.000% ] Weave Initializers:  0
[ 00.307% ] Load shadow types:  23
[ 01.991% ] Compute advice lists:  149
[ 00.160% ] Intertype weave:  12
[ 00.454% ] Add aspect code:  34
[ 00.281% ] Weaving advice:  21
[ 00.000% ] Validate jimple:  0
[ 03.727% ] Soot Packs:  279
[ 09.392% ] Soot Writing Output:  703
================================================
Abc started on Thu Jun 24 09:00:17 BST 2004
<<<< DoubledCalls.java >>>>
import org.aspectj.testing.Tester;

public class DoubledCalls {
    public static void main(java.lang.String[] args) {
        new java.lang.Runnable() {
            public void run() { new Integer(1).intValue(); }
        }.run();
        org.aspectj.testing.Tester.check(A/*A*/.calledInteger,
                                         "A.calledInteger");
    }
    
    public DoubledCalls() { super(); }
}
aspect A {
    static boolean calledInteger = false;
    
    before(): call(* (Integer).*(..)) { A/*A*/.calledInteger = true; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <DoubledCalls: void main(java.lang.String[])> from DoubledCalls
retrieve <DoubledCalls: void <init>()> from DoubledCalls
retrieve <DoubledCalls$1: void <init>()> from DoubledCalls$1
retrieve <DoubledCalls$1: void run()> from DoubledCalls$1
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming DoubledCalls... 
Transforming DoubledCalls$1... 
Abc finished on Thu Jun 24 09:00:25 BST 2004. ( 0 min. 7 sec. )
PASS: call points within block inner classes are doubled()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 118 failed (check: 70), 251 passed (check: 81), 0 skipped.
Executing test 370 (new): Gets and sets with other advice
================================================
Breakdown of abc phases  (total: 8162 millisec.)
------------------------------------------------
[ 00.466% ] Init. of Soot:  38
[ 00.037% ] Loading Jars:  3
[ 73.009% ] Polyglot phases:  5959
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.821% ] Recompute name pattern matches:  67
[ 00.000% ] Compute precedence relation:  0
[ 00.478% ] Intertype Adjuster:  39
[ 06.383% ] Retrieving bodies:  521
[ 00.000% ] Weave Initializers:  0
[ 00.282% ] Load shadow types:  23
[ 10.145% ] Compute advice lists:  828
[ 00.037% ] Intertype weave:  3
[ 00.453% ] Add aspect code:  37
[ 00.527% ] Weaving advice:  43
[ 00.000% ] Validate jimple:  0
[ 04.166% ] Soot Packs:  340
[ 03.149% ] Soot Writing Output:  257
================================================
Abc started on Thu Jun 24 09:00:27 BST 2004
<<<< Counting3.java >>>>
import java.util.Vector;
import org.aspectj.testing.*;

public class Counting3 {
    public static void main(java.lang.String[] args) {
        Testing.start();
        new Counting3().f();
        Testing.finish();
    }
    
    int j;
    
    void f() {
        this/*null*/.j = 13;
        int i = this/*null*/.j;
    }
    
    public Counting3() { super(); }
}
class Testing {
    static void start() {
        org.aspectj.testing.Tester.expectEventsInString(("e,egs,cegs,c,cgs,cegs,e,egs,cegs,s,gs,cgs,egs,cegs,g,gs,cgs," +
                                                         "egs,cegs"));
    }
    
    static void finish() {
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public Testing() { super(); }
}
aspect JoinPointCounting {
    pointcut g() : get( * (*).*) && within(Counting3);
    
    before(): g() { a("g"); }
    
    pointcut s() : set( * (*).*) && within(Counting3);
    
    before(): s() { a("s"); }
    
    pointcut gs() : g() || s();
    
    before(): gs() { a("gs"); }
    
    pointcut c() :
    call(* (*).*(..)) && within(Counting3) &&
      !call(* (Testing).*());
    
    before(): c() { a("c"); }
    
    pointcut e() : execution (* (*).*(..)) && within(Counting3);
    
    before(): e() { a("e"); }
    
    pointcut cgs() : c() || gs();
    
    before(): cgs() { a("cgs"); }
    
    pointcut egs() : e() || gs();
    
    before(): egs() { a("egs"); }
    
    pointcut cegs() : c() || e() || gs();
    
    before(): cegs() { a("cegs"); }
    
    static void a(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public static JoinPointCounting aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public JoinPointCounting() { super(); }
}
retrieve <Counting3: void main(java.lang.String[])> from Counting3
retrieve <Counting3: void f()> from Counting3
retrieve <Counting3: void <init>()> from Counting3
retrieve <Testing: void start()> from Testing
retrieve <Testing: void finish()> from Testing
retrieve <Testing: void <init>()> from Testing
retrieve <JoinPointCounting: void before$0()> from JoinPointCounting
retrieve <JoinPointCounting: void before$1()> from JoinPointCounting
retrieve <JoinPointCounting: void before$2()> from JoinPointCounting
retrieve <JoinPointCounting: void before$3()> from JoinPointCounting
retrieve <JoinPointCounting: void before$4()> from JoinPointCounting
retrieve <JoinPointCounting: void before$5()> from JoinPointCounting
retrieve <JoinPointCounting: void before$6()> from JoinPointCounting
retrieve <JoinPointCounting: void before$7()> from JoinPointCounting
retrieve <JoinPointCounting: void a(java.lang.String)> from JoinPointCounting
retrieve <JoinPointCounting: JoinPointCounting aspectOf()> from JoinPointCounting
retrieve <JoinPointCounting: boolean hasAspect()> from JoinPointCounting
retrieve <JoinPointCounting: void <init>()> from JoinPointCounting
Transforming JoinPointCounting... 
Transforming Counting3... 
Transforming Testing... 
Abc finished on Thu Jun 24 09:00:35 BST 2004. ( 0 min. 8 sec. )
PASS: Gets and sets with other advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 118 failed (check: 70), 252 passed (check: 81), 0 skipped.
Executing test 371 (new): Compiler can compile correct strictfp modifiers
================================================
Breakdown of abc phases  (total: 7178 millisec.)
------------------------------------------------
[ 00.543% ] Init. of Soot:  39
[ 00.042% ] Loading Jars:  3
[ 81.165% ] Polyglot phases:  5826
[ 00.000% ] Resolve class names:  0
[ 00.028% ] Declare Parents:  2
[ 00.697% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.557% ] Intertype Adjuster:  40
[ 07.314% ] Retrieving bodies:  525
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  23
[ 02.104% ] Compute advice lists:  151
[ 00.042% ] Intertype weave:  3
[ 00.125% ] Add aspect code:  9
[ 00.195% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.580% ] Soot Packs:  257
[ 03.288% ] Soot Writing Output:  236
================================================
Abc started on Thu Jun 24 09:00:38 BST 2004
<<<< StrictFpCompile.java >>>>
import org.aspectj.testing.*;

public strictfp class StrictFpCompile {
    public static void main(java.lang.String[] args) {
        new StrictFpCompile().go();
        org.aspectj.testing.Tester.check(StrictFpCompile/*StrictFpCompile*/.ran,
                                         "go did not run");
    }
    
    static boolean ran = false;
    
    void go() { StrictFpCompile/*StrictFpCompile*/.ran = true; }
    
    public StrictFpCompile() { super(); }
}
strictfp interface StrictInterface {
    public abstract float test2();
}
abstract strictfp class StrictClass {
    double d;
    
    StrictClass(double _d) {
        super();
        this/*null*/.d = _d;
    }
    
    abstract float test1();
    
    float test2() { return 0.0F; }
    
    strictfp float test3() { return 0.0F; }
    
    static strictfp float test4() { return 0.0F; }
}
class NonStrictClass {
    NonStrictClass() { super(); }
    
    float test2() { return 0.0F; }
    
    strictfp float test3() { return 0.0F; }
    
    static strictfp float test4() { return 0.0F; }
}
strictfp class OuterStrictClass {
    class InnerStrictClass {
        class InnerInnerClass {
            public InnerInnerClass() { super(); }
        }
        
        
        public InnerStrictClass() { super(); }
    }
    
    
    public OuterStrictClass() { super(); }
}
retrieve <StrictFpCompile: void main(java.lang.String[])> from StrictFpCompile
retrieve <StrictFpCompile: void go()> from StrictFpCompile
retrieve <StrictFpCompile: void <init>()> from StrictFpCompile
retrieve <StrictFpCompile: void <clinit>()> from StrictFpCompile
retrieve <StrictClass: void <init>(double)> from StrictClass
retrieve <StrictClass: float test2()> from StrictClass
retrieve <StrictClass: float test3()> from StrictClass
retrieve <StrictClass: float test4()> from StrictClass
retrieve <NonStrictClass: void <init>()> from NonStrictClass
retrieve <NonStrictClass: float test2()> from NonStrictClass
retrieve <NonStrictClass: float test3()> from NonStrictClass
retrieve <NonStrictClass: float test4()> from NonStrictClass
retrieve <OuterStrictClass: void <init>()> from OuterStrictClass
retrieve <OuterStrictClass$InnerStrictClass: void <init>(OuterStrictClass)> from OuterStrictClass$InnerStrictClass
retrieve <OuterStrictClass$InnerStrictClass$InnerInnerClass: void <init>(OuterStrictClass$InnerStrictClass)> from OuterStrictClass$InnerStrictClass$InnerInnerClass
Transforming StrictFpCompile... 
Transforming StrictClass... 
Transforming OuterStrictClass... 
Transforming NonStrictClass... 
Transforming OuterStrictClass$InnerStrictClass... 
Transforming OuterStrictClass$InnerStrictClass$InnerInnerClass... 
Transforming StrictInterface... 
Abc finished on Thu Jun 24 09:00:45 BST 2004. ( 0 min. 7 sec. )
PASS: Compiler can compile correct strictfp modifiers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 118 failed (check: 70), 253 passed (check: 81), 0 skipped.
Executing test 372 (new): basic test of callsto pointcuts
================================================
Breakdown of abc phases  (total: 8686 millisec.)
------------------------------------------------
[ 00.449% ] Init. of Soot:  39
[ 00.046% ] Loading Jars:  4
[ 69.526% ] Polyglot phases:  6039
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.564% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.679% ] Intertype Adjuster:  59
[ 06.251% ] Retrieving bodies:  543
[ 00.000% ] Weave Initializers:  0
[ 00.265% ] Load shadow types:  23
[ 11.743% ] Compute advice lists:  1020
[ 00.035% ] Intertype weave:  3
[ 00.403% ] Add aspect code:  35
[ 00.691% ] Weaving advice:  60
[ 00.000% ] Validate jimple:  0
[ 05.549% ] Soot Packs:  482
[ 03.753% ] Soot Writing Output:  326
================================================
Failed. Current status: 119 failed (check: 70), 253 passed (check: 81), 0 skipped.
Executing test 373 (new): package wildcards in packages
================================================
Breakdown of abc phases  (total: 8516 millisec.)
------------------------------------------------
[ 00.446% ] Init. of Soot:  38
[ 00.035% ] Loading Jars:  3
[ 72.511% ] Polyglot phases:  6175
[ 00.023% ] Resolve class names:  2
[ 00.012% ] Declare Parents:  1
[ 00.622% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.434% ] Intertype Adjuster:  37
[ 06.083% ] Retrieving bodies:  518
[ 00.000% ] Weave Initializers:  0
[ 00.352% ] Load shadow types:  30
[ 09.887% ] Compute advice lists:  842
[ 00.035% ] Intertype weave:  3
[ 00.423% ] Add aspect code:  36
[ 01.151% ] Weaving advice:  98
[ 00.000% ] Validate jimple:  0
[ 04.439% ] Soot Packs:  378
[ 03.546% ] Soot Writing Output:  302
================================================
Abc started on Thu Jun 24 09:00:59 BST 2004
<<<< PackageWildcards.java >>>>
package pack;

import org.aspectj.testing.Tester;

public aspect PackageWildcards {
    pointcut fooCut() : call(String (*).foo());
    
    String around ():
    fooCut() &&
      within(*) {
        java.lang.String result = this.proceed();
        return result + ":fooCut";
    }
    
    pointcut allMethodsCut() :
    target(pack.Foo) &&
      call(!abstract String (*).*(..));
    
    String around ():
    allMethodsCut() {
        java.lang.String result = this.proceed();
        return result + ":allMethodsCut";
    }
    
    public static void test() {
        java.lang.String message = new pack.Foo().foo();
        org.aspectj.testing.Tester.checkEqual(message,
                                              "foo:allMethodsCut:fooCut",
                                              "all advice active");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static pack.PackageWildcards aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public PackageWildcards() { super(); }
}
class Foo {
    java.lang.String foo() { return "foo"; }
    
    public Foo() { super(); }
}
retrieve <pack.PackageWildcards: java.lang.String around$0()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: java.lang.String around$1()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: void test()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: void main(java.lang.String[])> from pack.PackageWildcards
retrieve <pack.PackageWildcards: pack.PackageWildcards aspectOf()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: boolean hasAspect()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: void <init>()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: java.lang.String proceed$2()> from pack.PackageWildcards
retrieve <pack.PackageWildcards: java.lang.String proceed$3()> from pack.PackageWildcards
retrieve <pack.Foo: java.lang.String foo()> from pack.Foo
retrieve <pack.Foo: void <init>()> from pack.Foo
Transforming pack.PackageWildcards... 
Transforming pack.Foo... 
Transforming abc$access$pack_d_PackageWildcards$around$1... 
Transforming abc$access$pack_d_PackageWildcards$around$0... 
Abc finished on Thu Jun 24 09:01:08 BST 2004. ( 0 min. 8 sec. )
PASS: package wildcards in packages()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 119 failed (check: 70), 254 passed (check: 81), 0 skipped.
Executing test 374 (new): advice on catch clauses
getting SJPInfo for a untagged source line $r2 := @caughtexception
================================================
Breakdown of abc phases  (total: 8406 millisec.)
------------------------------------------------
[ 00.452% ] Init. of Soot:  38
[ 00.036% ] Loading Jars:  3
[ 71.306% ] Polyglot phases:  5994
[ 00.024% ] Resolve class names:  2
[ 00.012% ] Declare Parents:  1
[ 00.678% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.428% ] Intertype Adjuster:  36
[ 07.590% ] Retrieving bodies:  638
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  26
[ 10.588% ] Compute advice lists:  890
[ 00.036% ] Intertype weave:  3
[ 00.119% ] Add aspect code:  10
[ 01.237% ] Weaving advice:  104
[ 00.000% ] Validate jimple:  0
[ 04.045% ] Soot Packs:  340
[ 03.141% ] Soot Writing Output:  264
================================================
Failed. Current status: 120 failed (check: 70), 254 passed (check: 81), 0 skipped.
Executing test 375 (new): around advice on calls and receptions with lots of context
================================================
Breakdown of abc phases  (total: 8351 millisec.)
------------------------------------------------
[ 00.455% ] Init. of Soot:  38
[ 00.048% ] Loading Jars:  4
[ 70.770% ] Polyglot phases:  5910
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.647% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.455% ] Intertype Adjuster:  38
[ 12.861% ] Retrieving bodies:  1074
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  23
[ 04.119% ] Compute advice lists:  344
[ 00.036% ] Intertype weave:  3
[ 00.431% ] Add aspect code:  36
[ 01.233% ] Weaving advice:  103
[ 00.000% ] Validate jimple:  0
[ 04.790% ] Soot Packs:  400
[ 03.832% ] Soot Writing Output:  320
================================================
Abc started on Thu Jun 24 09:01:21 BST 2004
<<<< AroundCalls.java >>>>
import org.aspectj.testing.Tester;

public class AroundCalls {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(new C().m(),
                                              "acb:2",
                                              "many arounds");
    }
    
    public AroundCalls() { super(); }
}
class C {
    public java.lang.String m() { return new D().m1("a", 0); }
    
    public C() { super(); }
}
class D {
    public java.lang.String m1(java.lang.String s, int x) {
        return s + ":" + x;
    }
    
    public D() { super(); }
}
aspect A {
    String around (D d, String as, int ax):
    call(String (D).m1(String, int)) && args(as, ax) &&
      target(d) {
        return this.proceed(d, as + "c", ax + 1);
    }
    
    String around (String as, D d1, int ax):
    within(C) && target(d1) && call(String (*).m1(String, int)) &&
      args(as, ax) {
        return this.proceed(as + "b", d1, ax + 1);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AroundCalls: void main(java.lang.String[])> from AroundCalls
retrieve <AroundCalls: void test()> from AroundCalls
retrieve <AroundCalls: void <init>()> from AroundCalls
retrieve <C: java.lang.String m()> from C
retrieve <C: void <init>()> from C
retrieve <D: java.lang.String m1(java.lang.String,int)> from D
retrieve <D: void <init>()> from D
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String around$0(D,java.lang.String,int)> from A
retrieve <A: java.lang.String around$1(java.lang.String,D,int)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: java.lang.String proceed$2(D,java.lang.String,int)> from A
retrieve <A: java.lang.String proceed$3(java.lang.String,D,int)> from A
Transforming D... 
Transforming AroundCalls... 
Transforming A... 
Transforming C... 
Transforming abc$access$A$around$1... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 09:01:30 BST 2004. ( 0 min. 8 sec. )
PASS: around advice on calls and receptions with lots of context()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 120 failed (check: 70), 255 passed (check: 81), 0 skipped.
Executing test 376 (new): ! modifier and char in pointcut (no longer an error)
================================================
Breakdown of abc phases  (total: 8443 millisec.)
------------------------------------------------
[ 00.450% ] Init. of Soot:  38
[ 00.047% ] Loading Jars:  4
[ 76.572% ] Polyglot phases:  6465
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.415% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.426% ] Intertype Adjuster:  36
[ 07.959% ] Retrieving bodies:  672
[ 00.000% ] Weave Initializers:  0
[ 00.308% ] Load shadow types:  26
[ 06.052% ] Compute advice lists:  511
[ 00.036% ] Intertype weave:  3
[ 00.154% ] Add aspect code:  13
[ 00.178% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 03.861% ] Soot Packs:  326
[ 03.494% ] Soot Writing Output:  295
================================================
Abc started on Thu Jun 24 09:01:33 BST 2004
<<<< NotCharInPointcut.java >>>>
public class NotCharInPointcut {
    public static void main(java.lang.String[] args)
          throws java.lang.Exception {
        for (int i = 0;
             i <
             NotCharInPointcut/*NotCharInPointcut*/.methods/*null*/.length;
             i++) {
            org.aspectj.testing.Tester.expectEvent(NotCharInPointcut/*NotCharInPointcut*/.methods[i]);
            C.class.getMethod(NotCharInPointcut/*NotCharInPointcut*/.methods[i],
                              new java.lang.Class[] {  }).invoke(new C(),
                                                                 new java.lang.Object[] {  });
        }
    }
    
    static final java.lang.String[] methods =
      { "_void", "_boolean", "_byte", "_char", "_short", "_int", "_long", "_float", "_double", "_Object" };
    
    public NotCharInPointcut() { super(); }
}
class C {
    private void s(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public void _void() { s("_void"); }
    
    public boolean _boolean() {
        s("_boolean");
        return (boolean) false;
    }
    
    public byte _byte() {
        s("_byte");
        return (byte) 0;
    }
    
    public char _char() {
        s("_char");
        return (char) 0;
    }
    
    public short _short() {
        s("_short");
        return (short) 0;
    }
    
    public int _int() {
        s("_int");
        return (int) 0;
    }
    
    public long _long() {
        s("_long");
        return (long) 0;
    }
    
    public float _float() {
        s("_float");
        return (float) 0;
    }
    
    public double _double() {
        s("_double");
        return (double) 0;
    }
    
    public java.lang.Object _Object() {
        s("_Object");
        return this;
    }
    
    public C() { super(); }
}
aspect A {
    pointcut pcut1(NotCharInPointcut t) :
    this(t) &&
      execution (!* (*)._*());
    
    pointcut pcut2(NotCharInPointcut t) :
    this(t) && !this(NotCharInPointcut) &&
      execution (!* (*)._*());
    
    pointcut pcut3(NotCharInPointcut t) : pcut1(t) || pcut2(t);
    
    before(NotCharInPointcut t): pcut1(t) { s("1:" + thisJoinPoint); }
    
    before(): pcut2() { s("2:" + thisJoinPoint); }
    
    before(NotCharInPointcut t): pcut3(t) { s("3:" + thisJoinPoint); }
    
    private static final void s(java.lang.Object s) {
        org.aspectj.testing.Tester.check(false, "should be in " + s);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <NotCharInPointcut: java.lang.Class class$(java.lang.String)> from NotCharInPointcut
retrieve <NotCharInPointcut: void main(java.lang.String[])> from NotCharInPointcut
retrieve <NotCharInPointcut: void <init>()> from NotCharInPointcut
retrieve <NotCharInPointcut: void <clinit>()> from NotCharInPointcut
retrieve <C: void <init>()> from C
retrieve <C: void s(java.lang.String)> from C
retrieve <C: void _void()> from C
retrieve <C: boolean _boolean()> from C
retrieve <C: byte _byte()> from C
retrieve <C: char _char()> from C
retrieve <C: short _short()> from C
retrieve <C: int _int()> from C
retrieve <C: long _long()> from C
retrieve <C: float _float()> from C
retrieve <C: double _double()> from C
retrieve <C: java.lang.Object _Object()> from C
retrieve <A: void <init>()> from A
retrieve <A: void before$0(NotCharInPointcut,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$2(NotCharInPointcut,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void s(java.lang.Object)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming NotCharInPointcut... 
Transforming A... 
Transforming C... 
Abc finished on Thu Jun 24 09:01:41 BST 2004. ( 0 min. 8 sec. )
PASS: ! modifier and char in pointcut (no longer an error)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 120 failed (check: 70), 256 passed (check: 81), 0 skipped.
Executing test 377 (new): right number of aspect instances per cflow
================================================
Breakdown of abc phases  (total: 8093 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  39
[ 00.037% ] Loading Jars:  3
[ 72.853% ] Polyglot phases:  5896
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.470% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.754% ] Intertype Adjuster:  61
[ 12.109% ] Retrieving bodies:  980
[ 00.000% ] Weave Initializers:  0
[ 00.284% ] Load shadow types:  23
[ 03.966% ] Compute advice lists:  321
[ 00.037% ] Intertype weave:  3
[ 00.259% ] Add aspect code:  21
[ 01.087% ] Weaving advice:  88
[ 00.000% ] Validate jimple:  0
[ 04.559% ] Soot Packs:  369
[ 03.052% ] Soot Writing Output:  247
================================================
Abc started on Thu Jun 24 09:01:44 BST 2004
<<<< CFlowObjects.java >>>>
import org.aspectj.testing.Tester;

public class CFlowObjects {
    public static void main(java.lang.String[] args) {
        new Test().go();
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.cflowObjects,
                                              1,
                                              "1st cflow");
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.callsPerCFlow,
                                              1,
                                              "1 call for each cflow");
        new Test().go();
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.cflowObjects,
                                              2,
                                              "2nd cflow");
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.callsPerCFlow,
                                              1,
                                              "1 call for each cflow");
    }
    
    public CFlowObjects() { super(); }
}
class Test {
    static int cflowObjects = 0;
    
    static int callsPerCFlow = 0;
    
    void go() { foo(); }
    
    void foo() {  }
    
    public Test() { super(); }
}
aspect A {
    { Test/*Test*/.cflowObjects++; }
    
    { Test/*Test*/.callsPerCFlow = 0; }
    
    before():
    within(Test) &&
      call(void (Object+).*(..)) {
        Test/*Test*/.callsPerCFlow++;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <CFlowObjects: void <init>()> from CFlowObjects
retrieve <CFlowObjects: void main(java.lang.String[])> from CFlowObjects
retrieve <Test: void <clinit>()> from Test
retrieve <Test: void go()> from Test
retrieve <Test: void foo()> from Test
retrieve <Test: void <init>()> from Test
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming CFlowObjects... 
Transforming Test... 
Abc finished on Thu Jun 24 09:01:52 BST 2004. ( 0 min. 8 sec. )
PASS: right number of aspect instances per cflow()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 120 failed (check: 70), 257 passed (check: 81), 0 skipped.
Executing test 378 (new): many this's into around advice on calls
================================================
Breakdown of abc phases  (total: 9022 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  38
[ 00.044% ] Loading Jars:  4
[ 69.331% ] Polyglot phases:  6255
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.599% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.421% ] Intertype Adjuster:  38
[ 09.344% ] Retrieving bodies:  843
[ 00.000% ] Weave Initializers:  0
[ 00.266% ] Load shadow types:  24
[ 04.866% ] Compute advice lists:  439
[ 00.078% ] Intertype weave:  7
[ 00.643% ] Add aspect code:  58
[ 01.164% ] Weaving advice:  105
[ 00.011% ] Validate jimple:  1
[ 06.772% ] Soot Packs:  611
[ 05.996% ] Soot Writing Output:  541
================================================
Abc started on Thu Jun 24 09:01:54 BST 2004
<<<< AroundCallsArgs.java >>>>
import org.aspectj.testing.Tester;

public class AroundCallsArgs {
    public static void main(java.lang.String[] args) {
        new CL().go();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.data,
                                              "CP(hello)");
    }
    
    public AroundCallsArgs() { super(); }
}
aspect A {
    public static java.lang.String data = "";
    
    pointcut parseCalls(CP cp, java.lang.String cmd) :
    target(cp) && args(cmd) && call(void (CP).parse(String)) &&
      within(CL);
    
    void around (CP cp, String cmd):
    parseCalls(cp,
        cmd) {
        A/*A*/.data = cp.getClass().getName() + "(" + cmd + ")";
        this.proceed(cp, cmd);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class CL {
    void go() { new CP().parse("hello"); }
    
    public CL() { super(); }
}
class CP {
    void parse(java.lang.String cmd) {  }
    
    public CP() { super(); }
}
retrieve <AroundCallsArgs: void main(java.lang.String[])> from AroundCallsArgs
retrieve <AroundCallsArgs: void <init>()> from AroundCallsArgs
retrieve <A: void <init>()> from A
retrieve <A: void around$0(CP,java.lang.String)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void proceed$1(CP,java.lang.String)> from A
retrieve <A: void <clinit>()> from A
retrieve <CL: void <init>()> from CL
retrieve <CL: void go()> from CL
retrieve <CP: void <init>()> from CP
retrieve <CP: void parse(java.lang.String)> from CP
Transforming AroundCallsArgs... 
Transforming A... 
Transforming CP... 
Transforming CL... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 09:02:03 BST 2004. ( 0 min. 9 sec. )
PASS: many this's into around advice on calls()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 120 failed (check: 70), 258 passed (check: 81), 0 skipped.
Executing test 379 (new): Ensures introduction methods can have advice placed on them
================================================
Breakdown of abc phases  (total: 14674 millisec.)
------------------------------------------------
[ 00.382% ] Init. of Soot:  56
[ 00.027% ] Loading Jars:  4
[ 71.371% ] Polyglot phases:  10473
[ 00.014% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  2
[ 00.702% ] Recompute name pattern matches:  103
[ 00.000% ] Compute precedence relation:  0
[ 01.070% ] Intertype Adjuster:  157
[ 05.452% ] Retrieving bodies:  800
[ 00.000% ] Weave Initializers:  0
[ 00.245% ] Load shadow types:  36
[ 02.917% ] Compute advice lists:  428
[ 00.020% ] Intertype weave:  3
[ 00.170% ] Add aspect code:  25
[ 00.354% ] Weaving advice:  52
[ 00.000% ] Validate jimple:  0
[ 06.631% ] Soot Packs:  973
[ 10.631% ] Soot Writing Output:  1560
================================================
Abc started on Thu Jun 24 09:02:08 BST 2004
<<<< Dominates.java >>>>
import org.aspectj.testing.*;

public class Dominates {
    public static void main(java.lang.String[] args) {
        new Dominates().go(args);
    }
    
    void go(java.lang.String[] args) {
        new A().run();
        new ExtendsA().run();
        new ExtendsRunnable().run();
        org.aspectj.testing.Tester.check(Flags/*Flags*/.run1,
                                         "Flags.run1");
        org.aspectj.testing.Tester.check(Flags/*Flags*/.run2,
                                         "Flags.run2");
        org.aspectj.testing.Tester.check(Flags/*Flags*/.run3,
                                         "Flags.run3");
        org.aspectj.testing.Tester.check(Flags/*Flags*/.run4,
                                         "Flags.run4");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run1,
                                         "ExtendsFlags.run1");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run2,
                                         "ExtendsFlags.run2");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run3,
                                         "ExtendsFlags.run3");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run4,
                                         "ExtendsFlags.run4");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run5,
                                         "ExtendsFlags.run5");
        org.aspectj.testing.Tester.check(ExtendsFlags/*ExtendsFlags*/.run6,
                                         "ExtendsFlags.run6");
    }
    
    public Dominates() { super(); }
}
class A {
    public A() { super(); }
}
class Flags {
    public static boolean run1 = false;
    
    public static boolean run2 = false;
    
    public static boolean run3 = false;
    
    public static boolean run4 = false;
    
    public Flags() { super(); }
}
aspect Aspect0 {
    pointcut run() : call(* (*).run(..)) && target(A);
    
    before(): run() { Flags/*Flags*/.run1 = true; }
    
    public static Aspect0 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect0() { super(); }
}
aspect Aspect00 {
    pointcut run() :
    call(* (*).run(..)) &&
      target(java.lang.Runnable);
    
    before(): run() { Flags/*Flags*/.run4 = true; }
    
    public static Aspect00 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect00() { super(); }
}
aspect Aspect1 {
    declare parents : A implements java.lang.Runnable;
    
    public intertype void A.run() {  }
    
    public static Aspect1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect1() { super(); }
}
aspect Aspect2 {
    pointcut run() : call(* (*).run(..)) && target(A);
    
    before(): run() { Flags/*Flags*/.run2 = true; }
    
    public static Aspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect2() { super(); }
}
aspect Aspect3 {
    pointcut run() :
    call(* (*).run(..)) &&
      target(java.lang.Runnable);
    
    before(): run() { Flags/*Flags*/.run3 = true; }
    
    public static Aspect3 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect3() { super(); }
}
class ExtendsA {
    public ExtendsA() { super(); }
}
class ExtendsRunnable {
    public void run() {  }
    
    public ExtendsRunnable() { super(); }
}
class ExtendsFlags {
    public static boolean run1 = false;
    
    public static boolean run2 = false;
    
    public static boolean run3 = false;
    
    public static boolean run4 = false;
    
    public static boolean run5 = false;
    
    public static boolean run6 = false;
    
    public ExtendsFlags() { super(); }
}
aspect AspectExtends0 {
    pointcut run() : call(* (*).run(..)) && target(ExtendsA);
    
    before(): run() { ExtendsFlags/*ExtendsFlags*/.run1 = true; }
    
    public static AspectExtends0 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectExtends0() { super(); }
}
aspect AspectExtends00 {
    pointcut run(ExtendsRunnable r) :
    call(* (*).run(..)) &&
      target(r);
    
    before(ExtendsRunnable r):
    run(r) {
        if (r instanceof ExtendsA) {
            ExtendsFlags/*ExtendsFlags*/.run5 = true;
        } else {
            ExtendsFlags/*ExtendsFlags*/.run6 = true;
        }
    }
    
    public static AspectExtends00 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectExtends00() { super(); }
}
aspect AspectExtends1 {
    declare parents : ExtendsA extends ExtendsRunnable;
    
    public intertype void ExtendsA.run() {  }
    
    public static AspectExtends1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectExtends1() { super(); }
}
aspect AspectExtends2 {
    pointcut run() : call(* (*).run(..)) && target(ExtendsA);
    
    before(): run() { ExtendsFlags/*ExtendsFlags*/.run2 = true; }
    
    public static AspectExtends2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectExtends2() { super(); }
}
aspect AspectExtends3 {
    pointcut run(ExtendsRunnable r) :
    call(* (*).run(..)) &&
      target(r);
    
    before(ExtendsRunnable r):
    run(r) {
        if (r instanceof ExtendsA) {
            ExtendsFlags/*ExtendsFlags*/.run3 = true;
        } else {
            ExtendsFlags/*ExtendsFlags*/.run4 = true;
        }
    }
    
    public static AspectExtends3 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectExtends3() { super(); }
}
retrieve <Dominates: void go(java.lang.String[])> from Dominates
retrieve <Dominates: void <init>()> from Dominates
retrieve <Dominates: void main(java.lang.String[])> from Dominates
retrieve <A: void <init>()> from A
retrieve <A: void run()> from A
retrieve <Flags: void <init>()> from Flags
retrieve <Flags: void <clinit>()> from Flags
retrieve <Aspect0: void before$0()> from Aspect0
retrieve <Aspect0: Aspect0 aspectOf()> from Aspect0
retrieve <Aspect0: boolean hasAspect()> from Aspect0
retrieve <Aspect0: void <init>()> from Aspect0
retrieve <Aspect00: void before$1()> from Aspect00
retrieve <Aspect00: Aspect00 aspectOf()> from Aspect00
retrieve <Aspect00: boolean hasAspect()> from Aspect00
retrieve <Aspect00: void <init>()> from Aspect00
retrieve <Aspect1: void run(A)> from Aspect1
retrieve <Aspect1: Aspect1 aspectOf()> from Aspect1
retrieve <Aspect1: boolean hasAspect()> from Aspect1
retrieve <Aspect1: void <init>()> from Aspect1
retrieve <Aspect2: Aspect2 aspectOf()> from Aspect2
retrieve <Aspect2: boolean hasAspect()> from Aspect2
retrieve <Aspect2: void <init>()> from Aspect2
retrieve <Aspect2: void before$3()> from Aspect2
retrieve <Aspect3: boolean hasAspect()> from Aspect3
retrieve <Aspect3: void <init>()> from Aspect3
retrieve <Aspect3: void before$4()> from Aspect3
retrieve <Aspect3: Aspect3 aspectOf()> from Aspect3
retrieve <ExtendsA: void <init>()> from ExtendsA
retrieve <ExtendsA: void run()> from ExtendsA
retrieve <ExtendsRunnable: void run()> from ExtendsRunnable
retrieve <ExtendsRunnable: void <init>()> from ExtendsRunnable
retrieve <ExtendsFlags: void <init>()> from ExtendsFlags
retrieve <ExtendsFlags: void <clinit>()> from ExtendsFlags
retrieve <AspectExtends0: void before$5()> from AspectExtends0
retrieve <AspectExtends0: AspectExtends0 aspectOf()> from AspectExtends0
retrieve <AspectExtends0: boolean hasAspect()> from AspectExtends0
retrieve <AspectExtends0: void <init>()> from AspectExtends0
retrieve <AspectExtends00: boolean hasAspect()> from AspectExtends00
retrieve <AspectExtends00: void <init>()> from AspectExtends00
retrieve <AspectExtends00: void before$6(ExtendsRunnable)> from AspectExtends00
retrieve <AspectExtends00: AspectExtends00 aspectOf()> from AspectExtends00
retrieve <AspectExtends1: void run(ExtendsA)> from AspectExtends1
retrieve <AspectExtends1: AspectExtends1 aspectOf()> from AspectExtends1
retrieve <AspectExtends1: boolean hasAspect()> from AspectExtends1
retrieve <AspectExtends1: void <init>()> from AspectExtends1
retrieve <AspectExtends2: void before$8()> from AspectExtends2
retrieve <AspectExtends2: AspectExtends2 aspectOf()> from AspectExtends2
retrieve <AspectExtends2: boolean hasAspect()> from AspectExtends2
retrieve <AspectExtends2: void <init>()> from AspectExtends2
retrieve <AspectExtends3: void before$9(ExtendsRunnable)> from AspectExtends3
retrieve <AspectExtends3: AspectExtends3 aspectOf()> from AspectExtends3
retrieve <AspectExtends3: boolean hasAspect()> from AspectExtends3
retrieve <AspectExtends3: void <init>()> from AspectExtends3
Transforming AspectExtends2... 
Transforming A... 
Transforming ExtendsFlags... 
Transforming AspectExtends00... 
Transforming Aspect00... 
Transforming AspectExtends0... 
Transforming ExtendsRunnable... 
Transforming Aspect3... 
Transforming Dominates... 
Transforming AspectExtends3... 
Transforming AspectExtends1... 
Transforming Aspect2... 
Transforming ExtendsA... 
Transforming Aspect0... 
Transforming Flags... 
Transforming Aspect1... 
Abc finished on Thu Jun 24 09:02:23 BST 2004. ( 0 min. 14 sec. )
PASS: Ensures introduction methods can have advice placed on them()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 16 seconds
Passed. Current status: 120 failed (check: 70), 259 passed (check: 81), 0 skipped.
Executing test 380 (new): No boolean appearing in the 'if' clause for around advice with eachJVM()
================================================
Breakdown of abc phases  (total: 20357 millisec.)
------------------------------------------------
[ 00.698% ] Init. of Soot:  142
[ 00.015% ] Loading Jars:  3
[ 63.099% ] Polyglot phases:  12845
[ 00.010% ] Resolve class names:  2
[ 00.010% ] Declare Parents:  2
[ 00.545% ] Recompute name pattern matches:  111
[ 00.000% ] Compute precedence relation:  0
[ 00.192% ] Intertype Adjuster:  39
[ 07.516% ] Retrieving bodies:  1530
[ 00.000% ] Weave Initializers:  0
[ 00.142% ] Load shadow types:  29
[ 06.735% ] Compute advice lists:  1371
[ 00.020% ] Intertype weave:  4
[ 00.196% ] Add aspect code:  40
[ 01.695% ] Weaving advice:  345
[ 00.000% ] Validate jimple:  0
[ 12.777% ] Soot Packs:  2601
[ 06.352% ] Soot Writing Output:  1293
================================================
Abc started on Thu Jun 24 09:02:28 BST 2004
<<<< PR355.java >>>>
import org.aspectj.testing.*;
import java.io.*;

public class PR355 {
    public static void main(java.lang.String[] args) {
        new PR355().go();
    }
    
    static {
               java.lang.String[] types =
                 { "static", "non", "instance" };
               java.lang.String[] advice =
                 { "before", "after", "around" };
               for (int i = 0; i < types/*null*/.length; i++) {
                   for (int j = 0; j < advice/*null*/.length; j++) {
                       org.aspectj.testing.Tester.expectEvent(types[i] +
                                                              "-" +
                                                              advice[j]);
                   }
               }
               org.aspectj.testing.Tester.expectEventsInString("C.f,C.e");
           }
    
    void go() {
        new C().f();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PR355() { super(); }
}
class C {
    void f() {
        org.aspectj.testing.Tester.event("C.f");
        e();
    }
    
    void e() { org.aspectj.testing.Tester.event("C.e"); }
    
    public C() { super(); }
}
abstract aspect Cuts {
    pointcut p() : within(C) && call(* (C).*(..));
    
    static void a(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public Cuts() { super(); }
}
aspect StaticAspect extends Cuts {
    before(): p() { a("static-before"); }
    
    void around ():
    p() {
        a("static-around");
        this.proceed();
    }
    
    after(): p() { a("static-after"); }
    
    public static StaticAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public StaticAspect() { super(); }
}
aspect NonStaticAspect extends Cuts {
    before(): p() { a("non-before"); }
    
    void around ():
    p() {
        a("non-around");
        this.proceed();
    }
    
    after(): p() { a("non-after"); }
    
    public static NonStaticAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public NonStaticAspect() { super(); }
}
aspect InstanceOfAspect extends Cuts {
    before(): p() { a("instance-before"); }
    
    void around ():
    p() {
        a("instance-around");
        this.proceed();
    }
    
    after(): p() { a("instance-after"); }
    
    public static InstanceOfAspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public InstanceOfAspect() { super(); }
}
retrieve <PR355: void main(java.lang.String[])> from PR355
retrieve <PR355: void go()> from PR355
retrieve <PR355: void <init>()> from PR355
retrieve <PR355: void <clinit>()> from PR355
retrieve <C: void f()> from C
retrieve <C: void e()> from C
retrieve <C: void <init>()> from C
retrieve <Cuts: void a(java.lang.String)> from Cuts
retrieve <Cuts: void <init>()> from Cuts
retrieve <StaticAspect: void <init>()> from StaticAspect
retrieve <StaticAspect: boolean hasAspect()> from StaticAspect
retrieve <StaticAspect: void before$0()> from StaticAspect
retrieve <StaticAspect: void around$1()> from StaticAspect
retrieve <StaticAspect: void after$2()> from StaticAspect
retrieve <StaticAspect: StaticAspect aspectOf()> from StaticAspect
retrieve <StaticAspect: void proceed$9()> from StaticAspect
retrieve <NonStaticAspect: void <init>()> from NonStaticAspect
retrieve <NonStaticAspect: void before$3()> from NonStaticAspect
retrieve <NonStaticAspect: void around$4()> from NonStaticAspect
retrieve <NonStaticAspect: void after$5()> from NonStaticAspect
retrieve <NonStaticAspect: NonStaticAspect aspectOf()> from NonStaticAspect
retrieve <NonStaticAspect: boolean hasAspect()> from NonStaticAspect
retrieve <NonStaticAspect: void proceed$10()> from NonStaticAspect
retrieve <InstanceOfAspect: void proceed$11()> from InstanceOfAspect
retrieve <InstanceOfAspect: void <init>()> from InstanceOfAspect
retrieve <InstanceOfAspect: void before$6()> from InstanceOfAspect
retrieve <InstanceOfAspect: void around$7()> from InstanceOfAspect
retrieve <InstanceOfAspect: void after$8()> from InstanceOfAspect
retrieve <InstanceOfAspect: InstanceOfAspect aspectOf(java.lang.Object)> from InstanceOfAspect
retrieve <InstanceOfAspect: boolean hasAspect(java.lang.Object)> from InstanceOfAspect
Transforming PR355... 
Transforming NonStaticAspect... 
Transforming InstanceOfAspect... 
Transforming Cuts... 
Transforming StaticAspect... 
Transforming C... 
Transforming InstanceOfAspect$abc$PerThis... 
Transforming abc$access$StaticAspect$around$1... 
Transforming abc$access$NonStaticAspect$around$4... 
Transforming abc$access$InstanceOfAspect$around$7... 
Abc finished on Thu Jun 24 09:02:48 BST 2004. ( 0 min. 20 sec. )
PASS: No boolean appearing in the 'if' clause for around advice with eachJVM()()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 23 seconds
Passed. Current status: 120 failed (check: 70), 260 passed (check: 81), 0 skipped.
Executing test 381 (new): Order of super introductions.
================================================
Breakdown of abc phases  (total: 9068 millisec.)
------------------------------------------------
[ 01.632% ] Init. of Soot:  148
[ 00.044% ] Loading Jars:  4
[ 73.324% ] Polyglot phases:  6649
[ 00.022% ] Resolve class names:  2
[ 00.033% ] Declare Parents:  3
[ 00.651% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.419% ] Intertype Adjuster:  38
[ 08.094% ] Retrieving bodies:  734
[ 00.000% ] Weave Initializers:  0
[ 00.397% ] Load shadow types:  36
[ 05.018% ] Compute advice lists:  455
[ 00.033% ] Intertype weave:  3
[ 00.871% ] Add aspect code:  79
[ 00.154% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 06.054% ] Soot Packs:  549
[ 03.253% ] Soot Writing Output:  295
================================================
Abc started on Thu Jun 24 09:02:53 BST 2004
<<<< OrderOfExtendsPlusAndImplementsPlus.java >>>>
import org.aspectj.testing.Tester;

public class OrderOfExtendsPlusAndImplementsPlus {
    public static void main(java.lang.String[] args) {
        try {
            new OrderOfExtendsPlusAndImplementsPlus().realMain(args);
        }
        catch (java.lang.Throwable t) {
            org.aspectj.testing.Tester.throwable(t);
        }
    }
    
    public void realMain(java.lang.String[] args)
          throws java.lang.Exception {
        java.lang.Class[] cs =
          new java.lang.Class[] { C.class, D.class };
        for (int i = 0; i < cs/*null*/.length; i++) { check(cs[i]); }
    }
    
    private void check(java.lang.Class c) {
        org.aspectj.testing.Tester.checkEq(c.getInterfaces()[0],
                                           I.class,
                                           c +
                                           " doesn\'t implement " +
                                           I.class);
        org.aspectj.testing.Tester.checkEq(c.getSuperclass(),
                                           S.class,
                                           c + " doesn\'t extend " +
                                           S.class);
    }
    
    public OrderOfExtendsPlusAndImplementsPlus() { super(); }
}
class S {
    public S() { super(); }
}
interface I {}
class C {
    public C() { super(); }
}
class D {
    public D() { super(); }
}
aspect A {
    declare parents : C implements I;
    
    declare parents : C extends S;
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
aspect B {
    declare parents : D extends S;
    
    declare parents : D implements I;
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
retrieve <OrderOfExtendsPlusAndImplementsPlus: void main(java.lang.String[])> from OrderOfExtendsPlusAndImplementsPlus
retrieve <OrderOfExtendsPlusAndImplementsPlus: void realMain(java.lang.String[])> from OrderOfExtendsPlusAndImplementsPlus
retrieve <OrderOfExtendsPlusAndImplementsPlus: void check(java.lang.Class)> from OrderOfExtendsPlusAndImplementsPlus
retrieve <OrderOfExtendsPlusAndImplementsPlus: void <init>()> from OrderOfExtendsPlusAndImplementsPlus
retrieve <OrderOfExtendsPlusAndImplementsPlus: java.lang.Class class$(java.lang.String)> from OrderOfExtendsPlusAndImplementsPlus
retrieve <S: void <init>()> from S
retrieve <C: void <init>()> from C
retrieve <D: void <init>()> from D
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <B: void <init>()> from B
retrieve <B: B aspectOf()> from B
retrieve <B: boolean hasAspect()> from B
Transforming S... 
Transforming C... 
Transforming D... 
Transforming A... 
Transforming OrderOfExtendsPlusAndImplementsPlus... 
Transforming B... 
Transforming I... 
Abc finished on Thu Jun 24 09:03:02 BST 2004. ( 0 min. 9 sec. )
PASS: Order of super introductions.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 120 failed (check: 70), 261 passed (check: 81), 0 skipped.
Executing test 382 (new): Ensuring backdoor methods are produced.
Failed. Current status: 121 failed (check: 70), 261 passed (check: 81), 0 skipped.
Executing test 383 (new): no duplicate advice methods in abstract aspects
Failed. Current status: 122 failed (check: 70), 261 passed (check: 81), 0 skipped.
Executing test 384 (new): no duplicate advice methods in abstract aspects extended
Failed. Current status: 123 failed (check: 70), 261 passed (check: 81), 0 skipped.
Executing test 385 (new): Putting after-constructor advice on the wrong types implementing the same interface.
================================================
Breakdown of abc phases  (total: 9768 millisec.)
------------------------------------------------
[ 00.696% ] Init. of Soot:  68
[ 00.072% ] Loading Jars:  7
[ 76.945% ] Polyglot phases:  7516
[ 00.031% ] Resolve class names:  3
[ 00.010% ] Declare Parents:  1
[ 00.543% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.399% ] Intertype Adjuster:  39
[ 05.538% ] Retrieving bodies:  541
[ 00.000% ] Weave Initializers:  0
[ 00.276% ] Load shadow types:  27
[ 07.678% ] Compute advice lists:  750
[ 00.031% ] Intertype weave:  3
[ 00.348% ] Add aspect code:  34
[ 00.430% ] Weaving advice:  42
[ 00.000% ] Validate jimple:  0
[ 04.259% ] Soot Packs:  416
[ 02.744% ] Soot Writing Output:  268
================================================
Abc started on Thu Jun 24 09:03:32 BST 2004
<<<< AfterAdviceOnConstructorsOnTheWrongType.java >>>>
import org.aspectj.testing.Tester;

public class AfterAdviceOnConstructorsOnTheWrongType {
    public static void main(java.lang.String[] args) {
        new AfterAdviceOnConstructorsOnTheWrongType().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        new C().c();
        new D().d();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.clearEvents();
               org.aspectj.testing.Tester.expectEventsInString("after-c,c,after-d,d");
           }
    
    public AfterAdviceOnConstructorsOnTheWrongType() { super(); }
}
interface I {}
class C implements I {
    public void c() { org.aspectj.testing.Tester.event("c"); }
    
    public C() { super(); }
}
class D implements I {
    public void d() { org.aspectj.testing.Tester.event("d"); }
    
    public D() { super(); }
}
aspect A {
    after(C c):
    target(c) &&
      execution ((*).new(..)) {
        org.aspectj.testing.Tester.event("after-c");
    }
    
    after(D d):
    target(d) &&
      execution ((*).new(..)) {
        org.aspectj.testing.Tester.event("after-d");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AfterAdviceOnConstructorsOnTheWrongType: void <init>()> from AfterAdviceOnConstructorsOnTheWrongType
retrieve <AfterAdviceOnConstructorsOnTheWrongType: void main(java.lang.String[])> from AfterAdviceOnConstructorsOnTheWrongType
retrieve <AfterAdviceOnConstructorsOnTheWrongType: void realMain(java.lang.String[])> from AfterAdviceOnConstructorsOnTheWrongType
retrieve <AfterAdviceOnConstructorsOnTheWrongType: void <clinit>()> from AfterAdviceOnConstructorsOnTheWrongType
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <D: void d()> from D
retrieve <D: void <init>()> from D
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void after$0(C)> from A
retrieve <A: void after$1(D)> from A
Transforming D... 
Transforming C... 
Transforming A... 
Transforming AfterAdviceOnConstructorsOnTheWrongType... 
Transforming I... 
Abc finished on Thu Jun 24 09:03:41 BST 2004. ( 0 min. 9 sec. )
PASS: Putting after-constructor advice on the wrong types implementing the sam...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 123 failed (check: 70), 262 passed (check: 81), 0 skipped.
Executing test 386 (new): Instantiating non-static inner classes in advice.
================================================
Breakdown of abc phases  (total: 9263 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  39
[ 00.032% ] Loading Jars:  3
[ 70.690% ] Polyglot phases:  6548
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.410% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.723% ] Intertype Adjuster:  67
[ 06.337% ] Retrieving bodies:  587
[ 00.000% ] Weave Initializers:  0
[ 00.248% ] Load shadow types:  23
[ 09.738% ] Compute advice lists:  902
[ 00.032% ] Intertype weave:  3
[ 00.378% ] Add aspect code:  35
[ 01.274% ] Weaving advice:  118
[ 00.000% ] Validate jimple:  0
[ 05.301% ] Soot Packs:  491
[ 04.372% ] Soot Writing Output:  405
================================================
Abc started on Thu Jun 24 09:03:44 BST 2004
<<<< NonstaticInnerClassesInAspects.java >>>>
import org.aspectj.testing.Tester;

public class NonstaticInnerClassesInAspects {
    public static void main(java.lang.String[] args) {
        new NonstaticInnerClassesInAspects().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        new C().c();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("A$Inner-before-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-before-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-before-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner-after-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-after-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-after-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner-around-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-around-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-around-c");
               org.aspectj.testing.Tester.expectEvent("A$Inner-before-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-before-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-before-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner-after-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-after-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-after-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner-around-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-around-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-around-d");
               org.aspectj.testing.Tester.expectEvent("A$Inner-before-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-before-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-before-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner-after-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-after-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-after-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner-around-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner-around-x");
               org.aspectj.testing.Tester.expectEvent("A$Inner$InnerInner$InnerInnerInner-around-x");
           }
    
    public NonstaticInnerClassesInAspects() { super(); }
}
class C {
    public void c() { d(); }
    
    public void d() {  }
    
    public C() { super(); }
}
aspect A {
    pointcut c() : target(C) && call(void (*).c());
    
    pointcut d() : call(void (C).d());
    
    pointcut x() : target(C) && execution (void (*).c());
    
    after(): c() { this.new A.Inner().i("after-c"); }
    
    after(): d() { this.new A.Inner().i("after-d"); }
    
    after(): x() { this.new A.Inner().i("after-x"); }
    
    before(): c() { this.new A.Inner().i("before-c"); }
    
    before(): d() { this.new A.Inner().i("before-d"); }
    
    before(): x() { this.new A.Inner().i("before-x"); }
    
    void around ():
    c() {
        this.new A.Inner().i("around-c");
        this.proceed();
    }
    
    void around ():
    d() {
        this.new A.Inner().i("around-d");
        this.proceed();
    }
    
    void around ():
    x() {
        this.new A.Inner().i("around-x");
        this.proceed();
    }
    
    class Inner {
        void i(java.lang.String s) {
            a(s, this);
            this.new A.Inner.InnerInner().i(s);
        }
        
        class InnerInner {
            void i(java.lang.String s) {
                a(s, this);
                this.new A.Inner.InnerInner.InnerInnerInner().i(s);
            }
            
            class InnerInnerInner {
                void i(java.lang.String s) { a(s, this); }
                
                public InnerInnerInner() { super(); }
            }
            
            
            public InnerInner() { super(); }
        }
        
        
        public Inner() { super(); }
    }
    
    
    public static void a(java.lang.String s, java.lang.Object o) {
        org.aspectj.testing.Tester.event(o.getClass().getName() +
                                         "-" +
                                         s);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <NonstaticInnerClassesInAspects: void realMain(java.lang.String[])> from NonstaticInnerClassesInAspects
retrieve <NonstaticInnerClassesInAspects: void <init>()> from NonstaticInnerClassesInAspects
retrieve <NonstaticInnerClassesInAspects: void <clinit>()> from NonstaticInnerClassesInAspects
retrieve <NonstaticInnerClassesInAspects: void main(java.lang.String[])> from NonstaticInnerClassesInAspects
retrieve <C: void <init>()> from C
retrieve <C: void c()> from C
retrieve <C: void d()> from C
retrieve <A: void after$0()> from A
retrieve <A: void after$1()> from A
retrieve <A: void after$2()> from A
retrieve <A: void before$3()> from A
retrieve <A: void before$4()> from A
retrieve <A: void before$5()> from A
retrieve <A: void around$6()> from A
retrieve <A: void around$7()> from A
retrieve <A: void around$8()> from A
retrieve <A: void a(java.lang.String,java.lang.Object)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void proceed$9()> from A
retrieve <A: void proceed$10()> from A
retrieve <A: void proceed$11()> from A
retrieve <A$Inner: void i(java.lang.String)> from A$Inner
retrieve <A$Inner: void <init>(A)> from A$Inner
retrieve <A$Inner$InnerInner: void i(java.lang.String)> from A$Inner$InnerInner
retrieve <A$Inner$InnerInner: void <init>(A$Inner)> from A$Inner$InnerInner
retrieve <A$Inner$InnerInner$InnerInnerInner: void i(java.lang.String)> from A$Inner$InnerInner$InnerInnerInner
retrieve <A$Inner$InnerInner$InnerInnerInner: void <init>(A$Inner$InnerInner)> from A$Inner$InnerInner$InnerInnerInner
Transforming A... 
Transforming A$Inner... 
Transforming A$Inner$InnerInner... 
Transforming A$Inner$InnerInner$InnerInnerInner... 
Transforming C... 
Transforming NonstaticInnerClassesInAspects... 
Transforming abc$access$A$around$6... 
Transforming abc$access$A$around$7... 
Transforming abc$access$A$around$8... 
Abc finished on Thu Jun 24 09:03:53 BST 2004. ( 0 min. 9 sec. )
PASS: Instantiating non-static inner classes in advice.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 123 failed (check: 70), 263 passed (check: 81), 0 skipped.
Executing test 387 (new): Referring to pointcut in of clauses
================================================
Breakdown of abc phases  (total: 7966 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  40
[ 00.050% ] Loading Jars:  4
[ 74.705% ] Polyglot phases:  5951
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.590% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.464% ] Intertype Adjuster:  37
[ 06.440% ] Retrieving bodies:  513
[ 00.000% ] Weave Initializers:  0
[ 00.276% ] Load shadow types:  22
[ 09.641% ] Compute advice lists:  768
[ 00.038% ] Intertype weave:  3
[ 00.477% ] Add aspect code:  38
[ 00.301% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 03.540% ] Soot Packs:  282
[ 02.925% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 09:03:56 BST 2004
<<<< ReferringToPointcutsInAspect_PR316.java >>>>
import org.aspectj.testing.Tester;

public class ReferringToPointcutsInAspect_PR316 {
    public static void main(java.lang.String[] args) {
        new C().f();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("void-f");
               org.aspectj.testing.Tester.expectEvent("before-f");
           }
    
    public ReferringToPointcutsInAspect_PR316() { super(); }
}
class C {
    public void f() { org.aspectj.testing.Tester.event("void-f"); }
    
    public C() { super(); }
}
aspect A {
    pointcut i() : target(C);
    
    before():
    i() &&
      execution (* (*).f(..)) {
        org.aspectj.testing.Tester.event("before-f");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ReferringToPointcutsInAspect_PR316: void main(java.lang.String[])> from ReferringToPointcutsInAspect_PR316
retrieve <ReferringToPointcutsInAspect_PR316: void <init>()> from ReferringToPointcutsInAspect_PR316
retrieve <ReferringToPointcutsInAspect_PR316: void <clinit>()> from ReferringToPointcutsInAspect_PR316
retrieve <C: void <init>()> from C
retrieve <C: void f()> from C
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming ReferringToPointcutsInAspect_PR316... 
Transforming C... 
Abc finished on Thu Jun 24 09:04:04 BST 2004. ( 0 min. 8 sec. )
PASS: Referring to pointcut in of clauses()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 123 failed (check: 70), 264 passed (check: 81), 0 skipped.
Executing test 388 (new): Confused referring to instance variables and locals
================================================
Breakdown of abc phases  (total: 8647 millisec.)
------------------------------------------------
[ 00.439% ] Init. of Soot:  38
[ 00.046% ] Loading Jars:  4
[ 68.717% ] Polyglot phases:  5942
[ 00.000% ] Resolve class names:  0
[ 00.023% ] Declare Parents:  2
[ 00.393% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 05.539% ] Intertype Adjuster:  479
[ 05.782% ] Retrieving bodies:  500
[ 00.000% ] Weave Initializers:  0
[ 00.278% ] Load shadow types:  24
[ 03.597% ] Compute advice lists:  311
[ 00.035% ] Intertype weave:  3
[ 00.474% ] Add aspect code:  41
[ 00.150% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 06.546% ] Soot Packs:  566
[ 07.980% ] Soot Writing Output:  690
================================================
Abc started on Thu Jun 24 09:04:07 BST 2004
<<<< ScopesAndFields_PR191.java >>>>
import org.aspectj.testing.Tester;

public class ScopesAndFields_PR191 {
    public static void main(java.lang.String[] args) {
        new ScopesAndFields_PR191().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        C c = new C();
        c.a();
        org.aspectj.testing.Tester.checkEqual(c.c(), "C");
        org.aspectj.testing.Tester.checkEqual(c/*null*/.c, "c");
        org.aspectj.testing.Tester.checkEqual(c.t(), "c");
    }
    
    public ScopesAndFields_PR191() { super(); }
}
class C {
    public java.lang.String c = "c";
    
    public java.lang.String c() {
        java.lang.Object c = "C";
        return c + "";
    }
    
    public java.lang.String t() {
        java.lang.Object c = "C";
        return this/*<unknown>*/.c;
    }
    
    public void a() {
        java.lang.String c = "C";
        org.aspectj.testing.Tester.checkEqual(c + "", "C");
        org.aspectj.testing.Tester.checkEqual(this/*<unknown>*/.c,
                                              "c");
    }
    
    public C() { super(); }
}
retrieve <ScopesAndFields_PR191: void main(java.lang.String[])> from ScopesAndFields_PR191
retrieve <ScopesAndFields_PR191: void realMain(java.lang.String[])> from ScopesAndFields_PR191
retrieve <ScopesAndFields_PR191: void <init>()> from ScopesAndFields_PR191
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String c()> from C
retrieve <C: java.lang.String t()> from C
retrieve <C: void a()> from C
Transforming ScopesAndFields_PR191... 
Transforming C... 
Abc finished on Thu Jun 24 09:04:15 BST 2004. ( 0 min. 8 sec. )
PASS: Confused referring to instance variables and locals()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 123 failed (check: 70), 265 passed (check: 81), 0 skipped.
Executing test 389 (new): Parsing C+ expressions without parens in super introductions.
Failed. Current status: 124 failed (check: 70), 265 passed (check: 81), 0 skipped.
Executing test 390 (new): Introducing methods on classes that implements inner-interfaces with +implements.
Failed. Current status: 125 failed (check: 70), 265 passed (check: 81), 0 skipped.
Executing test 391 (new): Methods with the same name are generated when abstract aspects extend another abstract aspect.
Failed. Current status: 126 failed (check: 70), 265 passed (check: 81), 0 skipped.
Executing test 392 (new): Making sure final variables stay final.
================================================
Breakdown of abc phases  (total: 12763 millisec.)
------------------------------------------------
[ 00.298% ] Init. of Soot:  38
[ 00.031% ] Loading Jars:  4
[ 85.262% ] Polyglot phases:  10882
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 00.407% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.290% ] Intertype Adjuster:  37
[ 05.947% ] Retrieving bodies:  759
[ 00.000% ] Weave Initializers:  0
[ 00.196% ] Load shadow types:  25
[ 02.217% ] Compute advice lists:  283
[ 00.024% ] Intertype weave:  3
[ 00.094% ] Add aspect code:  12
[ 00.588% ] Weaving advice:  75
[ 00.000% ] Validate jimple:  0
[ 02.586% ] Soot Packs:  330
[ 02.029% ] Soot Writing Output:  259
================================================
Abc started on Thu Jun 24 09:04:35 BST 2004
<<<< RemovingFinals.java >>>>
import org.aspectj.testing.Tester;
import java.lang.reflect.*;

public class RemovingFinals {
    public static void main(java.lang.String[] args) {
        new RemovingFinals().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        try {
            org.aspectj.testing.Tester.check((C.class.getField("public_i").getModifiers() &
                                              java.lang.reflect.Modifier/*java.lang.reflect.Modifier*/.FINAL) !=
                                             0,
                                             "public_i is not final");
        }
        catch (java.lang.Throwable t) {
            org.aspectj.testing.Tester.throwable(t);
        }
    }
    
    public RemovingFinals() { super(); }
}
class C {
    public final int public_i = 1;
    
    static int x = 2;
    
    private final int CONST = 0;
    
    public void m() {
        switch (C/*C*/.x) {
            case this/*null*/.CONST:
                java.lang.System/*java.lang.System*/.out.println("no");
        }
    }
    
    public C() { super(); }
}
aspect A {
    before():
    staticinitialization(C) {
        new java.lang.StringBuffer().append(thisJoinPoint);
    }
    
    before():
    execution ((C).new(..)) {
        new java.lang.StringBuffer().append(thisJoinPoint);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <RemovingFinals: void realMain(java.lang.String[])> from RemovingFinals
retrieve <RemovingFinals: java.lang.Class class$(java.lang.String)> from RemovingFinals
retrieve <RemovingFinals: void <init>()> from RemovingFinals
retrieve <RemovingFinals: void main(java.lang.String[])> from RemovingFinals
retrieve <C: void m()> from C
retrieve <C: void <clinit>()> from C
retrieve <C: void <init>()> from C
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming C... 
Transforming RemovingFinals... 
Abc finished on Thu Jun 24 09:04:48 BST 2004. ( 0 min. 12 sec. )
PASS: Making sure final variables stay final.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 126 failed (check: 70), 266 passed (check: 81), 0 skipped.
Executing test 393 (new): Problem resolving meta-joinpoint names with around advice on methods called from around advice.
================================================
Breakdown of abc phases  (total: 13324 millisec.)
------------------------------------------------
[ 00.293% ] Init. of Soot:  39
[ 00.023% ] Loading Jars:  3
[ 57.153% ] Polyglot phases:  7615
[ 00.083% ] Resolve class names:  11
[ 00.015% ] Declare Parents:  2
[ 00.285% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.458% ] Intertype Adjuster:  61
[ 05.089% ] Retrieving bodies:  678
[ 00.000% ] Weave Initializers:  0
[ 00.173% ] Load shadow types:  23
[ 16.699% ] Compute advice lists:  2225
[ 00.030% ] Intertype weave:  4
[ 00.255% ] Add aspect code:  34
[ 03.482% ] Weaving advice:  464
[ 00.008% ] Validate jimple:  1
[ 09.307% ] Soot Packs:  1240
[ 06.650% ] Soot Writing Output:  886
================================================
Abc started on Thu Jun 24 09:04:50 BST 2004
<<<< AroundAdviceOnMethodsCalledInAroundAdvice.java >>>>
import org.aspectj.testing.Tester;

public class AroundAdviceOnMethodsCalledInAroundAdvice {
    public static void main(java.lang.String[] args) {
        new AroundAdviceOnMethodsCalledInAroundAdvice().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        Expect.expect();
        new C().g();
        new C().f("AroundMetaJoinpoints.realMain");
        new C("C.package.constructor");
        new C(123);
        new D().g();
        new D("D.package.constructor");
        new D(123);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public AroundAdviceOnMethodsCalledInAroundAdvice() { super(); }
}
aspect A {
    Object around ():
    call(public Object (*).f(String)) {
        jp(thisJoinPoint);
        return this.proceed();
    }
    
    private void jp(java.lang.Object join) {  }
    
    void around (): call(* (*).jp(..)) { this.proceed(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class D {
    java.lang.Object o = new C().f("D.o");
    
    public D() {
        super();
        new C().f("D.public.constructor");
    }
    
    D(java.lang.String f) {
        super();
        new C().f(f);
    }
    
    protected D(int i) {
        super();
        new C().f("D.protected.constructor");
    }
    
    private D(java.lang.Integer i) {
        super();
        new C().f("D.private.constructor");
    }
    
    { new C().f("D.init"); }
    
    static {
               new D(new java.lang.Integer(123));
               new C().f("D.static");
           }
    
    public void g() {
        org.aspectj.testing.Tester.event("D.g");
        new C().f("D.g");
    }
}
class C {
    public C() {
        super();
        f("C.public.constructor");
    }
    
    C(java.lang.String f) {
        super();
        f(f);
    }
    
    protected C(int i) {
        super();
        f("C.protected.constructor");
    }
    
    private C(java.lang.Integer i) {
        super();
        f("C.private.constructor");
    }
    
    java.lang.Object o = f("C.o");
    
    static { new C(new java.lang.Integer(123)).f("C.static"); }
    
    { f("C.init"); }
    
    public void g() {
        org.aspectj.testing.Tester.event("C.g");
        f("C.g");
    }
    
    public java.lang.Object f(java.lang.String f) {
        org.aspectj.testing.Tester.event("C.f-" + f);
        return null;
    }
}
class Expect {
    static void expect() {
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.private.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-C.static");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.g");
        org.aspectj.testing.Tester.expectEvent("C.f-C.g");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-AroundMetaJoinpoints.realMain");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.package.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.protected.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.private.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.static");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.public.constructor");
        org.aspectj.testing.Tester.expectEvent("D.g");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.g");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.package.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.o");
        org.aspectj.testing.Tester.expectEvent("C.f-C.init");
        org.aspectj.testing.Tester.expectEvent("C.f-C.public.constructor");
        org.aspectj.testing.Tester.expectEvent("C.f-D.protected.constructor");
    }
    
    public Expect() { super(); }
}
retrieve <AroundAdviceOnMethodsCalledInAroundAdvice: void <init>()> from AroundAdviceOnMethodsCalledInAroundAdvice
retrieve <AroundAdviceOnMethodsCalledInAroundAdvice: void main(java.lang.String[])> from AroundAdviceOnMethodsCalledInAroundAdvice
retrieve <AroundAdviceOnMethodsCalledInAroundAdvice: void realMain(java.lang.String[])> from AroundAdviceOnMethodsCalledInAroundAdvice
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: java.lang.Object proceed$2()> from A
retrieve <A: void proceed$3()> from A
retrieve <A: java.lang.Object around$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void jp(java.lang.Object)> from A
retrieve <A: void around$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <D: void <init>()> from D
retrieve <D: void <init>(java.lang.String)> from D
retrieve <D: void <init>(int)> from D
retrieve <D: void <init>(java.lang.Integer)> from D
retrieve <D: void g()> from D
retrieve <D: void <clinit>()> from D
retrieve <C: void <init>()> from C
retrieve <C: void <init>(java.lang.String)> from C
retrieve <C: void <init>(int)> from C
retrieve <C: void <init>(java.lang.Integer)> from C
retrieve <C: void g()> from C
retrieve <C: java.lang.Object f(java.lang.String)> from C
retrieve <C: void <clinit>()> from C
retrieve <Expect: void expect()> from Expect
retrieve <Expect: void <init>()> from Expect
Transforming D... 
Transforming A... 
Transforming C... 
Transforming AroundAdviceOnMethodsCalledInAroundAdvice... 
Transforming Expect... 
Transforming abc$access$A$around$0... 
Transforming abc$access$A$around$1... 
Abc finished on Thu Jun 24 09:05:04 BST 2004. ( 0 min. 13 sec. )
PASS: Problem resolving meta-joinpoint names with around advice on methods cal...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 126 failed (check: 70), 267 passed (check: 81), 0 skipped.
Executing test 394 (new): Make sure that names of lifted local classes are right when referenced in call-site advice
================================================
Breakdown of abc phases  (total: 8572 millisec.)
------------------------------------------------
[ 00.583% ] Init. of Soot:  50
[ 00.035% ] Loading Jars:  3
[ 78.243% ] Polyglot phases:  6707
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.455% ] Recompute name pattern matches:  39
[ 00.000% ] Compute precedence relation:  0
[ 00.747% ] Intertype Adjuster:  64
[ 07.070% ] Retrieving bodies:  606
[ 00.000% ] Weave Initializers:  0
[ 00.350% ] Load shadow types:  30
[ 04.048% ] Compute advice lists:  347
[ 00.035% ] Intertype weave:  3
[ 00.443% ] Add aspect code:  38
[ 00.280% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 04.561% ] Soot Packs:  391
[ 03.103% ] Soot Writing Output:  266
================================================
Abc started on Thu Jun 24 09:05:08 BST 2004
<<<< CallsAndLocalClasses.java >>>>
import org.aspectj.testing.Tester;

public class CallsAndLocalClasses {
    public static void main(java.lang.String[] args) {
        java.lang.Runnable r = new Outer().makeRunnable();
        r.run();
        Outer o = new Outer();
        o.toString();
        ((java.lang.Comparable) o).toString();
        org.aspectj.testing.Tester.check("run from Outer");
        org.aspectj.testing.Tester.check("m");
        org.aspectj.testing.Tester.check("before run");
        org.aspectj.testing.Tester.check("before m");
    }
    
    public CallsAndLocalClasses() { super(); }
}
class Outer implements java.lang.Comparable {
    public int compareTo(java.lang.Object other) {
        org.aspectj.testing.Tester.note("m");
        return 0;
    }
    
    public java.lang.Runnable makeRunnable() {
        return new java.lang.Runnable() {
            public void run() {
                Tester.note("run from Outer");
                compareTo(this);
            }
        };
    }
    
    public Outer() { super(); }
}
final class Foo {
    public java.lang.String toString() { return "Foo"; }
    
    public Foo() { super(); }
}
aspect A {
    before():
    call(void (Runnable).run()) {
        org.aspectj.testing.Tester.note("before run");
    }
    
    before():
    call(int (*).compareTo(Object)) {
        org.aspectj.testing.Tester.note("before m");
    }
    
    before():
    call(String (Object).toString()) {
        java.lang.System/*java.lang.System*/.out.println("before toString");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <CallsAndLocalClasses: void main(java.lang.String[])> from CallsAndLocalClasses
retrieve <CallsAndLocalClasses: void <init>()> from CallsAndLocalClasses
retrieve <Outer: java.lang.Runnable makeRunnable()> from Outer
retrieve <Outer: void <init>()> from Outer
retrieve <Outer: int compareTo(java.lang.Object)> from Outer
retrieve <Outer$1: void run()> from Outer$1
retrieve <Outer$1: void <init>(Outer)> from Outer$1
retrieve <Foo: java.lang.String toString()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Outer... 
Transforming Outer$1... 
Transforming Foo... 
Transforming CallsAndLocalClasses... 
Abc finished on Thu Jun 24 09:05:17 BST 2004. ( 0 min. 8 sec. )
PASS: Make sure that names of lifted local classes are right when referenced i...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 126 failed (check: 70), 268 passed (check: 81), 0 skipped.
Executing test 395 (new): matching for throws clause
================================================
Breakdown of abc phases  (total: 10114 millisec.)
------------------------------------------------
[ 00.386% ] Init. of Soot:  39
[ 00.040% ] Loading Jars:  4
[ 76.617% ] Polyglot phases:  7749
[ 00.020% ] Resolve class names:  2
[ 00.020% ] Declare Parents:  2
[ 00.534% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.395% ] Intertype Adjuster:  40
[ 07.465% ] Retrieving bodies:  755
[ 00.000% ] Weave Initializers:  0
[ 00.376% ] Load shadow types:  38
[ 02.946% ] Compute advice lists:  298
[ 00.109% ] Intertype weave:  11
[ 00.722% ] Add aspect code:  73
[ 00.218% ] Weaving advice:  22
[ 00.000% ] Validate jimple:  0
[ 06.160% ] Soot Packs:  623
[ 03.994% ] Soot Writing Output:  404
================================================
Abc started on Thu Jun 24 09:05:22 BST 2004
<<<< ThrowsMatching.java >>>>
import org.aspectj.testing.Tester;

public class ThrowsMatching {
    public static void main(java.lang.String[] args)
          throws java.lang.Exception {
        C c = new C();
        c.m1();
        c.m2();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.buf.toString(),
                                              "before:m1:m2:");
    }
    
    public ThrowsMatching() { super(); }
}
class E1 extends java.lang.Exception {
    public E1() { super(); }
}
class C {
    public void m1() throws E1 { A/*A*/.buf.append("m1:"); }
    
    public void m2() { A/*A*/.buf.append("m2:"); }
    
    public C() { super(); }
}
aspect A {
    static java.lang.StringBuffer buf = new java.lang.StringBuffer();
    
    before():
    call(void (C).m*() throws E1) {
        A/*A*/.buf.append("before:");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ThrowsMatching: void main(java.lang.String[])> from ThrowsMatching
retrieve <ThrowsMatching: void <init>()> from ThrowsMatching
retrieve <E1: void <init>()> from E1
retrieve <C: void <init>()> from C
retrieve <C: void m1()> from C
retrieve <C: void m2()> from C
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming C... 
Transforming E1... 
Transforming ThrowsMatching... 
Abc finished on Thu Jun 24 09:05:32 BST 2004. ( 0 min. 10 sec. )
PASS: matching for throws clause()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 126 failed (check: 70), 269 passed (check: 81), 0 skipped.
Executing test 396 (new): holding onto proceed calls in a closure-like way
Failed. Current status: 127 failed (check: 70), 269 passed (check: 81), 0 skipped.
Executing test 397 (new): basic test of declare soft
Failed. Current status: 128 failed (check: 70), 269 passed (check: 81), 0 skipped.
Executing test 398 (new): advice on calls to constructors of anonymous inners and access to context
================================================
Breakdown of abc phases  (total: 8499 millisec.)
------------------------------------------------
[ 00.447% ] Init. of Soot:  38
[ 00.047% ] Loading Jars:  4
[ 82.151% ] Polyglot phases:  6982
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.553% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.447% ] Intertype Adjuster:  38
[ 06.118% ] Retrieving bodies:  520
[ 00.000% ] Weave Initializers:  0
[ 00.271% ] Load shadow types:  23
[ 02.683% ] Compute advice lists:  228
[ 00.035% ] Intertype weave:  3
[ 00.424% ] Add aspect code:  36
[ 00.259% ] Weaving advice:  22
[ 00.000% ] Validate jimple:  0
[ 03.589% ] Soot Packs:  305
[ 02.930% ] Soot Writing Output:  249
================================================
Abc started on Thu Jun 24 09:05:55 BST 2004
<<<< NewAnonymous.java >>>>
import org.aspectj.testing.Tester;

public class NewAnonymous {
    public static void main(java.lang.String[] args) {  }
    
    public NewAnonymous() { super(); }
}
class C {
    private java.lang.String f = "fC";
    
    public void m(final java.lang.String s) {
        new java.lang.Runnable() {
            public void run() { System.out.println(s + ":" + f); }
        }.run();
    }
    
    public C() { super(); }
}
aspect A {
    before():
    call((*).new()) {
        java.lang.System/*java.lang.System*/.out.println("new Runnable");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <NewAnonymous: void <init>()> from NewAnonymous
retrieve <NewAnonymous: void main(java.lang.String[])> from NewAnonymous
retrieve <C: void m(java.lang.String)> from C
retrieve <C: java.lang.String access$000(C)> from C
retrieve <C: void <init>()> from C
retrieve <C$1: void run()> from C$1
retrieve <C$1: void <init>(C,java.lang.String)> from C$1
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming NewAnonymous... 
Transforming C... 
Transforming C$1... 
Abc finished on Thu Jun 24 09:06:04 BST 2004. ( 0 min. 8 sec. )
PASS: advice on calls to constructors of anonymous inners and access to context()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 128 failed (check: 70), 270 passed (check: 81), 0 skipped.
Executing test 399 (new): Cannot bind a name.
Failed. Current status: 129 failed (check: 70), 270 passed (check: 81), 0 skipped.
Executing test 400 (new/innerAspectAccess): inner aspects can't access outer pointcuts
================================================
Breakdown of abc phases  (total: 8031 millisec.)
------------------------------------------------
[ 00.685% ] Init. of Soot:  55
[ 00.075% ] Loading Jars:  6
[ 74.225% ] Polyglot phases:  5961
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.610% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.772% ] Intertype Adjuster:  62
[ 06.388% ] Retrieving bodies:  513
[ 00.000% ] Weave Initializers:  0
[ 00.311% ] Load shadow types:  25
[ 02.988% ] Compute advice lists:  240
[ 00.037% ] Intertype weave:  3
[ 00.436% ] Add aspect code:  35
[ 06.052% ] Weaving advice:  486
[ 00.000% ] Validate jimple:  0
[ 04.321% ] Soot Packs:  347
[ 03.051% ] Soot Writing Output:  245
================================================
Abc started on Thu Jun 24 09:06:19 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;

public class Driver {
    public static java.lang.String s = "s";
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        doIt();
        org.aspectj.testing.Tester.checkEqual(Driver/*Driver*/.s,
                                              "s:a:b",
                                              "both advice worked");
    }
    
    public static java.lang.String doIt() {
        return Driver/*Driver*/.s;
    }
    
    public Driver() { super(); }
}
aspect Outer {
    static int N = 10;
    
    pointcut staticMeth() :
    within(Driver) &&
      execution (String (*).doIt());
    
    static aspect Inner {
        static void foo() { int i = Outer/*Outer*/.N; }
        
        before(): staticMeth() { Driver/*Driver*/.s += ":b"; }
        
        pointcut innerPoints() :
        within(Driver) &&
          execution (void (*).test());
        
        public static Outer.Inner aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public Inner() { super(); }
    }
    
    
    before(): innerPoints() { Driver/*Driver*/.s += ":a"; }
    
    public static Outer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Outer() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: java.lang.String doIt()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
retrieve <Outer: boolean hasAspect()> from Outer
retrieve <Outer: void <init>()> from Outer
retrieve <Outer: void <clinit>()> from Outer
retrieve <Outer: void before$1()> from Outer
retrieve <Outer: Outer aspectOf()> from Outer
retrieve <Outer$Inner: Outer$Inner aspectOf()> from Outer$Inner
retrieve <Outer$Inner: boolean hasAspect()> from Outer$Inner
retrieve <Outer$Inner: void <init>()> from Outer$Inner
retrieve <Outer$Inner: void foo()> from Outer$Inner
retrieve <Outer$Inner: void before$0()> from Outer$Inner
Transforming Driver... 
Transforming Outer... 
Transforming Outer$Inner... 
Abc finished on Thu Jun 24 09:06:27 BST 2004. ( 0 min. 8 sec. )
PASS: inner aspects can't access outer pointcuts()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 129 failed (check: 70), 271 passed (check: 81), 0 skipped.
Executing test 401 (new): implements and extends are introduced before methods and fields
Failed. Current status: 130 failed (check: 70), 271 passed (check: 81), 0 skipped.
Executing test 402 (new): a static/inner aspect of a inner class of an aspect is pulled to the top level as static
================================================
Breakdown of abc phases  (total: 8542 millisec.)
------------------------------------------------
[ 00.445% ] Init. of Soot:  38
[ 00.035% ] Loading Jars:  3
[ 64.973% ] Polyglot phases:  5550
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.527% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.433% ] Intertype Adjuster:  37
[ 21.178% ] Retrieving bodies:  1809
[ 00.000% ] Weave Initializers:  0
[ 00.258% ] Load shadow types:  22
[ 03.278% ] Compute advice lists:  280
[ 00.691% ] Intertype weave:  59
[ 00.492% ] Add aspect code:  42
[ 00.152% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.788% ] Soot Packs:  409
[ 02.704% ] Soot Writing Output:  231
================================================
Abc started on Thu Jun 24 09:06:34 BST 2004
<<<< StaticInnerAspect.java >>>>
import org.aspectj.testing.*;

public class StaticInnerAspect {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true, "compiled");
    }
    
    public StaticInnerAspect() { super(); }
}
aspect Aspect {
    static class InnerClass {
        static aspect InnerAspect {
            public static Aspect.InnerClass.InnerAspect aspectOf()
                  throws org.aspectj.lang.NoAspectBoundException {
                return null;
            }
            
            public static boolean hasAspect() { return true; }
            
            public InnerAspect() { super(); }
        }
        
        
        public InnerClass() { super(); }
    }
    
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <StaticInnerAspect: void <init>()> from StaticInnerAspect
retrieve <StaticInnerAspect: void main(java.lang.String[])> from StaticInnerAspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect$InnerClass: void <init>()> from Aspect$InnerClass
retrieve <Aspect$InnerClass$InnerAspect: boolean hasAspect()> from Aspect$InnerClass$InnerAspect
retrieve <Aspect$InnerClass$InnerAspect: void <init>()> from Aspect$InnerClass$InnerAspect
retrieve <Aspect$InnerClass$InnerAspect: Aspect$InnerClass$InnerAspect aspectOf()> from Aspect$InnerClass$InnerAspect
Transforming Aspect... 
Transforming Aspect$InnerClass... 
Transforming Aspect$InnerClass$InnerAspect... 
Transforming StaticInnerAspect... 
Abc finished on Thu Jun 24 09:06:43 BST 2004. ( 0 min. 8 sec. )
PASS: a static/inner aspect of a inner class of an aspect is pulled to the top...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 130 failed (check: 70), 272 passed (check: 81), 0 skipped.
Executing test 403 (new): Crashes with privileged aspect.
================================================
Breakdown of abc phases  (total: 7518 millisec.)
------------------------------------------------
[ 00.585% ] Init. of Soot:  44
[ 00.053% ] Loading Jars:  4
[ 75.818% ] Polyglot phases:  5700
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.718% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 07.342% ] Intertype Adjuster:  552
[ 05.281% ] Retrieving bodies:  397
[ 00.000% ] Weave Initializers:  0
[ 00.306% ] Load shadow types:  23
[ 02.514% ] Compute advice lists:  189
[ 00.040% ] Intertype weave:  3
[ 00.452% ] Add aspect code:  34
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.671% ] Soot Packs:  276
[ 02.993% ] Soot Writing Output:  225
================================================
Abc started on Thu Jun 24 09:06:45 BST 2004
<<<< Privileged.java >>>>
import org.aspectj.testing.*;

privilegedaspect aspect PrivilegedAspect {
    public intertype void OtherClass.foo() {
        org.aspectj.testing.Tester.event("foo.intro");
    }
    
    public static PrivilegedAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public PrivilegedAspect() { super(); }
}
class OtherClass {
    public OtherClass() { super(); }
}
public class Privileged {
    public static void main(java.lang.String[] args) {
        new Privileged().go();
    }
    
    static {
               org.aspectj.testing.Tester.expectEventsInString("foo.intro,foo.done,foo.called");
           }
    
    void go() {
        org.aspectj.testing.Tester.event("foo.called");
        new OtherClass().foo();
        org.aspectj.testing.Tester.event("foo.done");
    }
    
    public Privileged() { super(); }
}
retrieve <PrivilegedAspect: void foo(OtherClass)> from PrivilegedAspect
retrieve <PrivilegedAspect: PrivilegedAspect aspectOf()> from PrivilegedAspect
retrieve <PrivilegedAspect: boolean hasAspect()> from PrivilegedAspect
retrieve <PrivilegedAspect: void <init>()> from PrivilegedAspect
retrieve <OtherClass: void <init>()> from OtherClass
retrieve <OtherClass: void foo()> from OtherClass
retrieve <Privileged: void <init>()> from Privileged
retrieve <Privileged: void main(java.lang.String[])> from Privileged
retrieve <Privileged: void go()> from Privileged
retrieve <Privileged: void <clinit>()> from Privileged
Transforming PrivilegedAspect... 
Transforming Privileged... 
Transforming OtherClass... 
Abc finished on Thu Jun 24 09:06:53 BST 2004. ( 0 min. 7 sec. )
PASS: Crashes with privileged aspect.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 130 failed (check: 70), 273 passed (check: 81), 0 skipped.
Executing test 404 (new): join points exist in the execution of field initializers
================================================
Breakdown of abc phases  (total: 8710 millisec.)
------------------------------------------------
[ 00.425% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  4
[ 78.060% ] Polyglot phases:  6799
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.620% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.425% ] Intertype Adjuster:  37
[ 07.199% ] Retrieving bodies:  627
[ 00.000% ] Weave Initializers:  0
[ 00.264% ] Load shadow types:  23
[ 04.742% ] Compute advice lists:  413
[ 00.034% ] Intertype weave:  3
[ 00.390% ] Add aspect code:  34
[ 00.448% ] Weaving advice:  39
[ 00.000% ] Validate jimple:  0
[ 04.156% ] Soot Packs:  362
[ 03.146% ] Soot Writing Output:  274
================================================
Failed. Current status: 131 failed (check: 70), 273 passed (check: 81), 0 skipped.
Executing test 405 (new/privilegedAspects): privileged aspects
Failed. Current status: 132 failed (check: 70), 273 passed (check: 81), 0 skipped.
Executing test 406 (new): advice on field gets in privileged aspects
Failed. Current status: 133 failed (check: 70), 273 passed (check: 81), 0 skipped.
Executing test 407 (new): Two anonymous classes in the same scope
================================================
Breakdown of abc phases  (total: 7832 millisec.)
------------------------------------------------
[ 00.485% ] Init. of Soot:  38
[ 00.051% ] Loading Jars:  4
[ 75.217% ] Polyglot phases:  5891
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.677% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.472% ] Intertype Adjuster:  37
[ 06.984% ] Retrieving bodies:  547
[ 00.000% ] Weave Initializers:  0
[ 00.294% ] Load shadow types:  23
[ 05.388% ] Compute advice lists:  422
[ 00.038% ] Intertype weave:  3
[ 00.498% ] Add aspect code:  39
[ 00.932% ] Weaving advice:  73
[ 00.000% ] Validate jimple:  0
[ 05.133% ] Soot Packs:  402
[ 03.779% ] Soot Writing Output:  296
================================================
Abc started on Thu Jun 24 09:07:16 BST 2004
<<<< TwoAnonymous.java >>>>
public class TwoAnonymous {
    java.lang.Runnable i =
      new java.lang.Runnable() {
        public void run() { System.out.println("i"); }
        
        private Object foo() { return null; }
    };
    
    java.lang.Runnable j =
      new java.lang.Runnable() {
        public void run() { System.out.println(new Integer(0)); }
    };
    
    public static void main(java.lang.String[] args) {
        java.lang.Runnable k =
          new java.lang.Runnable() {
            int x = 0;
            
            public void run() {
                System.out.println("k");
                x = 4;
            }
            
            private Object foo() { return null; }
        };
        java.lang.Runnable k1 =
          new java.lang.Runnable() {
            public void run() {  }
        };
        k.run();
    }
    
    public TwoAnonymous() { super(); }
}
aspect A {
    before(Runnable r):
    call(void (Runnable).run()) &&
      target(r) {
        java.lang.System/*java.lang.System*/.out.println("calling run: " +
                                                         r +
                                                         ", " +
                                                         thisJoinPoint.getArgs() +
                                                         ", " +
                                                         thisJoinPoint.getTarget());
    }
    
    after() returning(Runnable r):
    call((Runnable+).new()) {
        java.lang.System/*java.lang.System*/.out.println("new runnable: " +
                                                         r);
    }
    
    before():
    set( int (*).x) {
        java.lang.System/*java.lang.System*/.out.println("setting x");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <TwoAnonymous: void <init>()> from TwoAnonymous
retrieve <TwoAnonymous: void main(java.lang.String[])> from TwoAnonymous
retrieve <TwoAnonymous$2: void run()> from TwoAnonymous$2
retrieve <TwoAnonymous$2: java.lang.Object foo()> from TwoAnonymous$2
retrieve <TwoAnonymous$2: void <init>(TwoAnonymous)> from TwoAnonymous$2
retrieve <TwoAnonymous$1: void run()> from TwoAnonymous$1
retrieve <TwoAnonymous$1: void <init>(TwoAnonymous)> from TwoAnonymous$1
retrieve <TwoAnonymous$4: void run()> from TwoAnonymous$4
retrieve <TwoAnonymous$4: java.lang.Object foo()> from TwoAnonymous$4
retrieve <TwoAnonymous$4: void <init>()> from TwoAnonymous$4
retrieve <TwoAnonymous$3: void run()> from TwoAnonymous$3
retrieve <TwoAnonymous$3: void <init>()> from TwoAnonymous$3
retrieve <A: void before$0(java.lang.Runnable,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void afterReturning$1(java.lang.Runnable)> from A
retrieve <A: void before$2()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming TwoAnonymous... 
Transforming TwoAnonymous$1... 
Transforming TwoAnonymous$2... 
Transforming TwoAnonymous$3... 
Transforming TwoAnonymous$4... 
Abc finished on Thu Jun 24 09:07:24 BST 2004. ( 0 min. 7 sec. )
setting x
new runnable: TwoAnonymous$4@5aad2a
new runnable: TwoAnonymous$3@dad6d0
calling run: TwoAnonymous$4@5aad2a, [Ljava.lang.Object;@9e58be, TwoAnonymous$4@5aad2a
k
setting x
PASS: Two anonymous classes in the same scope()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 133 failed (check: 70), 274 passed (check: 81), 0 skipped.
Executing test 408 (new): basic tests for initializer and staticinitializer PCDs
================================================
Breakdown of abc phases  (total: 10894 millisec.)
------------------------------------------------
[ 00.340% ] Init. of Soot:  37
[ 00.037% ] Loading Jars:  4
[ 74.995% ] Polyglot phases:  8170
[ 00.018% ] Resolve class names:  2
[ 00.018% ] Declare Parents:  2
[ 00.569% ] Recompute name pattern matches:  62
[ 00.000% ] Compute precedence relation:  0
[ 00.358% ] Intertype Adjuster:  39
[ 05.352% ] Retrieving bodies:  583
[ 00.000% ] Weave Initializers:  0
[ 00.202% ] Load shadow types:  22
[ 10.070% ] Compute advice lists:  1097
[ 00.028% ] Intertype weave:  3
[ 00.312% ] Add aspect code:  34
[ 01.102% ] Weaving advice:  120
[ 00.000% ] Validate jimple:  0
[ 03.984% ] Soot Packs:  434
[ 02.616% ] Soot Writing Output:  285
================================================
Failed. Current status: 134 failed (check: 70), 274 passed (check: 81), 0 skipped.
Executing test 409 (new): introduction of an initializer into a class
================================================
Breakdown of abc phases  (total: 7993 millisec.)
------------------------------------------------
[ 00.463% ] Init. of Soot:  37
[ 00.050% ] Loading Jars:  4
[ 73.639% ] Polyglot phases:  5886
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.738% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.475% ] Intertype Adjuster:  38
[ 13.287% ] Retrieving bodies:  1062
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  22
[ 03.165% ] Compute advice lists:  253
[ 00.038% ] Intertype weave:  3
[ 00.425% ] Add aspect code:  34
[ 00.425% ] Weaving advice:  34
[ 00.000% ] Validate jimple:  0
[ 03.816% ] Soot Packs:  305
[ 03.153% ] Soot Writing Output:  252
================================================
Abc started on Thu Jun 24 09:07:42 BST 2004
<<<< IntroductionOfInitializer.java >>>>
import org.aspectj.testing.Tester;
import java.io.*;

public class IntroductionOfInitializer {
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        org.aspectj.testing.Tester.checkEqual(Foo/*Foo*/.a,
                                              "class",
                                              "zero instances");
        Foo foo = new Foo();
        org.aspectj.testing.Tester.checkEqual(Foo/*Foo*/.a,
                                              "class-instance",
                                              "one instances");
        foo = new Foo();
        org.aspectj.testing.Tester.checkEqual(Foo/*Foo*/.a,
                                              "class-instance-instance",
                                              "two instances");
    }
    
    public IntroductionOfInitializer() { super(); }
}
aspect A {
    private static java.lang.String classValue = "class";
    
    private static java.lang.String instanceValue = "-instance";
    
    after():
    staticinitialization(Foo) {
        Foo/*Foo*/.a += A/*A*/.classValue;
    }
    
    after():
    initialization((Foo).new(..)) {
        Foo/*Foo*/.a += A/*A*/.instanceValue;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class Foo {
    static java.lang.String a = "";
    
    public Foo() { super(); }
}
retrieve <IntroductionOfInitializer: void main(java.lang.String[])> from IntroductionOfInitializer
retrieve <IntroductionOfInitializer: void test()> from IntroductionOfInitializer
retrieve <IntroductionOfInitializer: void <init>()> from IntroductionOfInitializer
retrieve <A: void after$0()> from A
retrieve <A: void after$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <Foo: void <init>()> from Foo
retrieve <Foo: void <clinit>()> from Foo
Transforming A... 
Transforming Foo... 
Transforming IntroductionOfInitializer... 
Abc finished on Thu Jun 24 09:07:50 BST 2004. ( 0 min. 8 sec. )
PASS: introduction of an initializer into a class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 134 failed (check: 70), 275 passed (check: 81), 0 skipped.
Executing test 410 (new/access): some method accessibility tests, particularly package-protected and inheritance
================================================
Breakdown of abc phases  (total: 8323 millisec.)
------------------------------------------------
[ 00.457% ] Init. of Soot:  38
[ 00.048% ] Loading Jars:  4
[ 78.445% ] Polyglot phases:  6529
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.505% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.793% ] Intertype Adjuster:  66
[ 06.176% ] Retrieving bodies:  514
[ 00.000% ] Weave Initializers:  0
[ 00.300% ] Load shadow types:  25
[ 04.169% ] Compute advice lists:  347
[ 00.048% ] Intertype weave:  4
[ 00.457% ] Add aspect code:  38
[ 01.177% ] Weaving advice:  98
[ 00.000% ] Validate jimple:  0
[ 04.349% ] Soot Packs:  362
[ 03.028% ] Soot Writing Output:  252
================================================
Failed. Current status: 135 failed (check: 70), 275 passed (check: 81), 0 skipped.
Executing test 411 (new): fairly monotonous (and non-covering) tests for expanded dot patterns
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 13881 millisec.)
------------------------------------------------
[ 00.274% ] Init. of Soot:  38
[ 00.022% ] Loading Jars:  3
[ 61.617% ] Polyglot phases:  8553
[ 00.014% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  3
[ 00.331% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.274% ] Intertype Adjuster:  38
[ 08.119% ] Retrieving bodies:  1127
[ 00.000% ] Weave Initializers:  0
[ 00.202% ] Load shadow types:  28
[ 11.808% ] Compute advice lists:  1639
[ 00.022% ] Intertype weave:  3
[ 00.259% ] Add aspect code:  36
[ 01.167% ] Weaving advice:  162
[ 00.000% ] Validate jimple:  0
[ 06.347% ] Soot Packs:  881
[ 09.524% ] Soot Writing Output:  1322
================================================
Abc started on Thu Jun 24 09:08:04 BST 2004
<<<< ExpandedDotDotPattern.java >>>>
import org.aspectj.testing.Tester;

public class ExpandedDotDotPattern {
    public static void main(java.lang.String[] args) {
        new A().foo();
        new B().foo(3);
        new C().foo(3, 3);
        new D().foo(3, 3, 3);
        new E().foo(3, 3, 3, 3);
        new F().foo(3, 3, 3, 3, 3);
        org.aspectj.testing.Tester.checkEqual(A/*A*/.count,
                                              1 + 1 + 1 + 1 +
                                              1,
                                              "not enough 0-ary");
        org.aspectj.testing.Tester.checkEqual(B/*B*/.count,
                                              0 + 2 + 3 + 4 +
                                              5,
                                              "not enough 1-ary");
        org.aspectj.testing.Tester.checkEqual(C/*C*/.count,
                                              0 + 1 + 4 + 7 +
                                              11,
                                              "not enough 2-ary");
        org.aspectj.testing.Tester.checkEqual(D/*D*/.count,
                                              0 + 1 + 3 + 8 +
                                              15,
                                              "not enough 3-ary");
        org.aspectj.testing.Tester.checkEqual(E/*E*/.count,
                                              0 + 1 + 3 + 7 +
                                              16,
                                              "not enough 4-ary");
        org.aspectj.testing.Tester.checkEqual(F/*F*/.count,
                                              0 + 1 + 3 + 7 +
                                              15,
                                              "not enough 5-ary");
    }
    
    public ExpandedDotDotPattern() { super(); }
}
interface I {
    public abstract void inc();
}
class A implements I {
    static int count = 0;
    
    public void inc() { A/*A*/.count++; }
    
    void foo() {  }
    
    public A() { super(); }
}
class B implements I {
    static int count = 0;
    
    public void inc() { B/*B*/.count++; }
    
    void foo(int a) {  }
    
    public B() { super(); }
}
class C implements I {
    static int count = 0;
    
    public void inc() { C/*C*/.count++; }
    
    void foo(int a, int b) {  }
    
    public C() { super(); }
}
class D implements I {
    static int count = 0;
    
    public void inc() { D/*D*/.count++; }
    
    void foo(int a, int b, int c) {  }
    
    public D() { super(); }
}
class E implements I {
    static int count = 0;
    
    public void inc() { E/*E*/.count++; }
    
    void foo(int a, int b, int c, int d) {  }
    
    public E() { super(); }
}
class F implements I {
    static int count = 0;
    
    public void inc() { F/*F*/.count++; }
    
    void foo(int a, int b, int c, int d, int e) {  }
    
    public F() { super(); }
}
aspect Aspect {
    before(I i):
    this(i) &&
      execution (void (*).foo()) {
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
        i.inc();
    }
    
    before(I i): this(i) && execution (void (*).foo(..)) { i.inc(); }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int)) {
        java.lang.System/*java.lang.System*/.out.println("(int)" +
                                                         thisJoinPoint);
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., ..)) {
        java.lang.System/*java.lang.System*/.out.println("(.., ..)" +
                                                         thisJoinPoint);
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int)) {
        java.lang.System/*java.lang.System*/.out.println("(.., int)" +
                                                         thisJoinPoint);
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., .., int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(.., int, int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, .., int, int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, .., ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, .., int)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, int, ..)) {
        i.inc();
    }
    
    before(I i):
    this(i) &&
      execution (void (*).foo(int, int, int, int)) {
        i.inc();
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <ExpandedDotDotPattern: void main(java.lang.String[])> from ExpandedDotDotPattern
retrieve <ExpandedDotDotPattern: void <init>()> from ExpandedDotDotPattern
retrieve <A: void foo()> from A
retrieve <A: void inc()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <B: void inc()> from B
retrieve <B: void <init>()> from B
retrieve <B: void <clinit>()> from B
retrieve <B: void foo(int)> from B
retrieve <C: void inc()> from C
retrieve <C: void <init>()> from C
retrieve <C: void <clinit>()> from C
retrieve <C: void foo(int,int)> from C
retrieve <D: void inc()> from D
retrieve <D: void foo(int,int,int)> from D
retrieve <D: void <init>()> from D
retrieve <D: void <clinit>()> from D
retrieve <E: void inc()> from E
retrieve <E: void <init>()> from E
retrieve <E: void <clinit>()> from E
retrieve <E: void foo(int,int,int,int)> from E
retrieve <F: void foo(int,int,int,int,int)> from F
retrieve <F: void inc()> from F
retrieve <F: void <init>()> from F
retrieve <F: void <clinit>()> from F
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: void before$0(I,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$1(I)> from Aspect
retrieve <Aspect: void before$2(I,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$3(I,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$4(I)> from Aspect
retrieve <Aspect: void before$5(I,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$6(I)> from Aspect
retrieve <Aspect: void before$7(I)> from Aspect
retrieve <Aspect: void before$8(I)> from Aspect
retrieve <Aspect: void before$9(I)> from Aspect
retrieve <Aspect: void before$10(I)> from Aspect
retrieve <Aspect: void before$11(I)> from Aspect
retrieve <Aspect: void before$12(I)> from Aspect
retrieve <Aspect: void before$13(I)> from Aspect
retrieve <Aspect: void before$14(I)> from Aspect
retrieve <Aspect: void before$15(I)> from Aspect
retrieve <Aspect: void before$16(I)> from Aspect
retrieve <Aspect: void before$17(I)> from Aspect
retrieve <Aspect: void before$18(I)> from Aspect
retrieve <Aspect: void before$19(I)> from Aspect
retrieve <Aspect: void before$20(I)> from Aspect
retrieve <Aspect: void before$21(I)> from Aspect
retrieve <Aspect: void before$22(I)> from Aspect
retrieve <Aspect: void before$23(I)> from Aspect
retrieve <Aspect: void before$24(I)> from Aspect
retrieve <Aspect: void before$25(I)> from Aspect
retrieve <Aspect: void before$26(I)> from Aspect
retrieve <Aspect: void before$27(I)> from Aspect
retrieve <Aspect: void before$28(I)> from Aspect
retrieve <Aspect: void before$29(I)> from Aspect
retrieve <Aspect: void before$30(I)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
Transforming D... 
Transforming I... 
Transforming C... 
Transforming F... 
Transforming E... 
Transforming ExpandedDotDotPattern... 
Transforming Aspect... 
Transforming B... 
Transforming A... 
Abc finished on Thu Jun 24 09:08:18 BST 2004. ( 0 min. 13 sec. )
execution(void A.foo())
(.., ..)execution(void A.foo())
(int)execution(void B.foo(int))
(.., ..)execution(void B.foo(int))
(.., int)execution(void B.foo(int))
(.., ..)execution(void C.foo(int, int))
(.., int)execution(void C.foo(int, int))
(.., ..)execution(void D.foo(int, int, int))
(.., int)execution(void D.foo(int, int, int))
(.., ..)execution(void E.foo(int, int, int, int))
(.., int)execution(void E.foo(int, int, int, int))
(.., ..)execution(void F.foo(int, int, int, int, int))
(.., int)execution(void F.foo(int, int, int, int, int))
PASS: fairly monotonous (and non-covering) tests for expanded dot patterns()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 15 seconds
Passed. Current status: 135 failed (check: 70), 276 passed (check: 81), 0 skipped.
Executing test 412 (new): field patterns and subtyping
================================================
Breakdown of abc phases  (total: 10542 millisec.)
------------------------------------------------
[ 00.427% ] Init. of Soot:  45
[ 00.683% ] Loading Jars:  72
[ 75.915% ] Polyglot phases:  8003
[ 00.019% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  2
[ 00.493% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.379% ] Intertype Adjuster:  40
[ 12.370% ] Retrieving bodies:  1304
[ 00.000% ] Weave Initializers:  0
[ 00.275% ] Load shadow types:  29
[ 02.647% ] Compute advice lists:  279
[ 00.038% ] Intertype weave:  4
[ 00.341% ] Add aspect code:  36
[ 00.294% ] Weaving advice:  31
[ 00.000% ] Validate jimple:  0
[ 03.491% ] Soot Packs:  368
[ 02.609% ] Soot Writing Output:  275
================================================
Abc started on Thu Jun 24 09:08:22 BST 2004
<<<< FieldPatterns.java >>>>
import org.aspectj.testing.Tester;

public class FieldPatterns {
    public static void main(java.lang.String[] args) {
        SuperC sc = new SuperC();
        C c = new C();
        SubC subc = new SubC();
        org.aspectj.testing.Tester.checkEqual(sc/*null*/.name,
                                              "SuperC");
        org.aspectj.testing.Tester.checkEqual(sc/*null*/.count,
                                              1,
                                              "SuperC");
        org.aspectj.testing.Tester.checkEqual(c/*null*/.name, "C");
        org.aspectj.testing.Tester.checkEqual(c/*null*/.count,
                                              1,
                                              "C");
        org.aspectj.testing.Tester.checkEqual(subc/*null*/.name, "C");
        org.aspectj.testing.Tester.checkEqual(subc/*null*/.count,
                                              1,
                                              "SubC");
        org.aspectj.testing.Tester.checkEqual(((SuperC)
                                                 c)/*<unknown>*/.name,
                                              "SuperC");
        org.aspectj.testing.Tester.checkEqual(c/*null*/.count,
                                              2,
                                              "C as SuperC");
        c/*null*/.name = null;
    }
    
    public FieldPatterns() { super(); }
}
class SuperC {
    int count = 0;
    
    java.lang.String name = "SuperC";
    
    public SuperC() { super(); }
}
class C extends SuperC {
    java.lang.String name = "C";
    
    public C() { super(); }
}
class SubC extends C {
    public SubC() { super(); }
}
aspect A {
    before(SuperC sc):
    get( String (SuperC).name) &&
      target(sc) {
        sc/*null*/.count++;
    }
    
    before(C c):
    get( String (C).name) &&
      target(c) {
        c/*null*/.count++;
    }
    
    before(): set( String (C).name) {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <FieldPatterns: void main(java.lang.String[])> from FieldPatterns
retrieve <FieldPatterns: void <init>()> from FieldPatterns
retrieve <SuperC: void <init>()> from SuperC
retrieve <C: void <init>()> from C
retrieve <SubC: void <init>()> from SubC
retrieve <A: void before$0(SuperC)> from A
retrieve <A: void before$1(C)> from A
retrieve <A: void before$2()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming SubC... 
Transforming C... 
Transforming FieldPatterns... 
Transforming A... 
Transforming SuperC... 
Abc finished on Thu Jun 24 09:08:33 BST 2004. ( 0 min. 10 sec. )
PASS: field patterns and subtyping()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 135 failed (check: 70), 277 passed (check: 81), 0 skipped.
Executing test 413 (new): Checking formal matching as in Roeder's bug in 0.7b10
================================================
Breakdown of abc phases  (total: 10321 millisec.)
------------------------------------------------
[ 00.388% ] Init. of Soot:  40
[ 00.039% ] Loading Jars:  4
[ 69.964% ] Polyglot phases:  7221
[ 00.019% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  2
[ 00.329% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.581% ] Intertype Adjuster:  60
[ 06.065% ] Retrieving bodies:  626
[ 00.000% ] Weave Initializers:  0
[ 00.455% ] Load shadow types:  47
[ 11.336% ] Compute advice lists:  1170
[ 00.029% ] Intertype weave:  3
[ 00.194% ] Add aspect code:  20
[ 01.008% ] Weaving advice:  104
[ 00.000% ] Validate jimple:  0
[ 05.697% ] Soot Packs:  588
[ 03.876% ] Soot Writing Output:  400
================================================
Abc started on Thu Jun 24 09:08:35 BST 2004
<<<< FormalMatching.java >>>>
import org.aspectj.lang.*;
import org.aspectj.testing.*;

public class FormalMatching {
    public static void main(java.lang.String[] args) {
        new FormalMatching().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        call_v();
        call_vI(0);
        call_vII(0, 1);
        call_i();
        call_iI(0);
        call_iII(0, 1);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static java.lang.String[] methods =
      { "call_v", "call_vI", "call_vII", "call_i", "call_iI", "call_iII" };
    
    static {
               for (int i = 0;
                    i <
                    FormalMatching/*FormalMatching*/.methods/*null*/.length;
                    i++) {
                   org.aspectj.testing.Tester.expectEvent(FormalMatching/*FormalMatching*/.methods[i]);
                   org.aspectj.testing.Tester.expectEvent(FormalMatching/*FormalMatching*/.methods[i] +
                                                          "-advice");
               }
           }
    
    void call_v() { org.aspectj.testing.Tester.event("call_v"); }
    
    void call_vI(int i0) {
        org.aspectj.testing.Tester.event("call_vI");
    }
    
    void call_vII(int i0, int i1) {
        org.aspectj.testing.Tester.event("call_vII");
    }
    
    int call_i() {
        org.aspectj.testing.Tester.event("call_i");
        return 0;
    }
    
    int call_iI(int i0) {
        org.aspectj.testing.Tester.event("call_iI");
        return 0;
    }
    
    int call_iII(int i0, int i1) {
        org.aspectj.testing.Tester.event("call_iII");
        return 0;
    }
    
    public FormalMatching() { super(); }
}
aspect Aspect {
    pointcut args0(java.lang.Object o) :
    call(* (*).call*()) &&
      target(o);
    
    pointcut args1(java.lang.Object o, int i0) :
    call(* (*).call*(int)) && target(o) &&
      args(i0);
    
    pointcut args2(java.lang.Object o, int i0, int i1) :
    call(* (*).call*(int, int)) && target(o) &&
      args(i0, i1);
    
    before(Object o): args0(o) { a(thisJoinPoint); }
    
    before(Object o, int i0): args1(o, i0) { a(thisJoinPoint); }
    
    before(Object o, int i0, int i1):
    args2(o,
        i0,
        i1) {
        a(thisJoinPoint);
    }
    
    static void a(org.aspectj.lang.JoinPoint jp) {
        org.aspectj.testing.Tester.event(jp.getSignature().getName() +
                                         "-advice");
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <FormalMatching: void realMain(java.lang.String[])> from FormalMatching
retrieve <FormalMatching: void call_v()> from FormalMatching
retrieve <FormalMatching: void call_vI(int)> from FormalMatching
retrieve <FormalMatching: void call_vII(int,int)> from FormalMatching
retrieve <FormalMatching: int call_i()> from FormalMatching
retrieve <FormalMatching: int call_iI(int)> from FormalMatching
retrieve <FormalMatching: int call_iII(int,int)> from FormalMatching
retrieve <FormalMatching: void <init>()> from FormalMatching
retrieve <FormalMatching: void <clinit>()> from FormalMatching
retrieve <FormalMatching: void main(java.lang.String[])> from FormalMatching
retrieve <Aspect: void before$0(java.lang.Object,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$1(java.lang.Object,int,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void before$2(java.lang.Object,int,int,org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: void a(org.aspectj.lang.JoinPoint)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming Aspect... 
Transforming FormalMatching... 
Abc finished on Thu Jun 24 09:08:46 BST 2004. ( 0 min. 10 sec. )
PASS: Checking formal matching as in Roeder's bug in 0.7b10()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 135 failed (check: 70), 278 passed (check: 81), 0 skipped.
Executing test 414 (new): Introducing synchronized methods on interfaces.
================================================
Breakdown of abc phases  (total: 11094 millisec.)
------------------------------------------------
[ 00.424% ] Init. of Soot:  47
[ 00.036% ] Loading Jars:  4
[ 80.476% ] Polyglot phases:  8928
[ 00.018% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  3
[ 00.334% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 01.514% ] Intertype Adjuster:  168
[ 04.777% ] Retrieving bodies:  530
[ 00.000% ] Weave Initializers:  0
[ 00.270% ] Load shadow types:  30
[ 04.507% ] Compute advice lists:  500
[ 00.036% ] Intertype weave:  4
[ 00.775% ] Add aspect code:  86
[ 00.117% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.786% ] Soot Packs:  420
[ 02.902% ] Soot Writing Output:  322
================================================
Abc started on Thu Jun 24 09:08:51 BST 2004
<<<< SynchronizedMethodsOnInterfaces.java >>>>
import org.aspectj.testing.*;
import java.lang.reflect.*;

public class SynchronizedMethodsOnInterfaces {
    public static void main(java.lang.String[] args) {
        new SynchronizedMethodsOnInterfaces().realMain(args);
    }
    
    static { org.aspectj.testing.Tester.expectEventsInString("I,C"); }
    
    public void realMain(java.lang.String[] args) {
        method(new D());
        method(new C());
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    void method(java.lang.Object o) {
        try {
            o.getClass().getMethod("method",
                                   new java.lang.Class[] {  }).invoke(o,
                                                                      new java.lang.Object[] {  });
        }
        catch (java.lang.Throwable t) {
            org.aspectj.testing.Tester.check(false, t + "");
        }
    }
    
    public SynchronizedMethodsOnInterfaces() { super(); }
}
interface I {}
class D implements I {
    public D() { super(); }
}
class C {
    public C() { super(); }
}
aspect AspectI {
    public synchronized intertype void I.method() {
        org.aspectj.testing.Tester.event("I");
    }
    
    public static AspectI aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectI() { super(); }
}
aspect AspectC {
    public synchronized intertype void C.method() {
        org.aspectj.testing.Tester.event("C");
    }
    
    public static AspectC aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectC() { super(); }
}
retrieve <SynchronizedMethodsOnInterfaces: void <clinit>()> from SynchronizedMethodsOnInterfaces
retrieve <SynchronizedMethodsOnInterfaces: void <init>()> from SynchronizedMethodsOnInterfaces
retrieve <SynchronizedMethodsOnInterfaces: void main(java.lang.String[])> from SynchronizedMethodsOnInterfaces
retrieve <SynchronizedMethodsOnInterfaces: void realMain(java.lang.String[])> from SynchronizedMethodsOnInterfaces
retrieve <SynchronizedMethodsOnInterfaces: void method(java.lang.Object)> from SynchronizedMethodsOnInterfaces
retrieve <D: void method()> from D
retrieve <D: void <init>()> from D
retrieve <C: void method()> from C
retrieve <C: void <init>()> from C
retrieve <AspectI: void method(I)> from AspectI
retrieve <AspectI: AspectI aspectOf()> from AspectI
retrieve <AspectI: boolean hasAspect()> from AspectI
retrieve <AspectI: void <init>()> from AspectI
retrieve <AspectC: void method(C)> from AspectC
retrieve <AspectC: AspectC aspectOf()> from AspectC
retrieve <AspectC: boolean hasAspect()> from AspectC
retrieve <AspectC: void <init>()> from AspectC
Transforming AspectC... 
Transforming I... 
Transforming AspectI... 
Transforming C... 
Transforming D... 
Transforming SynchronizedMethodsOnInterfaces... 
Abc finished on Thu Jun 24 09:09:02 BST 2004. ( 0 min. 11 sec. )
PASS: Introducing synchronized methods on interfaces.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 135 failed (check: 70), 279 passed (check: 81), 0 skipped.
Executing test 415 (new): The pointcut params (..,int..) is not recognizing (Object,int,Object).
================================================
Breakdown of abc phases  (total: 15300 millisec.)
------------------------------------------------
[ 00.261% ] Init. of Soot:  40
[ 00.020% ] Loading Jars:  3
[ 56.131% ] Polyglot phases:  8588
[ 00.013% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  2
[ 00.627% ] Recompute name pattern matches:  96
[ 00.000% ] Compute precedence relation:  0
[ 00.255% ] Intertype Adjuster:  39
[ 06.092% ] Retrieving bodies:  932
[ 00.000% ] Weave Initializers:  0
[ 00.595% ] Load shadow types:  91
[ 26.732% ] Compute advice lists:  4090
[ 00.020% ] Intertype weave:  3
[ 00.229% ] Add aspect code:  35
[ 00.353% ] Weaving advice:  54
[ 00.007% ] Validate jimple:  1
[ 05.366% ] Soot Packs:  821
[ 03.288% ] Soot Writing Output:  503
================================================
Abc started on Thu Jun 24 09:09:05 BST 2004
<<<< Params.java >>>>
import org.aspectj.testing.*;

public class Params {
    public static void main(java.lang.String[] args) {
        new Params().go();
    }
    
    void go() {
        A a = new A();
        B b = new B();
        C c = new C();
        D d = new D();
        b(a);
        b(a, b);
        b(b, a);
        b(a, b, c);
        b(a, c, b);
        b(b, a, c);
        b(b, c, a);
        b(c, a, b);
        b(c, b, a);
        b(d, a, b, c);
        b(d, a, c, b);
        b(d, b, a, c);
        b(d, b, c, a);
        b(d, c, a, b);
        b(d, c, b, a);
        b(a, d, b, c);
        b(a, d, c, b);
        b(b, d, a, c);
        b(b, d, c, a);
        b(c, d, a, b);
        b(c, d, b, a);
        b(a, b, d, c);
        b(a, c, d, b);
        b(b, a, d, c);
        b(b, c, d, a);
        b(c, a, d, b);
        b(c, b, d, a);
        b(a, b, c, d);
        b(a, c, b, d);
        b(b, a, c, d);
        b(b, c, a, d);
        b(c, a, b, d);
        b(c, b, a, d);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static void m_(java.lang.String str) {
        org.aspectj.testing.Tester.expectEvent(str);
        org.aspectj.testing.Tester.expectEvent(str + ".advice");
    }
    
    static {
               m_("b1");
               m_("b2.1");
               m_("b2.2");
               m_("b3.1");
               m_("b3.2");
               m_("b3.3");
               m_("b3.4");
               m_("b3.5");
               m_("b3.6");
               m_("b4.1.1");
               m_("b4.1.2");
               m_("b4.1.3");
               m_("b4.1.4");
               m_("b4.1.5");
               m_("b4.1.6");
               m_("b4.2.1");
               m_("b4.2.2");
               m_("b4.2.3");
               m_("b4.2.4");
               m_("b4.2.5");
               m_("b4.2.6");
               m_("b4.3.1");
               m_("b4.3.2");
               m_("b4.3.3");
               m_("b4.3.4");
               m_("b4.3.5");
               m_("b4.3.6");
               m_("b4.4.1");
               m_("b4.4.2");
               m_("b4.4.3");
               m_("b4.4.4");
               m_("b4.4.5");
               m_("b4.4.6");
           }
    
    void b(A a) { a("b1"); }
    
    void b(A a, B b) { a("b2.1"); }
    
    void b(B b, A a) { a("b2.2"); }
    
    void b(A a, B b, C c) { a("b3.1"); }
    
    void b(A a, C c, B b) { a("b3.2"); }
    
    void b(B b, A a, C c) { a("b3.3"); }
    
    void b(B b, C c, A a) { a("b3.4"); }
    
    void b(C c, A a, B b) { a("b3.5"); }
    
    void b(C c, B b, A a) { a("b3.6"); }
    
    void b(D d, A a, B b, C c) { a("b4.1.1"); }
    
    void b(D d, A a, C c, B b) { a("b4.1.2"); }
    
    void b(D d, B b, A a, C c) { a("b4.1.3"); }
    
    void b(D d, B b, C c, A a) { a("b4.1.4"); }
    
    void b(D d, C c, A a, B b) { a("b4.1.5"); }
    
    void b(D d, C c, B b, A a) { a("b4.1.6"); }
    
    void b(A a, D d, B b, C c) { a("b4.2.1"); }
    
    void b(A a, D d, C c, B b) { a("b4.2.2"); }
    
    void b(B b, D d, A a, C c) { a("b4.2.3"); }
    
    void b(B b, D d, C c, A a) { a("b4.2.4"); }
    
    void b(C c, D d, A a, B b) { a("b4.2.5"); }
    
    void b(C c, D d, B b, A a) { a("b4.2.6"); }
    
    void b(A a, B b, D d, C c) { a("b4.3.1"); }
    
    void b(A a, C c, D d, B b) { a("b4.3.2"); }
    
    void b(B b, A a, D d, C c) { a("b4.3.3"); }
    
    void b(B b, C c, D d, A a) { a("b4.3.4"); }
    
    void b(C c, A a, D d, B b) { a("b4.3.5"); }
    
    void b(C c, B b, D d, A a) { a("b4.3.6"); }
    
    void b(A a, B b, C c, D d) { a("b4.4.1"); }
    
    void b(A a, C c, B b, D d) { a("b4.4.2"); }
    
    void b(B b, A a, C c, D d) { a("b4.4.3"); }
    
    void b(B b, C c, A a, D d) { a("b4.4.4"); }
    
    void b(C c, A a, B b, D d) { a("b4.4.5"); }
    
    void b(C c, B b, A a, D d) { a("b4.4.6"); }
    
    static java.lang.String str = "";
    
    public static void a(java.lang.Object o) {
        Params/*Params*/.str = o + "";
        org.aspectj.testing.Tester.event(Params/*Params*/.str);
    }
    
    public Params() { super(); }
}
class A {
    public A() { super(); }
}
class B {
    public B() { super(); }
}
class C {
    public C() { super(); }
}
class D {
    public D() { super(); }
}
aspect ParamsAspect {
    pointcut intParams() : call(* (*).*(.., A, ..)) && target(Params);
    
    after():
    intParams() {
        org.aspectj.testing.Tester.event(Params/*Params*/.str +
                                         ".advice");
    }
    
    public static ParamsAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ParamsAspect() { super(); }
}
retrieve <Params: void b(A,C,B,D)> from Params
retrieve <Params: void b(B,A,C,D)> from Params
retrieve <Params: void b(B,C,A,D)> from Params
retrieve <Params: void b(C,A,B,D)> from Params
retrieve <Params: void b(C,B,A,D)> from Params
retrieve <Params: void a(java.lang.Object)> from Params
retrieve <Params: void <init>()> from Params
retrieve <Params: void <clinit>()> from Params
retrieve <Params: void main(java.lang.String[])> from Params
retrieve <Params: void go()> from Params
retrieve <Params: void m_(java.lang.String)> from Params
retrieve <Params: void b(A)> from Params
retrieve <Params: void b(A,B)> from Params
retrieve <Params: void b(B,A)> from Params
retrieve <Params: void b(A,B,C)> from Params
retrieve <Params: void b(A,C,B)> from Params
retrieve <Params: void b(B,A,C)> from Params
retrieve <Params: void b(B,C,A)> from Params
retrieve <Params: void b(C,A,B)> from Params
retrieve <Params: void b(C,B,A)> from Params
retrieve <Params: void b(D,A,B,C)> from Params
retrieve <Params: void b(D,A,C,B)> from Params
retrieve <Params: void b(D,B,A,C)> from Params
retrieve <Params: void b(D,B,C,A)> from Params
retrieve <Params: void b(D,C,A,B)> from Params
retrieve <Params: void b(D,C,B,A)> from Params
retrieve <Params: void b(A,D,B,C)> from Params
retrieve <Params: void b(A,D,C,B)> from Params
retrieve <Params: void b(B,D,A,C)> from Params
retrieve <Params: void b(B,D,C,A)> from Params
retrieve <Params: void b(C,D,A,B)> from Params
retrieve <Params: void b(C,D,B,A)> from Params
retrieve <Params: void b(A,B,D,C)> from Params
retrieve <Params: void b(A,C,D,B)> from Params
retrieve <Params: void b(B,A,D,C)> from Params
retrieve <Params: void b(B,C,D,A)> from Params
retrieve <Params: void b(C,A,D,B)> from Params
retrieve <Params: void b(C,B,D,A)> from Params
retrieve <Params: void b(A,B,C,D)> from Params
retrieve <A: void <init>()> from A
retrieve <B: void <init>()> from B
retrieve <C: void <init>()> from C
retrieve <D: void <init>()> from D
retrieve <ParamsAspect: void <init>()> from ParamsAspect
retrieve <ParamsAspect: void after$0()> from ParamsAspect
retrieve <ParamsAspect: ParamsAspect aspectOf()> from ParamsAspect
retrieve <ParamsAspect: boolean hasAspect()> from ParamsAspect
Transforming D... 
Transforming B... 
Transforming ParamsAspect... 
Transforming A... 
Transforming C... 
Transforming Params... 
Abc finished on Thu Jun 24 09:09:21 BST 2004. ( 0 min. 15 sec. )
PASS: The pointcut params (..,int..) is not recognizing (Object,int,Object).()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 16 seconds
Passed. Current status: 135 failed (check: 70), 280 passed (check: 81), 0 skipped.
Executing test 416 (new): calls advice on array objects causes error in code generation
Failed. Current status: 136 failed (check: 70), 280 passed (check: 81), 0 skipped.
Executing test 417 (new): join points in field initializers aren't showing up.
================================================
Breakdown of abc phases  (total: 12606 millisec.)
------------------------------------------------
[ 00.349% ] Init. of Soot:  44
[ 00.024% ] Loading Jars:  3
[ 82.088% ] Polyglot phases:  10348
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 00.547% ] Recompute name pattern matches:  69
[ 00.000% ] Compute precedence relation:  0
[ 00.301% ] Intertype Adjuster:  38
[ 07.528% ] Retrieving bodies:  949
[ 00.000% ] Weave Initializers:  0
[ 00.190% ] Load shadow types:  24
[ 01.253% ] Compute advice lists:  158
[ 00.024% ] Intertype weave:  3
[ 00.357% ] Add aspect code:  45
[ 00.524% ] Weaving advice:  66
[ 00.000% ] Validate jimple:  0
[ 04.284% ] Soot Packs:  540
[ 02.499% ] Soot Writing Output:  315
================================================
Abc started on Thu Jun 24 09:09:37 BST 2004
<<<< NonexistentFieldInitializers.java >>>>
import org.aspectj.testing.Tester;

public class NonexistentFieldInitializers {
    public static void main(java.lang.String[] args) {
        new NonexistentFieldInitializers();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.i,
                                              2,
                                              "Not finding some join points in initializers");
    }
    
    static java.lang.Object so =
      java.lang.System/*java.lang.System*/.in;
    
    java.lang.Object o = java.lang.System/*java.lang.System*/.in;
    
    public NonexistentFieldInitializers() { super(); }
}
aspect A {
    static int i;
    
    before(): get( * (System).in) { A/*A*/.i++; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <NonexistentFieldInitializers: void main(java.lang.String[])> from NonexistentFieldInitializers
retrieve <NonexistentFieldInitializers: void <init>()> from NonexistentFieldInitializers
retrieve <NonexistentFieldInitializers: void <clinit>()> from NonexistentFieldInitializers
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming NonexistentFieldInitializers... 
Transforming A... 
Abc finished on Thu Jun 24 09:09:49 BST 2004. ( 0 min. 12 sec. )
PASS: join points in field initializers aren't showing up.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 15 seconds
Passed. Current status: 136 failed (check: 70), 281 passed (check: 81), 0 skipped.
Executing test 418 (new): Handlers problem
================================================
Breakdown of abc phases  (total: 15098 millisec.)
------------------------------------------------
[ 00.424% ] Init. of Soot:  64
[ 00.020% ] Loading Jars:  3
[ 75.732% ] Polyglot phases:  11434
[ 00.013% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  2
[ 00.397% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 00.861% ] Intertype Adjuster:  130
[ 14.154% ] Retrieving bodies:  2137
[ 00.000% ] Weave Initializers:  0
[ 00.179% ] Load shadow types:  27
[ 01.649% ] Compute advice lists:  249
[ 00.026% ] Intertype weave:  4
[ 00.132% ] Add aspect code:  20
[ 00.490% ] Weaving advice:  74
[ 00.000% ] Validate jimple:  0
[ 02.755% ] Soot Packs:  416
[ 03.153% ] Soot Writing Output:  476
================================================
Abc started on Thu Jun 24 09:09:54 BST 2004
<<<< PR318.java >>>>
public class PR318 {
    public static void main(java.lang.String[] args) {
        new PR318().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        Bar.bar();
        org.aspectj.testing.Tester.check(PR318/*PR318*/.caught,
                                         "Exception wasn\'t caught");
    }
    
    static boolean caught = false;
    
    public PR318() { super(); }
}
class Foo {
    static void foo() throws java.lang.Exception {
        throw new java.lang.IllegalArgumentException("foo!");
    }
    
    public Foo() { super(); }
}
class Bar {
    static void bar() {
        try {
            Foo.foo();
        }
        catch (java.lang.Exception e) {  }
    }
    
    public Bar() { super(); }
}
aspect A {
    before(Exception e):
    handler(Exception) &&
      args(e) {
        if (e instanceof java.lang.IllegalArgumentException) {
            PR318/*PR318*/.caught = true;
        }
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <PR318: void <clinit>()> from PR318
retrieve <PR318: void main(java.lang.String[])> from PR318
retrieve <PR318: void realMain(java.lang.String[])> from PR318
retrieve <PR318: void <init>()> from PR318
retrieve <Foo: void foo()> from Foo
retrieve <Foo: void <init>()> from Foo
retrieve <Bar: void <init>()> from Bar
retrieve <Bar: void bar()> from Bar
retrieve <A: void before$0(java.lang.Exception)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Bar... 
Transforming PR318... 
Transforming Foo... 
Abc finished on Thu Jun 24 09:10:09 BST 2004. ( 0 min. 15 sec. )
PASS: Handlers problem()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 17 seconds
Passed. Current status: 136 failed (check: 70), 282 passed (check: 81), 0 skipped.
Executing test 419 (new): work nicely with inner class method look-up rules and call-site advice
================================================
Breakdown of abc phases  (total: 10759 millisec.)
------------------------------------------------
[ 00.539% ] Init. of Soot:  58
[ 00.037% ] Loading Jars:  4
[ 81.522% ] Polyglot phases:  8771
[ 00.019% ] Resolve class names:  2
[ 00.009% ] Declare Parents:  1
[ 00.362% ] Recompute name pattern matches:  39
[ 00.000% ] Compute precedence relation:  0
[ 00.548% ] Intertype Adjuster:  59
[ 08.979% ] Retrieving bodies:  966
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  30
[ 01.831% ] Compute advice lists:  197
[ 00.037% ] Intertype weave:  4
[ 00.307% ] Add aspect code:  33
[ 00.130% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.881% ] Soot Packs:  310
[ 02.519% ] Soot Writing Output:  271
================================================
Failed. Current status: 137 failed (check: 70), 282 passed (check: 81), 0 skipped.
Executing test 420 (new): strictfp modifier allowed on advice
================================================
Breakdown of abc phases  (total: 7215 millisec.)
------------------------------------------------
[ 00.513% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 78.905% ] Polyglot phases:  5693
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.748% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.513% ] Intertype Adjuster:  37
[ 07.457% ] Retrieving bodies:  538
[ 00.000% ] Weave Initializers:  0
[ 00.333% ] Load shadow types:  24
[ 01.760% ] Compute advice lists:  127
[ 00.055% ] Intertype weave:  4
[ 00.499% ] Add aspect code:  36
[ 01.026% ] Weaving advice:  74
[ 00.000% ] Validate jimple:  0
[ 04.144% ] Soot Packs:  299
[ 03.936% ] Soot Writing Output:  284
================================================
Abc started on Thu Jun 24 09:10:27 BST 2004
<<<< StrictFPAdvice.java >>>>
import org.aspectj.testing.Tester;

public class StrictFPAdvice {
    public static void main(java.lang.String[] args) { m(2.0); }
    
    static double m(double a) { return a; }
    
    public StrictFPAdvice() { super(); }
}
aspect A {
    pointcut points(double d) :
    call(double (StrictFPAdvice).m(double)) &&
      args(d);
    
    strictfp before(double d): points(d) {  }
    
    strictfp double around (double d):
    points(d) {
        return this.proceed(d);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <StrictFPAdvice: void main(java.lang.String[])> from StrictFPAdvice
retrieve <StrictFPAdvice: double m(double)> from StrictFPAdvice
retrieve <StrictFPAdvice: void <init>()> from StrictFPAdvice
retrieve <A: void before$0(double)> from A
retrieve <A: double around$1(double)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: double proceed$2(double)> from A
Transforming A... 
Transforming StrictFPAdvice... 
Transforming abc$access$A$around$1... 
Abc finished on Thu Jun 24 09:10:35 BST 2004. ( 0 min. 7 sec. )
PASS: strictfp modifier allowed on advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 137 failed (check: 70), 283 passed (check: 81), 0 skipped.
Executing test 421 (new): No argthis was being created for calls advice.
================================================
Breakdown of abc phases  (total: 9268 millisec.)
------------------------------------------------
[ 00.410% ] Init. of Soot:  38
[ 00.043% ] Loading Jars:  4
[ 67.274% ] Polyglot phases:  6235
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.691% ] Recompute name pattern matches:  64
[ 00.000% ] Compute precedence relation:  0
[ 00.421% ] Intertype Adjuster:  39
[ 06.560% ] Retrieving bodies:  608
[ 00.000% ] Weave Initializers:  0
[ 00.345% ] Load shadow types:  32
[ 12.225% ] Compute advice lists:  1133
[ 00.054% ] Intertype weave:  5
[ 00.410% ] Add aspect code:  38
[ 01.446% ] Weaving advice:  134
[ 00.000% ] Validate jimple:  0
[ 05.568% ] Soot Packs:  516
[ 04.510% ] Soot Writing Output:  418
================================================
Failed. Current status: 138 failed (check: 70), 283 passed (check: 81), 0 skipped.
Executing test 422 (new): Ensuring no advice with instanceof(..) is run on static methods.
================================================
Breakdown of abc phases  (total: 8523 millisec.)
------------------------------------------------
[ 00.458% ] Init. of Soot:  39
[ 00.035% ] Loading Jars:  3
[ 70.703% ] Polyglot phases:  6026
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.634% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.469% ] Intertype Adjuster:  40
[ 12.519% ] Retrieving bodies:  1067
[ 00.000% ] Weave Initializers:  0
[ 00.270% ] Load shadow types:  23
[ 06.946% ] Compute advice lists:  592
[ 00.059% ] Intertype weave:  5
[ 00.422% ] Add aspect code:  36
[ 00.235% ] Weaving advice:  20
[ 00.000% ] Validate jimple:  0
[ 04.165% ] Soot Packs:  355
[ 03.039% ] Soot Writing Output:  259
================================================
Abc started on Thu Jun 24 09:10:50 BST 2004
<<<< StaticMethodsShouldNotReceiveInstanceofAdvice.java >>>>
import org.aspectj.testing.*;
import java.util.*;

public class StaticMethodsShouldNotReceiveInstanceofAdvice {
    public static void main(java.lang.String[] args) {
        ClassWithStaticMethods.staticMethod();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEventsInString("good0");
           }
    
    public StaticMethodsShouldNotReceiveInstanceofAdvice() {
        super();
    }
}
class ClassWithStaticMethods {
    public static void staticMethod() {  }
    
    public ClassWithStaticMethods() { super(); }
}
aspect PutsAdviceOnStaticMethods {
    static void bad(java.lang.Object msg) {
        org.aspectj.testing.Tester.check(false,
                                         "Shouldn\'t have seen: " +
                                         msg);
    }
    
    static void good(java.lang.String msg) {
        org.aspectj.testing.Tester.event(msg);
    }
    
    pointcut bad0() :
    this(ClassWithStaticMethods) &&
      execution (void (*).staticMethod());
    
    pointcut bad1(ClassWithStaticMethods c) :
    this(c) &&
      execution (void (*).staticMethod());
    
    pointcut bad2() :
    target(ClassWithStaticMethods) &&
      call(void (*).staticMethod());
    
    pointcut bad3(ClassWithStaticMethods c) :
    target(c) &&
      call(void (*).staticMethod());
    
    pointcut bad4() :
    target() &&
      call(void (ClassWithStaticMethods).staticMethod());
    
    pointcut bad5(ClassWithStaticMethods c) :
    target(c) &&
      call(void (*).staticMethod());
    
    before(): bad0() { bad("bad0:" + thisJoinPoint); }
    
    before(ClassWithStaticMethods c):
    bad1(c) {
        bad("bad1:" + thisJoinPoint);
    }
    
    before(): bad2() { bad("bad2:" + thisJoinPoint); }
    
    before(ClassWithStaticMethods c):
    bad3(c) {
        bad("bad3:" + thisJoinPoint);
    }
    
    before(): bad4() { bad("bad4:" + thisJoinPoint); }
    
    before(ClassWithStaticMethods c):
    bad5(c) {
        bad("bad5:" + thisJoinPoint);
    }
    
    pointcut good0() :
    execution (void (ClassWithStaticMethods).staticMethod());
    
    before(): good0() { good("good0"); }
    
    public static PutsAdviceOnStaticMethods aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public PutsAdviceOnStaticMethods() { super(); }
}
retrieve <StaticMethodsShouldNotReceiveInstanceofAdvice: void main(java.lang.String[])> from StaticMethodsShouldNotReceiveInstanceofAdvice
retrieve <StaticMethodsShouldNotReceiveInstanceofAdvice: void <clinit>()> from StaticMethodsShouldNotReceiveInstanceofAdvice
retrieve <StaticMethodsShouldNotReceiveInstanceofAdvice: void <init>()> from StaticMethodsShouldNotReceiveInstanceofAdvice
retrieve <ClassWithStaticMethods: void <init>()> from ClassWithStaticMethods
retrieve <ClassWithStaticMethods: void staticMethod()> from ClassWithStaticMethods
retrieve <PutsAdviceOnStaticMethods: void bad(java.lang.Object)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void good(java.lang.String)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$0(org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$1(ClassWithStaticMethods,org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$2(org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$3(ClassWithStaticMethods,org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$4(org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$5(ClassWithStaticMethods,org.aspectj.lang.JoinPoint)> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void before$6()> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: PutsAdviceOnStaticMethods aspectOf()> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: boolean hasAspect()> from PutsAdviceOnStaticMethods
retrieve <PutsAdviceOnStaticMethods: void <init>()> from PutsAdviceOnStaticMethods
Transforming PutsAdviceOnStaticMethods... 
Transforming ClassWithStaticMethods... 
Transforming StaticMethodsShouldNotReceiveInstanceofAdvice... 
Abc finished on Thu Jun 24 09:10:58 BST 2004. ( 0 min. 8 sec. )
PASS: Ensuring no advice with instanceof(..) is run on static methods.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 138 failed (check: 70), 284 passed (check: 81), 0 skipped.
Executing test 423 (new): Null pointer on gets advice showing the case causing the error
================================================
Breakdown of abc phases  (total: 7715 millisec.)
------------------------------------------------
[ 00.506% ] Init. of Soot:  39
[ 00.052% ] Loading Jars:  4
[ 80.156% ] Polyglot phases:  6184
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.506% ] Recompute name pattern matches:  39
[ 00.000% ] Compute precedence relation:  0
[ 00.765% ] Intertype Adjuster:  59
[ 06.312% ] Retrieving bodies:  487
[ 00.000% ] Weave Initializers:  0
[ 00.389% ] Load shadow types:  30
[ 02.139% ] Compute advice lists:  165
[ 00.039% ] Intertype weave:  3
[ 00.570% ] Add aspect code:  44
[ 01.244% ] Weaving advice:  96
[ 00.000% ] Validate jimple:  0
[ 03.850% ] Soot Packs:  297
[ 03.422% ] Soot Writing Output:  264
================================================
Abc started on Thu Jun 24 09:11:01 BST 2004
<<<< NullPointerOnGetsSimple.java >>>>
public class NullPointerOnGetsSimple {
    public static void main(java.lang.String[] args) {
        PrintService ps = new PrintService();
        ps/*null*/.string = "after";
        org.aspectj.testing.Tester.checkEqual("after",
                                              ps/*null*/.string);
    }
    
    public NullPointerOnGetsSimple() { super(); }
}
class PrintService {
    java.lang.String string = "before";
    
    public PrintService() { super(); }
}
aspect Aspect {
    pointcut needPrinter(PrintService ps) :
    get( String (PrintService).string) && target(ps) &&
      !within(Aspect);
    
    String around (PrintService ps):
    needPrinter(ps) {
        java.lang.System/*java.lang.System*/.out.println("around");
        org.aspectj.testing.Tester.checkEqual("after",
                                              ps/*null*/.string);
        return ps/*null*/.string;
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <NullPointerOnGetsSimple: void main(java.lang.String[])> from NullPointerOnGetsSimple
retrieve <NullPointerOnGetsSimple: void <init>()> from NullPointerOnGetsSimple
retrieve <PrintService: void <init>()> from PrintService
retrieve <Aspect: java.lang.String proceed$1(PrintService)> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: java.lang.String around$0(PrintService)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
Transforming NullPointerOnGetsSimple... 
Transforming Aspect... 
Transforming PrintService... 
Transforming abc$access$Aspect$around$0... 
Abc finished on Thu Jun 24 09:11:09 BST 2004. ( 0 min. 7 sec. )
around
PASS: Null pointer on gets advice showing the case causing the error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 138 failed (check: 70), 285 passed (check: 81), 0 skipped.
Executing test 424 (new): try to make sure that dynamic JoinPoint objects aren't generated when used inside of if (false) { ... }
getting SJPInfo for a untagged source line $i0 = i1 + i2
getting SJPInfo for a untagged source line $i0 = i1 + i2
getting SJPInfo for a untagged source line $i0 = i1 + i2
getting SJPInfo for a untagged source line $i0 = i1 + i2
================================================
Breakdown of abc phases  (total: 8420 millisec.)
------------------------------------------------
[ 00.463% ] Init. of Soot:  39
[ 00.036% ] Loading Jars:  3
[ 73.135% ] Polyglot phases:  6158
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.594% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.463% ] Intertype Adjuster:  39
[ 08.302% ] Retrieving bodies:  699
[ 00.000% ] Weave Initializers:  0
[ 00.321% ] Load shadow types:  27
[ 04.881% ] Compute advice lists:  411
[ 00.036% ] Intertype weave:  3
[ 00.273% ] Add aspect code:  23
[ 01.520% ] Weaving advice:  128
[ 00.000% ] Validate jimple:  0
[ 05.641% ] Soot Packs:  475
[ 04.287% ] Soot Writing Output:  361
================================================
Abc started on Thu Jun 24 09:11:11 BST 2004
<<<< IfdefsAndAdvice.java >>>>
import org.aspectj.testing.Tester;

public class IfdefsAndAdvice {
    public static void main(java.lang.String[] args) {
        double t1 = timeIt(1);
        double t2 = timeIt(2);
        double t3 = timeIt(3);
        double t4 = timeIt(4);
    }
    
    public static double timeIt(int m) {
        callIt(m);
        callIt(m);
        final int N = 1000;
        long startTime = java.lang.System.currentTimeMillis();
        for (int i = 0; i < N; i++) { callIt(m); }
        long stopTime = java.lang.System.currentTimeMillis();
        return (stopTime - startTime) / 1000.0;
    }
    
    public static void callIt(int m) {
        switch (m) {
            case 1:
                m1(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            case 2:
                m2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            case 3:
                m3(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            case 4:
                m4(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        }
    }
    
    public static int m1(int i1,
                         int i2,
                         int i3,
                         int i4,
                         int i5,
                         int i6,
                         int i7,
                         int i8,
                         int i9,
                         int i10) {
        return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10;
    }
    
    public static int m2(int i1,
                         int i2,
                         int i3,
                         int i4,
                         int i5,
                         int i6,
                         int i7,
                         int i8,
                         int i9,
                         int i10) {
        return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10;
    }
    
    public static int m3(int i1,
                         int i2,
                         int i3,
                         int i4,
                         int i5,
                         int i6,
                         int i7,
                         int i8,
                         int i9,
                         int i10) {
        return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10;
    }
    
    public static int m4(int i1,
                         int i2,
                         int i3,
                         int i4,
                         int i5,
                         int i6,
                         int i7,
                         int i8,
                         int i9,
                         int i10) {
        return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10;
    }
    
    public IfdefsAndAdvice() { super(); }
}
aspect A {
    static final boolean DEBUG = false;
    
    before():
    execution (int (*).m1(..)) {
        if (A/*A*/.DEBUG) {
            java.lang.Object args = thisJoinPoint.getThis();
        } else {
            java.lang.String sig = thisJoinPoint.toString();
        }
    }
    
    before():
    execution (int (*).m2(..)) {
        if (A/*A*/.DEBUG) {
            java.lang.Object args = thisJoinPoint.getThis();
        }
    }
    
    before():
    execution (int (*).m3(..)) {
        if (!A/*A*/.DEBUG) {
            java.lang.String sig = thisJoinPoint.toString();
        } else {
            java.lang.Object args = thisJoinPoint.getThis();
        }
    }
    
    before():
    execution (int (*).m4(..)) {
        if (!A/*A*/.DEBUG) {
            java.lang.Object args = thisJoinPoint.getThis();
        } else {
            java.lang.String sig = thisJoinPoint.toString();
        }
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <IfdefsAndAdvice: void main(java.lang.String[])> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: double timeIt(int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: void callIt(int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: int m1(int,int,int,int,int,int,int,int,int,int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: int m2(int,int,int,int,int,int,int,int,int,int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: int m3(int,int,int,int,int,int,int,int,int,int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: int m4(int,int,int,int,int,int,int,int,int,int)> from IfdefsAndAdvice
retrieve <IfdefsAndAdvice: void <init>()> from IfdefsAndAdvice
retrieve <A: void <init>()> from A
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$2(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$3(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <clinit>()> from A
Transforming IfdefsAndAdvice... 
Transforming A... 
Abc finished on Thu Jun 24 09:11:20 BST 2004. ( 0 min. 8 sec. )
PASS: try to make sure that dynamic JoinPoint objects aren't generated when us...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 138 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 425 (new): within and withincode (doesn't all work due to local class name issues)
================================================
Breakdown of abc phases  (total: 12404 millisec.)
------------------------------------------------
[ 00.306% ] Init. of Soot:  38
[ 00.032% ] Loading Jars:  4
[ 79.490% ] Polyglot phases:  9860
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 01.443% ] Recompute name pattern matches:  179
[ 00.000% ] Compute precedence relation:  0
[ 00.669% ] Intertype Adjuster:  83
[ 06.095% ] Retrieving bodies:  756
[ 00.000% ] Weave Initializers:  0
[ 00.282% ] Load shadow types:  35
[ 04.490% ] Compute advice lists:  557
[ 00.032% ] Intertype weave:  4
[ 00.339% ] Add aspect code:  42
[ 00.790% ] Weaving advice:  98
[ 00.000% ] Validate jimple:  0
[ 03.475% ] Soot Packs:  431
[ 02.523% ] Soot Writing Output:  313
================================================
Failed. Current status: 139 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 426 (new): around advice on calls within inner classes (including protected method calls)
Failed. Current status: 140 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 427 (new): around advice on calls within inner classes (including protected method calls)
Failed. Current status: 141 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 428 (new): Arguments to runNext should be final when needed
Failed. Current status: 142 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 429 (new): Method introductions
================================================
Breakdown of abc phases  (total: 9773 millisec.)
------------------------------------------------
[ 00.389% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  4
[ 77.571% ] Polyglot phases:  7581
[ 00.020% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  3
[ 00.553% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 01.678% ] Intertype Adjuster:  164
[ 04.881% ] Retrieving bodies:  477
[ 00.000% ] Weave Initializers:  0
[ 00.235% ] Load shadow types:  23
[ 05.976% ] Compute advice lists:  584
[ 00.041% ] Intertype weave:  4
[ 00.368% ] Add aspect code:  36
[ 00.153% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.502% ] Soot Packs:  440
[ 03.561% ] Soot Writing Output:  348
================================================
Failed. Current status: 143 failed (check: 70), 286 passed (check: 81), 0 skipped.
Executing test 430 (new): Putting an introduced method on each interface
================================================
Breakdown of abc phases  (total: 7987 millisec.)
------------------------------------------------
[ 00.488% ] Init. of Soot:  39
[ 00.038% ] Loading Jars:  3
[ 75.711% ] Polyglot phases:  6047
[ 00.038% ] Resolve class names:  3
[ 00.038% ] Declare Parents:  3
[ 00.639% ] Recompute name pattern matches:  51
[ 00.013% ] Compute precedence relation:  1
[ 02.103% ] Intertype Adjuster:  168
[ 06.373% ] Retrieving bodies:  509
[ 00.000% ] Weave Initializers:  0
[ 00.426% ] Load shadow types:  34
[ 04.858% ] Compute advice lists:  388
[ 00.038% ] Intertype weave:  3
[ 00.426% ] Add aspect code:  34
[ 00.188% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.858% ] Soot Packs:  388
[ 03.769% ] Soot Writing Output:  301
================================================
Abc started on Thu Jun 24 09:12:07 BST 2004
<<<< IntroducedMethodsOnEachInterface.java >>>>
import org.aspectj.testing.Tester;

public class IntroducedMethodsOnEachInterface {
    public static void main(java.lang.String[] args) {
        new IntroducedMethodsOnEachInterface().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        I i0 =
          new I() {
            public int j() { return 3; }
        };
        J j0 =
          new J() {
            public int j() { return 4; }
        };
        B b0 = new B();
        I ib = new B();
        J jb = new B();
        org.aspectj.testing.Tester.checkEqual(i0.j(), 3, "i0");
        org.aspectj.testing.Tester.checkEqual(j0.j(), 4, "j0");
        org.aspectj.testing.Tester.checkEqual(b0.j(), 2, "b0");
        org.aspectj.testing.Tester.checkEqual(ib.j(), 2, "ib");
        org.aspectj.testing.Tester.checkEqual(jb.j(), 2, "jb");
        H h0 =
          new H() {
            public int j() { return 7; }
        };
        H ch = new C();
        C c0 = new C();
        org.aspectj.testing.Tester.checkEqual(h0.j(), 7, "h0");
        org.aspectj.testing.Tester.checkEqual(ch.j(), 6, "ch");
        org.aspectj.testing.Tester.checkEqual(c0.j(), 6, "c0");
    }
    
    public IntroducedMethodsOnEachInterface() { super(); }
}
interface I {}
interface H {}
interface J {
    public abstract int j();
}
class B implements I {
    public B() { super(); }
}
class C implements H {
    public C() { super(); }
}
aspect A {
    declare parents : I implements J;
    
    declare parents : H implements I;
    
    declare parents : H implements J;
    
    public intertype int I.j() { return 1; }
    
    public intertype int B.j() { return 2; }
    
    public intertype int H.j() { return 5; }
    
    public intertype int C.j() { return 6; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <IntroducedMethodsOnEachInterface: void main(java.lang.String[])> from IntroducedMethodsOnEachInterface
retrieve <IntroducedMethodsOnEachInterface: void realMain(java.lang.String[])> from IntroducedMethodsOnEachInterface
retrieve <IntroducedMethodsOnEachInterface: void <init>()> from IntroducedMethodsOnEachInterface
retrieve <IntroducedMethodsOnEachInterface$3: int j()> from IntroducedMethodsOnEachInterface$3
retrieve <IntroducedMethodsOnEachInterface$3: void <init>(IntroducedMethodsOnEachInterface)> from IntroducedMethodsOnEachInterface$3
retrieve <IntroducedMethodsOnEachInterface$1: int j()> from IntroducedMethodsOnEachInterface$1
retrieve <IntroducedMethodsOnEachInterface$1: void <init>(IntroducedMethodsOnEachInterface)> from IntroducedMethodsOnEachInterface$1
retrieve <IntroducedMethodsOnEachInterface$2: int j()> from IntroducedMethodsOnEachInterface$2
retrieve <IntroducedMethodsOnEachInterface$2: void <init>(IntroducedMethodsOnEachInterface)> from IntroducedMethodsOnEachInterface$2
retrieve <B: int j()> from B
retrieve <B: void <init>()> from B
retrieve <C: int j()> from C
retrieve <C: void <init>()> from C
retrieve <A: int j(I)> from A
retrieve <A: int j(B)> from A
retrieve <A: int j(H)> from A
retrieve <A: int j(C)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming I... 
Transforming IntroducedMethodsOnEachInterface... 
Transforming IntroducedMethodsOnEachInterface$1... 
Transforming IntroducedMethodsOnEachInterface$2... 
Transforming H... 
Transforming C... 
Transforming B... 
Transforming J... 
Transforming IntroducedMethodsOnEachInterface$3... 
Transforming A... 
Abc finished on Thu Jun 24 09:12:15 BST 2004. ( 0 min. 8 sec. )
PASS: Putting an introduced method on each interface()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 287 passed (check: 81), 0 skipped.
Executing test 431 (new): Extending interfaces
================================================
Breakdown of abc phases  (total: 8145 millisec.)
------------------------------------------------
[ 00.479% ] Init. of Soot:  39
[ 00.037% ] Loading Jars:  3
[ 77.655% ] Polyglot phases:  6325
[ 00.037% ] Resolve class names:  3
[ 00.037% ] Declare Parents:  3
[ 00.724% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.454% ] Intertype Adjuster:  37
[ 07.428% ] Retrieving bodies:  605
[ 00.000% ] Weave Initializers:  0
[ 00.270% ] Load shadow types:  22
[ 03.904% ] Compute advice lists:  318
[ 00.037% ] Intertype weave:  3
[ 00.246% ] Add aspect code:  20
[ 00.196% ] Weaving advice:  16
[ 00.000% ] Validate jimple:  0
[ 04.690% ] Soot Packs:  382
[ 03.806% ] Soot Writing Output:  310
================================================
Abc started on Thu Jun 24 09:12:17 BST 2004
<<<< BindingInterfaces.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class BindingInterfaces {
    public static void main(java.lang.String[] args) {
        new BindingInterfaces().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        I i0 = new I() {};
        org.aspectj.testing.Tester.checkEqual(str(i0), "I", "i0");
        I ij = new J() {};
        org.aspectj.testing.Tester.checkEqual(str(ij), "JI", "ij");
        I ik = new K() {};
        org.aspectj.testing.Tester.checkEqual(str(ik), "KJI", "ik");
        J j0 = new J() {};
        org.aspectj.testing.Tester.checkEqual(str(j0), "JI", "j0");
        J jk = new K() {};
        org.aspectj.testing.Tester.checkEqual(str(jk), "KJI", "jk");
        K k0 = new K() {};
        org.aspectj.testing.Tester.checkEqual(str(k0), "KJI", "k0");
    }
    
    private java.lang.String str(java.lang.Object o) {
        return str(o.getClass().getInterfaces()[0]);
    }
    
    private java.lang.String str(java.lang.Class c) {
        java.lang.String str = c.getName();
        java.lang.Class[] is = c.getInterfaces();
        for (int i = 0; i < is/*null*/.length; i++) {
            str += str(is[i]);
        }
        return str;
    }
    
    public BindingInterfaces() { super(); }
}
interface I {}
interface J {}
interface K {}
aspect Aspect {
    declare parents : J implements I;
    
    declare parents : K implements J;
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <BindingInterfaces: void main(java.lang.String[])> from BindingInterfaces
retrieve <BindingInterfaces: void realMain(java.lang.String[])> from BindingInterfaces
retrieve <BindingInterfaces: java.lang.String str(java.lang.Object)> from BindingInterfaces
retrieve <BindingInterfaces: java.lang.String str(java.lang.Class)> from BindingInterfaces
retrieve <BindingInterfaces: void <init>()> from BindingInterfaces
retrieve <BindingInterfaces$2: void <init>(BindingInterfaces)> from BindingInterfaces$2
retrieve <BindingInterfaces$5: void <init>(BindingInterfaces)> from BindingInterfaces$5
retrieve <BindingInterfaces$1: void <init>(BindingInterfaces)> from BindingInterfaces$1
retrieve <BindingInterfaces$6: void <init>(BindingInterfaces)> from BindingInterfaces$6
retrieve <BindingInterfaces$3: void <init>(BindingInterfaces)> from BindingInterfaces$3
retrieve <BindingInterfaces$4: void <init>(BindingInterfaces)> from BindingInterfaces$4
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
Transforming I... 
Transforming BindingInterfaces... 
Transforming BindingInterfaces$1... 
Transforming Aspect... 
Transforming BindingInterfaces$2... 
Transforming J... 
Transforming BindingInterfaces$3... 
Transforming BindingInterfaces$4... 
Transforming BindingInterfaces$5... 
Transforming K... 
Transforming BindingInterfaces$6... 
Abc finished on Thu Jun 24 09:12:26 BST 2004. ( 0 min. 8 sec. )
PASS: Extending interfaces()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 288 passed (check: 81), 0 skipped.
Executing test 432 (new): Introducing private methods on interfaces
================================================
Breakdown of abc phases  (total: 8594 millisec.)
------------------------------------------------
[ 00.431% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  4
[ 68.548% ] Polyglot phases:  5891
[ 00.023% ] Resolve class names:  2
[ 00.047% ] Declare Parents:  4
[ 00.652% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 01.769% ] Intertype Adjuster:  152
[ 05.178% ] Retrieving bodies:  445
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  24
[ 13.917% ] Compute advice lists:  1196
[ 00.035% ] Intertype weave:  3
[ 00.407% ] Add aspect code:  35
[ 00.175% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.969% ] Soot Packs:  427
[ 03.526% ] Soot Writing Output:  303
================================================
Abc started on Thu Jun 24 09:12:28 BST 2004
<<<< IntroducingPrivateMethodsOnInterfaces.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class IntroducingPrivateMethodsOnInterfaces {
    public static void main(java.lang.String[] args) { AA.go(); }
    
    static {
               org.aspectj.testing.Tester.expectEvent("private_private");
               org.aspectj.testing.Tester.expectEvent("private_package");
               org.aspectj.testing.Tester.expectEvent("private_public");
               org.aspectj.testing.Tester.expectEvent("package_private");
               org.aspectj.testing.Tester.expectEvent("package_package");
               org.aspectj.testing.Tester.expectEvent("package_public");
               org.aspectj.testing.Tester.expectEvent("public_private");
               org.aspectj.testing.Tester.expectEvent("public_package");
               org.aspectj.testing.Tester.expectEvent("public_public");
           }
    
    public IntroducingPrivateMethodsOnInterfaces() { super(); }
}
interface I {}
class C {
    public C() { super(); }
}
aspect AA {
    public static void go() {
        I c = new C();
        c.private_private();
        c.private_package();
        c.private_public();
        c.package_private();
        c.package_package();
        c.package_public();
        c.public_private();
        c.public_package();
        c.public_public();
    }
    
    private intertype void I._private(java.lang.String s) {
        org.aspectj.testing.Tester.event("private_" + s);
    }
    
    intertype void I._package(java.lang.String s) {
        org.aspectj.testing.Tester.event("package_" + s);
    }
    
    public intertype void I._public(java.lang.String s) {
        org.aspectj.testing.Tester.event("public_" + s);
    }
    
    private intertype void I.private_private() {
        _private("private");
    }
    
    private intertype void I.private_package() {
        _package("private");
    }
    
    private intertype void I.private_public() { _public("private"); }
    
    intertype void I.package_private() { _private("package"); }
    
    intertype void I.package_package() { _package("package"); }
    
    intertype void I.package_public() { _public("package"); }
    
    public intertype void I.public_private() { _private("public"); }
    
    public intertype void I.public_package() { _package("public"); }
    
    public intertype void I.public_public() { _public("public"); }
    
    public static AA aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AA() { super(); }
}
aspect A {
    declare parents : C implements I;
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <IntroducingPrivateMethodsOnInterfaces: void <init>()> from IntroducingPrivateMethodsOnInterfaces
retrieve <IntroducingPrivateMethodsOnInterfaces: void main(java.lang.String[])> from IntroducingPrivateMethodsOnInterfaces
retrieve <IntroducingPrivateMethodsOnInterfaces: void <clinit>()> from IntroducingPrivateMethodsOnInterfaces
retrieve <C: void _public(java.lang.String)> from C
retrieve <C: void public_private()> from C
retrieve <C: void public_package()> from C
retrieve <C: void public_public()> from C
retrieve <C: void AA$_private$12(java.lang.String)> from C
retrieve <C: void AA$_package$14(java.lang.String)> from C
retrieve <C: void AA$private_private$17()> from C
retrieve <C: void AA$private_package$19()> from C
retrieve <C: void AA$private_public$21()> from C
retrieve <C: void AA$package_private$23()> from C
retrieve <C: void AA$package_package$25()> from C
retrieve <C: void AA$package_public$27()> from C
retrieve <C: void <init>()> from C
retrieve <AA: void public_public(I)> from AA
retrieve <AA: AA aspectOf()> from AA
retrieve <AA: boolean hasAspect()> from AA
retrieve <AA: void <init>()> from AA
retrieve <AA: void go()> from AA
retrieve <AA: void AA$_private$12(I,java.lang.String)> from AA
retrieve <AA: void AA$_package$14(I,java.lang.String)> from AA
retrieve <AA: void _public(I,java.lang.String)> from AA
retrieve <AA: void AA$private_private$17(I)> from AA
retrieve <AA: void AA$private_package$19(I)> from AA
retrieve <AA: void AA$private_public$21(I)> from AA
retrieve <AA: void AA$package_private$23(I)> from AA
retrieve <AA: void AA$package_package$25(I)> from AA
retrieve <AA: void AA$package_public$27(I)> from AA
retrieve <AA: void public_private(I)> from AA
retrieve <AA: void public_package(I)> from AA
retrieve <A: void <init>()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: A aspectOf()> from A
Transforming I... 
Transforming AA... 
Transforming C... 
Transforming A... 
Transforming IntroducingPrivateMethodsOnInterfaces... 
Abc finished on Thu Jun 24 09:12:37 BST 2004. ( 0 min. 8 sec. )
PASS: Introducing private methods on interfaces()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 289 passed (check: 81), 0 skipped.
Executing test 433 (new): Issuing errors for assigning variables thisJoinPoint -- not assigning thisJoinPoint.
================================================
Breakdown of abc phases  (total: 7599 millisec.)
------------------------------------------------
[ 00.500% ] Init. of Soot:  38
[ 00.053% ] Loading Jars:  4
[ 74.865% ] Polyglot phases:  5689
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.500% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.763% ] Intertype Adjuster:  58
[ 12.449% ] Retrieving bodies:  946
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  23
[ 02.079% ] Compute advice lists:  158
[ 00.039% ] Intertype weave:  3
[ 00.276% ] Add aspect code:  21
[ 01.171% ] Weaving advice:  89
[ 00.000% ] Validate jimple:  0
[ 03.750% ] Soot Packs:  285
[ 03.198% ] Soot Writing Output:  243
================================================
Abc started on Thu Jun 24 09:12:39 BST 2004
<<<< ThisJoinPointAssignments.java >>>>
public class ThisJoinPointAssignments {
    public static void main(java.lang.String[] args) {
        new ThisJoinPointAssignments().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        new C().f();
        org.aspectj.testing.Tester.check(A/*A*/.jp !=
                                         null,
                                         "Didn\'t set the JoinPoint");
    }
    
    public ThisJoinPointAssignments() { super(); }
}
class C {
    public void f() {  }
    
    public C() { super(); }
}
aspect A {
    static org.aspectj.lang.JoinPoint jp;
    
    before(): call(void (C).f()) { A/*A*/.jp = thisJoinPoint; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ThisJoinPointAssignments: void <init>()> from ThisJoinPointAssignments
retrieve <ThisJoinPointAssignments: void main(java.lang.String[])> from ThisJoinPointAssignments
retrieve <ThisJoinPointAssignments: void realMain(java.lang.String[])> from ThisJoinPointAssignments
retrieve <C: void f()> from C
retrieve <C: void <init>()> from C
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming C... 
Transforming ThisJoinPointAssignments... 
Abc finished on Thu Jun 24 09:12:47 BST 2004. ( 0 min. 7 sec. )
PASS: Issuing errors for assigning variables thisJoinPoint -- not assigning th...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 290 passed (check: 81), 0 skipped.
Executing test 434 (new): Static references inside of introduced bodies get bound correctly.
================================================
Breakdown of abc phases  (total: 7192 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  39
[ 00.056% ] Loading Jars:  4
[ 75.987% ] Polyglot phases:  5465
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.667% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 07.661% ] Intertype Adjuster:  551
[ 05.423% ] Retrieving bodies:  390
[ 00.000% ] Weave Initializers:  0
[ 00.348% ] Load shadow types:  25
[ 01.349% ] Compute advice lists:  97
[ 00.042% ] Intertype weave:  3
[ 00.695% ] Add aspect code:  50
[ 00.181% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.782% ] Soot Packs:  272
[ 03.226% ] Soot Writing Output:  232
================================================
Abc started on Thu Jun 24 09:12:50 BST 2004
<<<< StaticIntroducedReferences.java >>>>
public class StaticIntroducedReferences {
    public StaticIntroducedReferences() { super(); }
}
abstract aspect SuperA {
    static void m() {  }
    
    static int i = 0;
    
    public SuperA() { super(); }
}
aspect A extends SuperA {
    public static intertype void StaticIntroducedReferences.main(java.lang.String[] args) {
        SuperA/*SuperA*/.i++;
        m();
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <StaticIntroducedReferences: void <init>()> from StaticIntroducedReferences
retrieve <StaticIntroducedReferences: void main(java.lang.String[])> from StaticIntroducedReferences
retrieve <SuperA: void m()> from SuperA
retrieve <SuperA: void <init>()> from SuperA
retrieve <SuperA: void <clinit>()> from SuperA
retrieve <A: void <init>()> from A
retrieve <A: void main(java.lang.String[])> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming SuperA... 
Transforming A... 
Transforming StaticIntroducedReferences... 
Abc finished on Thu Jun 24 09:12:57 BST 2004. ( 0 min. 7 sec. )
PASS: Static references inside of introduced bodies get bound correctly.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 143 failed (check: 70), 291 passed (check: 81), 0 skipped.
Executing test 435 (new/cflowObjectCreations): cflow and object creations [of eachcflow]
================================================
Breakdown of abc phases  (total: 10358 millisec.)
------------------------------------------------
[ 00.367% ] Init. of Soot:  38
[ 00.029% ] Loading Jars:  3
[ 78.017% ] Polyglot phases:  8081
[ 00.019% ] Resolve class names:  2
[ 00.010% ] Declare Parents:  1
[ 00.512% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.357% ] Intertype Adjuster:  37
[ 10.224% ] Retrieving bodies:  1059
[ 00.000% ] Weave Initializers:  0
[ 00.222% ] Load shadow types:  23
[ 02.394% ] Compute advice lists:  248
[ 00.029% ] Intertype weave:  3
[ 00.193% ] Add aspect code:  20
[ 00.734% ] Weaving advice:  76
[ 00.000% ] Validate jimple:  0
[ 04.036% ] Soot Packs:  418
[ 02.858% ] Soot Writing Output:  296
================================================
Abc started on Thu Jun 24 09:13:00 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class Driver {
    public static java.lang.String s = "";
    
    public static void main(java.lang.String[] args) {
        new FTPServer();
        org.aspectj.testing.Tester.checkEqual(Driver/*Driver*/.s,
                                              "-connected-after",
                                              "");
    }
    
    public Driver() { super(); }
}
class FTPServer {
    public FTPServer() {
        super();
        new FTPConnection().connect();
    }
}
class FTPConnection {
    public void connect() { Driver/*Driver*/.s += "-connected"; }
    
    public FTPConnection() { super(); }
}
aspect FooBuilding {
    pointcut serverIdentification(FTPServer s) :
    target(s) &&
      execution ((*).new(..));
    
    after() returning(Object ret):
    target(FTPConnection) &&
      call(* (*).*(..)) {
        Driver/*Driver*/.s += "-after";
    }
    
    public static FooBuilding aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public FooBuilding() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Driver: void <clinit>()> from Driver
retrieve <FTPServer: void <init>()> from FTPServer
retrieve <FTPConnection: void connect()> from FTPConnection
retrieve <FTPConnection: void <init>()> from FTPConnection
retrieve <FooBuilding: void <init>()> from FooBuilding
retrieve <FooBuilding: void afterReturning$0(java.lang.Object)> from FooBuilding
retrieve <FooBuilding: FooBuilding aspectOf()> from FooBuilding
retrieve <FooBuilding: boolean hasAspect()> from FooBuilding
Transforming FTPConnection... 
Transforming FooBuilding... 
Transforming Driver... 
Transforming FTPServer... 
Abc finished on Thu Jun 24 09:13:10 BST 2004. ( 0 min. 10 sec. )
PASS: cflow and object creations [of eachcflow]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 143 failed (check: 70), 292 passed (check: 81), 0 skipped.
Executing test 436 (new/twofiles): Doesn't import MightHaveAspect when compiling with more than 1 file. [eachobject]
================================================
Breakdown of abc phases  (total: 8816 millisec.)
------------------------------------------------
[ 00.420% ] Init. of Soot:  37
[ 00.034% ] Loading Jars:  3
[ 76.418% ] Polyglot phases:  6737
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.635% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 05.717% ] Intertype Adjuster:  504
[ 06.590% ] Retrieving bodies:  581
[ 00.011% ] Weave Initializers:  1
[ 00.329% ] Load shadow types:  29
[ 02.280% ] Compute advice lists:  201
[ 00.034% ] Intertype weave:  3
[ 00.624% ] Add aspect code:  55
[ 00.522% ] Weaving advice:  46
[ 00.000% ] Validate jimple:  0
[ 03.358% ] Soot Packs:  296
[ 02.983% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 09:13:13 BST 2004
<<<< TheObject.java >>>>
import org.aspectj.testing.Tester;

public class TheObject {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true, "compiled!");
    }
    
    public TheObject() { super(); }
}
<<<< TheAspect.java >>>>
privilegedaspect aspect TheAspect {
    public static TheAspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public TheAspect() { super(); }
}
retrieve <TheObject: void main(java.lang.String[])> from TheObject
retrieve <TheObject: void <init>()> from TheObject
retrieve <TheAspect: TheAspect aspectOf(java.lang.Object)> from TheAspect
retrieve <TheAspect: boolean hasAspect(java.lang.Object)> from TheAspect
retrieve <TheAspect: void <init>()> from TheAspect
Transforming TheAspect... 
Transforming TheObject... 
Transforming TheAspect$abc$PerTarget... 
Abc finished on Thu Jun 24 09:13:22 BST 2004. ( 0 min. 8 sec. )
PASS: Doesn't import MightHaveAspect when compiling with more than 1 file. [ea...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 143 failed (check: 70), 293 passed (check: 81), 0 skipped.
Executing test 437 (new): test binding to formals in calls to constructors (binding to null) (eachobject !!! now misnamed)
================================================
Breakdown of abc phases  (total: 8495 millisec.)
------------------------------------------------
[ 00.459% ] Init. of Soot:  39
[ 00.035% ] Loading Jars:  3
[ 72.019% ] Polyglot phases:  6118
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.671% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.483% ] Intertype Adjuster:  41
[ 06.733% ] Retrieving bodies:  572
[ 00.000% ] Weave Initializers:  0
[ 00.388% ] Load shadow types:  33
[ 03.920% ] Compute advice lists:  333
[ 00.047% ] Intertype weave:  4
[ 00.424% ] Add aspect code:  36
[ 00.447% ] Weaving advice:  38
[ 00.000% ] Validate jimple:  0
[ 10.618% ] Soot Packs:  902
[ 03.708% ] Soot Writing Output:  315
================================================
Abc started on Thu Jun 24 09:13:24 BST 2004
<<<< BindingThisInsteadOfFormal.java >>>>
import org.aspectj.testing.*;

public class BindingThisInsteadOfFormal {
    public static void main(java.lang.String[] args) {
        Caller c = new Caller();
        c.goo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("before-string");
               org.aspectj.testing.Tester.expectEvent("before-go");
               org.aspectj.testing.Tester.expectEvent("before-static");
               org.aspectj.testing.Tester.expectEvent("before-c");
           }
    
    public BindingThisInsteadOfFormal() { super(); }
}
class Caller {
    void goo() {
        go();
        staticGo();
    }
    
    void go() {
        java.lang.String string = new java.lang.String("string");
        C c = new C();
    }
    
    static void staticGo() {  }
    
    public Caller() { super(); }
}
class C {
    public C() { super(); }
}
aspect Aspect {
    pointcut stringCtors() : call((String).new(String));
    
    before():
    stringCtors() {
        org.aspectj.testing.Tester.event("before-string");
    }
    
    pointcut cCtors() : call((C).new());
    
    before():
    cCtors() {
        org.aspectj.testing.Tester.event("before-c");
    }
    
    pointcut goCalls(Caller caller) :
    call(void (*).go()) &&
      target(caller);
    
    before(Caller caller):
    goCalls(caller) {
        org.aspectj.testing.Tester.event("before-go");
        org.aspectj.testing.Tester.check(caller !=
                                         null,
                                         "instance method");
    }
    
    pointcut goStaticCalls() : call(void (Caller).staticGo());
    
    before():
    goStaticCalls() {
        org.aspectj.testing.Tester.event("before-static");
    }
    
    public static Aspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Aspect() { super(); }
}
retrieve <BindingThisInsteadOfFormal: void main(java.lang.String[])> from BindingThisInsteadOfFormal
retrieve <BindingThisInsteadOfFormal: void <init>()> from BindingThisInsteadOfFormal
retrieve <BindingThisInsteadOfFormal: void <clinit>()> from BindingThisInsteadOfFormal
retrieve <Caller: void <init>()> from Caller
retrieve <Caller: void goo()> from Caller
retrieve <Caller: void go()> from Caller
retrieve <Caller: void staticGo()> from Caller
retrieve <C: void <init>()> from C
retrieve <Aspect: void before$0()> from Aspect
retrieve <Aspect: void before$1()> from Aspect
retrieve <Aspect: void before$2(Caller)> from Aspect
retrieve <Aspect: void before$3()> from Aspect
retrieve <Aspect: Aspect aspectOf(java.lang.Object)> from Aspect
retrieve <Aspect: boolean hasAspect(java.lang.Object)> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming BindingThisInsteadOfFormal... 
Transforming Aspect... 
Transforming C... 
Transforming Caller... 
Transforming Aspect$abc$PerThis... 
Abc finished on Thu Jun 24 09:13:33 BST 2004. ( 0 min. 8 sec. )
PASS: test binding to formals in calls to constructors (binding to null) (each...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 294 passed (check: 81), 0 skipped.
Executing test 438 (new): After advice isn't being woven into after throwing advice
================================================
Breakdown of abc phases  (total: 7963 millisec.)
------------------------------------------------
[ 00.477% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 78.237% ] Polyglot phases:  6230
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.603% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.477% ] Intertype Adjuster:  38
[ 07.723% ] Retrieving bodies:  615
[ 00.126% ] Weave Initializers:  10
[ 00.301% ] Load shadow types:  24
[ 03.190% ] Compute advice lists:  254
[ 00.038% ] Intertype weave:  3
[ 00.126% ] Add aspect code:  10
[ 00.540% ] Weaving advice:  43
[ 00.000% ] Validate jimple:  0
[ 04.634% ] Soot Packs:  369
[ 03.441% ] Soot Writing Output:  274
================================================
Abc started on Thu Jun 24 09:13:36 BST 2004
<<<< AfterThrowingNotWoven.java >>>>
import org.aspectj.testing.*;

public class AfterThrowingNotWoven {
    public static void main(java.lang.String[] args) {
        try {
            new Server().doSomething();
        }
        catch (FaultException fe) {
            org.aspectj.testing.Tester.event("caught-in-main");
        }
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("caught");
               org.aspectj.testing.Tester.expectEvent("caught-in-main");
           }
    
    public AfterThrowingNotWoven() { super(); }
}
class Server {
    public void doSomething() {
        java.lang.System/*java.lang.System*/.out.println("Doing something.");
        throw new FaultException();
    }
    
    public Server() { super(); }
}
class DisabledException extends java.lang.RuntimeException {
    public DisabledException() { super(); }
}
class FaultException extends java.lang.RuntimeException {
    public FaultException() { super(); }
}
aspect FaultHandler {
    private boolean Server.disabled = false;
    
    private void reportFault() {
        java.lang.System/*java.lang.System*/.out.println("Failure! Please fix it.");
    }
    
    public static void fixServer(Server s) {
        s/*null*/.disabled = false;
    }
    
    pointcut service(Server s) :
    target(s) &&
      call(public * (*).*(..));
    
    before(Server s):
    service(s) {
        if (s/*null*/.disabled) throw new DisabledException();
    }
    
    after(Server s) throwing(FaultException e):
    service(s) {
        s/*null*/.disabled = true;
        org.aspectj.testing.Tester.event("caught");
    }
    
    public static FaultHandler aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public FaultHandler() { super(); }
}
retrieve <AfterThrowingNotWoven: void <init>()> from AfterThrowingNotWoven
retrieve <AfterThrowingNotWoven: void <clinit>()> from AfterThrowingNotWoven
retrieve <AfterThrowingNotWoven: void main(java.lang.String[])> from AfterThrowingNotWoven
retrieve <Server: void <init>()> from Server
retrieve <Server: void doSomething()> from Server
retrieve <DisabledException: void <init>()> from DisabledException
retrieve <FaultException: void <init>()> from FaultException
retrieve <FaultHandler: void fixServer(Server)> from FaultHandler
retrieve <FaultHandler: void before$1(Server)> from FaultHandler
retrieve <FaultHandler: void afterThrowing$2(Server,FaultException)> from FaultHandler
retrieve <FaultHandler: FaultHandler aspectOf()> from FaultHandler
retrieve <FaultHandler: boolean hasAspect()> from FaultHandler
retrieve <FaultHandler: void <init>()> from FaultHandler
retrieve <FaultHandler: boolean init$disabled$5(Server)> from FaultHandler
retrieve <FaultHandler: void reportFault()> from FaultHandler
Transforming DisabledException... 
Transforming FaultException... 
Transforming AfterThrowingNotWoven... 
Transforming Server... 
Transforming FaultHandler... 
Abc finished on Thu Jun 24 09:13:44 BST 2004. ( 0 min. 8 sec. )
Doing something.
PASS: After advice isn't being woven into after throwing advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 143 failed (check: 70), 295 passed (check: 81), 0 skipped.
Executing test 439 (new): Throwing an EmptyStackException.
Failed. Current status: 144 failed (check: 70), 295 passed (check: 81), 0 skipped.
Executing test 440 (new/perThis): check that MightHaveAspect interface is created correctly for an aspect in deep package
================================================
Breakdown of abc phases  (total: 9265 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  39
[ 00.032% ] Loading Jars:  3
[ 83.724% ] Polyglot phases:  7757
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.475% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.464% ] Intertype Adjuster:  43
[ 05.515% ] Retrieving bodies:  511
[ 00.000% ] Weave Initializers:  0
[ 00.313% ] Load shadow types:  29
[ 02.051% ] Compute advice lists:  190
[ 00.032% ] Intertype weave:  3
[ 00.518% ] Add aspect code:  48
[ 00.313% ] Weaving advice:  29
[ 00.000% ] Validate jimple:  0
[ 03.346% ] Soot Packs:  310
[ 02.752% ] Soot Writing Output:  255
================================================
Failed. Current status: 145 failed (check: 70), 295 passed (check: 81), 0 skipped.
Executing test 441 (new): Defines clfow$ajc0 more once. [eachcflow]
================================================
Breakdown of abc phases  (total: 7996 millisec.)
------------------------------------------------
[ 00.475% ] Init. of Soot:  38
[ 00.050% ] Loading Jars:  4
[ 72.299% ] Polyglot phases:  5781
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.475% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.775% ] Intertype Adjuster:  62
[ 06.416% ] Retrieving bodies:  513
[ 00.000% ] Weave Initializers:  0
[ 00.375% ] Load shadow types:  30
[ 01.976% ] Compute advice lists:  158
[ 00.038% ] Intertype weave:  3
[ 00.263% ] Add aspect code:  21
[ 01.251% ] Weaving advice:  100
[ 00.000% ] Validate jimple:  0
[ 11.943% ] Soot Packs:  955
[ 03.614% ] Soot Writing Output:  289
================================================
Abc started on Thu Jun 24 09:14:03 BST 2004
<<<< Binkley.java >>>>
import org.aspectj.testing.Tester;

public class Binkley {
    public static void main(java.lang.String[] args) {
        new Binkley().realMain(args);
    }
    
    public void realMain(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true, "compiled!");
    }
    
    public Binkley() { super(); }
}
aspect A {
    pointcut pc() : within(Binkley);
    
    before(): cflow(pc()) && !call((*).new()) && !within(A) {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <Binkley: void <init>()> from Binkley
retrieve <Binkley: void main(java.lang.String[])> from Binkley
retrieve <Binkley: void realMain(java.lang.String[])> from Binkley
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming Binkley... 
Abc finished on Thu Jun 24 09:14:11 BST 2004. ( 0 min. 8 sec. )
PASS: Defines clfow$ajc0 more once. [eachcflow]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 145 failed (check: 70), 296 passed (check: 81), 0 skipped.
Executing test 442 (new): Various calls, receptions, and callsto tests [callsto]
================================================
Breakdown of abc phases  (total: 8562 millisec.)
------------------------------------------------
[ 00.456% ] Init. of Soot:  39
[ 00.035% ] Loading Jars:  3
[ 78.685% ] Polyglot phases:  6737
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.619% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.444% ] Intertype Adjuster:  38
[ 06.797% ] Retrieving bodies:  582
[ 00.000% ] Weave Initializers:  0
[ 00.280% ] Load shadow types:  24
[ 04.380% ] Compute advice lists:  375
[ 00.047% ] Intertype weave:  4
[ 00.397% ] Add aspect code:  34
[ 00.280% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 04.298% ] Soot Packs:  368
[ 03.235% ] Soot Writing Output:  277
================================================
Failed. Current status: 146 failed (check: 70), 296 passed (check: 81), 0 skipped.
Executing test 443 (new): Was throwing exception, now just an error. [eachobject]
================================================
Breakdown of abc phases  (total: 7697 millisec.)
------------------------------------------------
[ 00.494% ] Init. of Soot:  38
[ 00.052% ] Loading Jars:  4
[ 78.056% ] Polyglot phases:  6008
[ 00.039% ] Resolve class names:  3
[ 01.871% ] Declare Parents:  144
[ 00.741% ] Recompute name pattern matches:  57
[ 00.000% ] Compute precedence relation:  0
[ 00.481% ] Intertype Adjuster:  37
[ 06.587% ] Retrieving bodies:  507
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  23
[ 02.027% ] Compute advice lists:  156
[ 00.039% ] Intertype weave:  3
[ 00.650% ] Add aspect code:  50
[ 00.572% ] Weaving advice:  44
[ 00.000% ] Validate jimple:  0
[ 04.391% ] Soot Packs:  338
[ 03.703% ] Soot Writing Output:  285
================================================
Abc started on Thu Jun 24 09:14:25 BST 2004
<<<< PR320.java >>>>
public class PR320 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true,
                                         "OK to compile by 08b1!");
    }
    
    public PR320() { super(); }
}
class Product1 {
    public Product1() { super(); }
}
aspect Product1Aspect {
    pointcut instance(Product1 p) : target(p);
    
    before(Product1 p):
    instance(p) {
        java.lang.System/*java.lang.System*/.out.println("Im am instance of product1");
    }
    
    public static Product1Aspect aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Product1Aspect() { super(); }
}
retrieve <PR320: void <init>()> from PR320
retrieve <PR320: void main(java.lang.String[])> from PR320
retrieve <Product1: void <init>()> from Product1
retrieve <Product1Aspect: void <init>()> from Product1Aspect
retrieve <Product1Aspect: void before$0(Product1)> from Product1Aspect
retrieve <Product1Aspect: Product1Aspect aspectOf(java.lang.Object)> from Product1Aspect
retrieve <Product1Aspect: boolean hasAspect(java.lang.Object)> from Product1Aspect
Transforming Product1... 
Transforming PR320... 
Transforming Product1Aspect... 
Transforming Product1Aspect$abc$PerTarget... 
Abc finished on Thu Jun 24 09:14:33 BST 2004. ( 0 min. 7 sec. )
PASS: Was throwing exception, now just an error. [eachobject]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 146 failed (check: 70), 297 passed (check: 81), 0 skipped.
Executing test 444 (new): different version of aspect inheritance, particularly empty pointcuts and abstract cflows [eachcflow]
Failed. Current status: 147 failed (check: 70), 297 passed (check: 81), 0 skipped.
Executing test 445 (new): set advice on member initing throwing exception [eachobject]
================================================
Breakdown of abc phases  (total: 7630 millisec.)
------------------------------------------------
[ 00.511% ] Init. of Soot:  39
[ 00.052% ] Loading Jars:  4
[ 74.718% ] Polyglot phases:  5701
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.786% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 00.498% ] Intertype Adjuster:  38
[ 06.448% ] Retrieving bodies:  492
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  22
[ 01.953% ] Compute advice lists:  149
[ 00.039% ] Intertype weave:  3
[ 00.537% ] Add aspect code:  41
[ 06.671% ] Weaving advice:  509
[ 00.000% ] Validate jimple:  0
[ 04.168% ] Soot Packs:  318
[ 03.277% ] Soot Writing Output:  250
================================================
Abc started on Thu Jun 24 09:14:43 BST 2004
<<<< PR339.java >>>>
public class PR339 {
    public static void main(java.lang.String[] args) {
        new MemberInitSet().foo();
        org.aspectj.testing.Tester.check(true, "compiled");
    }
    
    public PR339() { super(); }
}
class MemberInitSet {
    java.lang.String s = "S";
    
    { this/*null*/.s = "s"; }
    
    void foo() { this/*null*/.s = "asdf"; }
    
    public MemberInitSet() { super(); }
}
aspect Setter {
    pointcut allSets() : set( String (MemberInitSet).s);
    
    public static Setter aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Setter() { super(); }
}
retrieve <PR339: void <init>()> from PR339
retrieve <PR339: void main(java.lang.String[])> from PR339
retrieve <MemberInitSet: void foo()> from MemberInitSet
retrieve <MemberInitSet: void <init>()> from MemberInitSet
retrieve <Setter: Setter aspectOf(java.lang.Object)> from Setter
retrieve <Setter: boolean hasAspect(java.lang.Object)> from Setter
retrieve <Setter: void <init>()> from Setter
Transforming Setter... 
Transforming PR339... 
Transforming MemberInitSet... 
Transforming Setter$abc$PerTarget... 
Abc finished on Thu Jun 24 09:14:51 BST 2004. ( 0 min. 7 sec. )
PASS: set advice on member initing throwing exception [eachobject]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 147 failed (check: 70), 298 passed (check: 81), 0 skipped.
Executing test 446 (new): Testing class names with same name's with difference case as package. [eachobject]
================================================
Breakdown of abc phases  (total: 8665 millisec.)
------------------------------------------------
[ 00.519% ] Init. of Soot:  45
[ 00.046% ] Loading Jars:  4
[ 71.495% ] Polyglot phases:  6195
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.404% ] Recompute name pattern matches:  35
[ 00.000% ] Compute precedence relation:  0
[ 00.669% ] Intertype Adjuster:  58
[ 05.713% ] Retrieving bodies:  495
[ 00.000% ] Weave Initializers:  0
[ 00.254% ] Load shadow types:  22
[ 02.516% ] Compute advice lists:  218
[ 00.058% ] Intertype weave:  5
[ 00.565% ] Add aspect code:  49
[ 00.473% ] Weaving advice:  41
[ 00.012% ] Validate jimple:  1
[ 07.640% ] Soot Packs:  662
[ 09.590% ] Soot Writing Output:  831
================================================
Abc started on Thu Jun 24 09:14:53 BST 2004
<<<< TraceAspect.java >>>>
package test;

import org.aspectj.testing.*;

aspect Trace {
    pointcut runs() : call(void (*).run());
    
    before(): runs() { org.aspectj.testing.Tester.event("before"); }
    
    after(): runs() { org.aspectj.testing.Tester.event("after"); }
    
    public static test.Trace aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public Trace() { super(); }
}
<<<< Test.java >>>>
package test;

import org.aspectj.testing.*;

public class Test {
    public static void main(java.lang.String[] args) {
        new test.Test().run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void run() { org.aspectj.testing.Tester.event("run"); }
    
    static {
               org.aspectj.testing.Tester.expectEventsInString("before,after,run");
           }
    
    public Test() { super(); }
}
retrieve <test.Trace: void before$0()> from test.Trace
retrieve <test.Trace: void after$1()> from test.Trace
retrieve <test.Trace: test.Trace aspectOf(java.lang.Object)> from test.Trace
retrieve <test.Trace: boolean hasAspect(java.lang.Object)> from test.Trace
retrieve <test.Trace: void <init>()> from test.Trace
retrieve <test.Test: void <clinit>()> from test.Test
retrieve <test.Test: void <init>()> from test.Test
retrieve <test.Test: void run()> from test.Test
retrieve <test.Test: void main(java.lang.String[])> from test.Test
Transforming test.Trace... 
Transforming test.Test... 
Transforming test.Trace$abc$PerTarget... 
Abc finished on Thu Jun 24 09:15:02 BST 2004. ( 0 min. 8 sec. )
PASS: Testing class names with same name's with difference case as package. [e...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 147 failed (check: 70), 299 passed (check: 81), 0 skipped.
Executing test 447 (new): Null pointer on gets advice with coverage [painful]
================================================
Breakdown of abc phases  (total: 33649 millisec.)
------------------------------------------------
[ 00.110% ] Init. of Soot:  37
[ 00.009% ] Loading Jars:  3
[ 25.929% ] Polyglot phases:  8725
[ 00.006% ] Resolve class names:  2
[ 00.006% ] Declare Parents:  2
[ 00.279% ] Recompute name pattern matches:  94
[ 00.000% ] Compute precedence relation:  0
[ 00.131% ] Intertype Adjuster:  44
[ 13.977% ] Retrieving bodies:  4703
[ 00.000% ] Weave Initializers:  0
[ 00.065% ] Load shadow types:  22
[ 22.815% ] Compute advice lists:  7677
[ 00.009% ] Intertype weave:  3
[ 00.134% ] Add aspect code:  45
[ 19.760% ] Weaving advice:  6649
[ 00.000% ] Validate jimple:  0
[ 09.810% ] Soot Packs:  3301
[ 06.960% ] Soot Writing Output:  2342
================================================
Abc started on Thu Jun 24 09:15:05 BST 2004
<<<< NullPointerOnGets.java >>>>
import org.aspectj.testing.*;

public class NullPointerOnGets {
    public static void main(java.lang.String[] args) {
        Strings.add();
        C.go();
        Ints.add();
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    static { org.aspectj.testing.Tester.expectEvent("static"); }
    
    public NullPointerOnGets() { super(); }
}
class C {
    public java.lang.String str0 = "str0";
    
    java.lang.String str1 = "str1";
    
    protected java.lang.String str2 = "str2";
    
    private java.lang.String str3 = "str3";
    
    public static java.lang.String sstr0 = "sstr0";
    
    static java.lang.String sstr1 = "sstr1";
    
    protected static java.lang.String sstr2 = "sstr2";
    
    private static java.lang.String sstr3 = "sstr3";
    
    public int int0 = 1;
    
    int int1 = 2;
    
    protected int int2 = 3;
    
    private int int3 = 4;
    
    public static int sint0 = -1;
    
    static int sint1 = -2;
    
    protected static int sint2 = -3;
    
    private static int sint3 = -4;
    
    static void go() {
        org.aspectj.testing.Tester.event("static");
        C c = new C();
        eq(c/*null*/.str0, "str0");
        c/*null*/.str0 = "str00";
        eq(c/*null*/.str0, "str00");
        eq(c/*null*/.str1, "str1");
        c/*null*/.str1 = "str11";
        eq(c/*null*/.str1, "str11");
        eq(c/*null*/.str2, "str2");
        c/*null*/.str2 = "str22";
        eq(c/*null*/.str2, "str22");
        eq(c/*null*/.str3, "str3");
        c/*null*/.str3 = "str33";
        eq(c/*null*/.str3, "str33");
        eq(C/*C*/.sstr0, "sstr0");
        C/*C*/.sstr0 = "sstr00";
        eq(C/*C*/.sstr0, "sstr00");
        eq(C/*C*/.sstr1, "sstr1");
        C/*C*/.sstr1 = "sstr11";
        eq(C/*C*/.sstr1, "sstr11");
        eq(C/*C*/.sstr2, "sstr2");
        C/*C*/.sstr2 = "sstr22";
        eq(C/*C*/.sstr2, "sstr22");
        eq(C/*C*/.sstr3, "sstr3");
        C/*C*/.sstr3 = "sstr33";
        eq(C/*C*/.sstr3, "sstr33");
        eq(c/*null*/.int0, 1);
        c/*null*/.int0 = 100;
        eq(c/*null*/.int0, 100);
        eq(c/*null*/.int1, 2);
        c/*null*/.int1 = 111;
        eq(c/*null*/.int1, 111);
        eq(c/*null*/.int2, 3);
        c/*null*/.int2 = 122;
        eq(c/*null*/.int2, 122);
        eq(c/*null*/.int3, 4);
        c/*null*/.int3 = 133;
        eq(c/*null*/.int3, 133);
        eq(C/*C*/.sint0, -1);
        C/*C*/.sint0 = 200;
        eq(C/*C*/.sint0, 200);
        eq(C/*C*/.sint1, -2);
        C/*C*/.sint1 = 211;
        eq(C/*C*/.sint1, 211);
        eq(C/*C*/.sint2, -3);
        C/*C*/.sint2 = 222;
        eq(C/*C*/.sint2, 222);
        eq(C/*C*/.sint3, -4);
        C/*C*/.sint3 = 233;
        eq(C/*C*/.sint3, 233);
    }
    
    private static void eq(int i0, int i1) {
        org.aspectj.testing.Tester.checkEqual(i0, i1);
    }
    
    private static void eq(java.lang.String s0, java.lang.String s1) {
        org.aspectj.testing.Tester.checkEqual(s0, s1);
    }
    
    public C() { super(); }
}
aspect StringAspect {
    static void a(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    pointcut gets_String_str0() : get( String (C).str0);
    
    pointcut gets_String_str1() : get( String (C).str1);
    
    pointcut gets_String_str2() : get( String (C).str2);
    
    pointcut gets_String_str3() : get( String (C).str3);
    
    pointcut gets_String_str0b() : get( String (C).str0);
    
    pointcut gets_String_str1b() : get( String (C).str1);
    
    pointcut gets_String_str2b() : get( String (C).str2);
    
    pointcut gets_String_str3b() : get( String (C).str3);
    
    pointcut sets_String_str0() : set( String (C).str0);
    
    pointcut sets_String_str1() : set( String (C).str1);
    
    pointcut sets_String_str2() : set( String (C).str2);
    
    pointcut sets_String_str3() : set( String (C).str3);
    
    pointcut sets_String_str0b() : set( String (C).str0);
    
    pointcut sets_String_str1b() : set( String (C).str1);
    
    pointcut sets_String_str2b() : set( String (C).str2);
    
    pointcut sets_String_str3b() : set( String (C).str3);
    
    pointcut sets_String_str0c() : set( String (C).str0);
    
    pointcut sets_String_str1c() : set( String (C).str1);
    
    pointcut sets_String_str2c() : set( String (C).str2);
    
    pointcut sets_String_str3c() : set( String (C).str3);
    
    pointcut gets_String_sstr0() : get( String (C).str0);
    
    pointcut gets_String_sstr1() : get( String (C).str1);
    
    pointcut gets_String_sstr2() : get( String (C).str2);
    
    pointcut gets_String_sstr3() : get( String (C).str3);
    
    pointcut gets_String_sstr0b() : get( String (C).str0);
    
    pointcut gets_String_sstr1b() : get( String (C).str1);
    
    pointcut gets_String_sstr2b() : get( String (C).str2);
    
    pointcut gets_String_sstr3b() : get( String (C).str3);
    
    pointcut sets_String_sstr0() : set( String (C).str0);
    
    pointcut sets_String_sstr1() : set( String (C).str1);
    
    pointcut sets_String_sstr2() : set( String (C).str2);
    
    pointcut sets_String_sstr3() : set( String (C).str3);
    
    pointcut sets_String_sstr0b() : set( String (C).str0);
    
    pointcut sets_String_sstr1b() : set( String (C).str1);
    
    pointcut sets_String_sstr2b() : set( String (C).str2);
    
    pointcut sets_String_sstr3b() : set( String (C).str3);
    
    pointcut sets_String_sstr0c() : set( String (C).str0);
    
    pointcut sets_String_sstr1c() : set( String (C).str1);
    
    pointcut sets_String_sstr2c() : set( String (C).str2);
    
    pointcut sets_String_sstr3c() : set( String (C).str3);
    
    before(): gets_String_str0() { a("b gets_String_str0"); }
    
    before(): gets_String_str1() { a("b gets_String_str1"); }
    
    before(): gets_String_str2() { a("b gets_String_str2"); }
    
    before(): gets_String_str3() { a("b gets_String_str3"); }
    
    before(): gets_String_str0b() { a("b gets_String_str0b"); }
    
    before(): gets_String_str1b() { a("b gets_String_str1b"); }
    
    before(): gets_String_str2b() { a("b gets_String_str2b"); }
    
    before(): gets_String_str3b() { a("b gets_String_str3b"); }
    
    before(): sets_String_str0() { a("b sets_String_str0"); }
    
    before(): sets_String_str1() { a("b sets_String_str1"); }
    
    before(): sets_String_str2() { a("b sets_String_str2"); }
    
    before(): sets_String_str3() { a("b sets_String_str3"); }
    
    before(): sets_String_str0b() { a("b sets_String_str0b"); }
    
    before(): sets_String_str1b() { a("b sets_String_str1b"); }
    
    before(): sets_String_str2b() { a("b sets_String_str2b"); }
    
    before(): sets_String_str3b() { a("b sets_String_str3b"); }
    
    before(): sets_String_str0c() { a("b sets_String_str0c"); }
    
    before(): sets_String_str1c() { a("b sets_String_str1c"); }
    
    before(): sets_String_str2c() { a("b sets_String_str2c"); }
    
    before(): sets_String_str3c() { a("b sets_String_str3c"); }
    
    before(): gets_String_sstr0() { a("b gets_String_sstr0"); }
    
    before(): gets_String_sstr1() { a("b gets_String_sstr1"); }
    
    before(): gets_String_sstr2() { a("b gets_String_sstr2"); }
    
    before(): gets_String_sstr3() { a("b gets_String_sstr3"); }
    
    before(): gets_String_sstr0b() { a("b gets_String_sstr0b"); }
    
    before(): gets_String_sstr1b() { a("b gets_String_sstr1b"); }
    
    before(): gets_String_sstr2b() { a("b gets_String_sstr2b"); }
    
    before(): gets_String_sstr3b() { a("b gets_String_sstr3b"); }
    
    before(): sets_String_sstr0() { a("b sets_String_sstr0"); }
    
    before(): sets_String_sstr1() { a("b sets_String_sstr1"); }
    
    before(): sets_String_sstr2() { a("b sets_String_sstr2"); }
    
    before(): sets_String_sstr3() { a("b sets_String_sstr3"); }
    
    before(): sets_String_sstr0b() { a("b sets_String_sstr0b"); }
    
    before(): sets_String_sstr1b() { a("b sets_String_sstr1b"); }
    
    before(): sets_String_sstr2b() { a("b sets_String_sstr2b"); }
    
    before(): sets_String_sstr3b() { a("b sets_String_sstr3b"); }
    
    before(): sets_String_sstr0c() { a("b sets_String_sstr0c"); }
    
    before(): sets_String_sstr1c() { a("b sets_String_sstr1c"); }
    
    before(): sets_String_sstr2c() { a("b sets_String_sstr2c"); }
    
    before(): sets_String_sstr3c() { a("b sets_String_sstr3c"); }
    
    Object around ():
    gets_String_str0() {
        a("a gets_String_str0");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str1() {
        a("a gets_String_str1");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str2() {
        a("a gets_String_str2");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str3() {
        a("a gets_String_str3");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str0b() {
        a("a gets_String_str0b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str1b() {
        a("a gets_String_str1b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str2b() {
        a("a gets_String_str2b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_str3b() {
        a("a gets_String_str3b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str0() {
        a("a sets_String_str0");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str1() {
        a("a sets_String_str1");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str2() {
        a("a sets_String_str2");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str3() {
        a("a sets_String_str3");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str0b() {
        a("a sets_String_str0b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str1b() {
        a("a sets_String_str1b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str2b() {
        a("a sets_String_str2b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str3b() {
        a("a sets_String_str3b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str0c() {
        a("a sets_String_str0c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str1c() {
        a("a sets_String_str1c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str2c() {
        a("a sets_String_str2c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_str3c() {
        a("a sets_String_str3c");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr0() {
        a("a gets_String_sstr0");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr1() {
        a("a gets_String_sstr1");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr2() {
        a("a gets_String_sstr2");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr3() {
        a("a gets_String_sstr3");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr0b() {
        a("a gets_String_sstr0b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr1b() {
        a("a gets_String_sstr1b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr2b() {
        a("a gets_String_sstr2b");
        return this.proceed();
    }
    
    Object around ():
    gets_String_sstr3b() {
        a("a gets_String_sstr3b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr0() {
        a("a sets_String_sstr0");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr1() {
        a("a sets_String_sstr1");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr2() {
        a("a sets_String_sstr2");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr3() {
        a("a sets_String_sstr3");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr0b() {
        a("a sets_String_sstr0b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr1b() {
        a("a sets_String_sstr1b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr2b() {
        a("a sets_String_sstr2b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr3b() {
        a("a sets_String_sstr3b");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr0c() {
        a("a sets_String_sstr0c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr1c() {
        a("a sets_String_sstr1c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr2c() {
        a("a sets_String_sstr2c");
        return this.proceed();
    }
    
    Object around ():
    sets_String_sstr3c() {
        a("a sets_String_sstr3c");
        return this.proceed();
    }
    
    after(): gets_String_str0() { a("f gets_String_str0"); }
    
    after(): gets_String_str1() { a("f gets_String_str1"); }
    
    after(): gets_String_str2() { a("f gets_String_str2"); }
    
    after(): gets_String_str3() { a("f gets_String_str3"); }
    
    after(): gets_String_str0b() { a("f gets_String_str0b"); }
    
    after(): gets_String_str1b() { a("f gets_String_str1b"); }
    
    after(): gets_String_str2b() { a("f gets_String_str2b"); }
    
    after(): gets_String_str3b() { a("f gets_String_str3b"); }
    
    after(): sets_String_str0() { a("f sets_String_str0"); }
    
    after(): sets_String_str1() { a("f sets_String_str1"); }
    
    after(): sets_String_str2() { a("f sets_String_str2"); }
    
    after(): sets_String_str3() { a("f sets_String_str3"); }
    
    after(): sets_String_str0b() { a("f sets_String_str0b"); }
    
    after(): sets_String_str1b() { a("f sets_String_str1b"); }
    
    after(): sets_String_str2b() { a("f sets_String_str2b"); }
    
    after(): sets_String_str3b() { a("f sets_String_str3b"); }
    
    after(): sets_String_str0c() { a("f sets_String_str0c"); }
    
    after(): sets_String_str1c() { a("f sets_String_str1c"); }
    
    after(): sets_String_str2c() { a("f sets_String_str2c"); }
    
    after(): sets_String_str3c() { a("f sets_String_str3c"); }
    
    after(): gets_String_sstr0() { a("f gets_String_sstr0"); }
    
    after(): gets_String_sstr1() { a("f gets_String_sstr1"); }
    
    after(): gets_String_sstr2() { a("f gets_String_sstr2"); }
    
    after(): gets_String_sstr3() { a("f gets_String_sstr3"); }
    
    after(): gets_String_sstr0b() { a("f gets_String_sstr0b"); }
    
    after(): gets_String_sstr1b() { a("f gets_String_sstr1b"); }
    
    after(): gets_String_sstr2b() { a("f gets_String_sstr2b"); }
    
    after(): gets_String_sstr3b() { a("f gets_String_sstr3b"); }
    
    after(): sets_String_sstr0() { a("f sets_String_sstr0"); }
    
    after(): sets_String_sstr1() { a("f sets_String_sstr1"); }
    
    after(): sets_String_sstr2() { a("f sets_String_sstr2"); }
    
    after(): sets_String_sstr3() { a("f sets_String_sstr3"); }
    
    after(): sets_String_sstr0b() { a("f sets_String_sstr0b"); }
    
    after(): sets_String_sstr1b() { a("f sets_String_sstr1b"); }
    
    after(): sets_String_sstr2b() { a("f sets_String_sstr2b"); }
    
    after(): sets_String_sstr3b() { a("f sets_String_sstr3b"); }
    
    after(): sets_String_sstr0c() { a("f sets_String_sstr0c"); }
    
    after(): sets_String_sstr1c() { a("f sets_String_sstr1c"); }
    
    after(): sets_String_sstr2c() { a("f sets_String_sstr2c"); }
    
    after(): sets_String_sstr3c() { a("f sets_String_sstr3c"); }
    
    public static StringAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public StringAspect() { super(); }
}
class Strings {
    static void m(java.lang.String s) {
        org.aspectj.testing.Tester.expectEvent(s);
    }
    
    static void add() {
        m("b gets_String_str0");
        m("f gets_String_str0");
        m("a gets_String_str0");
        m("b gets_String_str1");
        m("f gets_String_str1");
        m("a gets_String_str1");
        m("b gets_String_str2");
        m("f gets_String_str2");
        m("a gets_String_str2");
        m("b gets_String_str3");
        m("f gets_String_str3");
        m("a gets_String_str3");
        m("b gets_String_str0b");
        m("f gets_String_str0b");
        m("a gets_String_str0b");
        m("b gets_String_str1b");
        m("f gets_String_str1b");
        m("a gets_String_str1b");
        m("b gets_String_str2b");
        m("f gets_String_str2b");
        m("a gets_String_str2b");
        m("b gets_String_str3b");
        m("f gets_String_str3b");
        m("a gets_String_str3b");
        m("b sets_String_str0");
        m("f sets_String_str0");
        m("a sets_String_str0");
        m("b sets_String_str1");
        m("f sets_String_str1");
        m("a sets_String_str1");
        m("b sets_String_str2");
        m("f sets_String_str2");
        m("a sets_String_str2");
        m("b sets_String_str3");
        m("f sets_String_str3");
        m("a sets_String_str3");
        m("b sets_String_str0b");
        m("f sets_String_str0b");
        m("a sets_String_str0b");
        m("b sets_String_str1b");
        m("f sets_String_str1b");
        m("a sets_String_str1b");
        m("b sets_String_str2b");
        m("f sets_String_str2b");
        m("a sets_String_str2b");
        m("b sets_String_str3b");
        m("f sets_String_str3b");
        m("a sets_String_str3b");
        m("b sets_String_str0c");
        m("f sets_String_str0c");
        m("a sets_String_str0c");
        m("b sets_String_str1c");
        m("f sets_String_str1c");
        m("a sets_String_str1c");
        m("b sets_String_str2c");
        m("f sets_String_str2c");
        m("a sets_String_str2c");
        m("b sets_String_str3c");
        m("f sets_String_str3c");
        m("a sets_String_str3c");
        m("b gets_String_sstr0");
        m("f gets_String_sstr0");
        m("a gets_String_sstr0");
        m("b gets_String_sstr1");
        m("f gets_String_sstr1");
        m("a gets_String_sstr1");
        m("b gets_String_sstr2");
        m("f gets_String_sstr2");
        m("a gets_String_sstr2");
        m("b gets_String_sstr3");
        m("f gets_String_sstr3");
        m("a gets_String_sstr3");
        m("b gets_String_sstr0b");
        m("f gets_String_sstr0b");
        m("a gets_String_sstr0b");
        m("b gets_String_sstr1b");
        m("f gets_String_sstr1b");
        m("a gets_String_sstr1b");
        m("b gets_String_sstr2b");
        m("f gets_String_sstr2b");
        m("a gets_String_sstr2b");
        m("b gets_String_sstr3b");
        m("f gets_String_sstr3b");
        m("a gets_String_sstr3b");
        m("b sets_String_sstr0");
        m("f sets_String_sstr0");
        m("a sets_String_sstr0");
        m("b sets_String_sstr1");
        m("f sets_String_sstr1");
        m("a sets_String_sstr1");
        m("b sets_String_sstr2");
        m("f sets_String_sstr2");
        m("a sets_String_sstr2");
        m("b sets_String_sstr3");
        m("f sets_String_sstr3");
        m("a sets_String_sstr3");
        m("b sets_String_sstr0b");
        m("f sets_String_sstr0b");
        m("a sets_String_sstr0b");
        m("b sets_String_sstr1b");
        m("f sets_String_sstr1b");
        m("a sets_String_sstr1b");
        m("b sets_String_sstr2b");
        m("f sets_String_sstr2b");
        m("a sets_String_sstr2b");
        m("b sets_String_sstr3b");
        m("f sets_String_sstr3b");
        m("a sets_String_sstr3b");
        m("b sets_String_sstr0c");
        m("f sets_String_sstr0c");
        m("a sets_String_sstr0c");
        m("b sets_String_sstr1c");
        m("f sets_String_sstr1c");
        m("a sets_String_sstr1c");
        m("b sets_String_sstr2c");
        m("f sets_String_sstr2c");
        m("a sets_String_sstr2c");
        m("b sets_String_sstr3c");
        m("f sets_String_sstr3c");
        m("a sets_String_sstr3c");
    }
    
    public Strings() { super(); }
}
aspect IntAspect {
    static void a(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    pointcut gets_int_int0() : get( int (C).int0);
    
    pointcut gets_int_int1() : get( int (C).int1);
    
    pointcut gets_int_int2() : get( int (C).int2);
    
    pointcut gets_int_int3() : get( int (C).int3);
    
    pointcut gets_int_int0b() : get( int (C).int0);
    
    pointcut gets_int_int1b() : get( int (C).int1);
    
    pointcut gets_int_int2b() : get( int (C).int2);
    
    pointcut gets_int_int3b() : get( int (C).int3);
    
    pointcut sets_int_int0() : set( int (C).int0);
    
    pointcut sets_int_int1() : set( int (C).int1);
    
    pointcut sets_int_int2() : set( int (C).int2);
    
    pointcut sets_int_int3() : set( int (C).int3);
    
    pointcut sets_int_int0b() : set( int (C).int0);
    
    pointcut sets_int_int1b() : set( int (C).int1);
    
    pointcut sets_int_int2b() : set( int (C).int2);
    
    pointcut sets_int_int3b() : set( int (C).int3);
    
    pointcut sets_int_int0c() : set( int (C).int0);
    
    pointcut sets_int_int1c() : set( int (C).int1);
    
    pointcut sets_int_int2c() : set( int (C).int2);
    
    pointcut sets_int_int3c() : set( int (C).int3);
    
    pointcut gets_int_sint0() : get( int (C).int0);
    
    pointcut gets_int_sint1() : get( int (C).int1);
    
    pointcut gets_int_sint2() : get( int (C).int2);
    
    pointcut gets_int_sint3() : get( int (C).int3);
    
    pointcut gets_int_sint0b() : get( int (C).int0);
    
    pointcut gets_int_sint1b() : get( int (C).int1);
    
    pointcut gets_int_sint2b() : get( int (C).int2);
    
    pointcut gets_int_sint3b() : get( int (C).int3);
    
    pointcut sets_int_sint0() : set( int (C).int0);
    
    pointcut sets_int_sint1() : set( int (C).int1);
    
    pointcut sets_int_sint2() : set( int (C).int2);
    
    pointcut sets_int_sint3() : set( int (C).int3);
    
    pointcut sets_int_sint0b() : set( int (C).int0);
    
    pointcut sets_int_sint1b() : set( int (C).int1);
    
    pointcut sets_int_sint2b() : set( int (C).int2);
    
    pointcut sets_int_sint3b() : set( int (C).int3);
    
    pointcut sets_int_sint0c() : set( int (C).int0);
    
    pointcut sets_int_sint1c() : set( int (C).int1);
    
    pointcut sets_int_sint2c() : set( int (C).int2);
    
    pointcut sets_int_sint3c() : set( int (C).int3);
    
    before(): gets_int_int0() { a("b gets_int_int0"); }
    
    before(): gets_int_int1() { a("b gets_int_int1"); }
    
    before(): gets_int_int2() { a("b gets_int_int2"); }
    
    before(): gets_int_int3() { a("b gets_int_int3"); }
    
    before(): gets_int_int0b() { a("b gets_int_int0b"); }
    
    before(): gets_int_int1b() { a("b gets_int_int1b"); }
    
    before(): gets_int_int2b() { a("b gets_int_int2b"); }
    
    before(): gets_int_int3b() { a("b gets_int_int3b"); }
    
    before(): sets_int_int0() { a("b sets_int_int0"); }
    
    before(): sets_int_int1() { a("b sets_int_int1"); }
    
    before(): sets_int_int2() { a("b sets_int_int2"); }
    
    before(): sets_int_int3() { a("b sets_int_int3"); }
    
    before(): sets_int_int0b() { a("b sets_int_int0b"); }
    
    before(): sets_int_int1b() { a("b sets_int_int1b"); }
    
    before(): sets_int_int2b() { a("b sets_int_int2b"); }
    
    before(): sets_int_int3b() { a("b sets_int_int3b"); }
    
    before(): sets_int_int0c() { a("b sets_int_int0c"); }
    
    before(): sets_int_int1c() { a("b sets_int_int1c"); }
    
    before(): sets_int_int2c() { a("b sets_int_int2c"); }
    
    before(): sets_int_int3c() { a("b sets_int_int3c"); }
    
    before(): gets_int_sint0() { a("b gets_int_sint0"); }
    
    before(): gets_int_sint1() { a("b gets_int_sint1"); }
    
    before(): gets_int_sint2() { a("b gets_int_sint2"); }
    
    before(): gets_int_sint3() { a("b gets_int_sint3"); }
    
    before(): gets_int_sint0b() { a("b gets_int_sint0b"); }
    
    before(): gets_int_sint1b() { a("b gets_int_sint1b"); }
    
    before(): gets_int_sint2b() { a("b gets_int_sint2b"); }
    
    before(): gets_int_sint3b() { a("b gets_int_sint3b"); }
    
    before(): sets_int_sint0() { a("b sets_int_sint0"); }
    
    before(): sets_int_sint1() { a("b sets_int_sint1"); }
    
    before(): sets_int_sint2() { a("b sets_int_sint2"); }
    
    before(): sets_int_sint3() { a("b sets_int_sint3"); }
    
    before(): sets_int_sint0b() { a("b sets_int_sint0b"); }
    
    before(): sets_int_sint1b() { a("b sets_int_sint1b"); }
    
    before(): sets_int_sint2b() { a("b sets_int_sint2b"); }
    
    before(): sets_int_sint3b() { a("b sets_int_sint3b"); }
    
    before(): sets_int_sint0c() { a("b sets_int_sint0c"); }
    
    before(): sets_int_sint1c() { a("b sets_int_sint1c"); }
    
    before(): sets_int_sint2c() { a("b sets_int_sint2c"); }
    
    before(): sets_int_sint3c() { a("b sets_int_sint3c"); }
    
    Object around ():
    gets_int_int0() {
        a("a gets_int_int0");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int1() {
        a("a gets_int_int1");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int2() {
        a("a gets_int_int2");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int3() {
        a("a gets_int_int3");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int0b() {
        a("a gets_int_int0b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int1b() {
        a("a gets_int_int1b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int2b() {
        a("a gets_int_int2b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_int3b() {
        a("a gets_int_int3b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int0() {
        a("a sets_int_int0");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int1() {
        a("a sets_int_int1");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int2() {
        a("a sets_int_int2");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int3() {
        a("a sets_int_int3");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int0b() {
        a("a sets_int_int0b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int1b() {
        a("a sets_int_int1b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int2b() {
        a("a sets_int_int2b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int3b() {
        a("a sets_int_int3b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int0c() {
        a("a sets_int_int0c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int1c() {
        a("a sets_int_int1c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int2c() {
        a("a sets_int_int2c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_int3c() {
        a("a sets_int_int3c");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint0() {
        a("a gets_int_sint0");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint1() {
        a("a gets_int_sint1");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint2() {
        a("a gets_int_sint2");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint3() {
        a("a gets_int_sint3");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint0b() {
        a("a gets_int_sint0b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint1b() {
        a("a gets_int_sint1b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint2b() {
        a("a gets_int_sint2b");
        return this.proceed();
    }
    
    Object around ():
    gets_int_sint3b() {
        a("a gets_int_sint3b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint0() {
        a("a sets_int_sint0");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint1() {
        a("a sets_int_sint1");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint2() {
        a("a sets_int_sint2");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint3() {
        a("a sets_int_sint3");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint0b() {
        a("a sets_int_sint0b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint1b() {
        a("a sets_int_sint1b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint2b() {
        a("a sets_int_sint2b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint3b() {
        a("a sets_int_sint3b");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint0c() {
        a("a sets_int_sint0c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint1c() {
        a("a sets_int_sint1c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint2c() {
        a("a sets_int_sint2c");
        return this.proceed();
    }
    
    Object around ():
    sets_int_sint3c() {
        a("a sets_int_sint3c");
        return this.proceed();
    }
    
    after(): gets_int_int0() { a("f gets_int_int0"); }
    
    after(): gets_int_int1() { a("f gets_int_int1"); }
    
    after(): gets_int_int2() { a("f gets_int_int2"); }
    
    after(): gets_int_int3() { a("f gets_int_int3"); }
    
    after(): gets_int_int0b() { a("f gets_int_int0b"); }
    
    after(): gets_int_int1b() { a("f gets_int_int1b"); }
    
    after(): gets_int_int2b() { a("f gets_int_int2b"); }
    
    after(): gets_int_int3b() { a("f gets_int_int3b"); }
    
    after(): sets_int_int0() { a("f sets_int_int0"); }
    
    after(): sets_int_int1() { a("f sets_int_int1"); }
    
    after(): sets_int_int2() { a("f sets_int_int2"); }
    
    after(): sets_int_int3() { a("f sets_int_int3"); }
    
    after(): sets_int_int0b() { a("f sets_int_int0b"); }
    
    after(): sets_int_int1b() { a("f sets_int_int1b"); }
    
    after(): sets_int_int2b() { a("f sets_int_int2b"); }
    
    after(): sets_int_int3b() { a("f sets_int_int3b"); }
    
    after(): sets_int_int0c() { a("f sets_int_int0c"); }
    
    after(): sets_int_int1c() { a("f sets_int_int1c"); }
    
    after(): sets_int_int2c() { a("f sets_int_int2c"); }
    
    after(): sets_int_int3c() { a("f sets_int_int3c"); }
    
    after(): gets_int_sint0() { a("f gets_int_sint0"); }
    
    after(): gets_int_sint1() { a("f gets_int_sint1"); }
    
    after(): gets_int_sint2() { a("f gets_int_sint2"); }
    
    after(): gets_int_sint3() { a("f gets_int_sint3"); }
    
    after(): gets_int_sint0b() { a("f gets_int_sint0b"); }
    
    after(): gets_int_sint1b() { a("f gets_int_sint1b"); }
    
    after(): gets_int_sint2b() { a("f gets_int_sint2b"); }
    
    after(): gets_int_sint3b() { a("f gets_int_sint3b"); }
    
    after(): sets_int_sint0() { a("f sets_int_sint0"); }
    
    after(): sets_int_sint1() { a("f sets_int_sint1"); }
    
    after(): sets_int_sint2() { a("f sets_int_sint2"); }
    
    after(): sets_int_sint3() { a("f sets_int_sint3"); }
    
    after(): sets_int_sint0b() { a("f sets_int_sint0b"); }
    
    after(): sets_int_sint1b() { a("f sets_int_sint1b"); }
    
    after(): sets_int_sint2b() { a("f sets_int_sint2b"); }
    
    after(): sets_int_sint3b() { a("f sets_int_sint3b"); }
    
    after(): sets_int_sint0c() { a("f sets_int_sint0c"); }
    
    after(): sets_int_sint1c() { a("f sets_int_sint1c"); }
    
    after(): sets_int_sint2c() { a("f sets_int_sint2c"); }
    
    after(): sets_int_sint3c() { a("f sets_int_sint3c"); }
    
    public static IntAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public IntAspect() { super(); }
}
class Ints {
    static void m(java.lang.String s) {
        org.aspectj.testing.Tester.expectEvent(s);
    }
    
    static void add() {
        m("b gets_int_int0");
        m("f gets_int_int0");
        m("a gets_int_int0");
        m("b gets_int_int1");
        m("f gets_int_int1");
        m("a gets_int_int1");
        m("b gets_int_int2");
        m("f gets_int_int2");
        m("a gets_int_int2");
        m("b gets_int_int3");
        m("f gets_int_int3");
        m("a gets_int_int3");
        m("b gets_int_int0b");
        m("f gets_int_int0b");
        m("a gets_int_int0b");
        m("b gets_int_int1b");
        m("f gets_int_int1b");
        m("a gets_int_int1b");
        m("b gets_int_int2b");
        m("f gets_int_int2b");
        m("a gets_int_int2b");
        m("b gets_int_int3b");
        m("f gets_int_int3b");
        m("a gets_int_int3b");
        m("b sets_int_int0");
        m("f sets_int_int0");
        m("a sets_int_int0");
        m("b sets_int_int1");
        m("f sets_int_int1");
        m("a sets_int_int1");
        m("b sets_int_int2");
        m("f sets_int_int2");
        m("a sets_int_int2");
        m("b sets_int_int3");
        m("f sets_int_int3");
        m("a sets_int_int3");
        m("b sets_int_int0b");
        m("f sets_int_int0b");
        m("a sets_int_int0b");
        m("b sets_int_int1b");
        m("f sets_int_int1b");
        m("a sets_int_int1b");
        m("b sets_int_int2b");
        m("f sets_int_int2b");
        m("a sets_int_int2b");
        m("b sets_int_int3b");
        m("f sets_int_int3b");
        m("a sets_int_int3b");
        m("b sets_int_int0c");
        m("f sets_int_int0c");
        m("a sets_int_int0c");
        m("b sets_int_int1c");
        m("f sets_int_int1c");
        m("a sets_int_int1c");
        m("b sets_int_int2c");
        m("f sets_int_int2c");
        m("a sets_int_int2c");
        m("b sets_int_int3c");
        m("f sets_int_int3c");
        m("a sets_int_int3c");
        m("b gets_int_sint0");
        m("f gets_int_sint0");
        m("a gets_int_sint0");
        m("b gets_int_sint1");
        m("f gets_int_sint1");
        m("a gets_int_sint1");
        m("b gets_int_sint2");
        m("f gets_int_sint2");
        m("a gets_int_sint2");
        m("b gets_int_sint3");
        m("f gets_int_sint3");
        m("a gets_int_sint3");
        m("b gets_int_sint0b");
        m("f gets_int_sint0b");
        m("a gets_int_sint0b");
        m("b gets_int_sint1b");
        m("f gets_int_sint1b");
        m("a gets_int_sint1b");
        m("b gets_int_sint2b");
        m("f gets_int_sint2b");
        m("a gets_int_sint2b");
        m("b gets_int_sint3b");
        m("f gets_int_sint3b");
        m("a gets_int_sint3b");
        m("b sets_int_sint0");
        m("f sets_int_sint0");
        m("a sets_int_sint0");
        m("b sets_int_sint1");
        m("f sets_int_sint1");
        m("a sets_int_sint1");
        m("b sets_int_sint2");
        m("f sets_int_sint2");
        m("a sets_int_sint2");
        m("b sets_int_sint3");
        m("f sets_int_sint3");
        m("a sets_int_sint3");
        m("b sets_int_sint0b");
        m("f sets_int_sint0b");
        m("a sets_int_sint0b");
        m("b sets_int_sint1b");
        m("f sets_int_sint1b");
        m("a sets_int_sint1b");
        m("b sets_int_sint2b");
        m("f sets_int_sint2b");
        m("a sets_int_sint2b");
        m("b sets_int_sint3b");
        m("f sets_int_sint3b");
        m("a sets_int_sint3b");
        m("b sets_int_sint0c");
        m("f sets_int_sint0c");
        m("a sets_int_sint0c");
        m("b sets_int_sint1c");
        m("f sets_int_sint1c");
        m("a sets_int_sint1c");
        m("b sets_int_sint2c");
        m("f sets_int_sint2c");
        m("a sets_int_sint2c");
        m("b sets_int_sint3c");
        m("f sets_int_sint3c");
        m("a sets_int_sint3c");
    }
    
    public Ints() { super(); }
}
retrieve <NullPointerOnGets: void main(java.lang.String[])> from NullPointerOnGets
retrieve <NullPointerOnGets: void <init>()> from NullPointerOnGets
retrieve <NullPointerOnGets: void <clinit>()> from NullPointerOnGets
retrieve <C: void <init>()> from C
retrieve <C: void go()> from C
retrieve <C: void eq(int,int)> from C
retrieve <C: void eq(java.lang.String,java.lang.String)> from C
retrieve <C: void <clinit>()> from C
retrieve <StringAspect: void <init>()> from StringAspect
retrieve <StringAspect: void a(java.lang.String)> from StringAspect
retrieve <StringAspect: void before$0()> from StringAspect
retrieve <StringAspect: void before$1()> from StringAspect
retrieve <StringAspect: void before$2()> from StringAspect
retrieve <StringAspect: void before$3()> from StringAspect
retrieve <StringAspect: void before$4()> from StringAspect
retrieve <StringAspect: void before$5()> from StringAspect
retrieve <StringAspect: void before$6()> from StringAspect
retrieve <StringAspect: void before$7()> from StringAspect
retrieve <StringAspect: void before$8()> from StringAspect
retrieve <StringAspect: void before$9()> from StringAspect
retrieve <StringAspect: void before$10()> from StringAspect
retrieve <StringAspect: void before$11()> from StringAspect
retrieve <StringAspect: void before$12()> from StringAspect
retrieve <StringAspect: void before$13()> from StringAspect
retrieve <StringAspect: void before$14()> from StringAspect
retrieve <StringAspect: void before$15()> from StringAspect
retrieve <StringAspect: void before$16()> from StringAspect
retrieve <StringAspect: void before$17()> from StringAspect
retrieve <StringAspect: void before$18()> from StringAspect
retrieve <StringAspect: void before$19()> from StringAspect
retrieve <StringAspect: void before$20()> from StringAspect
retrieve <StringAspect: void before$21()> from StringAspect
retrieve <StringAspect: void before$22()> from StringAspect
retrieve <StringAspect: void before$23()> from StringAspect
retrieve <StringAspect: void before$24()> from StringAspect
retrieve <StringAspect: void before$25()> from StringAspect
retrieve <StringAspect: void before$26()> from StringAspect
retrieve <StringAspect: void before$27()> from StringAspect
retrieve <StringAspect: void before$28()> from StringAspect
retrieve <StringAspect: void before$29()> from StringAspect
retrieve <StringAspect: void before$30()> from StringAspect
retrieve <StringAspect: void before$31()> from StringAspect
retrieve <StringAspect: void before$32()> from StringAspect
retrieve <StringAspect: void before$33()> from StringAspect
retrieve <StringAspect: void before$34()> from StringAspect
retrieve <StringAspect: void before$35()> from StringAspect
retrieve <StringAspect: void before$36()> from StringAspect
retrieve <StringAspect: void before$37()> from StringAspect
retrieve <StringAspect: void before$38()> from StringAspect
retrieve <StringAspect: void before$39()> from StringAspect
retrieve <StringAspect: java.lang.Object around$40()> from StringAspect
retrieve <StringAspect: java.lang.Object around$41()> from StringAspect
retrieve <StringAspect: java.lang.Object around$42()> from StringAspect
retrieve <StringAspect: java.lang.Object around$43()> from StringAspect
retrieve <StringAspect: java.lang.Object around$44()> from StringAspect
retrieve <StringAspect: java.lang.Object around$45()> from StringAspect
retrieve <StringAspect: java.lang.Object around$46()> from StringAspect
retrieve <StringAspect: java.lang.Object around$47()> from StringAspect
retrieve <StringAspect: java.lang.Object around$48()> from StringAspect
retrieve <StringAspect: java.lang.Object around$49()> from StringAspect
retrieve <StringAspect: java.lang.Object around$50()> from StringAspect
retrieve <StringAspect: java.lang.Object around$51()> from StringAspect
retrieve <StringAspect: java.lang.Object around$52()> from StringAspect
retrieve <StringAspect: java.lang.Object around$53()> from StringAspect
retrieve <StringAspect: java.lang.Object around$54()> from StringAspect
retrieve <StringAspect: java.lang.Object around$55()> from StringAspect
retrieve <StringAspect: java.lang.Object around$56()> from StringAspect
retrieve <StringAspect: java.lang.Object around$57()> from StringAspect
retrieve <StringAspect: java.lang.Object around$58()> from StringAspect
retrieve <StringAspect: java.lang.Object around$59()> from StringAspect
retrieve <StringAspect: java.lang.Object around$60()> from StringAspect
retrieve <StringAspect: java.lang.Object around$61()> from StringAspect
retrieve <StringAspect: java.lang.Object around$62()> from StringAspect
retrieve <StringAspect: java.lang.Object around$63()> from StringAspect
retrieve <StringAspect: java.lang.Object around$64()> from StringAspect
retrieve <StringAspect: java.lang.Object around$65()> from StringAspect
retrieve <StringAspect: java.lang.Object around$66()> from StringAspect
retrieve <StringAspect: java.lang.Object around$67()> from StringAspect
retrieve <StringAspect: java.lang.Object around$68()> from StringAspect
retrieve <StringAspect: java.lang.Object around$69()> from StringAspect
retrieve <StringAspect: java.lang.Object around$70()> from StringAspect
retrieve <StringAspect: java.lang.Object around$71()> from StringAspect
retrieve <StringAspect: java.lang.Object around$72()> from StringAspect
retrieve <StringAspect: java.lang.Object around$73()> from StringAspect
retrieve <StringAspect: java.lang.Object around$74()> from StringAspect
retrieve <StringAspect: java.lang.Object around$75()> from StringAspect
retrieve <StringAspect: java.lang.Object around$76()> from StringAspect
retrieve <StringAspect: java.lang.Object around$77()> from StringAspect
retrieve <StringAspect: java.lang.Object around$78()> from StringAspect
retrieve <StringAspect: java.lang.Object around$79()> from StringAspect
retrieve <StringAspect: void after$80()> from StringAspect
retrieve <StringAspect: void after$81()> from StringAspect
retrieve <StringAspect: void after$82()> from StringAspect
retrieve <StringAspect: void after$83()> from StringAspect
retrieve <StringAspect: void after$84()> from StringAspect
retrieve <StringAspect: void after$85()> from StringAspect
retrieve <StringAspect: void after$86()> from StringAspect
retrieve <StringAspect: void after$87()> from StringAspect
retrieve <StringAspect: void after$88()> from StringAspect
retrieve <StringAspect: void after$89()> from StringAspect
retrieve <StringAspect: void after$90()> from StringAspect
retrieve <StringAspect: void after$91()> from StringAspect
retrieve <StringAspect: void after$92()> from StringAspect
retrieve <StringAspect: void after$93()> from StringAspect
retrieve <StringAspect: void after$94()> from StringAspect
retrieve <StringAspect: void after$95()> from StringAspect
retrieve <StringAspect: void after$96()> from StringAspect
retrieve <StringAspect: void after$97()> from StringAspect
retrieve <StringAspect: void after$98()> from StringAspect
retrieve <StringAspect: void after$99()> from StringAspect
retrieve <StringAspect: void after$100()> from StringAspect
retrieve <StringAspect: void after$101()> from StringAspect
retrieve <StringAspect: void after$102()> from StringAspect
retrieve <StringAspect: void after$103()> from StringAspect
retrieve <StringAspect: void after$104()> from StringAspect
retrieve <StringAspect: void after$105()> from StringAspect
retrieve <StringAspect: void after$106()> from StringAspect
retrieve <StringAspect: void after$107()> from StringAspect
retrieve <StringAspect: void after$108()> from StringAspect
retrieve <StringAspect: void after$109()> from StringAspect
retrieve <StringAspect: void after$110()> from StringAspect
retrieve <StringAspect: void after$111()> from StringAspect
retrieve <StringAspect: void after$112()> from StringAspect
retrieve <StringAspect: void after$113()> from StringAspect
retrieve <StringAspect: void after$114()> from StringAspect
retrieve <StringAspect: void after$115()> from StringAspect
retrieve <StringAspect: void after$116()> from StringAspect
retrieve <StringAspect: void after$117()> from StringAspect
retrieve <StringAspect: void after$118()> from StringAspect
retrieve <StringAspect: void after$119()> from StringAspect
retrieve <StringAspect: StringAspect aspectOf()> from StringAspect
retrieve <StringAspect: boolean hasAspect()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$240()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$241()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$242()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$243()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$244()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$245()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$246()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$247()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$248()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$249()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$250()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$251()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$252()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$253()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$254()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$255()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$256()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$257()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$258()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$259()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$260()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$261()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$262()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$263()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$264()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$265()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$266()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$267()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$268()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$269()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$270()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$271()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$272()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$273()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$274()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$275()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$276()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$277()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$278()> from StringAspect
retrieve <StringAspect: java.lang.Object proceed$279()> from StringAspect
retrieve <Strings: void m(java.lang.String)> from Strings
retrieve <Strings: void add()> from Strings
retrieve <Strings: void <init>()> from Strings
retrieve <IntAspect: void before$126()> from IntAspect
retrieve <IntAspect: void before$127()> from IntAspect
retrieve <IntAspect: void before$128()> from IntAspect
retrieve <IntAspect: void before$129()> from IntAspect
retrieve <IntAspect: void before$130()> from IntAspect
retrieve <IntAspect: void before$131()> from IntAspect
retrieve <IntAspect: void before$132()> from IntAspect
retrieve <IntAspect: void before$133()> from IntAspect
retrieve <IntAspect: void a(java.lang.String)> from IntAspect
retrieve <IntAspect: void before$134()> from IntAspect
retrieve <IntAspect: void before$135()> from IntAspect
retrieve <IntAspect: void before$136()> from IntAspect
retrieve <IntAspect: void before$137()> from IntAspect
retrieve <IntAspect: void before$138()> from IntAspect
retrieve <IntAspect: void before$139()> from IntAspect
retrieve <IntAspect: void before$140()> from IntAspect
retrieve <IntAspect: void before$141()> from IntAspect
retrieve <IntAspect: void before$142()> from IntAspect
retrieve <IntAspect: void before$143()> from IntAspect
retrieve <IntAspect: void before$144()> from IntAspect
retrieve <IntAspect: void before$145()> from IntAspect
retrieve <IntAspect: void before$146()> from IntAspect
retrieve <IntAspect: void before$147()> from IntAspect
retrieve <IntAspect: void before$148()> from IntAspect
retrieve <IntAspect: void before$149()> from IntAspect
retrieve <IntAspect: void before$150()> from IntAspect
retrieve <IntAspect: void before$151()> from IntAspect
retrieve <IntAspect: void before$152()> from IntAspect
retrieve <IntAspect: void before$153()> from IntAspect
retrieve <IntAspect: void before$154()> from IntAspect
retrieve <IntAspect: void before$155()> from IntAspect
retrieve <IntAspect: void before$156()> from IntAspect
retrieve <IntAspect: void before$157()> from IntAspect
retrieve <IntAspect: void before$158()> from IntAspect
retrieve <IntAspect: void before$159()> from IntAspect
retrieve <IntAspect: java.lang.Object around$160()> from IntAspect
retrieve <IntAspect: java.lang.Object around$161()> from IntAspect
retrieve <IntAspect: java.lang.Object around$162()> from IntAspect
retrieve <IntAspect: java.lang.Object around$163()> from IntAspect
retrieve <IntAspect: java.lang.Object around$164()> from IntAspect
retrieve <IntAspect: java.lang.Object around$165()> from IntAspect
retrieve <IntAspect: java.lang.Object around$166()> from IntAspect
retrieve <IntAspect: java.lang.Object around$167()> from IntAspect
retrieve <IntAspect: java.lang.Object around$168()> from IntAspect
retrieve <IntAspect: java.lang.Object around$169()> from IntAspect
retrieve <IntAspect: java.lang.Object around$170()> from IntAspect
retrieve <IntAspect: java.lang.Object around$171()> from IntAspect
retrieve <IntAspect: java.lang.Object around$172()> from IntAspect
retrieve <IntAspect: java.lang.Object around$173()> from IntAspect
retrieve <IntAspect: java.lang.Object around$174()> from IntAspect
retrieve <IntAspect: java.lang.Object around$175()> from IntAspect
retrieve <IntAspect: java.lang.Object around$176()> from IntAspect
retrieve <IntAspect: java.lang.Object around$177()> from IntAspect
retrieve <IntAspect: java.lang.Object around$178()> from IntAspect
retrieve <IntAspect: java.lang.Object around$179()> from IntAspect
retrieve <IntAspect: java.lang.Object around$180()> from IntAspect
retrieve <IntAspect: java.lang.Object around$181()> from IntAspect
retrieve <IntAspect: java.lang.Object around$182()> from IntAspect
retrieve <IntAspect: java.lang.Object around$183()> from IntAspect
retrieve <IntAspect: java.lang.Object around$184()> from IntAspect
retrieve <IntAspect: java.lang.Object around$185()> from IntAspect
retrieve <IntAspect: java.lang.Object around$186()> from IntAspect
retrieve <IntAspect: java.lang.Object around$187()> from IntAspect
retrieve <IntAspect: java.lang.Object around$188()> from IntAspect
retrieve <IntAspect: java.lang.Object around$189()> from IntAspect
retrieve <IntAspect: java.lang.Object around$190()> from IntAspect
retrieve <IntAspect: java.lang.Object around$191()> from IntAspect
retrieve <IntAspect: java.lang.Object around$192()> from IntAspect
retrieve <IntAspect: java.lang.Object around$193()> from IntAspect
retrieve <IntAspect: java.lang.Object around$194()> from IntAspect
retrieve <IntAspect: java.lang.Object around$195()> from IntAspect
retrieve <IntAspect: java.lang.Object around$196()> from IntAspect
retrieve <IntAspect: java.lang.Object around$197()> from IntAspect
retrieve <IntAspect: java.lang.Object around$198()> from IntAspect
retrieve <IntAspect: java.lang.Object around$199()> from IntAspect
retrieve <IntAspect: void after$200()> from IntAspect
retrieve <IntAspect: void after$201()> from IntAspect
retrieve <IntAspect: void after$202()> from IntAspect
retrieve <IntAspect: void after$203()> from IntAspect
retrieve <IntAspect: void after$204()> from IntAspect
retrieve <IntAspect: void after$205()> from IntAspect
retrieve <IntAspect: void after$206()> from IntAspect
retrieve <IntAspect: void after$207()> from IntAspect
retrieve <IntAspect: void after$208()> from IntAspect
retrieve <IntAspect: void after$209()> from IntAspect
retrieve <IntAspect: void after$210()> from IntAspect
retrieve <IntAspect: void after$211()> from IntAspect
retrieve <IntAspect: void after$212()> from IntAspect
retrieve <IntAspect: void after$213()> from IntAspect
retrieve <IntAspect: void after$214()> from IntAspect
retrieve <IntAspect: void after$215()> from IntAspect
retrieve <IntAspect: void after$216()> from IntAspect
retrieve <IntAspect: void after$217()> from IntAspect
retrieve <IntAspect: void after$218()> from IntAspect
retrieve <IntAspect: void after$219()> from IntAspect
retrieve <IntAspect: void after$220()> from IntAspect
retrieve <IntAspect: void after$221()> from IntAspect
retrieve <IntAspect: void after$222()> from IntAspect
retrieve <IntAspect: void after$223()> from IntAspect
retrieve <IntAspect: void after$224()> from IntAspect
retrieve <IntAspect: void after$225()> from IntAspect
retrieve <IntAspect: void after$226()> from IntAspect
retrieve <IntAspect: void after$227()> from IntAspect
retrieve <IntAspect: void after$228()> from IntAspect
retrieve <IntAspect: void after$229()> from IntAspect
retrieve <IntAspect: void after$230()> from IntAspect
retrieve <IntAspect: void after$231()> from IntAspect
retrieve <IntAspect: void after$232()> from IntAspect
retrieve <IntAspect: void after$233()> from IntAspect
retrieve <IntAspect: void after$234()> from IntAspect
retrieve <IntAspect: void after$235()> from IntAspect
retrieve <IntAspect: void after$236()> from IntAspect
retrieve <IntAspect: void after$237()> from IntAspect
retrieve <IntAspect: void after$238()> from IntAspect
retrieve <IntAspect: void after$239()> from IntAspect
retrieve <IntAspect: IntAspect aspectOf()> from IntAspect
retrieve <IntAspect: void <init>()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$280()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$281()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$282()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$283()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$284()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$285()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$286()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$287()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$288()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$289()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$290()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$291()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$292()> from IntAspect
retrieve <IntAspect: boolean hasAspect()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$293()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$294()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$295()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$296()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$297()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$298()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$299()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$300()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$301()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$302()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$303()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$304()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$305()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$306()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$307()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$308()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$309()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$310()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$311()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$312()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$313()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$314()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$315()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$316()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$317()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$318()> from IntAspect
retrieve <IntAspect: java.lang.Object proceed$319()> from IntAspect
retrieve <IntAspect: void before$120()> from IntAspect
retrieve <IntAspect: void before$121()> from IntAspect
retrieve <IntAspect: void before$122()> from IntAspect
retrieve <IntAspect: void before$123()> from IntAspect
retrieve <IntAspect: void before$124()> from IntAspect
retrieve <IntAspect: void before$125()> from IntAspect
retrieve <Ints: void m(java.lang.String)> from Ints
retrieve <Ints: void add()> from Ints
retrieve <Ints: void <init>()> from Ints
Transforming Ints... 
Transforming C... 
Transforming StringAspect... 
Transforming Strings... 
Transforming NullPointerOnGets... 
Transforming IntAspect... 
Transforming abc$access$StringAspect$around$76... 
Transforming abc$access$StringAspect$around$72... 
Transforming abc$access$StringAspect$around$68... 
Transforming abc$access$StringAspect$around$56... 
Transforming abc$access$StringAspect$around$52... 
Transforming abc$access$StringAspect$around$48... 
Transforming abc$access$StringAspect$around$77... 
Transforming abc$access$StringAspect$around$73... 
Transforming abc$access$StringAspect$around$69... 
Transforming abc$access$StringAspect$around$57... 
Transforming abc$access$StringAspect$around$53... 
Transforming abc$access$StringAspect$around$49... 
Transforming abc$access$StringAspect$around$78... 
Transforming abc$access$StringAspect$around$74... 
Transforming abc$access$StringAspect$around$70... 
Transforming abc$access$StringAspect$around$58... 
Transforming abc$access$StringAspect$around$54... 
Transforming abc$access$StringAspect$around$50... 
Transforming abc$access$StringAspect$around$79... 
Transforming abc$access$StringAspect$around$75... 
Transforming abc$access$StringAspect$around$71... 
Transforming abc$access$StringAspect$around$59... 
Transforming abc$access$StringAspect$around$55... 
Transforming abc$access$StringAspect$around$51... 
Transforming abc$access$IntAspect$around$196... 
Transforming abc$access$IntAspect$around$192... 
Transforming abc$access$IntAspect$around$188... 
Transforming abc$access$IntAspect$around$176... 
Transforming abc$access$IntAspect$around$172... 
Transforming abc$access$IntAspect$around$168... 
Transforming abc$access$IntAspect$around$197... 
Transforming abc$access$IntAspect$around$193... 
Transforming abc$access$IntAspect$around$189... 
Transforming abc$access$IntAspect$around$177... 
Transforming abc$access$IntAspect$around$173... 
Transforming abc$access$IntAspect$around$169... 
Transforming abc$access$IntAspect$around$198... 
Transforming abc$access$IntAspect$around$194... 
Transforming abc$access$IntAspect$around$190... 
Transforming abc$access$IntAspect$around$178... 
Transforming abc$access$IntAspect$around$174... 
Transforming abc$access$IntAspect$around$170... 
Transforming abc$access$IntAspect$around$199... 
Transforming abc$access$IntAspect$around$195... 
Transforming abc$access$IntAspect$around$191... 
Transforming abc$access$IntAspect$around$179... 
Transforming abc$access$IntAspect$around$175... 
Transforming abc$access$IntAspect$around$171... 
Transforming abc$access$StringAspect$around$64... 
Transforming abc$access$StringAspect$around$60... 
Transforming abc$access$StringAspect$around$44... 
Transforming abc$access$StringAspect$around$40... 
Transforming abc$access$StringAspect$around$65... 
Transforming abc$access$StringAspect$around$61... 
Transforming abc$access$StringAspect$around$45... 
Transforming abc$access$StringAspect$around$41... 
Transforming abc$access$StringAspect$around$66... 
Transforming abc$access$StringAspect$around$62... 
Transforming abc$access$StringAspect$around$46... 
Transforming abc$access$StringAspect$around$42... 
Transforming abc$access$StringAspect$around$67... 
Transforming abc$access$StringAspect$around$63... 
Transforming abc$access$StringAspect$around$47... 
Transforming abc$access$StringAspect$around$43... 
Transforming abc$access$IntAspect$around$184... 
Transforming abc$access$IntAspect$around$180... 
Transforming abc$access$IntAspect$around$164... 
Transforming abc$access$IntAspect$around$160... 
Transforming abc$access$IntAspect$around$185... 
Transforming abc$access$IntAspect$around$181... 
Transforming abc$access$IntAspect$around$165... 
Transforming abc$access$IntAspect$around$161... 
Transforming abc$access$IntAspect$around$186... 
Transforming abc$access$IntAspect$around$182... 
Transforming abc$access$IntAspect$around$166... 
Transforming abc$access$IntAspect$around$162... 
Transforming abc$access$IntAspect$around$187... 
Transforming abc$access$IntAspect$around$183... 
Transforming abc$access$IntAspect$around$167... 
Transforming abc$access$IntAspect$around$163... 
Abc finished on Thu Jun 24 09:15:39 BST 2004. ( 0 min. 33 sec. )
PASS: Null pointer on gets advice with coverage [painful]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 35 seconds
Passed. Current status: 147 failed (check: 70), 300 passed (check: 81), 0 skipped.
Executing test 448 (new): Basic test for cflow pointcuts [eachcflow]
================================================
Breakdown of abc phases  (total: 13931 millisec.)
------------------------------------------------
[ 00.273% ] Init. of Soot:  38
[ 00.022% ] Loading Jars:  3
[ 74.051% ] Polyglot phases:  10316
[ 00.014% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  2
[ 01.120% ] Recompute name pattern matches:  156
[ 00.000% ] Compute precedence relation:  0
[ 00.395% ] Intertype Adjuster:  55
[ 14.636% ] Retrieving bodies:  2039
[ 00.000% ] Weave Initializers:  0
[ 00.165% ] Load shadow types:  23
[ 02.534% ] Compute advice lists:  353
[ 00.022% ] Intertype weave:  3
[ 00.244% ] Add aspect code:  34
[ 00.409% ] Weaving advice:  57
[ 00.000% ] Validate jimple:  0
[ 03.647% ] Soot Packs:  508
[ 02.455% ] Soot Writing Output:  342
================================================
Abc started on Thu Jun 24 09:15:41 BST 2004
<<<< CFlowPoints.java >>>>
import org.aspectj.testing.Tester;

public class CFlowPoints {
    public static void main(java.lang.String[] args) {
        new Test().go(2);
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.callsPerCFlow,
                                              2 +
                                              1,
                                              "3 call for each cflow");
        Test/*Test*/.callsPerCFlow = 0;
        new Test().go(3);
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.callsPerCFlow,
                                              3 + 2 +
                                              1,
                                              "6 call for each cflow");
        try {
            Each.aspectOf();
            org.aspectj.testing.Tester.checkFailed("should have thrown exception");
        }
        catch (org.aspectj.lang.NoAspectBoundException exc) {  }
    }
    
    public CFlowPoints() { super(); }
}
class Test {
    static int cflowObjects = 0;
    
    static int callsPerCFlow = 0;
    
    java.lang.Object lastEachCFlow = null;
    
    void go(int n) {
        for (int i = 0; i < n; i++) foo("i", "i");
        if (n >= 0) go(n - 1);
        org.aspectj.testing.Tester.check(Each.aspectOf() !=
                                         this/*null*/.lastEachCFlow,
                                         "unique eachcflows");
        this/*null*/.lastEachCFlow = Each.aspectOf();
    }
    
    void foo(java.lang.String s1, java.lang.String s2) {  }
    
    public Test() { super(); }
}
aspect A {
    pointcut root(int x) :
    target(Test) && call(void (*).go(int)) &&
      args(x);
    
    pointcut flow(int x) : cflow(root(x));
    
    before():
    root(int) &&
      !cflow(root(int)) {
        org.aspectj.testing.Tester.checkEqual(Test/*Test*/.callsPerCFlow,
                                              0,
                                              "top call");
    }
    
    before(String s1, int y, String s2):
    flow(y) && target(Test) && target(java.lang.Object) &&
      call(void (*).*(String, String)) &&
      args(s1, s2) {
        Test/*Test*/.callsPerCFlow++;
        org.aspectj.testing.Tester.checkEqual(s1,
                                              s2,
                                              "extra parameters");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
aspect Each {
    pointcut flowCut() : target(Test) && call(void (*).go(int));
    
    public static Each aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Each() { super(); }
}
retrieve <CFlowPoints: void main(java.lang.String[])> from CFlowPoints
retrieve <CFlowPoints: void <init>()> from CFlowPoints
retrieve <Test: void <init>()> from Test
retrieve <Test: void go(int)> from Test
retrieve <Test: void foo(java.lang.String,java.lang.String)> from Test
retrieve <Test: void <clinit>()> from Test
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void before$0()> from A
retrieve <A: void before$1(java.lang.String,int,java.lang.String)> from A
retrieve <A: A aspectOf()> from A
retrieve <Each: boolean hasAspect()> from Each
retrieve <Each: Each aspectOf()> from Each
retrieve <Each: void <init>()> from Each
Transforming CFlowPoints... 
Transforming Test... 
Transforming A... 
Transforming Each... 
Abc finished on Thu Jun 24 09:15:55 BST 2004. ( 0 min. 14 sec. )
PASS: Basic test for cflow pointcuts [eachcflow]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 15 seconds
Passed. Current status: 147 failed (check: 70), 301 passed (check: 81), 0 skipped.
Executing test 449 (new): Crashing when looking up the type of array members.
Failed. Current status: 148 failed (check: 70), 301 passed (check: 81), 0 skipped.
Executing test 450 (new): PostfixExprs to various synthetic things are fixed correctly [eachobject]
Failed. Current status: 149 failed (check: 70), 301 passed (check: 81), 0 skipped.
Executing test 451 (new): Dave Binkley's problem with eachcflowroot. [eachcflow]
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 12110 millisec.)
------------------------------------------------
[ 00.314% ] Init. of Soot:  38
[ 00.033% ] Loading Jars:  4
[ 59.992% ] Polyglot phases:  7265
[ 00.017% ] Resolve class names:  2
[ 00.017% ] Declare Parents:  2
[ 01.247% ] Recompute name pattern matches:  151
[ 00.000% ] Compute precedence relation:  0
[ 01.396% ] Intertype Adjuster:  169
[ 12.469% ] Retrieving bodies:  1510
[ 00.000% ] Weave Initializers:  0
[ 00.190% ] Load shadow types:  23
[ 06.978% ] Compute advice lists:  845
[ 00.025% ] Intertype weave:  3
[ 01.239% ] Add aspect code:  150
[ 03.212% ] Weaving advice:  389
[ 00.000% ] Validate jimple:  0
[ 09.463% ] Soot Packs:  1146
[ 03.410% ] Soot Writing Output:  413
================================================
Abc started on Thu Jun 24 09:16:12 BST 2004
<<<< Binkley2.java >>>>
import java.util.*;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import org.aspectj.testing.*;

public class Binkley2 {
    public static void main(java.lang.String[] args) {
        C c = new C();
        Art/*Art*/.enable = true;
        Ar/*Ar*/.enable = false;
        new C().foo();
        Art/*Art*/.enable = false;
        Ar/*Ar*/.enable = true;
        new C().foo();
        Post.checkAll();
    }
    
    public Binkley2() { super(); }
}
class C {
    public int x = 0;
    
    public void foo() {
        this/*null*/.x = 1;
        this/*null*/.x = 2;
    }
    
    public C() { super(); }
}
class Post {
    static java.util.List haves = new java.util.Vector();
    
    static java.lang.String[] wants =
      new java.lang.String[] { "preinitialization(C())-Ar-0", "initialization(C())-Ar-0", "execution(C())-Ar-0", "set(C.x)-Ar-0", "execution(C.foo())-Ar-0", "set(C.x)-Ar-0", "set(C.x)-Ar-0", "preinitialization(C())-Art-0", "initialization(C())-Art-0", "execution(C())-Art-1", "set(C.x)-Art-2", "execution(C.foo())-Art-0", "set(C.x)-Art-1", "set(C.x)-Art-2" };
    
    static void post(org.aspectj.lang.JoinPoint jp,
                     java.lang.String name,
                     int num) {
        Post/*Post*/.haves.add(jp.toShortString() + "-" + name + "-" +
                               num);
    }
    
    static void checkAll() {
        org.aspectj.testing.Tester.checkEqual(Post/*Post*/.haves,
                                              Post/*Post*/.wants,
                                              "haves != wants");
    }
    
    public Post() { super(); }
}
aspect Ar {
    pointcut pc() : within(C);
    
    int count = 0;
    
    static boolean enable = false;
    
    before():
    pc() {
        if (Ar/*Ar*/.enable) {
            Post.post(thisJoinPoint, "Ar", this/*null*/.count++);
        }
    }
    
    public static Ar aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Ar() { super(); }
}
aspect Art {
    pointcut pc() : within(C);
    
    int count = 0;
    
    static boolean enable = false;
    
    before():
    pc() {
        if (Art/*Art*/.enable) {
            Post.post(thisJoinPoint, "Art", this/*null*/.count++);
        }
    }
    
    public static Art aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Art() { super(); }
}
retrieve <Binkley2: void <init>()> from Binkley2
retrieve <Binkley2: void main(java.lang.String[])> from Binkley2
retrieve <C: void foo()> from C
retrieve <C: void <init>()> from C
retrieve <Post: void post(org.aspectj.lang.JoinPoint,java.lang.String,int)> from Post
retrieve <Post: void checkAll()> from Post
retrieve <Post: void <init>()> from Post
retrieve <Post: void <clinit>()> from Post
retrieve <Ar: void before$0(org.aspectj.lang.JoinPoint)> from Ar
retrieve <Ar: Ar aspectOf()> from Ar
retrieve <Ar: void <init>()> from Ar
retrieve <Ar: void <clinit>()> from Ar
retrieve <Ar: boolean hasAspect()> from Ar
retrieve <Art: void <init>()> from Art
retrieve <Art: void before$1(org.aspectj.lang.JoinPoint)> from Art
retrieve <Art: Art aspectOf()> from Art
retrieve <Art: boolean hasAspect()> from Art
retrieve <Art: void <clinit>()> from Art
Transforming C... 
Transforming Binkley2... 
Transforming Post... 
Transforming Art... 
Transforming Ar... 
Abc finished on Thu Jun 24 09:16:24 BST 2004. ( 0 min. 12 sec. )
PASS: Dave Binkley's problem with eachcflowroot. [eachcflow]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 149 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 452 (new): advice on an inherited method
Failed. Current status: 150 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 453 (new): , PR#115 checks the ordering of catch clauses
================================================
Breakdown of abc phases  (total: 8391 millisec.)
------------------------------------------------
[ 00.679% ] Init. of Soot:  57
[ 00.143% ] Loading Jars:  12
[ 76.141% ] Polyglot phases:  6389
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.584% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.441% ] Intertype Adjuster:  37
[ 07.413% ] Retrieving bodies:  622
[ 00.000% ] Weave Initializers:  0
[ 00.262% ] Load shadow types:  22
[ 06.352% ] Compute advice lists:  533
[ 00.036% ] Intertype weave:  3
[ 00.358% ] Add aspect code:  30
[ 00.369% ] Weaving advice:  31
[ 00.000% ] Validate jimple:  0
[ 03.957% ] Soot Packs:  332
[ 03.218% ] Soot Writing Output:  270
================================================
Failed. Current status: 151 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 454 (new): various declared exception permutations
Failed. Current status: 152 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 455 (new): ordering of advice kinds as well as cflow and dominates
================================================
Breakdown of abc phases  (total: 10276 millisec.)
------------------------------------------------
[ 00.370% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  4
[ 66.728% ] Polyglot phases:  6857
[ 00.019% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  2
[ 00.662% ] Recompute name pattern matches:  68
[ 00.010% ] Compute precedence relation:  1
[ 00.360% ] Intertype Adjuster:  37
[ 08.525% ] Retrieving bodies:  876
[ 00.000% ] Weave Initializers:  0
[ 00.272% ] Load shadow types:  28
[ 08.116% ] Compute advice lists:  834
[ 00.029% ] Intertype weave:  3
[ 00.292% ] Add aspect code:  30
[ 01.294% ] Weaving advice:  133
[ 00.000% ] Validate jimple:  0
[ 07.620% ] Soot Packs:  783
[ 05.644% ] Soot Writing Output:  580
================================================
Failed. Current status: 153 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 456 (new): advice on default constructor for a class only referenced via reflection
Failed. Current status: 154 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 457 (new): calling and called this params in calls points
Failed. Current status: 155 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 458 (new): primitive parameters coercable to Object just like return values are
================================================
Breakdown of abc phases  (total: 7890 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 73.270% ] Polyglot phases:  5781
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.608% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.482% ] Intertype Adjuster:  38
[ 06.553% ] Retrieving bodies:  517
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  22
[ 02.915% ] Compute advice lists:  230
[ 00.038% ] Intertype weave:  3
[ 00.507% ] Add aspect code:  40
[ 01.141% ] Weaving advice:  90
[ 00.000% ] Validate jimple:  0
[ 10.165% ] Soot Packs:  802
[ 03.473% ] Soot Writing Output:  274
================================================
Failed. Current status: 156 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 459 (new): Does the matrix coverage thing for the new method signatures
Failed. Current status: 157 failed (check: 70), 302 passed (check: 81), 0 skipped.
Executing test 460 (new): join points in static/dynamic initializers aren't showing up.
================================================
Breakdown of abc phases  (total: 7414 millisec.)
------------------------------------------------
[ 00.499% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 80.024% ] Polyglot phases:  5933
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.513% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.850% ] Intertype Adjuster:  63
[ 06.717% ] Retrieving bodies:  498
[ 00.000% ] Weave Initializers:  0
[ 00.391% ] Load shadow types:  29
[ 02.806% ] Compute advice lists:  208
[ 00.040% ] Intertype weave:  3
[ 00.486% ] Add aspect code:  36
[ 00.418% ] Weaving advice:  31
[ 00.000% ] Validate jimple:  0
[ 04.006% ] Soot Packs:  297
[ 03.143% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 09:17:35 BST 2004
<<<< NonexistentInitializers.java >>>>
import org.aspectj.testing.Tester;

public class NonexistentInitializers {
    public static void main(java.lang.String[] args) {
        new NonexistentInitializers();
        org.aspectj.testing.Tester.checkEqual(A/*A*/.i,
                                              4,
                                              "Not finding some join points in initializers");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.foo, 2, "foo");
        org.aspectj.testing.Tester.checkEqual(A/*A*/.get, 2, "get");
    }
    
    static void foo() {  }
    
    static void bar(java.lang.Object o) {  }
    
    {
        bar(java.lang.System/*java.lang.System*/.in);
        NonexistentInitializers.foo();
    }
    
    static {
               bar(java.lang.System/*java.lang.System*/.in);
               NonexistentInitializers.foo();
           }
    
    public NonexistentInitializers() { super(); }
}
aspect A {
    static int i = 0;
    
    static int foo = 0;
    
    static int get = 0;
    
    before():
    call(void (NonexistentInitializers).foo()) {
        A/*A*/.i++;
        A/*A*/.foo++;
    }
    
    before():
    get( * (System).in) {
        A/*A*/.i++;
        A/*A*/.get++;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <NonexistentInitializers: void main(java.lang.String[])> from NonexistentInitializers
retrieve <NonexistentInitializers: void foo()> from NonexistentInitializers
retrieve <NonexistentInitializers: void bar(java.lang.Object)> from NonexistentInitializers
retrieve <NonexistentInitializers: void <init>()> from NonexistentInitializers
retrieve <NonexistentInitializers: void <clinit>()> from NonexistentInitializers
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming NonexistentInitializers... 
Abc finished on Thu Jun 24 09:17:43 BST 2004. ( 0 min. 7 sec. )
PASS: join points in static/dynamic initializers aren't showing up.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 157 failed (check: 70), 303 passed (check: 81), 0 skipped.
Executing test 461 (new): Gets and sets on a number of variables (field access ???)
================================================
Breakdown of abc phases  (total: 9572 millisec.)
------------------------------------------------
[ 00.397% ] Init. of Soot:  38
[ 00.042% ] Loading Jars:  4
[ 65.692% ] Polyglot phases:  6288
[ 00.021% ] Resolve class names:  2
[ 00.021% ] Declare Parents:  2
[ 00.690% ] Recompute name pattern matches:  66
[ 00.000% ] Compute precedence relation:  0
[ 00.418% ] Intertype Adjuster:  40
[ 07.052% ] Retrieving bodies:  675
[ 00.010% ] Weave Initializers:  1
[ 00.272% ] Load shadow types:  26
[ 05.098% ] Compute advice lists:  488
[ 00.031% ] Intertype weave:  3
[ 00.397% ] Add aspect code:  38
[ 00.637% ] Weaving advice:  61
[ 00.000% ] Validate jimple:  0
[ 14.135% ] Soot Packs:  1353
[ 05.088% ] Soot Writing Output:  487
================================================
Abc started on Thu Jun 24 09:17:45 BST 2004
<<<< Gets.java >>>>
import org.aspectj.testing.*;

public class Gets {
    public static void main(java.lang.String[] args) {
        new Gets().go();
    }
    
    public int nums0 = 5;
    
    public int nums1 = 5;
    
    public int nums2 = 5;
    
    public int nums3 = 5;
    
    public int nums4 = 20;
    
    public int nums5 = 9;
    
    public int nums6 = 11;
    
    public int nums7 = 9;
    
    public int nums8 = 11;
    
    public int nums9 = 5;
    
    void go() {
        this/*null*/.nums0 = 10;
        this/*null*/.nums1 += 5;
        this/*null*/.nums2 -= -5;
        this/*null*/.nums3 *= 2;
        this/*null*/.nums4 /= 2;
        this/*null*/.nums5++;
        this/*null*/.nums6--;
        ++this/*null*/.nums7;
        --this/*null*/.nums8;
        this/*null*/.nums9 = this/*null*/.nums0;
        { int i = this/*null*/.nums0; }
        { int i = this/*null*/.nums1; }
        { int i = this/*null*/.nums2; }
        { int i = this/*null*/.nums3; }
        { int i = this/*null*/.nums4; }
        { int i = this/*null*/.nums5; }
        { int i = this/*null*/.nums6; }
        { int i = this/*null*/.nums7; }
        { int i = this/*null*/.nums8; }
        { int i = this/*null*/.nums9; }
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.bstar,
                                         "Advice wasn\'t run for GetAspect.star");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b0,
                                         "Advice wasn\'t run for GetAspect.nums0");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b1,
                                         "Advice wasn\'t run for GetAspect.nums1");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b2,
                                         "Advice wasn\'t run for GetAspect.nums2");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b3,
                                         "Advice wasn\'t run for GetAspect.nums3");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b4,
                                         "Advice wasn\'t run for GetAspect.nums4");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b5,
                                         "Advice wasn\'t run for GetAspect.nums5");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b6,
                                         "Advice wasn\'t run for GetAspect.nums6");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b7,
                                         "Advice wasn\'t run for GetAspect.nums7");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b8,
                                         "Advice wasn\'t run for GetAspect.nums8");
        org.aspectj.testing.Tester.check(GetAspect/*GetAspect*/.b9,
                                         "Advice wasn\'t run for GetAspect.nums9");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.bstar,
                                         "Advice wasn\'t run for SetAspect2.star");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b0,
                                         "Advice wasn\'t run for SetAspect2.nums0");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b1,
                                         "Advice wasn\'t run for SetAspect2.nums1");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b2,
                                         "Advice wasn\'t run for SetAspect2.nums2");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b3,
                                         "Advice wasn\'t run for SetAspect2.nums3");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b4,
                                         "Advice wasn\'t run for SetAspect2.nums4");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b5,
                                         "Advice wasn\'t run for SetAspect2.nums5");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b6,
                                         "Advice wasn\'t run for SetAspect2.nums6");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b7,
                                         "Advice wasn\'t run for SetAspect2.nums7");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b8,
                                         "Advice wasn\'t run for SetAspect2.nums8");
        org.aspectj.testing.Tester.check(SetAspect2/*SetAspect2*/.b9,
                                         "Advice wasn\'t run for SetAspect2.nums9");
    }
    
    public Gets() { super(); }
}
aspect GetAspect {
    static boolean bstar = false;
    
    after():
    get( int (Gets).*) {
        GetAspect/*GetAspect*/.bstar = true;
    }
    
    static boolean b0 = false;
    
    after():
    get( int (Gets).nums0) {
        GetAspect/*GetAspect*/.b0 = true;
    }
    
    static boolean b1 = false;
    
    after():
    get( int (Gets).nums1) {
        GetAspect/*GetAspect*/.b1 = true;
    }
    
    static boolean b2 = false;
    
    after():
    get( int (Gets).nums2) {
        GetAspect/*GetAspect*/.b2 = true;
    }
    
    static boolean b3 = false;
    
    after():
    get( int (Gets).nums3) {
        GetAspect/*GetAspect*/.b3 = true;
    }
    
    static boolean b4 = false;
    
    after():
    get( int (Gets).nums4) {
        GetAspect/*GetAspect*/.b4 = true;
    }
    
    static boolean b5 = false;
    
    after():
    get( int (Gets).nums5) {
        GetAspect/*GetAspect*/.b5 = true;
    }
    
    static boolean b6 = false;
    
    after():
    get( int (Gets).nums6) {
        GetAspect/*GetAspect*/.b6 = true;
    }
    
    static boolean b7 = false;
    
    after():
    get( int (Gets).nums7) {
        GetAspect/*GetAspect*/.b7 = true;
    }
    
    static boolean b8 = false;
    
    after():
    get( int (Gets).nums8) {
        GetAspect/*GetAspect*/.b8 = true;
    }
    
    static boolean b9 = false;
    
    after():
    get( int (Gets).nums9) {
        GetAspect/*GetAspect*/.b9 = true;
    }
    
    public static GetAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public GetAspect() { super(); }
}
aspect SetAspect2 {
    static boolean bstar = false;
    
    after():
    set( int (Gets).*) {
        SetAspect2/*SetAspect2*/.bstar = true;
    }
    
    static boolean b0 = false;
    
    after():
    set( int (Gets).nums0) {
        SetAspect2/*SetAspect2*/.b0 = true;
    }
    
    static boolean b1 = false;
    
    after():
    set( int (Gets).nums1) {
        SetAspect2/*SetAspect2*/.b1 = true;
    }
    
    static boolean b2 = false;
    
    after():
    set( int (Gets).nums2) {
        SetAspect2/*SetAspect2*/.b2 = true;
    }
    
    static boolean b3 = false;
    
    after():
    set( int (Gets).nums3) {
        SetAspect2/*SetAspect2*/.b3 = true;
    }
    
    static boolean b4 = false;
    
    after():
    set( int (Gets).nums4) {
        SetAspect2/*SetAspect2*/.b4 = true;
    }
    
    static boolean b5 = false;
    
    after():
    set( int (Gets).nums5) {
        SetAspect2/*SetAspect2*/.b5 = true;
    }
    
    static boolean b6 = false;
    
    after():
    set( int (Gets).nums6) {
        SetAspect2/*SetAspect2*/.b6 = true;
    }
    
    static boolean b7 = false;
    
    after():
    set( int (Gets).nums7) {
        SetAspect2/*SetAspect2*/.b7 = true;
    }
    
    static boolean b8 = false;
    
    after():
    set( int (Gets).nums8) {
        SetAspect2/*SetAspect2*/.b8 = true;
    }
    
    static boolean b9 = false;
    
    after():
    set( int (Gets).nums9) {
        SetAspect2/*SetAspect2*/.b9 = true;
    }
    
    public static SetAspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public SetAspect2() { super(); }
}
retrieve <Gets: void main(java.lang.String[])> from Gets
retrieve <Gets: void go()> from Gets
retrieve <Gets: void <init>()> from Gets
retrieve <GetAspect: void after$7()> from GetAspect
retrieve <GetAspect: void after$8()> from GetAspect
retrieve <GetAspect: void after$9()> from GetAspect
retrieve <GetAspect: void after$10()> from GetAspect
retrieve <GetAspect: GetAspect aspectOf()> from GetAspect
retrieve <GetAspect: boolean hasAspect()> from GetAspect
retrieve <GetAspect: void <init>()> from GetAspect
retrieve <GetAspect: void <clinit>()> from GetAspect
retrieve <GetAspect: void after$0()> from GetAspect
retrieve <GetAspect: void after$1()> from GetAspect
retrieve <GetAspect: void after$2()> from GetAspect
retrieve <GetAspect: void after$3()> from GetAspect
retrieve <GetAspect: void after$4()> from GetAspect
retrieve <GetAspect: void after$5()> from GetAspect
retrieve <GetAspect: void after$6()> from GetAspect
retrieve <SetAspect2: void after$11()> from SetAspect2
retrieve <SetAspect2: void after$12()> from SetAspect2
retrieve <SetAspect2: void after$13()> from SetAspect2
retrieve <SetAspect2: void after$14()> from SetAspect2
retrieve <SetAspect2: void after$15()> from SetAspect2
retrieve <SetAspect2: void after$16()> from SetAspect2
retrieve <SetAspect2: void after$17()> from SetAspect2
retrieve <SetAspect2: void after$18()> from SetAspect2
retrieve <SetAspect2: void after$19()> from SetAspect2
retrieve <SetAspect2: void after$20()> from SetAspect2
retrieve <SetAspect2: void after$21()> from SetAspect2
retrieve <SetAspect2: SetAspect2 aspectOf()> from SetAspect2
retrieve <SetAspect2: boolean hasAspect()> from SetAspect2
retrieve <SetAspect2: void <init>()> from SetAspect2
retrieve <SetAspect2: void <clinit>()> from SetAspect2
Transforming SetAspect2... 
Transforming Gets... 
Transforming GetAspect... 
Abc finished on Thu Jun 24 09:17:55 BST 2004. ( 0 min. 9 sec. )
PASS: Gets and sets on a number of variables (field access ???)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 157 failed (check: 70), 304 passed (check: 81), 0 skipped.
Executing test 462 (new): correct types of parameters at call-sites
Failed. Current status: 158 failed (check: 70), 304 passed (check: 81), 0 skipped.
Executing test 463 (new): Joinpoints are showing up on intermediate call sites
Failed. Current status: 159 failed (check: 70), 304 passed (check: 81), 0 skipped.
Executing test 464 (new): Reception based on strictfp modifier
================================================
Breakdown of abc phases  (total: 8863 millisec.)
------------------------------------------------
[ 00.417% ] Init. of Soot:  37
[ 00.034% ] Loading Jars:  3
[ 69.356% ] Polyglot phases:  6147
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.542% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.417% ] Intertype Adjuster:  37
[ 07.221% ] Retrieving bodies:  640
[ 00.000% ] Weave Initializers:  0
[ 00.248% ] Load shadow types:  22
[ 14.013% ] Compute advice lists:  1242
[ 00.034% ] Intertype weave:  3
[ 00.192% ] Add aspect code:  17
[ 00.147% ] Weaving advice:  13
[ 00.011% ] Validate jimple:  1
[ 04.051% ] Soot Packs:  359
[ 03.272% ] Soot Writing Output:  290
================================================
Failed. Current status: 160 failed (check: 70), 304 passed (check: 81), 0 skipped.
Executing test 465 (new): Subclasses that do not redefine a method are not being handled correctly
================================================
Breakdown of abc phases  (total: 8797 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  4
[ 73.150% ] Polyglot phases:  6435
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.591% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.409% ] Intertype Adjuster:  36
[ 07.230% ] Retrieving bodies:  636
[ 00.000% ] Weave Initializers:  0
[ 00.330% ] Load shadow types:  29
[ 08.844% ] Compute advice lists:  778
[ 00.034% ] Intertype weave:  3
[ 00.114% ] Add aspect code:  10
[ 00.921% ] Weaving advice:  81
[ 00.000% ] Validate jimple:  0
[ 03.876% ] Soot Packs:  341
[ 03.990% ] Soot Writing Output:  351
================================================
Abc started on Thu Jun 24 09:18:17 BST 2004
<<<< PR353b.java >>>>
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import org.aspectj.testing.*;
import java.util.*;

public class PR353b {
    public static void main(java.lang.String[] args) {
        new PR353b().go();
    }
    
    void go() {
        s/*s*/.c = "E";
        C c = new E();
        c.foo();
        s/*s*/.c = "C";
        c = new C();
        c.foo();
        s/*s*/.c = "E";
        E e = new E();
        e.foo();
        s/*s*/.c = "E2";
        E2 e2 = new E2();
        e2.foo();
        s/*s*/.c = "F";
        F f = new F();
        f.foo();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("call C");
               org.aspectj.testing.Tester.expectEvent("call E2");
           }
    
    public PR353b() { super(); }
}
class C {
    void foo() {  }
    
    public C() { super(); }
}
class E extends C {
    public E() { super(); }
}
class F extends E {
    public F() { super(); }
}
class E2 extends C {
    void foo() {  }
    
    public E2() { super(); }
}
class s {
    public static java.lang.String c;
    
    public s() { super(); }
}
aspect A {
    pointcut p3() : this(C) && call(* (*).foo()) && !target(E);
    
    before():
    p3() {
        java.lang.Object target = thisJoinPoint.getTarget();
        org.aspectj.lang.JoinPoint.StaticPart sp =
          thisJoinPoint.getStaticPart();
        org.aspectj.lang.Signature sig = sp.getSignature();
        java.lang.Class dt = sig.getDeclaringType();
        org.aspectj.testing.Tester.check(!(target instanceof E),
                                         target.getClass().getName() +
                                         " instanceof E");
        org.aspectj.testing.Tester.event("call " +
                                         target.getClass().getName());
        org.aspectj.testing.Tester.check(dt ==
                                         PR353b.class,
                                         "dt != instanceof PR353b");
        org.aspectj.testing.Tester.check(!(target instanceof E),
                                         "!instanceof E");
        java.lang.String c =
          thisJoinPoint.getSignature().getDeclaringType().getName();
        org.aspectj.testing.Tester.check(s/*s*/.c.equals(c),
                                         "p3: " + s/*s*/.c + " != " +
                                         c);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <PR353b: void go()> from PR353b
retrieve <PR353b: void <init>()> from PR353b
retrieve <PR353b: void <clinit>()> from PR353b
retrieve <PR353b: void main(java.lang.String[])> from PR353b
retrieve <C: void foo()> from C
retrieve <C: void <init>()> from C
retrieve <E: void <init>()> from E
retrieve <F: void <init>()> from F
retrieve <E2: void foo()> from E2
retrieve <E2: void <init>()> from E2
retrieve <s: void <init>()> from s
retrieve <A: void <init>()> from A
retrieve <A: java.lang.Class class$(java.lang.String)> from A
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming E2... 
Transforming A... 
Transforming E... 
Transforming C... 
Transforming F... 
Transforming s... 
Transforming PR353b... 
Abc finished on Thu Jun 24 09:18:26 BST 2004. ( 0 min. 8 sec. )
PASS: Subclasses that do not redefine a method are not being handled correctly()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 160 failed (check: 70), 305 passed (check: 81), 0 skipped.
Executing test 466 (new): making sure that super calls are bound to the right methods
================================================
Breakdown of abc phases  (total: 9306 millisec.)
------------------------------------------------
[ 00.462% ] Init. of Soot:  43
[ 00.043% ] Loading Jars:  4
[ 72.211% ] Polyglot phases:  6720
[ 00.021% ] Resolve class names:  2
[ 00.021% ] Declare Parents:  2
[ 00.655% ] Recompute name pattern matches:  61
[ 00.000% ] Compute precedence relation:  0
[ 00.430% ] Intertype Adjuster:  40
[ 12.164% ] Retrieving bodies:  1132
[ 00.000% ] Weave Initializers:  0
[ 00.247% ] Load shadow types:  23
[ 04.427% ] Compute advice lists:  412
[ 00.054% ] Intertype weave:  5
[ 00.258% ] Add aspect code:  24
[ 00.355% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 05.405% ] Soot Packs:  503
[ 03.245% ] Soot Writing Output:  302
================================================
Abc started on Thu Jun 24 09:18:29 BST 2004
<<<< SupersAndInterfaces.java >>>>
import org.aspectj.testing.Tester;
import java.io.IOException;

public class SupersAndInterfaces {
    public static void main(java.lang.String[] args)
          throws java.io.IOException {
        new C2().m();
        org.aspectj.testing.Tester.check("ran before");
        new C().toString();
        org.aspectj.testing.Tester.check("ran before toString");
    }
    
    public SupersAndInterfaces() { super(); }
}
class C {
    public void m() throws java.io.IOException {
        if (false) throw new java.io.IOException("testing");
    }
    
    public java.lang.String toString() {
        return super.toString() + "C";
    }
    
    public C() { super(); }
}
interface I {
    public abstract void m() throws java.io.IOException;
}
class C1 extends C implements I {
    public C1() { super(); }
}
class C2 extends C1 {
    static boolean ranBody;
    
    public void m() throws java.io.IOException {
        C2/*C2*/.ranBody = true;
        super.m();
    }
    
    public C2() { super(); }
}
aspect A {
    before():
    call(void (*).m()) {
        org.aspectj.testing.Tester.note("ran before");
        org.aspectj.testing.Tester.check(!C2/*C2*/.ranBody,
                                         "first entry");
    }
    
    before():
    call(String (*).toString()) {
        org.aspectj.testing.Tester.note("ran before toString");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <SupersAndInterfaces: void <init>()> from SupersAndInterfaces
retrieve <SupersAndInterfaces: void main(java.lang.String[])> from SupersAndInterfaces
retrieve <C: void m()> from C
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String toString()> from C
retrieve <C1: void <init>()> from C1
retrieve <C2: void m()> from C2
retrieve <C2: void <init>()> from C2
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming C2... 
Transforming C1... 
Transforming I... 
Transforming SupersAndInterfaces... 
Transforming A... 
Transforming C... 
Abc finished on Thu Jun 24 09:18:38 BST 2004. ( 0 min. 9 sec. )
PASS: making sure that super calls are bound to the right methods()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 160 failed (check: 70), 306 passed (check: 81), 0 skipped.
Executing test 467 (new): inheritance, around advice and abstract pointcuts [eachobject] (still)
Failed. Current status: 161 failed (check: 70), 306 passed (check: 81), 0 skipped.
Executing test 468 (new/foemmel): Priviledged aspect methods are missing for privates. [eachobject]
Failed. Current status: 162 failed (check: 70), 306 passed (check: 81), 0 skipped.
Executing test 469 (new): exceptions thrown and caught in advice, particularly try+proceed
Failed. Current status: 163 failed (check: 70), 306 passed (check: 81), 0 skipped.
Executing test 470 (new): Not and And operators in pointcuts not working
================================================
Breakdown of abc phases  (total: 7869 millisec.)
------------------------------------------------
[ 00.470% ] Init. of Soot:  37
[ 00.051% ] Loading Jars:  4
[ 74.075% ] Polyglot phases:  5829
[ 00.025% ] Resolve class names:  2
[ 00.280% ] Declare Parents:  22
[ 01.029% ] Recompute name pattern matches:  81
[ 00.000% ] Compute precedence relation:  0
[ 00.572% ] Intertype Adjuster:  45
[ 06.418% ] Retrieving bodies:  505
[ 00.000% ] Weave Initializers:  0
[ 00.356% ] Load shadow types:  28
[ 07.930% ] Compute advice lists:  624
[ 00.318% ] Intertype weave:  25
[ 00.457% ] Add aspect code:  36
[ 00.267% ] Weaving advice:  21
[ 00.000% ] Validate jimple:  0
[ 04.829% ] Soot Packs:  380
[ 02.923% ] Soot Writing Output:  230
================================================
Abc started on Thu Jun 24 09:18:55 BST 2004
<<<< NotAndPointcut.java >>>>
import org.aspectj.testing.Tester;

public class NotAndPointcut {
    static java.lang.String str = "";
    
    public static void main(java.lang.String[] args) {
        new NotAndPointcut().showBug();
        org.aspectj.testing.Tester.checkEqual(NotAndPointcut/*NotAndPointcut*/.str,
                                              "ran",
                                              "advice didn\'t run");
    }
    
    public void showBug() {  }
    
    public NotAndPointcut() { super(); }
}
aspect BugInPCD {
    pointcut p() :
    execution (* (NotAndPointcut).showBug(..)) &&
      !(target(NotAndPointcut) && call(* (NotAndPointcut).*(..)));
    
    before(): p() { NotAndPointcut/*NotAndPointcut*/.str += "ran"; }
    
    public static BugInPCD aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public BugInPCD() { super(); }
}
retrieve <NotAndPointcut: void main(java.lang.String[])> from NotAndPointcut
retrieve <NotAndPointcut: void showBug()> from NotAndPointcut
retrieve <NotAndPointcut: void <init>()> from NotAndPointcut
retrieve <NotAndPointcut: void <clinit>()> from NotAndPointcut
retrieve <BugInPCD: void <init>()> from BugInPCD
retrieve <BugInPCD: void before$0()> from BugInPCD
retrieve <BugInPCD: BugInPCD aspectOf()> from BugInPCD
retrieve <BugInPCD: boolean hasAspect()> from BugInPCD
Transforming NotAndPointcut... 
Transforming BugInPCD... 
Abc finished on Thu Jun 24 09:19:03 BST 2004. ( 0 min. 7 sec. )
PASS: Not and And operators in pointcuts not working()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 163 failed (check: 70), 307 passed (check: 81), 0 skipped.
Executing test 471 (new): Member initializers should run before the current class constructor
================================================
Breakdown of abc phases  (total: 8028 millisec.)
------------------------------------------------
[ 00.648% ] Init. of Soot:  52
[ 00.062% ] Loading Jars:  5
[ 80.518% ] Polyglot phases:  6464
[ 00.000% ] Resolve class names:  0
[ 00.025% ] Declare Parents:  2
[ 00.785% ] Recompute name pattern matches:  63
[ 00.000% ] Compute precedence relation:  0
[ 00.598% ] Intertype Adjuster:  48
[ 07.536% ] Retrieving bodies:  605
[ 00.000% ] Weave Initializers:  0
[ 00.286% ] Load shadow types:  23
[ 03.027% ] Compute advice lists:  243
[ 00.062% ] Intertype weave:  5
[ 00.137% ] Add aspect code:  11
[ 00.174% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.326% ] Soot Packs:  267
[ 02.815% ] Soot Writing Output:  226
================================================
Abc started on Thu Jun 24 09:19:06 BST 2004
<<<< MemberInitializationsAfterExplicitConstructorCalls.java >>>>
import org.aspectj.testing.Tester;

public class MemberInitializationsAfterExplicitConstructorCalls {
    public static void main(java.lang.String[] args) {
        MemberInitializationsAfterExplicitConstructorCalls.ThisCall thisCall =
          new MemberInitializationsAfterExplicitConstructorCalls.ThisCall("foo");
        thisCall.go();
        thisCall =
          new MemberInitializationsAfterExplicitConstructorCalls.ThisCall();
        thisCall.go();
    }
    
    static class ThisCall {
        java.lang.String init = "INIT";
        
        java.lang.String member = null;
        
        ThisCall(java.lang.String input) {
            super();
            this/*<unknown>*/.init = input;
            this/*<unknown>*/.member = input;
        }
        
        ThisCall() {
            this("correctValue");
            org.aspectj.testing.Tester.check(!"INIT".equals(this/*null*/.init),
                                             "String constructor: !\"INIT\".equals(init)");
            org.aspectj.testing.Tester.check(null !=
                                             this/*null*/.member,
                                             "String constructor: null != member");
        }
        
        void go() {
            org.aspectj.testing.Tester.check(!"INIT".equals(this/*null*/.init),
                                             "instance method: !\"INIT\".equals(init)");
            org.aspectj.testing.Tester.check(null !=
                                             this/*null*/.member,
                                             "instance method: null != member");
        }
    }
    
    
    public MemberInitializationsAfterExplicitConstructorCalls() {
        super();
    }
}
retrieve <MemberInitializationsAfterExplicitConstructorCalls: void main(java.lang.String[])> from MemberInitializationsAfterExplicitConstructorCalls
retrieve <MemberInitializationsAfterExplicitConstructorCalls: void <init>()> from MemberInitializationsAfterExplicitConstructorCalls
retrieve <MemberInitializationsAfterExplicitConstructorCalls$ThisCall: void <init>()> from MemberInitializationsAfterExplicitConstructorCalls$ThisCall
retrieve <MemberInitializationsAfterExplicitConstructorCalls$ThisCall: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCalls$ThisCall
retrieve <MemberInitializationsAfterExplicitConstructorCalls$ThisCall: void go()> from MemberInitializationsAfterExplicitConstructorCalls$ThisCall
Transforming MemberInitializationsAfterExplicitConstructorCalls... 
Transforming MemberInitializationsAfterExplicitConstructorCalls$ThisCall... 
Abc finished on Thu Jun 24 09:19:14 BST 2004. ( 0 min. 8 sec. )
PASS: Member initializers should run before the current class constructor()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 163 failed (check: 70), 308 passed (check: 81), 0 skipped.
Executing test 472 (new): Coverage tests for Member initializers should run before the current class constructor and after super
================================================
Breakdown of abc phases  (total: 13332 millisec.)
------------------------------------------------
[ 00.278% ] Init. of Soot:  37
[ 00.030% ] Loading Jars:  4
[ 50.825% ] Polyglot phases:  6776
[ 00.000% ] Resolve class names:  0
[ 00.015% ] Declare Parents:  2
[ 00.345% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.300% ] Intertype Adjuster:  40
[ 07.328% ] Retrieving bodies:  977
[ 00.000% ] Weave Initializers:  0
[ 00.173% ] Load shadow types:  23
[ 31.181% ] Compute advice lists:  4157
[ 00.023% ] Intertype weave:  3
[ 00.060% ] Add aspect code:  8
[ 00.113% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 04.710% ] Soot Packs:  628
[ 04.620% ] Soot Writing Output:  616
================================================
Abc started on Thu Jun 24 09:19:17 BST 2004
<<<< MemberInitializationsAfterExplicitConstructorCallsCoverage.java >>>>
import org.aspectj.testing.Tester;

public class MemberInitializationsAfterExplicitConstructorCallsCoverage {
    public static final java.lang.String INPUT = "input";
    
    public static final java.lang.String INIT = "INIT";
    
    public static void main(java.lang.String[] args) { test(); }
    
    public static void test() {
        boolean doPassingTests = true;
        boolean doFailingTests = true;
        {
            MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple thisCall =
              new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple(1);
            thisCall.go();
        }
        if (doPassingTests) {
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopBlock thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopBlock(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomSimple thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomSimple(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomBlock thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomBlock(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallMixed thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallMixed(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild();
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild(2);
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallChild(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
                thisCall.go();
            }
            {
                ThisCallEnclosing.ThisCallEnclosed thisCall =
                  new ThisCallEnclosing("ignored").new ThisCallEnclosed();
            }
        }
        if (doFailingTests) {
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopSimple();
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopBlock thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallTopBlock();
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomSimple thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomSimple();
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomBlock thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallBottomBlock();
                thisCall.go();
            }
            {
                MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallMixed thisCall =
                  new MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallMixed();
                thisCall.go();
            }
        }
    }
    
    static class ThisCallTopSimple {
        int initOne = 1;
        
        java.lang.String initString = "INIT";
        
        java.lang.Object initNull = null;
        
        java.lang.String initNone;
        
        ThisCallTopSimple(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallTopSimple(\" + input + \")");
            setValues(input);
            checkMembersHaveSetValues(("constructor ThisCallTopSimple.ThisCallTopSimple(\" + input +" +
                                       " \")"));
        }
        
        void setValues(java.lang.String input) {
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
        }
        
        ThisCallTopSimple(int ignored) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallTopSimple.ThisCallTopSimple(int)");
            setValues(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallTopSimple.ThisCallTopSimple(int)");
        }
        
        ThisCallTopSimple() {
            this(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallTopSimple.ThisCallTopSimple()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallTopSimple.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
    }
    
    
    static class ThisCallTopBlock {
        int initOne;
        
        java.lang.String initString;
        
        java.lang.Object initNull;
        
        java.lang.String initNone;
        
        {
            this/*null*/.initOne = 1;
            this/*null*/.initString = "INIT";
            this/*null*/.initNull = null;
        }
        
        ThisCallTopBlock(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallTopBlock(\" + input + \")");
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
            checkMembersHaveSetValues("constructor ThisCallTopSimple.ThisCall(\" + input + \")");
        }
        
        ThisCallTopBlock() {
            this(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallTopSimple.ThisCallTopBlock()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallTopBlock.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
    }
    
    
    static class ThisCallBottomSimple {
        ThisCallBottomSimple(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallBottomSimple(\" + input + \")");
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
            checkMembersHaveSetValues(("constructor ThisCallBottomSimple.ThisCallBottomSimple(\" + i" +
                                       "nput + \")"));
        }
        
        ThisCallBottomSimple() {
            this(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallBottomSimple.ThisCallBottomSimple()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallBottomSimple.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
        
        int initOne = 1;
        
        java.lang.String initString = "INIT";
        
        java.lang.Object initNull = null;
        
        java.lang.String initNone;
    }
    
    
    static class ThisCallBottomBlock {
        ThisCallBottomBlock(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallBottomBlock(\" + input + \")");
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
            checkMembersHaveSetValues(("constructor ThisCallBottomBlock.ThisCallBottomBlock(\" + inp" +
                                       "ut + \")"));
        }
        
        ThisCallBottomBlock() {
            this(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallBottemBlock.ThisCallBottomBlock()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallBottomBlock.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
        
        int initOne;
        
        java.lang.String initString;
        
        java.lang.Object initNull;
        
        java.lang.String initNone;
        
        {
            this/*null*/.initOne = 1;
            this/*null*/.initString = "INIT";
            this/*null*/.initNull = null;
        }
    }
    
    
    static class ThisCallMixed {
        int initOne = 1;
        
        java.lang.String initString;
        
        ThisCallMixed(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallMixed(\" + input + \")");
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
            checkMembersHaveSetValues("constructor ThisCallMixed.ThisCallMixed(\" + input + \")");
        }
        
        ThisCallMixed() {
            this(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallMixed.ThisCallMixed()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallMixed.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
        
        java.lang.String initNone;
        
        java.lang.Object initNull;
        
        {
            this/*null*/.initString = "INIT";
            this/*null*/.initNull = null;
        }
    }
    
    
    static class ThisCallChild extends MemberInitializationsAfterExplicitConstructorCallsCoverage.ThisCallParent {
        int initOne = 1;
        
        java.lang.String initString = "INIT";
        
        java.lang.Object initNull = null;
        
        java.lang.String initNone;
        
        ThisCallChild(java.lang.String input) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallChild(\" + input + \")");
            setValues(input);
            checkMembersHaveSetValues("constructor ThisCallChild.ThisCallChild((\" + input + \")");
            ;
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  "ThisCallChild.ThisCallChild(int ignored)");
        }
        
        void setValues(java.lang.String input) {
            this/*<unknown>*/.initString = input;
            this/*<unknown>*/.initNull = input;
            this/*<unknown>*/.initNone = input;
            this/*<unknown>*/.initOne = 2;
        }
        
        private static java.lang.String checkObject(java.lang.String correctResult,
                                                    java.lang.Object expected,
                                                    java.lang.Object actual,
                                                    java.lang.String failedResult,
                                                    java.lang.String testerMessage) {
            if (null == expected) {
                if (null == actual) { return correctResult; }
            } else
                if (null != actual && expected.equals(actual)) {
                    return correctResult;
                }
            if (null != testerMessage) {
                org.aspectj.testing.Tester.checkEqual(actual,
                                                      expected,
                                                      testerMessage);
            }
            return failedResult;
        }
        
        ThisCallChild(int ignored) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallChild.ThisCallChild(int)");
            setValues(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallChild.ThisCallChild(int)");
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  "ThisCallChild.ThisCallChild(int ignored)");
        }
        
        ThisCallChild() {
            super(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveInitializedValues("constructor ThisCallChild.ThisCallChild()");
            setValues(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallChild.ThisCallChild()");
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  "ThisCallChild.ThisCallChild()");
        }
        
        private static final java.lang.String tccsuperlabel =
          ("ThisCallChild.ThisCallChild(long)/* parent initialization co" +
           "mplete before child */");
        
        ThisCallChild(long ignored) {
            super();
            checkMembersHaveInitializedValues("constructor ThisCallChild.ThisCallChild()");
            setValues(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT);
            checkMembersHaveSetValues("constructor ThisCallChild.ThisCallChild()");
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  "ThisCallChild.ThisCallChild()");
        }
        
        void go() {
            checkMembersHaveSetValues("method ThisCallChild.go()");
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  "ThisCallChild.go()");
        }
        
        protected void checkMembersHaveInitializedValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual("INIT",
                                                  this/*null*/.initString,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual((java.lang.Object)
                                                    null,
                                                  this/*null*/.initNone,
                                                  label +
                                                  " initialized ");
            org.aspectj.testing.Tester.checkEqual(1,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " initialized ");
        }
        
        protected void checkMembersHaveSetValues(java.lang.String label) {
            org.aspectj.testing.Tester.checkEqual(2,
                                                  this/*null*/.initOne,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initString,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual("input",
                                                  this/*null*/.initNone,
                                                  label +
                                                  " set ");
            org.aspectj.testing.Tester.checkEqual(MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT,
                                                  this/*null*/.initNull,
                                                  label +
                                                  " set ");
        }
    }
    
    
    static class ThisCallParent {
        protected java.lang.Object parentObject =
          MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INIT;
        
        protected java.lang.Object getParentObject() {
            return this/*null*/.parentObject;
        }
        
        ThisCallParent() {
            super();
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INIT,
                                                  "ThisCallParent.ThisCallParent()");
            this/*null*/.parentObject =
              MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INPUT;
        }
        
        ThisCallParent(java.lang.String input) {
            super();
            org.aspectj.testing.Tester.checkEqual(this/*null*/.parentObject,
                                                  MemberInitializationsAfterExplicitConstructorCallsCoverage/*MemberInitializationsAfterExplicitConstructorCallsCoverage*/.INIT,
                                                  "ThisCallParent.ThisCallParent(\"" +
                                                  input +
                                                  "\")");
            this/*null*/.parentObject = input;
        }
    }
    
    
    public MemberInitializationsAfterExplicitConstructorCallsCoverage() {
        super();
    }
}
class ThisCallEnclosing {
    public static final java.lang.String INPUT = "input";
    
    public static final java.lang.String INIT = "INIT";
    
    java.lang.String initString =
      ThisCallEnclosing/*ThisCallEnclosing*/.INIT;
    
    java.lang.String constructedString;
    
    public ThisCallEnclosing.ThisCallEnclosed getEnclosed() {
        return this.new ThisCallEnclosing.ThisCallEnclosed();
    }
    
    ThisCallEnclosing(java.lang.String ignored) {
        super();
        this/*null*/.constructedString =
          ThisCallEnclosing/*ThisCallEnclosing*/.INPUT;
        this/*null*/.initString =
          ThisCallEnclosing/*ThisCallEnclosing*/.INPUT;
    }
    
    public class ThisCallEnclosed {
        boolean didCheck;
        
        {
            org.aspectj.testing.Tester.checkEqual(ThisCallEnclosing/*ThisCallEnclosing*/.INPUT,
                                                  ThisCallEnclosing.this/*null*/.initString,
                                                  "ThisCallEnclosed.<initializer> initString");
            org.aspectj.testing.Tester.checkEqual(ThisCallEnclosing/*ThisCallEnclosing*/.INPUT,
                                                  ThisCallEnclosing.this/*null*/.constructedString,
                                                  "ThisCallEnclosed.<initializer> constructedString");
            this/*null*/.didCheck = true;
        }
        
        public ThisCallEnclosed() {
            this("init: " +
                 ThisCallEnclosing.this/*null*/.initString +
                 " constructed: " +
                 ThisCallEnclosing.this/*null*/.constructedString);
            org.aspectj.testing.Tester.check(this/*null*/.didCheck,
                                             "initializer ran before ThisCallEnclosed() body");
        }
        
        public ThisCallEnclosed(java.lang.String s) {
            super();
            org.aspectj.testing.Tester.checkEqual(ThisCallEnclosing/*ThisCallEnclosing*/.INPUT,
                                                  ThisCallEnclosing.this/*null*/.initString,
                                                  "ThisCallEnclosed(String) initString");
            org.aspectj.testing.Tester.checkEqual(ThisCallEnclosing/*ThisCallEnclosing*/.INPUT,
                                                  ThisCallEnclosing.this/*null*/.constructedString,
                                                  "ThisCallEnclosed(String) constructedString");
            org.aspectj.testing.Tester.check(this/*null*/.didCheck,
                                             "initializer ran before ThisCallEnclosed(String) body");
        }
    }
    
}
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage: void main(java.lang.String[])> from MemberInitializationsAfterExplicitConstructorCallsCoverage
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage: void test()> from MemberInitializationsAfterExplicitConstructorCallsCoverage
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage: void <clinit>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void setValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void <init>(int)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void checkMembersHaveInitializedValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void checkMembersHaveSetValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void setValues(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: java.lang.String checkObject(java.lang.String,java.lang.Object,java.lang.Object,java.lang.String,java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void <init>(int)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void <init>(long)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void <clinit>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild: void go()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent: java.lang.Object getParentObject()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent: void <init>(java.lang.String)> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent
retrieve <MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent: void <init>()> from MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent
retrieve <ThisCallEnclosing: ThisCallEnclosing$ThisCallEnclosed getEnclosed()> from ThisCallEnclosing
retrieve <ThisCallEnclosing: void <init>(java.lang.String)> from ThisCallEnclosing
retrieve <ThisCallEnclosing: void <clinit>()> from ThisCallEnclosing
retrieve <ThisCallEnclosing$ThisCallEnclosed: void <init>(ThisCallEnclosing,java.lang.String)> from ThisCallEnclosing$ThisCallEnclosed
retrieve <ThisCallEnclosing$ThisCallEnclosed: void <init>(ThisCallEnclosing)> from ThisCallEnclosing$ThisCallEnclosed
Transforming ThisCallEnclosing... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage... 
Transforming ThisCallEnclosing$ThisCallEnclosed... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomBlock... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallParent... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallMixed... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallChild... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopBlock... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallBottomSimple... 
Transforming MemberInitializationsAfterExplicitConstructorCallsCoverage$ThisCallTopSimple... 
Abc finished on Thu Jun 24 09:19:30 BST 2004. ( 0 min. 13 sec. )
PASS: Coverage tests for Member initializers should run before the current cla...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 14 seconds
Passed. Current status: 163 failed (check: 70), 309 passed (check: 81), 0 skipped.
Executing test 473 (new): thisJoinPoint{Static} not visible in if() pcd of named pointcut
Failed. Current status: 164 failed (check: 70), 309 passed (check: 81), 0 skipped.
Executing test 474 (new): pcd if() expression visibility at compile-time  (minimal operation)
Failed. Current status: 165 failed (check: 70), 309 passed (check: 81), 0 skipped.
Executing test 475 (new): pcd if() NPE in compiler when unwinding assignment in pcd if(expr)
================================================
Breakdown of abc phases  (total: 7327 millisec.)
------------------------------------------------
[ 00.532% ] Init. of Soot:  39
[ 00.055% ] Loading Jars:  4
[ 76.334% ] Polyglot phases:  5593
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.601% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.819% ] Intertype Adjuster:  60
[ 06.701% ] Retrieving bodies:  491
[ 00.000% ] Weave Initializers:  0
[ 00.328% ] Load shadow types:  24
[ 01.133% ] Compute advice lists:  83
[ 00.055% ] Intertype weave:  4
[ 00.273% ] Add aspect code:  20
[ 00.177% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 10.086% ] Soot Packs:  739
[ 02.852% ] Soot Writing Output:  209
================================================
Abc started on Thu Jun 24 09:19:40 BST 2004
<<<< IfPCDExprAssignUnparseFailure.java >>>>
import org.aspectj.testing.Tester;

public class IfPCDExprAssignUnparseFailure {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true, "compiler test");
    }
    
    public IfPCDExprAssignUnparseFailure() { super(); }
}
aspect AspectFor {
    static int i;
    
    pointcut namedIf() : if(0 == (AspectFor/*AspectFor*/.i = 2));
    
    public static AspectFor aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AspectFor() { super(); }
}
retrieve <IfPCDExprAssignUnparseFailure: void main(java.lang.String[])> from IfPCDExprAssignUnparseFailure
retrieve <IfPCDExprAssignUnparseFailure: void <init>()> from IfPCDExprAssignUnparseFailure
retrieve <AspectFor: AspectFor aspectOf()> from AspectFor
retrieve <AspectFor: boolean hasAspect()> from AspectFor
retrieve <AspectFor: void <init>()> from AspectFor
retrieve <AspectFor: boolean if$0()> from AspectFor
Transforming AspectFor... 
Transforming IfPCDExprAssignUnparseFailure... 
Abc finished on Thu Jun 24 09:19:47 BST 2004. ( 0 min. 7 sec. )
PASS: pcd if() NPE in compiler when unwinding assignment in pcd if(expr)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 165 failed (check: 70), 310 passed (check: 81), 0 skipped.
Executing test 476 (new): pcd if() dup methods produced when pointcut after advice etc (javac)
================================================
Breakdown of abc phases  (total: 7288 millisec.)
------------------------------------------------
[ 00.535% ] Init. of Soot:  39
[ 00.055% ] Loading Jars:  4
[ 73.120% ] Polyglot phases:  5329
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.659% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.508% ] Intertype Adjuster:  37
[ 06.751% ] Retrieving bodies:  492
[ 00.000% ] Weave Initializers:  0
[ 00.316% ] Load shadow types:  23
[ 02.017% ] Compute advice lists:  147
[ 05.818% ] Intertype weave:  424
[ 00.810% ] Add aspect code:  59
[ 00.535% ] Weaving advice:  39
[ 00.000% ] Validate jimple:  0
[ 05.530% ] Soot Packs:  403
[ 03.293% ] Soot Writing Output:  240
================================================
Abc started on Thu Jun 24 09:19:50 BST 2004
<<<< IfPCDDupMethod.java >>>>
public class IfPCDDupMethod {
    public static void main(java.lang.String[] args) {  }
    
    public IfPCDDupMethod() { super(); }
}
aspect AlreadyDefined {
    before(): ifFalse(java.lang.Object) { signal(""); }
    
    pointcut ifFalse(java.lang.Object t) :
    this(t) &&
      if(t instanceof java.lang.Runnable);
    
    after():
    withincode(static void (IfPCDDupMethod).main(String[])) {
        signal("");
    }
    
    static void signal(java.lang.String msg) {  }
    
    public static AlreadyDefined aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AlreadyDefined() { super(); }
}
retrieve <IfPCDDupMethod: void main(java.lang.String[])> from IfPCDDupMethod
retrieve <IfPCDDupMethod: void <init>()> from IfPCDDupMethod
retrieve <AlreadyDefined: void <init>()> from AlreadyDefined
retrieve <AlreadyDefined: void before$0()> from AlreadyDefined
retrieve <AlreadyDefined: void after$1()> from AlreadyDefined
retrieve <AlreadyDefined: void signal(java.lang.String)> from AlreadyDefined
retrieve <AlreadyDefined: AlreadyDefined aspectOf()> from AlreadyDefined
retrieve <AlreadyDefined: boolean hasAspect()> from AlreadyDefined
retrieve <AlreadyDefined: boolean if$2(java.lang.Object)> from AlreadyDefined
Transforming IfPCDDupMethod... 
Transforming AlreadyDefined... 
Abc finished on Thu Jun 24 09:19:57 BST 2004. ( 0 min. 7 sec. )
PASS: pcd if() dup methods produced when pointcut after advice etc (javac)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 165 failed (check: 70), 311 passed (check: 81), 0 skipped.
Executing test 477 (new): pcd if() variants: [anonymous, named] x [execution, call, callTyped, get, set, initializations] x [before, after, around]
================================================
Breakdown of abc phases  (total: 12520 millisec.)
------------------------------------------------
[ 00.312% ] Init. of Soot:  39
[ 00.024% ] Loading Jars:  3
[ 60.615% ] Polyglot phases:  7589
[ 00.016% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  2
[ 00.423% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.335% ] Intertype Adjuster:  42
[ 08.075% ] Retrieving bodies:  1011
[ 00.000% ] Weave Initializers:  0
[ 00.192% ] Load shadow types:  24
[ 13.618% ] Compute advice lists:  1705
[ 00.032% ] Intertype weave:  4
[ 00.168% ] Add aspect code:  21
[ 01.989% ] Weaving advice:  249
[ 00.000% ] Validate jimple:  0
[ 07.684% ] Soot Packs:  962
[ 06.502% ] Soot Writing Output:  814
================================================
Abc started on Thu Jun 24 09:20:00 BST 2004
<<<< IfPCDAdviceMethods.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

class TestContext {
    public static void signal(java.lang.String event) {
        org.aspectj.testing.Tester.event(event);
    }
    
    public static void expectSignal(java.lang.String event) {
        org.aspectj.testing.Tester.expectEvent(event);
    }
    
    public static void startTest() {  }
    
    public static void endTest() {
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    public static void testFailed(java.lang.String failureMessage) {
        org.aspectj.testing.Tester.check(false, failureMessage);
    }
    
    public TestContext() { super(); }
}
class BaseApp {
    int i;
    
    int get() { return this/*null*/.i; }
    
    void set(int i) { this/*<unknown>*/.i = i; }
    
    void uncountedCall() {  }
    
    void callFromOutside(int i) { call(i); }
    
    private void call(int i) { TestContext.signal("call(int)"); }
    
    public BaseApp() { super(); }
}
public class IfPCDAdviceMethods {
    public static void main(java.lang.String[] args) {
        TestContext.startTest();
        BaseApp target = new BaseApp();
        target.callFromOutside(0);
        target.uncountedCall();
        target.set(1);
        if (!(1 == target.get())) {
            TestContext.testFailed("1 != target.get()");
        }
        TestContext.endTest();
    }
    
    static {
               java.lang.String[] cuts =
                 { "call_pc", "callType_pc", "execution_pc", "get_pc", "set_pc", "initialization_pc" };
               java.lang.String[] kinds =
                 { "before", "after", "around" };
               java.lang.String[] ifs =
                 { "if(true)", "namedIf()", "anonymous" };
               for (int i = 0; i < cuts/*null*/.length; i++) {
                   for (int j = 0; j < kinds/*null*/.length; j++) {
                       for (int k = 0; k < ifs/*null*/.length; k++) {
                           if (kinds[j].equals("around") &&
                               cuts[i].equals("initialization_pc"))
                               continue;
                           TestContext.expectSignal(kinds[j] + "." +
                                                    cuts[i] +
                                                    "." +
                                                    ifs[k]);
                       }
                   }
               }
               TestContext.expectSignal("call(int)");
               final int namedIfCalls =
                 2 * cuts/*null*/.length * (ifs/*null*/.length - 1) -
               1;
               for (int i = 0; i < namedIfCalls; i++) {
                   TestContext.expectSignal("executedNamedIf:" + i);
               }
           }
    
    public IfPCDAdviceMethods() { super(); }
}
aspect TestSignals {
    pointcut errorIfCalled() :
    call(boolean (*).executedNamedIfNever(..));
    
    after():
    errorIfCalled() {
        java.lang.StringBuffer sb = new java.lang.StringBuffer();
        sb.append("TestSignals.after() : errorIfCalled()");
        org.aspectj.lang.JoinPoint.StaticPart sp =
          thisJoinPointStaticPart;
        if (null == sp) {
            sb.append("null thisJoinPointStaticPart");
        } else {
            sb.append(" kind=" + sp.getKind());
            sb.append(" signature=" + sp.getSignature());
            sb.append(" source=" + sp.getSourceLocation());
        }
        TestContext.testFailed(sb.toString());
    }
    
    public static TestSignals aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public TestSignals() { super(); }
}
aspect Aspect {
    static int namedIfCounter;
    
    static int namedIfNeverCounter;
    
    static int i;
    
    static boolean executedNamedIf() {
        a("executedNamedIf:" + Aspect/*Aspect*/.namedIfCounter++);
        return true;
    }
    
    static boolean executedNamedIfNever() {
        a("executedNamedIfNever:" +
          Aspect/*Aspect*/.namedIfNeverCounter++);
        return true;
    }
    
    pointcut namedIf() :
    !within(Aspect) &&
      if(1 == 0 || executedNamedIf());
    
    pointcut namedIfNever() : if(1 == 1 && executedNamedIfNever());
    
    pointcut ifTrue() : if(true);
    
    pointcut ifFalse() : if(false);
    
    pointcut set_pc() : if(true) && set( int (BaseApp).i);
    
    pointcut get_pc() : if(true) && get( int (BaseApp).i);
    
    pointcut call_pc() :
    if(true) && call(void (*).call(int)) &&
      within(BaseApp);
    
    pointcut callType_pc() :
    if(true) &&
      call(void (BaseApp).call(int));
    
    pointcut execution_pc() :
    if(true) && within(BaseApp) &&
      execution (void (*).*(int));
    
    pointcut initialization_pc() :
    if(true) &&
      initialization((BaseApp).new(..));
    
    pointcut named_set_pc() : namedIf() && set( int (BaseApp).i);
    
    pointcut named_get_pc() : namedIf() && get( int (BaseApp).i);
    
    pointcut named_call_pc() :
    namedIf() && call(void (*).call(int)) &&
      within(BaseApp);
    
    pointcut named_callType_pc() :
    namedIf() && call(void (BaseApp).call(int)) &&
      within(BaseApp);
    
    pointcut named_execution_pc() :
    namedIf() &&
      execution (void (*).*(int));
    
    pointcut named_initialization_pc() :
    namedIf() &&
      initialization((BaseApp).new(..));
    
    before(): set_pc() { a("before.set_pc.if(true)"); }
    
    before(): get_pc() { a("before.get_pc.if(true)"); }
    
    before(): call_pc() { a("before.call_pc.if(true)"); }
    
    before(): callType_pc() { a("before.callType_pc.if(true)"); }
    
    before(): execution_pc() { a("before.execution_pc.if(true)"); }
    
    before():
    initialization_pc() {
        a("before.initialization_pc.if(true)");
    }
    
    before(): named_set_pc() { a("before.set_pc.namedIf()"); }
    
    before(): named_get_pc() { a("before.get_pc.namedIf()"); }
    
    before(): named_call_pc() { a("before.call_pc.namedIf()"); }
    
    before():
    named_callType_pc() {
        a("before.callType_pc.namedIf()");
    }
    
    before():
    named_execution_pc() {
        a("before.execution_pc.namedIf()");
    }
    
    before():
    named_initialization_pc() {
        a("before.initialization_pc.namedIf()");
    }
    
    Object around ():
    set_pc() {
        a("around.set_pc.if(true)");
        return this.proceed();
    }
    
    int around ():
    get_pc() {
        a("around.get_pc.if(true)");
        return this.proceed();
    }
    
    void around ():
    call_pc() {
        a("around.call_pc.if(true)");
        this.proceed();
    }
    
    void around ():
    callType_pc() {
        a("around.callType_pc.if(true)");
        this.proceed();
    }
    
    void around ():
    execution_pc() {
        a("around.execution_pc.if(true)");
        this.proceed();
    }
    
    Object around ():
    named_set_pc() {
        a("around.set_pc.namedIf()");
        return this.proceed();
    }
    
    int around ():
    named_get_pc() {
        a("around.get_pc.namedIf()");
        return this.proceed();
    }
    
    void around ():
    named_call_pc() {
        a("around.call_pc.namedIf()");
        this.proceed();
    }
    
    void around ():
    named_callType_pc() {
        a("around.callType_pc.namedIf()");
        this.proceed();
    }
    
    void around ():
    named_execution_pc() {
        a("around.execution_pc.namedIf()");
        this.proceed();
    }
    
    after(): set_pc() { a("after.set_pc.if(true)"); }
    
    after(): get_pc() { a("after.get_pc.if(true)"); }
    
    after(): call_pc() { a("after.call_pc.if(true)"); }
    
    after(): callType_pc() { a("after.callType_pc.if(true)"); }
    
    after(): execution_pc() { a("after.execution_pc.if(true)"); }
    
    after():
    initialization_pc() {
        a("after.initialization_pc.if(true)");
    }
    
    after(): named_set_pc() { a("after.set_pc.namedIf()"); }
    
    after(): named_get_pc() { a("after.get_pc.namedIf()"); }
    
    after(): named_call_pc() { a("after.call_pc.namedIf()"); }
    
    after(): named_callType_pc() { a("after.callType_pc.namedIf()"); }
    
    after():
    named_execution_pc() {
        a("after.execution_pc.namedIf()");
    }
    
    after():
    named_initialization_pc() {
        a("after.initialization_pc.namedIf()");
    }
    
    static void a(java.lang.String msg) { TestContext.signal(msg); }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
aspect Aspect2 {
    before():
    if(true) &&
      set( int (BaseApp).i) {
        a("before.set_pc.anonymous");
    }
    
    before():
    if(true) &&
      get( int (BaseApp).i) {
        a("before.get_pc.anonymous");
    }
    
    before():
    if(true) &&
      call(void (*).uncountedCall()) {
        a("before.call_pc.anonymous");
    }
    
    before():
    if(true) &&
      call(void (BaseApp).uncountedCall()) {
        a("before.callType_pc.anonymous");
    }
    
    before():
    if(true) &&
      execution (void (BaseApp).uncountedCall()) {
        a("before.execution_pc.anonymous");
    }
    
    before():
    if(true) &&
      initialization((BaseApp).new(..)) {
        a("before.initialization_pc.anonymous");
    }
    
    Object around ():
    if(true) &&
      set( int (BaseApp).i) {
        a("around.set_pc.anonymous");
        return this.proceed();
    }
    
    int around ():
    if(true) &&
      get( int (BaseApp).i) {
        a("around.get_pc.anonymous");
        return this.proceed();
    }
    
    void around ():
    if(true) &&
      call(void (*).uncountedCall()) {
        a("around.call_pc.anonymous");
        this.proceed();
    }
    
    void around ():
    if(true) &&
      call(void (BaseApp).uncountedCall()) {
        a("around.callType_pc.anonymous");
        this.proceed();
    }
    
    void around ():
    if(true) &&
      execution (void (BaseApp).uncountedCall()) {
        a("around.execution_pc.anonymous");
        this.proceed();
    }
    
    after():
    if(true) &&
      set( int (BaseApp).i) {
        a("after.set_pc.anonymous");
    }
    
    after():
    if(true) &&
      get( int (BaseApp).i) {
        a("after.get_pc.anonymous");
    }
    
    after():
    if(true) &&
      call(void (*).uncountedCall()) {
        a("after.call_pc.anonymous");
    }
    
    after():
    if(true) &&
      call(void (BaseApp).uncountedCall()) {
        a("after.callType_pc.anonymous");
    }
    
    after():
    if(true) &&
      execution (void (BaseApp).uncountedCall()) {
        a("after.execution_pc.anonymous");
    }
    
    after():
    if(true) &&
      initialization((BaseApp).new(..)) {
        a("after.initialization_pc.anonymous");
    }
    
    static void a(java.lang.String msg) { TestContext.signal(msg); }
    
    public static Aspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect2() { super(); }
}
retrieve <TestContext: void <init>()> from TestContext
retrieve <TestContext: void signal(java.lang.String)> from TestContext
retrieve <TestContext: void expectSignal(java.lang.String)> from TestContext
retrieve <TestContext: void startTest()> from TestContext
retrieve <TestContext: void endTest()> from TestContext
retrieve <TestContext: void testFailed(java.lang.String)> from TestContext
retrieve <BaseApp: int get()> from BaseApp
retrieve <BaseApp: void set(int)> from BaseApp
retrieve <BaseApp: void uncountedCall()> from BaseApp
retrieve <BaseApp: void callFromOutside(int)> from BaseApp
retrieve <BaseApp: void call(int)> from BaseApp
retrieve <BaseApp: void <init>()> from BaseApp
retrieve <IfPCDAdviceMethods: void <clinit>()> from IfPCDAdviceMethods
retrieve <IfPCDAdviceMethods: void main(java.lang.String[])> from IfPCDAdviceMethods
retrieve <IfPCDAdviceMethods: void <init>()> from IfPCDAdviceMethods
retrieve <TestSignals: TestSignals aspectOf()> from TestSignals
retrieve <TestSignals: boolean hasAspect()> from TestSignals
retrieve <TestSignals: void <init>()> from TestSignals
retrieve <TestSignals: void after$0(org.aspectj.lang.JoinPoint$StaticPart)> from TestSignals
retrieve <Aspect: boolean if$52()> from Aspect
retrieve <Aspect: boolean if$54()> from Aspect
retrieve <Aspect: boolean if$55()> from Aspect
retrieve <Aspect: boolean if$56()> from Aspect
retrieve <Aspect: boolean if$57()> from Aspect
retrieve <Aspect: boolean if$58()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: boolean if$59()> from Aspect
retrieve <Aspect: boolean if$60()> from Aspect
retrieve <Aspect: boolean if$61()> from Aspect
retrieve <Aspect: java.lang.Object proceed$62()> from Aspect
retrieve <Aspect: int proceed$63()> from Aspect
retrieve <Aspect: void proceed$64()> from Aspect
retrieve <Aspect: void proceed$65()> from Aspect
retrieve <Aspect: void proceed$66()> from Aspect
retrieve <Aspect: java.lang.Object proceed$67()> from Aspect
retrieve <Aspect: int proceed$68()> from Aspect
retrieve <Aspect: void proceed$69()> from Aspect
retrieve <Aspect: void proceed$70()> from Aspect
retrieve <Aspect: void proceed$71()> from Aspect
retrieve <Aspect: boolean executedNamedIf()> from Aspect
retrieve <Aspect: boolean executedNamedIfNever()> from Aspect
retrieve <Aspect: void before$1()> from Aspect
retrieve <Aspect: void before$2()> from Aspect
retrieve <Aspect: void before$3()> from Aspect
retrieve <Aspect: void before$4()> from Aspect
retrieve <Aspect: void before$5()> from Aspect
retrieve <Aspect: void before$6()> from Aspect
retrieve <Aspect: void before$7()> from Aspect
retrieve <Aspect: void before$8()> from Aspect
retrieve <Aspect: void before$9()> from Aspect
retrieve <Aspect: void before$10()> from Aspect
retrieve <Aspect: void before$11()> from Aspect
retrieve <Aspect: void before$12()> from Aspect
retrieve <Aspect: java.lang.Object around$13()> from Aspect
retrieve <Aspect: int around$14()> from Aspect
retrieve <Aspect: void around$15()> from Aspect
retrieve <Aspect: void around$16()> from Aspect
retrieve <Aspect: void around$17()> from Aspect
retrieve <Aspect: java.lang.Object around$18()> from Aspect
retrieve <Aspect: int around$19()> from Aspect
retrieve <Aspect: void around$20()> from Aspect
retrieve <Aspect: void around$21()> from Aspect
retrieve <Aspect: void around$22()> from Aspect
retrieve <Aspect: void after$23()> from Aspect
retrieve <Aspect: void after$24()> from Aspect
retrieve <Aspect: void after$25()> from Aspect
retrieve <Aspect: void after$26()> from Aspect
retrieve <Aspect: void after$27()> from Aspect
retrieve <Aspect: void after$28()> from Aspect
retrieve <Aspect: void after$29()> from Aspect
retrieve <Aspect: void after$30()> from Aspect
retrieve <Aspect: void after$31()> from Aspect
retrieve <Aspect: void after$32()> from Aspect
retrieve <Aspect: void after$33()> from Aspect
retrieve <Aspect: void after$34()> from Aspect
retrieve <Aspect: void a(java.lang.String)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: boolean if$53()> from Aspect
retrieve <Aspect2: void <init>()> from Aspect2
retrieve <Aspect2: void before$35()> from Aspect2
retrieve <Aspect2: void before$36()> from Aspect2
retrieve <Aspect2: void before$37()> from Aspect2
retrieve <Aspect2: void before$38()> from Aspect2
retrieve <Aspect2: void before$39()> from Aspect2
retrieve <Aspect2: void before$40()> from Aspect2
retrieve <Aspect2: java.lang.Object around$41()> from Aspect2
retrieve <Aspect2: int around$42()> from Aspect2
retrieve <Aspect2: void around$43()> from Aspect2
retrieve <Aspect2: void around$44()> from Aspect2
retrieve <Aspect2: void around$45()> from Aspect2
retrieve <Aspect2: void after$46()> from Aspect2
retrieve <Aspect2: void after$47()> from Aspect2
retrieve <Aspect2: void after$48()> from Aspect2
retrieve <Aspect2: void after$49()> from Aspect2
retrieve <Aspect2: void after$50()> from Aspect2
retrieve <Aspect2: void after$51()> from Aspect2
retrieve <Aspect2: Aspect2 aspectOf()> from Aspect2
retrieve <Aspect2: boolean if$72()> from Aspect2
retrieve <Aspect2: boolean if$73()> from Aspect2
retrieve <Aspect2: boolean if$74()> from Aspect2
retrieve <Aspect2: boolean if$75()> from Aspect2
retrieve <Aspect2: boolean if$76()> from Aspect2
retrieve <Aspect2: boolean if$77()> from Aspect2
retrieve <Aspect2: boolean if$79()> from Aspect2
retrieve <Aspect2: java.lang.Object proceed$78()> from Aspect2
retrieve <Aspect2: boolean if$81()> from Aspect2
retrieve <Aspect2: int proceed$80()> from Aspect2
retrieve <Aspect2: boolean if$83()> from Aspect2
retrieve <Aspect2: void proceed$82()> from Aspect2
retrieve <Aspect2: boolean if$85()> from Aspect2
retrieve <Aspect2: void proceed$84()> from Aspect2
retrieve <Aspect2: boolean if$87()> from Aspect2
retrieve <Aspect2: void proceed$86()> from Aspect2
retrieve <Aspect2: boolean if$88()> from Aspect2
retrieve <Aspect2: boolean if$89()> from Aspect2
retrieve <Aspect2: boolean if$90()> from Aspect2
retrieve <Aspect2: boolean if$91()> from Aspect2
retrieve <Aspect2: boolean if$92()> from Aspect2
retrieve <Aspect2: boolean if$93()> from Aspect2
retrieve <Aspect2: boolean hasAspect()> from Aspect2
retrieve <Aspect2: void a(java.lang.String)> from Aspect2
Transforming BaseApp... 
Transforming TestContext... 
Transforming TestSignals... 
Transforming Aspect... 
Transforming Aspect2... 
Transforming IfPCDAdviceMethods... 
Transforming abc$access$Aspect$around$19... 
Transforming abc$access$Aspect$around$14... 
Transforming abc$access$Aspect2$around$42... 
Transforming abc$access$Aspect$around$18... 
Transforming abc$access$Aspect$around$13... 
Transforming abc$access$Aspect2$around$41... 
Transforming abc$access$Aspect$around$22... 
Transforming abc$access$Aspect$around$17... 
Transforming abc$access$Aspect2$around$45... 
Transforming abc$access$Aspect$around$21... 
Transforming abc$access$Aspect$around$20... 
Transforming abc$access$Aspect$around$16... 
Transforming abc$access$Aspect$around$15... 
Transforming abc$access$Aspect2$around$44... 
Transforming abc$access$Aspect2$around$43... 
Abc finished on Thu Jun 24 09:20:12 BST 2004. ( 0 min. 12 sec. )
PASS: pcd if() variants: [anonymous, named] x [execution, call, callTyped, get...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 13 seconds
Passed. Current status: 165 failed (check: 70), 312 passed (check: 81), 0 skipped.
Executing test 478 (new/pr456): advice on advice in usejavac mode
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(1 options 2 paths)" because old ajc 1.0 option: usejavac
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 165 failed (check: 70), 312 passed (check: 81), 1 skipped.
Executing test 479 (new): initialization order with this
================================================
Breakdown of abc phases  (total: 6954 millisec.)
------------------------------------------------
[ 00.546% ] Init. of Soot:  38
[ 00.144% ] Loading Jars:  10
[ 80.774% ] Polyglot phases:  5617
[ 00.000% ] Resolve class names:  0
[ 00.029% ] Declare Parents:  2
[ 00.676% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.561% ] Intertype Adjuster:  39
[ 07.550% ] Retrieving bodies:  525
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  23
[ 02.229% ] Compute advice lists:  155
[ 00.043% ] Intertype weave:  3
[ 00.115% ] Add aspect code:  8
[ 00.187% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.581% ] Soot Packs:  249
[ 03.236% ] Soot Writing Output:  225
================================================
Abc started on Thu Jun 24 09:20:16 BST 2004
<<<< InitializationOrder.java >>>>
import org.aspectj.testing.Tester;

public class InitializationOrder {
    public static void main(java.lang.String[] args) {
        C c = new C();
        org.aspectj.testing.Tester.check(null !=
                                         c/*null*/.s,
                                         "null == c.s");
        Sub s = new Sub();
        org.aspectj.testing.Tester.check("ok" ==
                                         s/*null*/.o,
                                         "\"ok\" == s.o");
        org.aspectj.testing.Tester.check(null ==
                                         s/*null*/.p,
                                         "null == s.p");
    }
    
    public InitializationOrder() { super(); }
}
class C {
    public java.lang.String s = null;
    
    C(java.lang.String s) {
        super();
        this/*<unknown>*/.s = s;
    }
    
    C() { this("uh oh"); }
}
class S {
    public java.lang.Object p;
    
    S(java.lang.Object p) {
        super();
        this/*<unknown>*/.p = p;
    }
}
class Sub extends S {
    Sub() {
        super(null);
        this/*null*/.o = "ok";
    }
    
    java.lang.Object o;
}
retrieve <InitializationOrder: void <init>()> from InitializationOrder
retrieve <InitializationOrder: void main(java.lang.String[])> from InitializationOrder
retrieve <C: void <init>(java.lang.String)> from C
retrieve <C: void <init>()> from C
retrieve <S: void <init>(java.lang.Object)> from S
retrieve <Sub: void <init>()> from Sub
Transforming S... 
Transforming InitializationOrder... 
Transforming Sub... 
Transforming C... 
Abc finished on Thu Jun 24 09:20:23 BST 2004. ( 0 min. 7 sec. )
PASS: initialization order with this()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 165 failed (check: 70), 313 passed (check: 81), 1 skipped.
Executing test 480 (new): !within and !this handling for callee-side call points
================================================
Breakdown of abc phases  (total: 8446 millisec.)
------------------------------------------------
[ 00.438% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  4
[ 71.868% ] Polyglot phases:  6070
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.710% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 00.438% ] Intertype Adjuster:  37
[ 06.346% ] Retrieving bodies:  536
[ 00.000% ] Weave Initializers:  0
[ 00.332% ] Load shadow types:  28
[ 04.144% ] Compute advice lists:  350
[ 00.036% ] Intertype weave:  3
[ 00.426% ] Add aspect code:  36
[ 00.414% ] Weaving advice:  35
[ 00.000% ] Validate jimple:  0
[ 04.760% ] Soot Packs:  402
[ 09.993% ] Soot Writing Output:  844
================================================
Abc started on Thu Jun 24 09:20:26 BST 2004
<<<< NotThis.java >>>>
import org.aspectj.testing.Tester;

public class NotThis {
    public static void main(java.lang.String[] args) {
        new NotThis().go();
    }
    
    void go() {
        A a = new A(this);
        a.go();
        org.aspectj.testing.Tester.checkEqual(Q/*Q*/.buf.toString(),
                                              "foo:within(A):this(A):!within(B):!this(B):");
        Q/*Q*/.buf = new java.lang.StringBuffer();
        B b = new B(this);
        b.go();
        org.aspectj.testing.Tester.checkEqual(Q/*Q*/.buf.toString(),
                                              "foo:");
    }
    
    public void foo(java.lang.Object o) { Q/*Q*/.buf.append("foo:"); }
    
    public NotThis() { super(); }
}
class A {
    NotThis t;
    
    A(NotThis n) {
        super();
        this/*null*/.t = n;
    }
    
    void go() { this/*null*/.t.foo(this); }
}
class B {
    NotThis t;
    
    B(NotThis n) {
        super();
        this/*null*/.t = n;
    }
    
    void go() { this/*null*/.t.foo(this); }
}
aspect Q {
    static java.lang.StringBuffer buf = new java.lang.StringBuffer();
    
    after():
    call(void (NotThis).foo(Object)) &&
      within(A) {
        Q/*Q*/.buf.append("within(A):");
    }
    
    after():
    call(void (NotThis).foo(Object)) &&
      this(A) {
        Q/*Q*/.buf.append("this(A):");
    }
    
    after():
    call(void (NotThis).foo(Object)) &&
      !within(B) {
        Q/*Q*/.buf.append("!within(B):");
    }
    
    after():
    call(void (NotThis).foo(Object)) &&
      !this(B) {
        Q/*Q*/.buf.append("!this(B):");
    }
    
    public static Q aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Q() { super(); }
}
retrieve <NotThis: void go()> from NotThis
retrieve <NotThis: void <init>()> from NotThis
retrieve <NotThis: void main(java.lang.String[])> from NotThis
retrieve <NotThis: void foo(java.lang.Object)> from NotThis
retrieve <A: void <init>(NotThis)> from A
retrieve <A: void go()> from A
retrieve <B: void <init>(NotThis)> from B
retrieve <B: void go()> from B
retrieve <Q: void <init>()> from Q
retrieve <Q: void after$0()> from Q
retrieve <Q: void after$1()> from Q
retrieve <Q: void after$2()> from Q
retrieve <Q: void after$3()> from Q
retrieve <Q: Q aspectOf()> from Q
retrieve <Q: boolean hasAspect()> from Q
retrieve <Q: void <clinit>()> from Q
Transforming A... 
Transforming B... 
Transforming NotThis... 
Transforming Q... 
Abc finished on Thu Jun 24 09:20:34 BST 2004. ( 0 min. 8 sec. )
PASS: !within and !this handling for callee-side call points()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 165 failed (check: 70), 314 passed (check: 81), 1 skipped.
Executing test 481 (new/innerInterfaces): private inner interfaces and bytecode visibility
Failed. Current status: 166 failed (check: 70), 314 passed (check: 81), 1 skipped.
Executing test 482 (new): elaborated into testing of around on all join points
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
Failed. Current status: 167 failed (check: 70), 314 passed (check: 81), 1 skipped.
Executing test 483 (new): type name hygiene when code comes from aspects in different packages
================================================
Breakdown of abc phases  (total: 8177 millisec.)
------------------------------------------------
[ 00.526% ] Init. of Soot:  43
[ 00.061% ] Loading Jars:  5
[ 79.198% ] Polyglot phases:  6476
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.624% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.697% ] Intertype Adjuster:  57
[ 06.873% ] Retrieving bodies:  562
[ 00.000% ] Weave Initializers:  0
[ 00.281% ] Load shadow types:  23
[ 02.519% ] Compute advice lists:  206
[ 00.037% ] Intertype weave:  3
[ 00.587% ] Add aspect code:  48
[ 00.318% ] Weaving advice:  26
[ 00.000% ] Validate jimple:  0
[ 04.610% ] Soot Packs:  377
[ 03.620% ] Soot Writing Output:  296
================================================
Failed. Current status: 168 failed (check: 70), 314 passed (check: 81), 1 skipped.
Executing test 484 (new): cflowbelow dependencies (from Chris Dutchyn)
================================================
Breakdown of abc phases  (total: 8939 millisec.)
------------------------------------------------
[ 00.414% ] Init. of Soot:  37
[ 00.034% ] Loading Jars:  3
[ 72.424% ] Polyglot phases:  6474
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.425% ] Recompute name pattern matches:  38
[ 00.000% ] Compute precedence relation:  0
[ 00.660% ] Intertype Adjuster:  59
[ 06.063% ] Retrieving bodies:  542
[ 00.000% ] Weave Initializers:  0
[ 00.291% ] Load shadow types:  26
[ 04.094% ] Compute advice lists:  366
[ 00.034% ] Intertype weave:  3
[ 00.190% ] Add aspect code:  17
[ 00.638% ] Weaving advice:  57
[ 00.000% ] Validate jimple:  0
[ 10.907% ] Soot Packs:  975
[ 03.781% ] Soot Writing Output:  338
================================================
Abc started on Thu Jun 24 09:21:07 BST 2004
<<<< CflowBelowTest.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class CflowBelowTest {
    static final java.lang.String[] expectedSteps =
      new java.lang.String[] { "Num.fact(4) within Num.fact(5) within another Num.fact(6)", "Num.fact(3) within Num.fact(4) within another Num.fact(5)", "Num.fact(2) within Num.fact(3) within another Num.fact(4)", "Num.fact(1) within Num.fact(2) within another Num.fact(3)" };
    
    static java.util.List steps = new java.util.ArrayList();
    
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new Num().fact(6), 720);
        org.aspectj.testing.Tester.checkEqual(CflowBelowTest/*CflowBelowTest*/.steps.toArray(),
                                              CflowBelowTest/*CflowBelowTest*/.expectedSteps,
                                              "steps");
    }
    
    public CflowBelowTest() { super(); }
}
class Num {
    int fact(int x) {
        if (x == 1) return 1;
        return x * fact(x - 1);
    }
    
    public Num() { super(); }
}
aspect CflowBelow01 {
    before(int x1, int x2, int x3):
    call(int (Num).fact(int)) && args(x1) &&
      cflowbelow(call(int (Num).fact(int)) && args(x2) &&
        cflowbelow(call(int (Num).fact(int)) && args(x3))) {
        CflowBelowTest/*CflowBelowTest*/.steps.add("Num.fact(" + x1 +
                                                   ") within Num.fact(" +
                                                   x2 +
                                                   ") within another Num.fact(" +
                                                   x3 +
                                                   ")");
    }
    
    public static CflowBelow01 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public CflowBelow01() { super(); }
}
retrieve <CflowBelowTest: void main(java.lang.String[])> from CflowBelowTest
retrieve <CflowBelowTest: void <clinit>()> from CflowBelowTest
retrieve <CflowBelowTest: void <init>()> from CflowBelowTest
retrieve <Num: void <init>()> from Num
retrieve <Num: int fact(int)> from Num
retrieve <CflowBelow01: void before$0(int,int,int)> from CflowBelow01
retrieve <CflowBelow01: CflowBelow01 aspectOf()> from CflowBelow01
retrieve <CflowBelow01: boolean hasAspect()> from CflowBelow01
retrieve <CflowBelow01: void <init>()> from CflowBelow01
Transforming CflowBelow01... 
Transforming Num... 
Transforming CflowBelowTest... 
Abc finished on Thu Jun 24 09:21:16 BST 2004. ( 0 min. 9 sec. )
PASS: cflowbelow dependencies (from Chris Dutchyn)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 168 failed (check: 70), 315 passed (check: 81), 1 skipped.
Executing test 485 (new): target type matching with messy interface hierarchies
Failed. Current status: 169 failed (check: 70), 315 passed (check: 81), 1 skipped.
Executing test 486 (new): PR#458 Compiler was incorrectly flagging error in advice on initialization and static initialization
================================================
Breakdown of abc phases  (total: 7078 millisec.)
------------------------------------------------
[ 00.551% ] Init. of Soot:  39
[ 00.042% ] Loading Jars:  3
[ 74.442% ] Polyglot phases:  5269
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.622% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.805% ] Intertype Adjuster:  57
[ 06.711% ] Retrieving bodies:  475
[ 00.000% ] Weave Initializers:  0
[ 00.311% ] Load shadow types:  22
[ 00.848% ] Compute advice lists:  60
[ 00.042% ] Intertype weave:  3
[ 00.579% ] Add aspect code:  41
[ 01.144% ] Weaving advice:  81
[ 00.000% ] Validate jimple:  0
[ 04.281% ] Soot Packs:  303
[ 09.565% ] Soot Writing Output:  677
================================================
Abc started on Thu Jun 24 09:21:22 BST 2004
<<<< StaticInitCE.java >>>>
public class StaticInitCE {
    public static void main(java.lang.String[] args) { new C(); }
    
    public StaticInitCE() { super(); }
}
class C {
    C() { super(); }
}
aspect A {
    void around (): staticinitialization(C) { this.proceed(); }
    
    void around (): initialization((C).new()) { this.proceed(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <StaticInitCE: void main(java.lang.String[])> from StaticInitCE
retrieve <StaticInitCE: void <init>()> from StaticInitCE
retrieve <C: void <init>()> from C
retrieve <A: void around$0()> from A
retrieve <A: void around$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void proceed$2()> from A
retrieve <A: void proceed$3()> from A
Transforming A... 
Transforming C... 
Transforming StaticInitCE... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 09:21:29 BST 2004. ( 0 min. 7 sec. )
PASS: PR#458 Compiler was incorrectly flagging error in advice on initializati...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 169 failed (check: 70), 316 passed (check: 81), 1 skipped.
Executing test 487 (new): Compiler incorrectly flagging *1 (non-alphabetic start to signature pattern)
================================================
Breakdown of abc phases  (total: 9120 millisec.)
------------------------------------------------
[ 00.417% ] Init. of Soot:  38
[ 00.033% ] Loading Jars:  3
[ 67.390% ] Polyglot phases:  6146
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.779% ] Recompute name pattern matches:  71
[ 00.000% ] Compute precedence relation:  0
[ 00.439% ] Intertype Adjuster:  40
[ 05.888% ] Retrieving bodies:  537
[ 00.000% ] Weave Initializers:  0
[ 00.263% ] Load shadow types:  24
[ 05.757% ] Compute advice lists:  525
[ 00.033% ] Intertype weave:  3
[ 00.428% ] Add aspect code:  39
[ 01.283% ] Weaving advice:  117
[ 00.000% ] Validate jimple:  0
[ 12.566% ] Soot Packs:  1146
[ 04.682% ] Soot Writing Output:  427
================================================
Abc started on Thu Jun 24 09:21:32 BST 2004
<<<< NonAlphaSignaturePatternCE.java >>>>
import org.aspectj.testing.Tester;

public class NonAlphaSignaturePatternCE {
    public static void main(java.lang.String[] args) {
        C1 c = new C1();
        c.m1();
        c.update();
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    public NonAlphaSignaturePatternCE() { super(); }
}
class C1 {
    public int fi1;
    
    public float f1 = 1.0F;
    
    void cflowbelow() {  }
    
    void m1() {
        java.lang.String s = "m1 ";
        cflowbelow();
    }
    
    void update() {
        this/*null*/.fi1 = 1;
        int i = this/*null*/.fi1;
    }
    
    public C1() { super(); }
}
aspect A {
    static {
               org.aspectj.testing.Tester.expectEvent("call m1");
               org.aspectj.testing.Tester.expectEvent("before call *1");
               org.aspectj.testing.Tester.expectEvent("before p1");
               org.aspectj.testing.Tester.expectEvent("before execution *1");
               org.aspectj.testing.Tester.expectEvent("initialization *1");
               org.aspectj.testing.Tester.expectEvent("staticinitialization *1");
               org.aspectj.testing.Tester.expectEvent("withincode *1");
               org.aspectj.testing.Tester.expectEvent("cflow *1");
               org.aspectj.testing.Tester.expectEvent("cflowbelow *1");
               org.aspectj.testing.Tester.expectEvent("set *1");
               org.aspectj.testing.Tester.expectEvent("get *1");
           }
    
    after():
    call(void (*).m1()) {
        org.aspectj.testing.Tester.event("call m1");
    }
    
    pointcut p1() : call(void (*).*1());
    
    before(): p1() { org.aspectj.testing.Tester.event("before p1"); }
    
    before():
    call(void (*).*1()) {
        org.aspectj.testing.Tester.event("before call *1");
    }
    
    after():
    execution (void (*).*1()) {
        org.aspectj.testing.Tester.event("before execution *1");
    }
    
    after():
    initialization((*1).new()) {
        org.aspectj.testing.Tester.event("initialization *1");
    }
    
    before():
    staticinitialization(*1) {
        org.aspectj.testing.Tester.event("staticinitialization *1");
    }
    
    before():
    withincode(void (C1).*1()) {
        org.aspectj.testing.Tester.event("withincode *1");
    }
    
    before():
    set( int (C*1).fi1) {
        org.aspectj.testing.Tester.event("set *1");
    }
    
    before():
    get( int (*).*1) {
        org.aspectj.testing.Tester.event("get *1");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
aspect B {
    before():
    cflowbelow(execution (void (*1).m1())) &&
      !within(B) {
        org.aspectj.testing.Tester.event("cflowbelow *1");
    }
    
    before():
    cflow(execution (void (*1).m1())) &&
      !within(B) {
        org.aspectj.testing.Tester.event("cflow *1");
    }
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
retrieve <NonAlphaSignaturePatternCE: void main(java.lang.String[])> from NonAlphaSignaturePatternCE
retrieve <NonAlphaSignaturePatternCE: void <init>()> from NonAlphaSignaturePatternCE
retrieve <C1: void cflowbelow()> from C1
retrieve <C1: void m1()> from C1
retrieve <C1: void update()> from C1
retrieve <C1: void <init>()> from C1
retrieve <A: void after$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: void after$3()> from A
retrieve <A: void after$4()> from A
retrieve <A: void before$5()> from A
retrieve <A: void before$6()> from A
retrieve <A: void before$7()> from A
retrieve <A: void before$8()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <B: boolean hasAspect()> from B
retrieve <B: void before$9()> from B
retrieve <B: void before$10()> from B
retrieve <B: B aspectOf()> from B
retrieve <B: void <init>()> from B
Transforming A... 
Transforming NonAlphaSignaturePatternCE... 
Transforming C1... 
Transforming B... 
Abc finished on Thu Jun 24 09:21:41 BST 2004. ( 0 min. 9 sec. )
PASS: Compiler incorrectly flagging *1 (non-alphabetic start to signature patt...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 169 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 488 (new): Unable to bind privately-introduced field name from introduced method in the same aspect
================================================
Breakdown of abc phases  (total: 7781 millisec.)
------------------------------------------------
[ 00.501% ] Init. of Soot:  39
[ 00.039% ] Loading Jars:  3
[ 78.512% ] Polyglot phases:  6109
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.476% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 02.211% ] Intertype Adjuster:  172
[ 05.282% ] Retrieving bodies:  411
[ 00.116% ] Weave Initializers:  9
[ 00.283% ] Load shadow types:  22
[ 03.971% ] Compute advice lists:  309
[ 00.039% ] Intertype weave:  3
[ 00.527% ] Add aspect code:  41
[ 00.167% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.395% ] Soot Packs:  342
[ 03.431% ] Soot Writing Output:  267
================================================
Failed. Current status: 170 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 489 (new/anonInnerClass): anonymous inner class with aspect
================================================
Breakdown of abc phases  (total: 8192 millisec.)
------------------------------------------------
[ 00.452% ] Init. of Soot:  37
[ 00.049% ] Loading Jars:  4
[ 70.593% ] Polyglot phases:  5783
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.647% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.464% ] Intertype Adjuster:  38
[ 13.037% ] Retrieving bodies:  1068
[ 00.000% ] Weave Initializers:  0
[ 00.281% ] Load shadow types:  23
[ 03.235% ] Compute advice lists:  265
[ 00.049% ] Intertype weave:  4
[ 00.439% ] Add aspect code:  36
[ 00.159% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 07.410% ] Soot Packs:  607
[ 03.137% ] Soot Writing Output:  257
================================================
Failed. Current status: 171 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 490 (new): Arguments are not being passed in to calls advice
Failed. Current status: 172 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 491 (design/intro): interfaces as mixins with introduction
Failed. Current status: 173 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 492 (new): functional modifiers work correctly with introduced members
================================================
Breakdown of abc phases  (total: 8508 millisec.)
------------------------------------------------
[ 00.435% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  4
[ 73.719% ] Polyglot phases:  6272
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.611% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 01.693% ] Intertype Adjuster:  144
[ 06.758% ] Retrieving bodies:  575
[ 00.106% ] Weave Initializers:  9
[ 00.259% ] Load shadow types:  22
[ 08.686% ] Compute advice lists:  739
[ 00.035% ] Intertype weave:  3
[ 00.141% ] Add aspect code:  12
[ 00.153% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.090% ] Soot Packs:  348
[ 03.220% ] Soot Writing Output:  274
================================================
Failed. Current status: 174 failed (check: 70), 317 passed (check: 81), 1 skipped.
Executing test 493 (new): ExceptionInInitializerError accessing cflow in aspect initialization - before variants
================================================
Breakdown of abc phases  (total: 8422 millisec.)
------------------------------------------------
[ 00.451% ] Init. of Soot:  38
[ 00.036% ] Loading Jars:  3
[ 69.639% ] Polyglot phases:  5865
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.689% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.487% ] Intertype Adjuster:  41
[ 13.073% ] Retrieving bodies:  1101
[ 00.000% ] Weave Initializers:  0
[ 00.261% ] Load shadow types:  22
[ 03.538% ] Compute advice lists:  298
[ 00.036% ] Intertype weave:  3
[ 00.237% ] Add aspect code:  20
[ 01.223% ] Weaving advice:  103
[ 00.000% ] Validate jimple:  0
[ 05.901% ] Soot Packs:  497
[ 04.381% ] Soot Writing Output:  369
================================================
Abc started on Thu Jun 24 09:22:35 BST 2004
<<<< CflowInitInAspectVariantsBefore.java >>>>
import org.aspectj.testing.Tester;

public class CflowInitInAspectVariantsBefore {
    public static void main(java.lang.String[] args) {
        new C().a();
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("cflow before pc()");
               org.aspectj.testing.Tester.expectEvent("cflow before execution(void C.a())");
               org.aspectj.testing.Tester.expectEvent("cflowbelow before pc()");
               org.aspectj.testing.Tester.expectEvent("cflowbelow before execution(void C.a())");
           }
    
    public CflowInitInAspectVariantsBefore() { super(); }
}
class C {
    void a() { b(); }
    
    private void b() { int i = 1; }
    
    public C() { super(); }
}
aspect A {
    pointcut pc() : execution (void (C).a());
    
    pointcut safety() : !within(A);
    
    static boolean touched = false;
    
    before():
    safety() &&
      cflow(pc()) {
        if (!A/*A*/.touched) A/*A*/.touched = true;
        org.aspectj.testing.Tester.event("cflow before pc()");
    }
    
    before():
    safety() &&
      cflow(execution (void (C).a())) {
        if (!A/*A*/.touched) A/*A*/.touched = true;
        org.aspectj.testing.Tester.event("cflow before execution(void C.a())");
    }
    
    before():
    safety() &&
      cflowbelow(pc()) {
        if (!A/*A*/.touched) A/*A*/.touched = true;
        org.aspectj.testing.Tester.event("cflowbelow before pc()");
    }
    
    before():
    safety() &&
      cflowbelow(execution (void (C).a())) {
        if (!A/*A*/.touched) A/*A*/.touched = true;
        org.aspectj.testing.Tester.event("cflowbelow before execution(void C.a())");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <CflowInitInAspectVariantsBefore: void <clinit>()> from CflowInitInAspectVariantsBefore
retrieve <CflowInitInAspectVariantsBefore: void main(java.lang.String[])> from CflowInitInAspectVariantsBefore
retrieve <CflowInitInAspectVariantsBefore: void <init>()> from CflowInitInAspectVariantsBefore
retrieve <C: void a()> from C
retrieve <C: void b()> from C
retrieve <C: void <init>()> from C
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: void before$3()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming C... 
Transforming CflowInitInAspectVariantsBefore... 
Abc finished on Thu Jun 24 09:22:44 BST 2004. ( 0 min. 8 sec. )
PASS: ExceptionInInitializerError accessing cflow in aspect initialization - b...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 174 failed (check: 70), 318 passed (check: 81), 1 skipped.
Executing test 494 (new): NoClassDefFoundError accessing cflow in aspect initialization - after variants
================================================
Breakdown of abc phases  (total: 8903 millisec.)
------------------------------------------------
[ 00.427% ] Init. of Soot:  38
[ 00.045% ] Loading Jars:  4
[ 66.326% ] Polyglot phases:  5905
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.651% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.438% ] Intertype Adjuster:  39
[ 11.648% ] Retrieving bodies:  1037
[ 00.000% ] Weave Initializers:  0
[ 00.258% ] Load shadow types:  23
[ 03.066% ] Compute advice lists:  273
[ 00.045% ] Intertype weave:  4
[ 00.404% ] Add aspect code:  36
[ 01.730% ] Weaving advice:  154
[ 00.000% ] Validate jimple:  0
[ 09.682% ] Soot Packs:  862
[ 05.234% ] Soot Writing Output:  466
================================================
Abc started on Thu Jun 24 09:22:46 BST 2004
<<<< CflowInitInAspectVariantsAfter.java >>>>
import org.aspectj.testing.Tester;

public class CflowInitInAspectVariantsAfter {
    public static void main(java.lang.String[] args) {
        new C().a();
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("cflow after pc()");
               org.aspectj.testing.Tester.expectEvent("cflow after execution(void C.a())");
               org.aspectj.testing.Tester.expectEvent("cflowbelow after pc()");
               org.aspectj.testing.Tester.expectEvent("cflowbelow after execution(void C.a())");
           }
    
    public CflowInitInAspectVariantsAfter() { super(); }
}
class C {
    void a() { b(); }
    
    private void b() { int i = 1; }
    
    public C() { super(); }
}
aspect A {
    pointcut safety() : !within(A);
    
    pointcut pc() : execution (void (C).a());
    
    after():
    safety() &&
      cflow(pc()) {
        org.aspectj.testing.Tester.event("cflow after pc()");
    }
    
    after():
    safety() &&
      cflow(execution (void (C).a())) {
        org.aspectj.testing.Tester.event("cflow after execution(void C.a())");
    }
    
    after():
    safety() &&
      cflowbelow(pc()) {
        org.aspectj.testing.Tester.event("cflowbelow after pc()");
    }
    
    after():
    safety() &&
      cflowbelow(execution (void (C).a())) {
        org.aspectj.testing.Tester.event("cflowbelow after execution(void C.a())");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <CflowInitInAspectVariantsAfter: void main(java.lang.String[])> from CflowInitInAspectVariantsAfter
retrieve <CflowInitInAspectVariantsAfter: void <clinit>()> from CflowInitInAspectVariantsAfter
retrieve <CflowInitInAspectVariantsAfter: void <init>()> from CflowInitInAspectVariantsAfter
retrieve <C: void a()> from C
retrieve <C: void b()> from C
retrieve <C: void <init>()> from C
retrieve <A: void after$0()> from A
retrieve <A: void after$1()> from A
retrieve <A: void after$2()> from A
retrieve <A: void after$3()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming C... 
Transforming CflowInitInAspectVariantsAfter... 
Abc finished on Thu Jun 24 09:22:55 BST 2004. ( 0 min. 9 sec. )
PASS: NoClassDefFoundError accessing cflow in aspect initialization - after va...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 174 failed (check: 70), 319 passed (check: 81), 1 skipped.
Executing test 495 (new): InternalCompilerError in JpPlan when args alone
getting SJPInfo for a untagged source line goto [?= (branch)]
================================================
Breakdown of abc phases  (total: 8260 millisec.)
------------------------------------------------
[ 00.460% ] Init. of Soot:  38
[ 00.036% ] Loading Jars:  3
[ 74.237% ] Polyglot phases:  6132
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.714% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.460% ] Intertype Adjuster:  38
[ 06.392% ] Retrieving bodies:  528
[ 00.000% ] Weave Initializers:  0
[ 00.278% ] Load shadow types:  23
[ 08.789% ] Compute advice lists:  726
[ 00.036% ] Intertype weave:  3
[ 00.242% ] Add aspect code:  20
[ 01.053% ] Weaving advice:  87
[ 00.000% ] Validate jimple:  0
[ 03.898% ] Soot Packs:  322
[ 03.354% ] Soot Writing Output:  277
================================================
Abc started on Thu Jun 24 09:22:58 BST 2004
<<<< ArgsAlone.java >>>>
import org.aspectj.testing.Tester;

public class ArgsAlone {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("within 2 method-call");
        org.aspectj.testing.Tester.expectEvent("within 2 method-execution");
        new TargetClass().callInt(2);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public ArgsAlone() { super(); }
}
class TargetClass {
    void callInt(int i) { while (i > 0) { --i; } }
    
    public TargetClass() { super(); }
}
aspect Aspect {
    pointcut pc() :
    call(void (TargetClass).callInt(int)) ||
      execution (void (TargetClass).callInt(int));
    
    before(int i):
    !target(Aspect) && args(i) &&
      !target(java.lang.StringBuffer) {
        org.aspectj.testing.Tester.event("within " + i + " " +
                                         thisJoinPointStaticPart.getKind());
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <ArgsAlone: void <init>()> from ArgsAlone
retrieve <ArgsAlone: void main(java.lang.String[])> from ArgsAlone
retrieve <TargetClass: void callInt(int)> from TargetClass
retrieve <TargetClass: void <init>()> from TargetClass
retrieve <Aspect: void before$0(int,org.aspectj.lang.JoinPoint$StaticPart)> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming TargetClass... 
Transforming Aspect... 
Transforming ArgsAlone... 
Abc finished on Thu Jun 24 09:23:06 BST 2004. ( 0 min. 8 sec. )
PASS: InternalCompilerError in JpPlan when args alone()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 174 failed (check: 70), 320 passed (check: 81), 1 skipped.
Executing test 496 (new): compile error using pcd if() with advice on introduced methods.
Failed. Current status: 175 failed (check: 70), 320 passed (check: 81), 1 skipped.
Executing test 497 (new): compile errors boolean using cflow and unimplemented method using around advice on methods introduced by interface
Failed. Current status: 176 failed (check: 70), 320 passed (check: 81), 1 skipped.
Executing test 498 (new): aspect as member of interface
================================================
Breakdown of abc phases  (total: 7755 millisec.)
------------------------------------------------
[ 00.490% ] Init. of Soot:  38
[ 00.039% ] Loading Jars:  3
[ 80.593% ] Polyglot phases:  6250
[ 00.039% ] Resolve class names:  3
[ 00.026% ] Declare Parents:  2
[ 00.696% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.593% ] Intertype Adjuster:  46
[ 06.667% ] Retrieving bodies:  517
[ 00.000% ] Weave Initializers:  0
[ 00.322% ] Load shadow types:  25
[ 01.947% ] Compute advice lists:  151
[ 00.039% ] Intertype weave:  3
[ 00.464% ] Add aspect code:  36
[ 00.464% ] Weaving advice:  36
[ 00.000% ] Validate jimple:  0
[ 04.268% ] Soot Packs:  331
[ 03.353% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 09:23:26 BST 2004
<<<< AspectInInterfaceCP.java >>>>
import org.aspectj.testing.Tester;

public class AspectInInterfaceCP {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEvents("before");
    }
    
    public AspectInInterfaceCP() { super(); }
}
interface HasPrivateAspect {
    static aspect Inner {
        before():
        execution (* (*).main(..)) {
            org.aspectj.testing.Tester.event("before");
        }
        
        public static HasPrivateAspect.Inner aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public Inner() { super(); }
    }
    
}
retrieve <AspectInInterfaceCP: void main(java.lang.String[])> from AspectInInterfaceCP
retrieve <AspectInInterfaceCP: void <init>()> from AspectInInterfaceCP
retrieve <HasPrivateAspect$Inner: void before$0()> from HasPrivateAspect$Inner
retrieve <HasPrivateAspect$Inner: HasPrivateAspect$Inner aspectOf()> from HasPrivateAspect$Inner
retrieve <HasPrivateAspect$Inner: boolean hasAspect()> from HasPrivateAspect$Inner
retrieve <HasPrivateAspect$Inner: void <init>()> from HasPrivateAspect$Inner
Transforming HasPrivateAspect... 
Transforming HasPrivateAspect$Inner... 
Transforming AspectInInterfaceCP... 
Abc finished on Thu Jun 24 09:23:34 BST 2004. ( 0 min. 7 sec. )
PASS: aspect as member of interface()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 176 failed (check: 70), 321 passed (check: 81), 1 skipped.
Executing test 499 (new): missing method name to synthetic invocation
Failed. Current status: 177 failed (check: 70), 321 passed (check: 81), 1 skipped.
Executing test 500 (new): protected subclass impl of superclass method with default access and variants
Failed. Current status: 178 failed (check: 70), 321 passed (check: 81), 1 skipped.
Executing test 501 (new): Exception planning advice
Failed. Current status: 179 failed (check: 70), 321 passed (check: 81), 1 skipped.
Executing test 502 (new): unreproduced bug with advice - probably UTR
================================================
Breakdown of abc phases  (total: 8951 millisec.)
------------------------------------------------
[ 00.425% ] Init. of Soot:  38
[ 00.045% ] Loading Jars:  4
[ 74.305% ] Polyglot phases:  6651
[ 00.022% ] Resolve class names:  2
[ 00.022% ] Declare Parents:  2
[ 00.614% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 01.005% ] Intertype Adjuster:  90
[ 07.351% ] Retrieving bodies:  658
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  25
[ 05.128% ] Compute advice lists:  459
[ 00.034% ] Intertype weave:  3
[ 00.212% ] Add aspect code:  19
[ 01.709% ] Weaving advice:  153
[ 00.000% ] Validate jimple:  0
[ 04.670% ] Soot Packs:  418
[ 04.178% ] Soot Writing Output:  374
================================================
context=word_0
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=word_1
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=word_2
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=word_3
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=word_4
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=EXCEPTION
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=DEBUG
call(void Logger.log(Logger.ChromePriority, Unknown, String))
context=DEBUG-Exception
call(void Logger.log(Logger.ChromePriority, Unknown, String, Exception))
Abc started on Thu Jun 24 09:23:55 BST 2004
<<<< PR520.java >>>>
import org.aspectj.testing.Tester;

public class PR520 {
    public static void main(java.lang.String[] args) {
        PR520 me = new PR520();
        me.testValidThreeArgumentCall();
        me.testValidThreeArgumentCallTwo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void testValidThreeArgumentCall() {
        for (int i = 0;
             i < Logger/*Logger*/.PRIORITIES/*null*/.length;
             i++) {
            Logger.log(Logger/*Logger*/.PRIORITIES[i],
                       Logger/*Logger*/.API,
                       "context=word_" +
                       i);
        }
    }
    
    public void testValidThreeArgumentCallTwo() {
        Logger.log(Logger/*Logger*/.EXCEPTION,
                   Logger/*Logger*/.API,
                   "context=EXCEPTION");
        Logger.log(Logger/*Logger*/.DEBUG,
                   Logger/*Logger*/.API,
                   "context=DEBUG");
        Logger.log(Logger/*Logger*/.DEBUG,
                   Logger/*Logger*/.API,
                   "context=DEBUG-Exception",
                   new java.lang.Exception("bad bad boy"));
    }
    
    public static void signal(java.lang.String s,
                              java.lang.String context) {
        signal(context + ": " + s);
    }
    
    public static void signal(java.lang.String s) {
        java.lang.System/*java.lang.System*/.err.println(s);
        org.aspectj.testing.Tester.event(s);
    }
    
    private static final java.lang.String[] EXPECTED;
    
    static {
               PR520/*PR520*/.EXPECTED =
                 (new java.lang.String[] { "context=word_0", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                              ")"), "context=word_1", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                       ")"), "context=word_2", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                                                ")"), "context=word_3", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                                                                         ")"), "context=word_4", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                                                                                                  ")"), "context=EXCEPTION", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                                                                                                                              ")"), "context=DEBUG", ("call(void Logger.log(Logger.ChromePriority, Unknown, String)" +
                                                                                                                                                                                                                      ")"), "context=DEBUG-Exception", ("call(void Logger.log(Logger.ChromePriority, Unknown, String," +
                                                                                                                                                                                                                                                        " Exception))") });
               org.aspectj.testing.Tester.expectEventsInString(PR520/*PR520*/.EXPECTED);
           }
    
    public PR520() { super(); }
}
class Unknown {
    public Unknown() { super(); }
}
class Logger {
    static class ChromePriority {
        public ChromePriority() { super(); }
    }
    
    
    public static final Logger.ChromePriority DEBUG;
    
    public static final Logger.ChromePriority EXCEPTION;
    
    public static final Logger.ChromePriority FATAL;
    
    public static final Logger.ChromePriority INFO;
    
    public static final Logger.ChromePriority WARN;
    
    public static final Unknown API;
    
    public static final Logger.ChromePriority[] PRIORITIES;
    
    static {
               Logger/*Logger*/.API = new Unknown();
               Logger/*Logger*/.PRIORITIES =
                 (new Logger.ChromePriority[5]);
               Logger/*Logger*/.DEBUG = new Logger.ChromePriority();
               Logger/*Logger*/.EXCEPTION =
                 new Logger.ChromePriority();
               Logger/*Logger*/.FATAL = new Logger.ChromePriority();
               Logger/*Logger*/.INFO = new Logger.ChromePriority();
               Logger/*Logger*/.WARN = new Logger.ChromePriority();
               Logger/*Logger*/.PRIORITIES[0] =
                 Logger/*Logger*/.DEBUG;
               Logger/*Logger*/.PRIORITIES[1] =
                 Logger/*Logger*/.EXCEPTION;
               Logger/*Logger*/.PRIORITIES[2] =
                 Logger/*Logger*/.FATAL;
               Logger/*Logger*/.PRIORITIES[3] = Logger/*Logger*/.INFO;
               Logger/*Logger*/.PRIORITIES[4] = Logger/*Logger*/.WARN;
           }
    
    public static void log(Logger.ChromePriority p,
                           Unknown q,
                           java.lang.String message,
                           java.lang.Exception e) {
        PR520.signal(message);
    }
    
    public static void log(Logger.ChromePriority p,
                           Unknown q,
                           java.lang.String message) {
        PR520.signal(message);
    }
    
    public Logger() { super(); }
}
aspect LoggerCategoryCreator {
    pointcut allLoggingCalls() : call(public void (Logger).log(..));
    
    void around ():
    allLoggingCalls() {
        this.proceed();
        PR520.signal(thisJoinPointStaticPart.toString());
    }
    
    public static LoggerCategoryCreator aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public LoggerCategoryCreator() { super(); }
}
retrieve <PR520: void main(java.lang.String[])> from PR520
retrieve <PR520: void testValidThreeArgumentCall()> from PR520
retrieve <PR520: void testValidThreeArgumentCallTwo()> from PR520
retrieve <PR520: void signal(java.lang.String,java.lang.String)> from PR520
retrieve <PR520: void signal(java.lang.String)> from PR520
retrieve <PR520: void <init>()> from PR520
retrieve <PR520: void <clinit>()> from PR520
retrieve <Unknown: void <init>()> from Unknown
retrieve <Logger: void <init>()> from Logger
retrieve <Logger: void <clinit>()> from Logger
retrieve <Logger: void log(Logger$ChromePriority,Unknown,java.lang.String,java.lang.Exception)> from Logger
retrieve <Logger: void log(Logger$ChromePriority,Unknown,java.lang.String)> from Logger
retrieve <Logger$ChromePriority: void <init>()> from Logger$ChromePriority
retrieve <LoggerCategoryCreator: void around$0(org.aspectj.lang.JoinPoint$StaticPart)> from LoggerCategoryCreator
retrieve <LoggerCategoryCreator: LoggerCategoryCreator aspectOf()> from LoggerCategoryCreator
retrieve <LoggerCategoryCreator: boolean hasAspect()> from LoggerCategoryCreator
retrieve <LoggerCategoryCreator: void proceed$1()> from LoggerCategoryCreator
retrieve <LoggerCategoryCreator: void <init>()> from LoggerCategoryCreator
Transforming PR520... 
Transforming Unknown... 
Transforming LoggerCategoryCreator... 
Transforming Logger... 
Transforming Logger$ChromePriority... 
Transforming abc$access$LoggerCategoryCreator$around$0... 
Abc finished on Thu Jun 24 09:24:04 BST 2004. ( 0 min. 9 sec. )
PASS: unreproduced bug with advice - probably UTR()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 179 failed (check: 70), 322 passed (check: 81), 1 skipped.
Executing test 503 (new): introduced inner interfaces accessible inside aspect
Failed. Current status: 180 failed (check: 70), 322 passed (check: 81), 1 skipped.
Executing test 504 (new): validate (enclosing) join point and source locations
Failed. Current status: 181 failed (check: 70), 322 passed (check: 81), 1 skipped.
Executing test 505 (new): advice formals are just like method formals
================================================
Breakdown of abc phases  (total: 7686 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 72.040% ] Polyglot phases:  5537
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.625% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.468% ] Intertype Adjuster:  36
[ 06.583% ] Retrieving bodies:  506
[ 00.000% ] Weave Initializers:  0
[ 00.273% ] Load shadow types:  21
[ 09.758% ] Compute advice lists:  750
[ 00.039% ] Intertype weave:  3
[ 00.455% ] Add aspect code:  35
[ 01.106% ] Weaving advice:  85
[ 00.000% ] Validate jimple:  0
[ 04.541% ] Soot Packs:  349
[ 03.539% ] Soot Writing Output:  272
================================================
Abc started on Thu Jun 24 09:24:18 BST 2004
<<<< AdviceFormalsCp.java >>>>
import org.aspectj.testing.Tester;

public class AdviceFormalsCp {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(new C().m("bye"),
                                              "foo");
        org.aspectj.testing.Tester.checkEqual(new C().mi(2.0), 1);
    }
    
    public AdviceFormalsCp() { super(); }
}
class C {
    public java.lang.String m(java.lang.Object p) { return "foo"; }
    
    public int mi(double p) { return 1; }
    
    public C() { super(); }
}
aspect A {
    after(Object p) returning(Object o):
    call(* (C).m*(*)) &&
      args(p) {
        p = java.lang.Boolean/*java.lang.Boolean*/.TRUE;
        o = java.lang.Boolean/*java.lang.Boolean*/.TRUE;
        org.aspectj.testing.Tester.checkEqual(p,
                                              java.lang.Boolean/*java.lang.Boolean*/.TRUE);
        org.aspectj.testing.Tester.checkEqual(o,
                                              java.lang.Boolean/*java.lang.Boolean*/.TRUE);
    }
    
    Object around (Object p, Object o):
    call(* (C).m*(*)) && args(p) &&
      target(o) {
        java.lang.Object ret = this.proceed(p, o);
        p = java.lang.Boolean/*java.lang.Boolean*/.TRUE;
        o = java.lang.Boolean/*java.lang.Boolean*/.TRUE;
        org.aspectj.testing.Tester.checkEqual(p,
                                              java.lang.Boolean/*java.lang.Boolean*/.TRUE);
        org.aspectj.testing.Tester.checkEqual(o,
                                              java.lang.Boolean/*java.lang.Boolean*/.TRUE);
        return ret;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AdviceFormalsCp: void main(java.lang.String[])> from AdviceFormalsCp
retrieve <AdviceFormalsCp: void <init>()> from AdviceFormalsCp
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String m(java.lang.Object)> from C
retrieve <C: int mi(double)> from C
retrieve <A: void <init>()> from A
retrieve <A: void afterReturning$0(java.lang.Object,java.lang.Object)> from A
retrieve <A: java.lang.Object around$1(java.lang.Object,java.lang.Object)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: java.lang.Object proceed$2(java.lang.Object,java.lang.Object)> from A
Transforming AdviceFormalsCp... 
Transforming C... 
Transforming A... 
Transforming abc$access$A$around$1... 
Abc finished on Thu Jun 24 09:24:26 BST 2004. ( 0 min. 7 sec. )
PASS: advice formals are just like method formals()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 181 failed (check: 70), 323 passed (check: 81), 1 skipped.
Executing test 506 (new): advice formals produce errors just like method formals
Failed. Current status: 182 failed (check: 71), 323 passed (check: 81), 1 skipped.
Executing test 507 (new): advice throws clauses must be compatible with joinpoints they apply to
Failed. Current status: 183 failed (check: 71), 323 passed (check: 81), 1 skipped.
Executing test 508 (new): potential method conflicts with introductions and interfaces and PR#561
================================================
Breakdown of abc phases  (total: 7307 millisec.)
------------------------------------------------
[ 00.506% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 76.187% ] Polyglot phases:  5567
[ 00.027% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.630% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 02.162% ] Intertype Adjuster:  158
[ 05.419% ] Retrieving bodies:  396
[ 00.000% ] Weave Initializers:  0
[ 00.301% ] Load shadow types:  22
[ 04.585% ] Compute advice lists:  335
[ 00.041% ] Intertype weave:  3
[ 00.452% ] Add aspect code:  33
[ 00.205% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 05.584% ] Soot Packs:  408
[ 03.846% ] Soot Writing Output:  281
================================================
Abc started on Thu Jun 24 09:24:37 BST 2004
<<<< MethodConflictsCP.java >>>>
import org.aspectj.testing.Tester;

public class MethodConflictsCP {
    public static void main(java.lang.String[] args) {
        C c = new C();
        org.aspectj.testing.Tester.checkEqual(c.ma(), "C");
        org.aspectj.testing.Tester.checkEqual(c.m1(), "I1-C");
        org.aspectj.testing.Tester.checkEqual(c.m2(), "I2-C");
        I1 i1 = c;
        org.aspectj.testing.Tester.checkEqual(i1.m2(), "I2-C");
        org.aspectj.testing.Tester.checkEqual(new CO().toString(),
                                              "IO");
    }
    
    public MethodConflictsCP() { super(); }
}
class C implements I1, I2 {
    public java.lang.String ma() { return "C"; }
    
    public C() { super(); }
}
interface BaseI {
    public abstract java.lang.String m1();
    
    public abstract java.lang.String m2();
}
interface I1 extends BaseI {
    static aspect BODY {
        public intertype java.lang.String I1.m1() {
            return "I1-" + ma();
        }
        
        public abstract intertype java.lang.String I1.ma();
        
        public static I1.BODY aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public BODY() { super(); }
    }
    
}
interface I2 extends BaseI {
    static aspect BODY {
        public intertype java.lang.String I2.m2() {
            return "I2-" + ma();
        }
        
        public abstract intertype java.lang.String I2.ma();
        
        private intertype java.lang.String I2.mp() { return "I2"; }
        
        public static I2.BODY aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public BODY() { super(); }
    }
    
}
interface IO {
    static aspect BODY {
        public intertype java.lang.String IO.toString() {
            return "IO";
        }
        
        public static IO.BODY aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public BODY() { super(); }
    }
    
}
class CO implements IO {
    public CO() { super(); }
}
retrieve <MethodConflictsCP: void <init>()> from MethodConflictsCP
retrieve <MethodConflictsCP: void main(java.lang.String[])> from MethodConflictsCP
retrieve <C: java.lang.String m1()> from C
retrieve <C: java.lang.String ma()> from C
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String m2()> from C
retrieve <C: java.lang.String I2$BODY$mp$10()> from C
retrieve <I1$BODY: boolean hasAspect()> from I1$BODY
retrieve <I1$BODY: java.lang.String m1(I1)> from I1$BODY
retrieve <I1$BODY: I1$BODY aspectOf()> from I1$BODY
retrieve <I1$BODY: void <init>()> from I1$BODY
retrieve <I2$BODY: boolean hasAspect()> from I2$BODY
retrieve <I2$BODY: java.lang.String m2(I2)> from I2$BODY
retrieve <I2$BODY: java.lang.String I2$BODY$mp$10(I2)> from I2$BODY
retrieve <I2$BODY: I2$BODY aspectOf()> from I2$BODY
retrieve <I2$BODY: void <init>()> from I2$BODY
retrieve <IO$BODY: boolean hasAspect()> from IO$BODY
retrieve <IO$BODY: void <init>()> from IO$BODY
retrieve <IO$BODY: java.lang.String toString(IO)> from IO$BODY
retrieve <IO$BODY: IO$BODY aspectOf()> from IO$BODY
retrieve <CO: void <init>()> from CO
retrieve <CO: java.lang.String toString()> from CO
Transforming I1... 
Transforming CO... 
Transforming MethodConflictsCP... 
Transforming C... 
Transforming IO... 
Transforming IO$BODY... 
Transforming I2... 
Transforming I1$BODY... 
Transforming BaseI... 
Transforming I2$BODY... 
Abc finished on Thu Jun 24 09:24:44 BST 2004. ( 0 min. 7 sec. )
PASS: potential method conflicts with introductions and interfaces and PR#561()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 183 failed (check: 71), 324 passed (check: 81), 1 skipped.
Executing test 509 (new): illegal method conflicts with introductions and interfaces and PR#561
Failed. Current status: 184 failed (check: 72), 324 passed (check: 81), 1 skipped.
Executing test 510 (new): AspectOf available for different aspect types
Failed. Current status: 185 failed (check: 72), 324 passed (check: 81), 1 skipped.
Executing test 511 (new/privilegedAspects): access to all members of class and inner class from privileged aspect
Failed. Current status: 186 failed (check: 72), 324 passed (check: 81), 1 skipped.
Executing test 512 (new): cflow alone with around produces compiler bcg StackOverflowError
Failed. Current status: 187 failed (check: 72), 324 passed (check: 81), 1 skipped.
Executing test 513 (new): get/set join points run for complex assignment operators (+=, etc.) (working)
================================================
Breakdown of abc phases  (total: 9813 millisec.)
------------------------------------------------
[ 00.367% ] Init. of Soot:  36
[ 00.031% ] Loading Jars:  3
[ 60.940% ] Polyglot phases:  5980
[ 00.020% ] Resolve class names:  2
[ 00.020% ] Declare Parents:  2
[ 00.520% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.367% ] Intertype Adjuster:  36
[ 07.419% ] Retrieving bodies:  728
[ 00.000% ] Weave Initializers:  0
[ 00.224% ] Load shadow types:  22
[ 20.717% ] Compute advice lists:  2033
[ 00.051% ] Intertype weave:  5
[ 00.173% ] Add aspect code:  17
[ 00.306% ] Weaving advice:  30
[ 00.000% ] Validate jimple:  0
[ 04.810% ] Soot Packs:  472
[ 04.035% ] Soot Writing Output:  396
================================================
Abc started on Thu Jun 24 09:25:08 BST 2004
<<<< AssignOps.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

aspect A {
    static boolean start = false;
    
    static int bset;
    
    static int bget;
    
    static int siset;
    
    static int siget;
    
    static int iset;
    
    static int iget;
    
    static void start() {
        A/*A*/.siset =
          (A/*A*/.siget = (A/*A*/.iset = (A/*A*/.iget = 0)));
        A/*A*/.start = true;
    }
    
    static java.lang.String p() {
        return " siset=" + A/*A*/.siset + " siget=" + A/*A*/.siget +
               " iset=" +
               A/*A*/.iset +
               " iget=" +
        A/*A*/.iget;
    }
    
    before():
    get( int (AssignOps).staticInt) {
        signal(AssignOps/*AssignOps*/.sigetStr + A/*A*/.siget++);
        check(A/*A*/.siget ==
              1 + A/*A*/.siset,
              "siget == (1+siset)" +
              p());
    }
    
    before():
    set( int (AssignOps).staticInt) {
        signal(AssignOps/*AssignOps*/.sisetStr + A/*A*/.siset++);
        check(A/*A*/.siget == A/*A*/.siset, "siget == siset" + p());
    }
    
    before():
    get( int (AssignOps).instanceInt) {
        signal(AssignOps/*AssignOps*/.igetStr + A/*A*/.iget++);
        check(A/*A*/.iget ==
              1 + A/*A*/.iset,
              "iget == (1+iset)" +
              p());
    }
    
    before():
    set( int (AssignOps).instanceInt) {
        signal(AssignOps/*AssignOps*/.isetStr + A/*A*/.iset++);
        check(A/*A*/.iget == A/*A*/.iset, "iget == iset" + p());
    }
    
    before():
    get( boolean (AssignOps).bool) {
        signal(AssignOps/*AssignOps*/.bgetStr + A/*A*/.bget++);
        check(A/*A*/.bget ==
              1 + A/*A*/.bset,
              "bget == (1+bset)" +
              p());
    }
    
    before():
    set( boolean (AssignOps).bool) {
        signal(AssignOps/*AssignOps*/.bsetStr + A/*A*/.bset++);
        check(A/*A*/.bget == A/*A*/.bset, "bget == bset" + p());
    }
    
    static void check(boolean b, java.lang.String s) {
        if (A/*A*/.start) org.aspectj.testing.Tester.check(b, s);
    }
    
    static void signal(java.lang.String s) {
        if (A/*A*/.start) org.aspectj.testing.Tester.event(s);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
public class AssignOps {
    static int staticInt;
    
    int instanceInt;
    
    boolean bool;
    
    static final java.lang.String sisetStr =
      "before() : set(int AssignOps.staticInt)";
    
    static final java.lang.String sigetStr =
      "before() : get(int AssignOps.staticInt)";
    
    static final java.lang.String isetStr =
      "before() : set(int AssignOps.instanceInt)";
    
    static final java.lang.String igetStr =
      "before() : get(int AssignOps.instanceInt)";
    
    static final java.lang.String bsetStr =
      "before() : set(boolean AssignOps.bool)";
    
    static final java.lang.String bgetStr =
      "before() : get(boolean AssignOps.bool)";
    
    public static void main(java.lang.String[] args) {
        new AssignOps(3).run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static void t(java.lang.String s) {
        org.aspectj.testing.Tester.expectEvent(s);
    }
    
    AssignOps(int i) {
        super();
        this/*null*/.instanceInt = i;
    }
    
    void run() {
        A.start();
        t(AssignOps/*AssignOps*/.igetStr + "0");
        t(AssignOps/*AssignOps*/.isetStr + "0");
        this/*null*/.instanceInt++;
        t(AssignOps/*AssignOps*/.sigetStr + "0");
        t(AssignOps/*AssignOps*/.sisetStr + "0");
        AssignOps/*AssignOps*/.staticInt++;
        t(AssignOps/*AssignOps*/.igetStr + "1");
        t(AssignOps/*AssignOps*/.isetStr + "1");
        this/*null*/.instanceInt += 2;
        t(AssignOps/*AssignOps*/.sigetStr + "1");
        t(AssignOps/*AssignOps*/.sisetStr + "1");
        AssignOps/*AssignOps*/.staticInt += 2;
        t(AssignOps/*AssignOps*/.igetStr + "2");
        t(AssignOps/*AssignOps*/.isetStr + "2");
        this/*null*/.instanceInt--;
        t(AssignOps/*AssignOps*/.sigetStr + "2");
        t(AssignOps/*AssignOps*/.sisetStr + "2");
        AssignOps/*AssignOps*/.staticInt--;
        t(AssignOps/*AssignOps*/.igetStr + "3");
        t(AssignOps/*AssignOps*/.isetStr + "3");
        this/*null*/.instanceInt -= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "3");
        t(AssignOps/*AssignOps*/.sisetStr + "3");
        AssignOps/*AssignOps*/.staticInt -= 2;
        t(AssignOps/*AssignOps*/.igetStr + "4");
        t(AssignOps/*AssignOps*/.isetStr + "4");
        this/*null*/.instanceInt *= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "4");
        t(AssignOps/*AssignOps*/.sisetStr + "4");
        AssignOps/*AssignOps*/.staticInt *= 2;
        t(AssignOps/*AssignOps*/.igetStr + "5");
        t(AssignOps/*AssignOps*/.isetStr + "5");
        this/*null*/.instanceInt /= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "5");
        t(AssignOps/*AssignOps*/.sisetStr + "5");
        AssignOps/*AssignOps*/.staticInt /= 2;
        t(AssignOps/*AssignOps*/.igetStr + "6");
        t(AssignOps/*AssignOps*/.isetStr + "6");
        this/*null*/.instanceInt %= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "6");
        t(AssignOps/*AssignOps*/.sisetStr + "6");
        AssignOps/*AssignOps*/.staticInt %= 2;
        t(AssignOps/*AssignOps*/.igetStr + "7");
        t(AssignOps/*AssignOps*/.isetStr + "7");
        this/*null*/.instanceInt >>= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "7");
        t(AssignOps/*AssignOps*/.sisetStr + "7");
        AssignOps/*AssignOps*/.staticInt >>= 2;
        t(AssignOps/*AssignOps*/.igetStr + "8");
        t(AssignOps/*AssignOps*/.isetStr + "8");
        this/*null*/.instanceInt <<= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "8");
        t(AssignOps/*AssignOps*/.sisetStr + "8");
        AssignOps/*AssignOps*/.staticInt <<= 2;
        t(AssignOps/*AssignOps*/.igetStr + "9");
        t(AssignOps/*AssignOps*/.isetStr + "9");
        this/*null*/.instanceInt >>>= 2;
        t(AssignOps/*AssignOps*/.sigetStr + "9");
        t(AssignOps/*AssignOps*/.sisetStr + "9");
        AssignOps/*AssignOps*/.staticInt >>>= 2;
        t(AssignOps/*AssignOps*/.bgetStr + "0");
        t(AssignOps/*AssignOps*/.bsetStr + "0");
        this/*null*/.bool &= true;
        t(AssignOps/*AssignOps*/.bgetStr + "1");
        t(AssignOps/*AssignOps*/.bsetStr + "1");
        this/*null*/.bool |= false;
        t(AssignOps/*AssignOps*/.bgetStr + "2");
        t(AssignOps/*AssignOps*/.bsetStr + "2");
        this/*null*/.bool ^= false;
    }
}
retrieve <A: void start()> from A
retrieve <A: java.lang.String p()> from A
retrieve <A: void before$0()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: void before$3()> from A
retrieve <A: void before$4()> from A
retrieve <A: void before$5()> from A
retrieve <A: void check(boolean,java.lang.String)> from A
retrieve <A: void signal(java.lang.String)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <AssignOps: void main(java.lang.String[])> from AssignOps
retrieve <AssignOps: void t(java.lang.String)> from AssignOps
retrieve <AssignOps: void <init>(int)> from AssignOps
retrieve <AssignOps: void run()> from AssignOps
retrieve <AssignOps: void <clinit>()> from AssignOps
Transforming A... 
Transforming AssignOps... 
Abc finished on Thu Jun 24 09:25:18 BST 2004. ( 0 min. 9 sec. )
PASS: get/set join points run for complex assignment operators (+=, etc.) (wor...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 187 failed (check: 72), 325 passed (check: 81), 1 skipped.
Executing test 514 (new/introTypeMissing): this available in introduced field initializers
================================================
Breakdown of abc phases  (total: 7981 millisec.)
------------------------------------------------
[ 00.464% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 69.979% ] Polyglot phases:  5585
[ 00.025% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.551% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.501% ] Intertype Adjuster:  40
[ 08.044% ] Retrieving bodies:  642
[ 00.226% ] Weave Initializers:  18
[ 00.276% ] Load shadow types:  22
[ 11.452% ] Compute advice lists:  914
[ 00.038% ] Intertype weave:  3
[ 00.263% ] Add aspect code:  21
[ 00.175% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 04.398% ] Soot Packs:  351
[ 03.558% ] Soot Writing Output:  284
================================================
Abc started on Thu Jun 24 09:25:20 BST 2004
<<<< ThisInIntroFieldInit.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class ThisInIntroFieldInit {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("result init");
        org.aspectj.testing.Tester.expectEvent("internalResult init");
        TargetClass me = new TargetClass();
        org.aspectj.testing.Tester.check(me/*null*/.t_result_ref,
                                         "me.t_result_ref");
        org.aspectj.testing.Tester.check(me/*null*/.t_result_ref_this,
                                         "me.t_result_ref_this");
        org.aspectj.testing.Tester.check(me/*null*/.t_result_ref_qualified,
                                         "me.t_result_ref_qualified");
        org.aspectj.testing.Tester.check(me/*null*/.t_result,
                                         "me.t_result");
        org.aspectj.testing.Tester.check(me/*null*/.t_result_this,
                                         "me.t_result_this");
        org.aspectj.testing.Tester.check(me/*null*/.t_result_qualified,
                                         "me.t_result_qualified");
        org.aspectj.testing.Tester.check(me/*null*/.t_result_anon,
                                         "me.t_result_anon");
        org.aspectj.testing.Tester.check(!me/*null*/.result_ref,
                                         "me.result_ref");
        org.aspectj.testing.Tester.check(!me/*null*/.result_ref_this,
                                         "me.result_ref_this");
        org.aspectj.testing.Tester.check(!me/*null*/.result_ref_qualified,
                                         "me.result_ref_qualified");
        org.aspectj.testing.Tester.check(me/*null*/.result,
                                         "me.result");
        org.aspectj.testing.Tester.check(me/*null*/.result_this,
                                         "me.result_this");
        org.aspectj.testing.Tester.check(me/*null*/.result_qualified,
                                         "me.result_qualified");
        org.aspectj.testing.Tester.check(me/*null*/.result_anon,
                                         "me.result_anon");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public ThisInIntroFieldInit() { super(); }
}
class TargetClass {
    boolean targTest() { return null != this; }
    
    public boolean ok = this != null;
    
    public boolean t_result_ref = this/*null*/.ok;
    
    public boolean t_result_ref_this = this/*<unknown>*/.ok;
    
    public boolean t_result_ref_qualified =
      TargetClass.this/*<unknown>*/.ok;
    
    public boolean t_result = targTest();
    
    public boolean t_result_this = this.targTest();
    
    public boolean t_result_qualified = TargetClass.this.targTest();
    
    boolean t_result_anon =
      new Validator() {
          public boolean valid() {
              boolean one = targTest();
              boolean two = TargetClass.this.targTest();
              boolean three = ok;
              boolean four = TargetClass.this/*<unknown>*/.ok;
              Tester.event("internalResult init");
              return one && two && three && four;
          }
      }.valid();
    
    public TargetClass() { super(); }
}
interface Validator {
    public abstract boolean valid();
}
aspect A {
    public boolean TargetClass.result_ref =
      hostTargetClassthis/*null*/.ok;
    
    public boolean TargetClass.result_ref_this =
      hostTargetClassthis/*<unknown>*/.ok;
    
    public boolean TargetClass.result_ref_qualified =
      TargetClass.hostTargetClassthis/*<unknown>*/.ok;
    
    public boolean TargetClass.result = targTest();
    
    public boolean TargetClass.result_this =
      hostTargetClassthis.targTest();
    
    public boolean TargetClass.result_qualified =
      TargetClass.hostTargetClassthis.targTest();
    
    public boolean TargetClass.result_anon =
      new Validator() {
          public boolean valid() {
              boolean one = targTest();
              boolean two = TargetClass.this.targTest();
              boolean three = !ok;
              boolean four = !TargetClass.this/*<unknown>*/.ok;
              Tester.event("result init");
              return one && two && three && four;
          }
      }.valid();
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ThisInIntroFieldInit: void main(java.lang.String[])> from ThisInIntroFieldInit
retrieve <ThisInIntroFieldInit: void <init>()> from ThisInIntroFieldInit
retrieve <TargetClass: boolean targTest()> from TargetClass
retrieve <TargetClass: void <init>()> from TargetClass
retrieve <TargetClass$1: void <init>(TargetClass)> from TargetClass$1
retrieve <TargetClass$1: boolean valid()> from TargetClass$1
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: boolean init$result_ref$14(TargetClass)> from A
retrieve <A: boolean init$result_ref_this$15(TargetClass)> from A
retrieve <A: boolean init$result_ref_qualified$16(TargetClass)> from A
retrieve <A: boolean init$result$17(TargetClass)> from A
retrieve <A: boolean init$result_this$18(TargetClass)> from A
retrieve <A: boolean init$result_qualified$19(TargetClass)> from A
retrieve <A: boolean init$result_anon$20(TargetClass)> from A
retrieve <A$1: void <init>(TargetClass)> from A$1
retrieve <A$1: boolean valid()> from A$1
Transforming TargetClass... 
Transforming A... 
Transforming Validator... 
Transforming ThisInIntroFieldInit... 
Transforming TargetClass$1... 
Transforming A$1... 
Abc finished on Thu Jun 24 09:25:29 BST 2004. ( 0 min. 8 sec. )
PASS: this available in introduced field initializers()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 187 failed (check: 72), 326 passed (check: 81), 1 skipped.
Executing test 515 (new/introTypeMissing): Introduced type unavailable to cast expressions in introduced methods
Failed. Current status: 188 failed (check: 72), 326 passed (check: 81), 1 skipped.
Executing test 516 (new/introTypeMissing): Introduced type unavailable to qualified new expressions in introduced methods
Failed. Current status: 189 failed (check: 72), 326 passed (check: 81), 1 skipped.
Executing test 517 (new/introTypeMissing): Introduced type unavailable to cast expressions in introduced field initializers
Failed. Current status: 190 failed (check: 72), 326 passed (check: 81), 1 skipped.
Executing test 518 (new/introTypeMissing): Aspect type unavailable to qualified new expressions in body of introduced methods
================================================
Breakdown of abc phases  (total: 6866 millisec.)
------------------------------------------------
[ 00.524% ] Init. of Soot:  36
[ 00.058% ] Loading Jars:  4
[ 78.182% ] Polyglot phases:  5368
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.743% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 01.966% ] Intertype Adjuster:  135
[ 05.724% ] Retrieving bodies:  393
[ 00.000% ] Weave Initializers:  0
[ 00.320% ] Load shadow types:  22
[ 03.889% ] Compute advice lists:  267
[ 00.044% ] Intertype weave:  3
[ 00.495% ] Add aspect code:  34
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.428% ] Soot Packs:  304
[ 03.379% ] Soot Writing Output:  232
================================================
Abc started on Thu Jun 24 09:25:59 BST 2004
<<<< AspectInIntroducedMethod.java >>>>
import org.aspectj.testing.Tester;

public class AspectInIntroducedMethod {
    public static void main(java.lang.String[] args) {
        java.lang.String result = new TargetClass().addMethod();
        org.aspectj.testing.Tester.check("inner".equals(result),
                                         "\"inner\".equals(\"" +
                                         result +
                                         "\")");
    }
    
    public AspectInIntroducedMethod() { super(); }
}
aspect A {
    class inner {
        public java.lang.String name() { return "inner"; }
        
        public inner() { super(); }
    }
    
    
    public java.lang.String getName() {
        this.new A.inner();
        A a = this;
        return a.new inner().name();
    }
    
    public intertype java.lang.String TargetClass.addMethod() {
        java.lang.String result = null;
        A a = A.aspectOf();
        result = a.getName();
        result = a.new inner().name();
        return result;
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class TargetClass {
    public TargetClass() { super(); }
}
retrieve <AspectInIntroducedMethod: void <init>()> from AspectInIntroducedMethod
retrieve <AspectInIntroducedMethod: void main(java.lang.String[])> from AspectInIntroducedMethod
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String getName()> from A
retrieve <A: java.lang.String addMethod(TargetClass)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A$inner: void <init>(A)> from A$inner
retrieve <A$inner: java.lang.String name()> from A$inner
retrieve <TargetClass: void <init>()> from TargetClass
retrieve <TargetClass: java.lang.String addMethod()> from TargetClass
Transforming TargetClass... 
Transforming A... 
Transforming A$inner... 
Transforming AspectInIntroducedMethod... 
Abc finished on Thu Jun 24 09:26:06 BST 2004. ( 0 min. 6 sec. )
PASS: Aspect type unavailable to qualified new expressions in body of introduc...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 190 failed (check: 72), 327 passed (check: 81), 1 skipped.
Executing test 519 (new/introTypeMissing): Introduced type unavailable to instanceof expressions in introduced methods
Failed. Current status: 191 failed (check: 73), 327 passed (check: 81), 1 skipped.
Executing test 520 (new/introTypeMissing): Introduced type unavailable to qualified new expressions in introduced field initializers
Failed. Current status: 192 failed (check: 73), 327 passed (check: 81), 1 skipped.
Executing test 521 (new): variable slots and finally/catch causing verify errors
================================================
Breakdown of abc phases  (total: 7679 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 75.882% ] Polyglot phases:  5827
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.586% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.482% ] Intertype Adjuster:  37
[ 08.504% ] Retrieving bodies:  653
[ 00.000% ] Weave Initializers:  0
[ 00.286% ] Load shadow types:  22
[ 04.740% ] Compute advice lists:  364
[ 00.039% ] Intertype weave:  3
[ 00.195% ] Add aspect code:  15
[ 00.859% ] Weaving advice:  66
[ 00.000% ] Validate jimple:  0
[ 04.428% ] Soot Packs:  340
[ 03.425% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 09:26:22 BST 2004
<<<< AfterFinally.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class AfterFinally {
    public static void main(java.lang.String[] args) {
        new AfterFinally().m("hi");
    }
    
    private java.lang.String getX() { return "X"; }
    
    public java.util.Collection m(java.lang.String key) {
        java.lang.String x = null;
        java.util.ArrayList y = new java.util.ArrayList();
        java.util.Iterator i = null;
        try {
            x = this.getX();
            java.util.Collection personList =
              new java.util.ArrayList();
            y.add("foo");
            i = y.iterator();
            while (i.hasNext()) {
                personList.add(new java.lang.String(i.next() +
                                                    " foo"));
            }
            return personList;
        }
        catch (java.lang.Exception e) {
            throw new java.lang.RuntimeException("bad:" + e);
        }
        finally {
            x.toString();
            y.toString();
            i.toString();
        }
    }
    
    public AfterFinally() { super(); }
}
aspect A {
    before():
    execution (* (*).*(..)) &&
      within(AfterFinally) {
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
    }
    
    after():
    execution (* (*).*(..)) &&
      within(AfterFinally) {
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AfterFinally: java.lang.String getX()> from AfterFinally
retrieve <AfterFinally: java.util.Collection m(java.lang.String)> from AfterFinally
retrieve <AfterFinally: void <init>()> from AfterFinally
retrieve <AfterFinally: void main(java.lang.String[])> from AfterFinally
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void after$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming AfterFinally... 
Abc finished on Thu Jun 24 09:26:30 BST 2004. ( 0 min. 7 sec. )
execution(void AfterFinally.main(String[]))
execution(Collection AfterFinally.m(String))
execution(String AfterFinally.getX())
execution(String AfterFinally.getX())
execution(Collection AfterFinally.m(String))
execution(void AfterFinally.main(String[]))
PASS: variable slots and finally/catch causing verify errors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 192 failed (check: 73), 328 passed (check: 81), 1 skipped.
Executing test 522 (new): enclosing join point not exported properly in pre-initialization join point
Failed. Current status: 193 failed (check: 73), 328 passed (check: 81), 1 skipped.
Executing test 523 (new): after advice on static method with pcd if() using result
Failed. Current status: 194 failed (check: 74), 328 passed (check: 81), 1 skipped.
Executing test 524 (new): after advice on static method with pcd if() using result through pointcut
Failed. Current status: 195 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 525 (new/PR600): AbstractMethodError for introduced methods (order 1)
Failed. Current status: 196 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 526 (new/PR600): AbstractMethodError for introduced methods (order 2)
Failed. Current status: 197 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 527 (new/PR600): AbstractMethodError for introduced methods (order 3)
Failed. Current status: 198 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 528 (new/PR600): AbstractMethodError for introduced methods (order 4)
Failed. Current status: 199 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 529 (new/PR600): AbstractMethodError for introduced methods (order 5)
Failed. Current status: 200 failed (check: 75), 328 passed (check: 81), 1 skipped.
Executing test 530 (new): declare error and abstract pointcuts
================================================
Breakdown of abc phases  (total: 6802 millisec.)
------------------------------------------------
[ 00.529% ] Init. of Soot:  36
[ 00.044% ] Loading Jars:  3
[ 74.890% ] Polyglot phases:  5094
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.750% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.529% ] Intertype Adjuster:  36
[ 06.998% ] Retrieving bodies:  476
[ 00.000% ] Weave Initializers:  0
[ 00.323% ] Load shadow types:  22
[ 01.411% ] Compute advice lists:  96
[ 00.044% ] Intertype weave:  3
[ 00.588% ] Add aspect code:  40
[ 00.191% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.366% ] Soot Packs:  297
[ 09.277% ] Soot Writing Output:  631
================================================
Failed. Current status: 201 failed (check: 76), 328 passed (check: 81), 1 skipped.
Executing test 531 (new/runtime): Exercise runtime classes (optionally in 1.1 VM)
Failed. Current status: 202 failed (check: 76), 328 passed (check: 81), 1 skipped.
Executing test 532 (new): VerifyError after around advice falls off end of tryCatch
================================================
Breakdown of abc phases  (total: 6764 millisec.)
------------------------------------------------
[ 00.444% ] Init. of Soot:  30
[ 00.074% ] Loading Jars:  5
[ 80.381% ] Polyglot phases:  5437
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.813% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.532% ] Intertype Adjuster:  36
[ 08.013% ] Retrieving bodies:  542
[ 00.000% ] Weave Initializers:  0
[ 00.310% ] Load shadow types:  21
[ 02.395% ] Compute advice lists:  162
[ 00.044% ] Intertype weave:  3
[ 00.384% ] Add aspect code:  26
[ 00.192% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.179% ] Soot Packs:  215
[ 03.179% ] Soot Writing Output:  215
================================================
Failed. Current status: 203 failed (check: 77), 328 passed (check: 81), 1 skipped.
Executing test 533 (new): Named within pointcuts failing
================================================
Breakdown of abc phases  (total: 7073 millisec.)
------------------------------------------------
[ 00.523% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 73.844% ] Polyglot phases:  5223
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.650% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.537% ] Intertype Adjuster:  38
[ 06.659% ] Retrieving bodies:  471
[ 00.000% ] Weave Initializers:  0
[ 00.396% ] Load shadow types:  28
[ 08.002% ] Compute advice lists:  566
[ 00.042% ] Intertype weave:  3
[ 00.509% ] Add aspect code:  36
[ 00.382% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 05.231% ] Soot Packs:  370
[ 03.125% ] Soot Writing Output:  221
================================================
Abc started on Thu Jun 24 09:27:56 BST 2004
<<<< NamedWithinPointcuts.java >>>>
import org.aspectj.testing.Tester;

public class NamedWithinPointcuts {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("before");
        org.aspectj.testing.Tester.checkAllEventsIgnoreDups();
    }
    
    public NamedWithinPointcuts() { super(); }
}
aspect Test {
    pointcut withinAspects() : within(Test);
    
    static void log() {  }
    
    before():
    !withinAspects() {
        log();
        org.aspectj.testing.Tester.event("before");
    }
    
    public static Test aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Test() { super(); }
}
retrieve <NamedWithinPointcuts: void main(java.lang.String[])> from NamedWithinPointcuts
retrieve <NamedWithinPointcuts: void <init>()> from NamedWithinPointcuts
retrieve <Test: boolean hasAspect()> from Test
retrieve <Test: void <init>()> from Test
retrieve <Test: void log()> from Test
retrieve <Test: void before$0()> from Test
retrieve <Test: Test aspectOf()> from Test
Transforming NamedWithinPointcuts... 
Transforming Test... 
Abc finished on Thu Jun 24 09:28:03 BST 2004. ( 0 min. 7 sec. )
PASS: Named within pointcuts failing()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 203 failed (check: 77), 329 passed (check: 81), 1 skipped.
Executing test 534 (new/subaspects): aspect with private abstract pointcut
================================================
Breakdown of abc phases  (total: 6348 millisec.)
------------------------------------------------
[ 00.567% ] Init. of Soot:  36
[ 00.047% ] Loading Jars:  3
[ 77.867% ] Polyglot phases:  4943
[ 00.032% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  1
[ 00.709% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.567% ] Intertype Adjuster:  36
[ 12.193% ] Retrieving bodies:  774
[ 00.000% ] Weave Initializers:  0
[ 00.457% ] Load shadow types:  29
[ 00.614% ] Compute advice lists:  39
[ 00.047% ] Intertype weave:  3
[ 00.599% ] Add aspect code:  38
[ 00.189% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.560% ] Soot Packs:  226
[ 02.536% ] Soot Writing Output:  161
================================================
Failed. Current status: 204 failed (check: 78), 329 passed (check: 81), 1 skipped.
Executing test 535 (new/subaspects): concrete aspect unable to access abstract package-private pointcut in parent for overriding
Failed. Current status: 205 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 536 (new/subaspects): inner, outer, and outside-package subaspects of an aspect with abstract protected-, public-, and default-access pointcuts
Failed. Current status: 206 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 537 (new/subaspects): inner subaspects of an aspect with private pointcut
Failed. Current status: 207 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 538 (new/subaspects): outer subaspects of an aspect with private pointcut
Failed. Current status: 208 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 539 (new/subaspects): abstract aspect used statically should not cause instantiation of advice or pointcut
Failed. Current status: 209 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 540 (new): private inner interface accessible in scope when declared on outer class
Failed. Current status: 210 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 541 (new): accessing protected superclass members in and outside CCC from body of method introduction
Failed. Current status: 211 failed (check: 79), 329 passed (check: 81), 1 skipped.
Executing test 542 (new): accessing private superclass members from body of method introduction
Failed. Current status: 212 failed (check: 80), 329 passed (check: 81), 1 skipped.
Executing test 543 (new): simple test for around and casting
================================================
Breakdown of abc phases  (total: 7360 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 73.709% ] Polyglot phases:  5425
[ 00.027% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.802% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.489% ] Intertype Adjuster:  36
[ 06.617% ] Retrieving bodies:  487
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 02.283% ] Compute advice lists:  168
[ 00.041% ] Intertype weave:  3
[ 00.530% ] Add aspect code:  39
[ 01.291% ] Weaving advice:  95
[ 00.000% ] Validate jimple:  0
[ 09.769% ] Soot Packs:  719
[ 03.573% ] Soot Writing Output:  263
================================================
Abc started on Thu Jun 24 09:29:05 BST 2004
<<<< AroundCasting.java >>>>
import org.aspectj.testing.Tester;

public class AroundCasting {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(AroundCasting/*AroundCasting*/.x =
                                                3,
                                              3);
        org.aspectj.testing.Tester.checkEqual(AroundCasting/*AroundCasting*/.x,
                                              1003);
        org.aspectj.testing.Tester.checkEvents(new java.lang.String[] { "enter main" });
    }
    
    static int x;
    
    public AroundCasting() { super(); }
}
aspect A {
    static boolean test() { return true; }
    
    int around ():
    if(test()) &&
      get( int (AroundCasting).x) {
        return this.proceed() + 1000;
    }
    
    void around ():
    execution (void (AroundCasting).main(String[])) {
        org.aspectj.testing.Tester.event("enter main");
        this.proceed();
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AroundCasting: void main(java.lang.String[])> from AroundCasting
retrieve <AroundCasting: void <init>()> from AroundCasting
retrieve <A: boolean test()> from A
retrieve <A: int around$0()> from A
retrieve <A: void around$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: boolean if$3()> from A
retrieve <A: int proceed$2()> from A
retrieve <A: void proceed$4()> from A
Transforming A... 
Transforming AroundCasting... 
Transforming abc$access$A$around$0... 
Transforming abc$access$A$around$1... 
Abc finished on Thu Jun 24 09:29:12 BST 2004. ( 0 min. 7 sec. )
PASS: simple test for around and casting()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 212 failed (check: 80), 330 passed (check: 81), 1 skipped.
Executing test 544 (new/aroundinner): aroundInner 1 - around advice inner Thread subclass running proceed but not writing field
Failed. Current status: 213 failed (check: 80), 330 passed (check: 81), 1 skipped.
Executing test 545 (new/aroundinner): aroundInner 2 - around advice inner Runnable running proceed and writing method-final proxy
Failed. Current status: 214 failed (check: 80), 330 passed (check: 81), 1 skipped.
Executing test 546 (new/aroundinner): aroundInner 3 - around advice inner class running proceed and writing field
================================================
Breakdown of abc phases  (total: 7701 millisec.)
------------------------------------------------
[ 00.480% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 74.601% ] Polyglot phases:  5745
[ 00.013% ] Resolve class names:  1
[ 00.026% ] Declare Parents:  2
[ 00.636% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.467% ] Intertype Adjuster:  36
[ 08.882% ] Retrieving bodies:  684
[ 00.013% ] Weave Initializers:  1
[ 00.325% ] Load shadow types:  25
[ 05.168% ] Compute advice lists:  398
[ 00.039% ] Intertype weave:  3
[ 00.156% ] Add aspect code:  12
[ 00.987% ] Weaving advice:  76
[ 00.000% ] Validate jimple:  0
[ 04.155% ] Soot Packs:  320
[ 04.012% ] Soot Writing Output:  309
================================================
Abc started on Thu Jun 24 09:29:33 BST 2004
<<<< Minimal.java >>>>
public class Minimal {
    public static void main(java.lang.String[] args) {
        Target.main(args);
    }
    
    public Minimal() { super(); }
}
class MyObject {
    int result = 0;
    
    public MyObject() { super(); }
}
aspect Aspect {
    static final java.lang.String[] SIGNALS =
      new java.lang.String[] { "around - run - before proceed", "around - run - after proceed" };
    
    int around ():
    pointcutTarget() {
        MyObject o =
          new MyObject() {
            void ignored() { result = 1; }
        };
        Common.signal(Aspect/*Aspect*/.SIGNALS[0]);
        int i = this.proceed();
        Common.signal(Aspect/*Aspect*/.SIGNALS[1]);
        return i;
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
<<<< Common.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class Common {
    public static java.lang.String[] SIGNALS =
      new java.lang.String[] {  };
    
    public static final void expect(java.lang.String[] args) {
        for (int i = 0; i < args/*null*/.length; i++) {
            expect(args[i]);
        }
    }
    
    public static final void expect(java.lang.String s) {
        org.aspectj.testing.Tester.expectEvent(s);
    }
    
    public static final void signal(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public static final void fail(java.lang.String s) {
        org.aspectj.testing.Tester.check(false, s);
    }
    
    public static final void check() {
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static final void joinWith(java.lang.Thread thread) {
        if (null == thread) { Common.fail("null thread"); }
        try {
            thread.join();
        }
        catch (java.lang.InterruptedException e) {
            Common.fail("Interrupted");
        }
    }
    
    public Common() { super(); }
}
class Target {
    public static void main(java.lang.String[] args) {
        Common.expect(Target/*Target*/.SIGNALS);
        Common.expect(Aspect/*Aspect*/.SIGNALS);
        int result = new Target().targetMethod();
        if (1 != result) Common.fail("1 != result: " + result);
        Common.check();
    }
    
    pointcut pointcutTarget() : call(int (Target).targetMethod());
    
    public static java.lang.String[] SIGNALS =
      new java.lang.String[] { "targetMethod()" };
    
    public int targetMethod() {
        Common.signal(Target/*Target*/.SIGNALS[0]);
        return 1;
    }
    
    public Target() { super(); }
}
retrieve <Minimal: void main(java.lang.String[])> from Minimal
retrieve <Minimal: void <init>()> from Minimal
retrieve <MyObject: void <init>()> from MyObject
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: int around$0()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: int proceed$1()> from Aspect
retrieve <Aspect: void <clinit>()> from Aspect
retrieve <Aspect$1: void <init>(Aspect)> from Aspect$1
retrieve <Aspect$1: void ignored()> from Aspect$1
retrieve <Common: void expect(java.lang.String[])> from Common
retrieve <Common: void expect(java.lang.String)> from Common
retrieve <Common: void signal(java.lang.String)> from Common
retrieve <Common: void fail(java.lang.String)> from Common
retrieve <Common: void check()> from Common
retrieve <Common: void joinWith(java.lang.Thread)> from Common
retrieve <Common: void <init>()> from Common
retrieve <Common: void <clinit>()> from Common
retrieve <Target: void <clinit>()> from Target
retrieve <Target: void main(java.lang.String[])> from Target
retrieve <Target: void <init>()> from Target
retrieve <Target: int targetMethod()> from Target
Transforming Minimal... 
Transforming Aspect... 
Transforming Target... 
Transforming Common... 
Transforming MyObject... 
Transforming Aspect$1... 
Transforming abc$access$Aspect$around$0... 
Abc finished on Thu Jun 24 09:29:41 BST 2004. ( 0 min. 7 sec. )
PASS: aroundInner 3 - around advice inner class running proceed and writing fi...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 214 failed (check: 80), 331 passed (check: 81), 1 skipped.
Executing test 547 (new/aroundinner): aroundInner 4 - around advice inner Thread subclass running proceed and writing field
Failed. Current status: 215 failed (check: 80), 331 passed (check: 81), 1 skipped.
Executing test 548 (new/aroundinner): aroundInner 5 - around advice inner Runnable (subinterface) running proceed and writing field introduced on subinterface
Failed. Current status: 216 failed (check: 80), 331 passed (check: 81), 1 skipped.
Executing test 549 (new): Named local class closing over proceed invocation
Failed. Current status: 217 failed (check: 80), 331 passed (check: 81), 1 skipped.
Executing test 550 (new): beautiful recursive computation of factorial with around is now supported
================================================
Breakdown of abc phases  (total: 7297 millisec.)
------------------------------------------------
[ 00.507% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 73.839% ] Polyglot phases:  5388
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.576% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.781% ] Intertype Adjuster:  57
[ 06.784% ] Retrieving bodies:  495
[ 00.000% ] Weave Initializers:  0
[ 00.301% ] Load shadow types:  22
[ 02.275% ] Compute advice lists:  166
[ 00.055% ] Intertype weave:  4
[ 00.274% ] Add aspect code:  20
[ 01.179% ] Weaving advice:  86
[ 00.000% ] Validate jimple:  0
[ 09.812% ] Soot Packs:  716
[ 03.522% ] Soot Writing Output:  257
================================================
Abc started on Thu Jun 24 09:30:05 BST 2004
<<<< CircularAdvice.java >>>>
import org.aspectj.testing.Tester;

public class CircularAdvice {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(m(5),
                                              5 * 4 * 3 * 2 *
                                              1,
                                              "factorial with advice");
    }
    
    public static long m(long l) { return -1; }
    
    public CircularAdvice() { super(); }
}
aspect FactorialViaAround {
    long around (long l):
    call(long (*).m(long)) &&
      args(l) {
        if (l == 0) {
            return 1;
        } else {
            return l * CircularAdvice.m(l - 1);
        }
    }
    
    public static FactorialViaAround aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public FactorialViaAround() { super(); }
}
retrieve <CircularAdvice: void main(java.lang.String[])> from CircularAdvice
retrieve <CircularAdvice: long m(long)> from CircularAdvice
retrieve <CircularAdvice: void <init>()> from CircularAdvice
retrieve <FactorialViaAround: long around$0(long)> from FactorialViaAround
retrieve <FactorialViaAround: FactorialViaAround aspectOf()> from FactorialViaAround
retrieve <FactorialViaAround: boolean hasAspect()> from FactorialViaAround
retrieve <FactorialViaAround: void <init>()> from FactorialViaAround
retrieve <FactorialViaAround: long proceed$1(long)> from FactorialViaAround
Transforming FactorialViaAround... 
Transforming CircularAdvice... 
Transforming abc$access$FactorialViaAround$around$0... 
Abc finished on Thu Jun 24 09:30:12 BST 2004. ( 0 min. 7 sec. )
PASS: beautiful recursive computation of factorial with around is now supported()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 217 failed (check: 80), 332 passed (check: 81), 1 skipped.
Executing test 551 (new): multi-dispatch not used for named pcd references
Abc started on Thu Jun 24 09:30:15 BST 2004
<<<< MultiDispatchCf.java >>>>
import org.aspectj.testing.Tester;

public class MultiDispatchCf {
    public static void main(java.lang.String[] args) {
        C c = new C();
        org.aspectj.testing.Tester.event("**** exec ****");
        run(new C());
        org.aspectj.testing.Tester.event("**** call ****");
        run(new C());
        org.aspectj.testing.Tester.event("**** both=call ****");
        run(new C());
        org.aspectj.testing.Tester.printEvents();
    }
    
    static void run(C c) {
        org.aspectj.testing.Tester.event(c.doit("s1"));
        org.aspectj.testing.Tester.event(c.doit(new java.lang.Integer(10)));
        org.aspectj.testing.Tester.event(c.doit(new java.lang.Double(1.25)));
        java.lang.Object o;
        o = "s2";
        org.aspectj.testing.Tester.event(c.doit(o));
        o = new java.lang.Integer(20);
        org.aspectj.testing.Tester.event(c.doit(o));
        o = new java.lang.Double(2.25);
        org.aspectj.testing.Tester.event(c.doit(o));
    }
    
    public MultiDispatchCf() { super(); }
}
class C {
    java.lang.String doit(java.lang.Object o) {
        return "did-" + o.toString();
    }
    
    public C() { super(); }
}
aspect MultiCall {
    pointcut t1(java.lang.String s) :
    call(String (C).doit(Object)) &&
      args(s);
    
    String around (String s): t1(s) { return this.proceed(s); }
    
    String around (Object o): t1(o) { return this.proceed(o); }
    
    pointcut m(java.lang.Object o) :
    call(String (C).doit(Object)) &&
      args(o);
    
    java.lang.String getPrefix() { return "call"; }
    
    String around (String s):
    m(s) {
        return getPrefix() + "-string-" + s;
    }
    
    String around (Integer i):
    m(i) {
        return getPrefix() + "-integer-" + i;
    }
    
    String around (Double d):
    m(d) {
        return getPrefix() + "-double-" + d;
    }
    
    public static MultiCall aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MultiCall() { super(); }
}
aspect MultiCreate {
    pointcut make(java.lang.Object o) :
    this(o) &&
      execution ((*).new(..));
    
    private static interface I {}
    
    
    declare parents : C implements MultiCreate.I;
    
    before(I i):
    make(i) {
        java.lang.System/*java.lang.System*/.out.println("new I: " +
                                                         i);
    }
    
    public static MultiCreate aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MultiCreate() { super(); }
}
PASS: multi-dispatch not used for named pcd references()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 3 seconds
Passed. Current status: 217 failed (check: 80), 333 passed (check: 82), 1 skipped.
Executing test 552 (new): multi-dispatch implemented through around + args
Failed. Current status: 218 failed (check: 80), 333 passed (check: 82), 1 skipped.
Executing test 553 (new): unrecognized aspect should not net Cloneable and Serializable warnings
Abc started on Thu Jun 24 09:30:28 BST 2004
PASS: unrecognized aspect should not net Cloneable and Serializable warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 218 failed (check: 80), 334 passed (check: 83), 1 skipped.
Executing test 554 (new): unreachable code generated by around advice on the execution of void methods
getting SJPInfo for a untagged source line goto [?= (branch)]
getting SJPInfo for a untagged source line return
Failed. Current status: 219 failed (check: 80), 334 passed (check: 83), 1 skipped.
Executing test 555 (new): Overriding method implementations using introduction on interfaces
Failed. Current status: 220 failed (check: 80), 334 passed (check: 83), 1 skipped.
Executing test 556 (new): more coverage for around and concrete methods on interfaces
Failed. Current status: 221 failed (check: 80), 334 passed (check: 83), 1 skipped.
Executing test 557 (new): invalid number and type of proceed arguments
Failed. Current status: 222 failed (check: 81), 334 passed (check: 83), 1 skipped.
Executing test 558 (new): after returning advice order
================================================
Breakdown of abc phases  (total: 10273 millisec.)
------------------------------------------------
[ 00.360% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  4
[ 54.940% ] Polyglot phases:  5644
[ 00.019% ] Resolve class names:  2
[ 00.010% ] Declare Parents:  1
[ 00.516% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.350% ] Intertype Adjuster:  36
[ 05.354% ] Retrieving bodies:  550
[ 00.010% ] Weave Initializers:  1
[ 00.204% ] Load shadow types:  21
[ 10.455% ] Compute advice lists:  1074
[ 00.029% ] Intertype weave:  3
[ 00.175% ] Add aspect code:  18
[ 03.154% ] Weaving advice:  324
[ 00.000% ] Validate jimple:  0
[ 15.896% ] Soot Packs:  1633
[ 08.488% ] Soot Writing Output:  872
================================================
Abc started on Thu Jun 24 09:30:51 BST 2004
<<<< Cricket.java >>>>
import org.aspectj.testing.Tester;

public class Cricket {
    public static void main(java.lang.String[] args) {
        Lib l = new Lib();
        org.aspectj.testing.Tester.event("call stringMethod");
        l.stringMethod(2);
        org.aspectj.testing.Tester.event("call voidMethod");
        l.voidMethod(2);
        org.aspectj.testing.Tester.checkEventsFromFile("Cricket.out");
    }
    
    public Cricket() { super(); }
}
class Lib {
    public void voidMethod(int count) {
        if (count == 0) return; else voidMethod(count - 1);
    }
    
    public java.lang.String stringMethod(int count) {
        if (count == 0)
            return "0";
        else
            return count + "-" + stringMethod(count - 1);
    }
    
    public Lib() { super(); }
}
aspect Trace {
    pointcut entry() : target(Lib) && call(* (*).*(..));
    
    pointcut topEntry() : entry() && !cflowbelow(entry());
    
    before():
    topEntry() {
        org.aspectj.testing.Tester.event("->top entry: " +
                                         thisJoinPoint);
    }
    
    after():
    entry() {
        org.aspectj.testing.Tester.event("->exit: " + thisJoinPoint);
    }
    
    after() returning(Object o):
    entry() {
        org.aspectj.testing.Tester.event("->exit: " + thisJoinPoint +
                                         " with " +
                                         o);
    }
    
    after():
    topEntry() {
        org.aspectj.testing.Tester.event("->top exit: " +
                                         thisJoinPoint);
    }
    
    after() returning(Object o):
    topEntry() {
        org.aspectj.testing.Tester.event("->top exit: " +
                                         thisJoinPoint +
                                         " with " +
                                         o);
    }
    
    public static Trace aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Trace() { super(); }
}
retrieve <Cricket: void main(java.lang.String[])> from Cricket
retrieve <Cricket: void <init>()> from Cricket
retrieve <Lib: void voidMethod(int)> from Lib
retrieve <Lib: java.lang.String stringMethod(int)> from Lib
retrieve <Lib: void <init>()> from Lib
retrieve <Trace: boolean hasAspect()> from Trace
retrieve <Trace: void <init>()> from Trace
retrieve <Trace: void before$0(org.aspectj.lang.JoinPoint)> from Trace
retrieve <Trace: void after$1(org.aspectj.lang.JoinPoint)> from Trace
retrieve <Trace: void afterReturning$2(java.lang.Object,org.aspectj.lang.JoinPoint)> from Trace
retrieve <Trace: void after$3(org.aspectj.lang.JoinPoint)> from Trace
retrieve <Trace: void afterReturning$4(java.lang.Object,org.aspectj.lang.JoinPoint)> from Trace
retrieve <Trace: Trace aspectOf()> from Trace
Transforming Cricket... 
Transforming Lib... 
Transforming Trace... 
Abc finished on Thu Jun 24 09:31:01 BST 2004. ( 0 min. 10 sec. )
PASS: after returning advice order()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 222 failed (check: 81), 335 passed (check: 83), 1 skipped.
Executing test 559 (new): after returning advice param
================================================
Breakdown of abc phases  (total: 7969 millisec.)
------------------------------------------------
[ 00.464% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 71.088% ] Polyglot phases:  5665
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.791% ] Recompute name pattern matches:  63
[ 00.000% ] Compute precedence relation:  0
[ 00.477% ] Intertype Adjuster:  38
[ 06.877% ] Retrieving bodies:  548
[ 00.000% ] Weave Initializers:  0
[ 00.339% ] Load shadow types:  27
[ 10.704% ] Compute advice lists:  853
[ 00.038% ] Intertype weave:  3
[ 00.502% ] Add aspect code:  40
[ 00.502% ] Weaving advice:  40
[ 00.000% ] Validate jimple:  0
[ 04.819% ] Soot Packs:  384
[ 03.313% ] Soot Writing Output:  264
================================================
Failed. Current status: 223 failed (check: 81), 335 passed (check: 83), 1 skipped.
Executing test 560 (new): ! and declaring types with callee-side call join points
Failed. Current status: 224 failed (check: 81), 335 passed (check: 83), 1 skipped.
Executing test 561 (new): . Binding the wrong arguments in withincode(..).
================================================
Breakdown of abc phases  (total: 7136 millisec.)
------------------------------------------------
[ 00.518% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 80.774% ] Polyglot phases:  5764
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.827% ] Recompute name pattern matches:  59
[ 00.000% ] Compute precedence relation:  0
[ 00.518% ] Intertype Adjuster:  37
[ 06.684% ] Retrieving bodies:  477
[ 00.000% ] Weave Initializers:  0
[ 00.308% ] Load shadow types:  22
[ 02.803% ] Compute advice lists:  200
[ 00.042% ] Intertype weave:  3
[ 00.490% ] Add aspect code:  35
[ 00.168% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.658% ] Soot Packs:  261
[ 03.111% ] Soot Writing Output:  222
================================================
Abc started on Thu Jun 24 09:31:17 BST 2004
<<<< BindingArgumentsInWithincode.java >>>>
import java.util.*;

public class BindingArgumentsInWithincode {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(true, "compiled");
    }
    
    public BindingArgumentsInWithincode() { super(); }
}
class C {
    public void someMethod(java.lang.String s) {
        new java.util.ArrayList().add(s + ":" + s);
    }
    
    public C() { super(); }
}
aspect A {
    pointcut top(java.lang.String s) :
    withincode(void (*).someMethod(String)) &&
      args(s);
    
    pointcut method(java.lang.Object o) :
    call(* (java.util.List).add(Object)) &&
      args(o);
    
    before(String s, Object o): top(s) && method(o) {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <BindingArgumentsInWithincode: void main(java.lang.String[])> from BindingArgumentsInWithincode
retrieve <BindingArgumentsInWithincode: void <init>()> from BindingArgumentsInWithincode
retrieve <C: void <init>()> from C
retrieve <C: void someMethod(java.lang.String)> from C
retrieve <A: void <init>()> from A
retrieve <A: void before$0(java.lang.String,java.lang.Object)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming BindingArgumentsInWithincode... 
Transforming A... 
Transforming C... 
Abc finished on Thu Jun 24 09:31:24 BST 2004. ( 0 min. 7 sec. )
PASS: . Binding the wrong arguments in withincode(..).()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 224 failed (check: 81), 336 passed (check: 83), 1 skipped.
Executing test 562 (new): . Matching arguments in cflow correctly.
================================================
Breakdown of abc phases  (total: 7510 millisec.)
------------------------------------------------
[ 00.493% ] Init. of Soot:  37
[ 00.040% ] Loading Jars:  3
[ 73.009% ] Polyglot phases:  5483
[ 00.146% ] Resolve class names:  11
[ 00.027% ] Declare Parents:  2
[ 00.493% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 00.759% ] Intertype Adjuster:  57
[ 06.471% ] Retrieving bodies:  486
[ 00.000% ] Weave Initializers:  0
[ 00.293% ] Load shadow types:  22
[ 03.382% ] Compute advice lists:  254
[ 00.067% ] Intertype weave:  5
[ 00.439% ] Add aspect code:  33
[ 00.852% ] Weaving advice:  64
[ 00.000% ] Validate jimple:  0
[ 04.421% ] Soot Packs:  332
[ 09.108% ] Soot Writing Output:  684
================================================
Abc started on Thu Jun 24 09:31:26 BST 2004
<<<< MatchingArgumentsInCflow.java >>>>
import org.aspectj.testing.*;
import java.util.*;

public class MatchingArgumentsInCflow {
    public static void main(java.lang.String[] args) {
        new MethodParam().someMethod("arg");
    }
    
    public MatchingArgumentsInCflow() { super(); }
}
class MethodParam {
    public void someMethod(java.lang.String arg) {
        java.util.List list = new java.util.LinkedList();
        list.add(new java.lang.String(arg + ":" + arg));
    }
    
    public MethodParam() { super(); }
}
aspect MethodParamAspect {
    pointcut flow(java.lang.String s) :
    cflow(execution (void (*).someMethod(String)) &&
      args(s));
    
    pointcut some(java.lang.Object o) :
    call(* (List).add(Object)) &&
      args(o);
    
    before(String s, Object o):
    flow(s) &&
      some(o) {
        org.aspectj.testing.Tester.checkEqual(s, "arg");
        org.aspectj.testing.Tester.checkEqual(o, "arg:arg");
        org.aspectj.testing.Tester.checkNotEqual(s, o);
    }
    
    public static MethodParamAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public MethodParamAspect() { super(); }
}
retrieve <MatchingArgumentsInCflow: void main(java.lang.String[])> from MatchingArgumentsInCflow
retrieve <MatchingArgumentsInCflow: void <init>()> from MatchingArgumentsInCflow
retrieve <MethodParam: void <init>()> from MethodParam
retrieve <MethodParam: void someMethod(java.lang.String)> from MethodParam
retrieve <MethodParamAspect: boolean hasAspect()> from MethodParamAspect
retrieve <MethodParamAspect: void <init>()> from MethodParamAspect
retrieve <MethodParamAspect: void before$0(java.lang.String,java.lang.Object)> from MethodParamAspect
retrieve <MethodParamAspect: MethodParamAspect aspectOf()> from MethodParamAspect
Transforming MatchingArgumentsInCflow... 
Transforming MethodParam... 
Transforming MethodParamAspect... 
Abc finished on Thu Jun 24 09:31:34 BST 2004. ( 0 min. 7 sec. )
PASS: . Matching arguments in cflow correctly.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 224 failed (check: 81), 337 passed (check: 83), 1 skipped.
Executing test 563 (new): . Binding variables with numbers in their name with pertarget(..)'s.
================================================
Breakdown of abc phases  (total: 9049 millisec.)
------------------------------------------------
[ 00.442% ] Init. of Soot:  40
[ 00.553% ] Loading Jars:  50
[ 63.311% ] Polyglot phases:  5729
[ 00.022% ] Resolve class names:  2
[ 00.011% ] Declare Parents:  1
[ 00.674% ] Recompute name pattern matches:  61
[ 00.000% ] Compute precedence relation:  0
[ 00.409% ] Intertype Adjuster:  37
[ 06.012% ] Retrieving bodies:  544
[ 00.000% ] Weave Initializers:  0
[ 00.276% ] Load shadow types:  25
[ 12.255% ] Compute advice lists:  1109
[ 00.033% ] Intertype weave:  3
[ 00.641% ] Add aspect code:  58
[ 01.580% ] Weaving advice:  143
[ 00.000% ] Validate jimple:  0
[ 07.901% ] Soot Packs:  715
[ 05.879% ] Soot Writing Output:  532
================================================
Abc started on Thu Jun 24 09:31:36 BST 2004
<<<< PerTargetAndVariablesWithNumbersInTheirNames.java >>>>
import org.aspectj.testing.*;

public class PerTargetAndVariablesWithNumbersInTheirNames {
    public static void main(java.lang.String[] args) {
        new C();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("Hello 1");
               org.aspectj.testing.Tester.expectEvent("World 2");
               org.aspectj.testing.Tester.expectEvent("Hello World around 1");
               org.aspectj.testing.Tester.expectEvent("Hello World around 2");
               org.aspectj.testing.Tester.expectEvent("Hello World around 3");
               org.aspectj.testing.Tester.expectEvent("Hello World around 4");
           }
    
    public PerTargetAndVariablesWithNumbersInTheirNames() { super(); }
}
class C {
    public C() {
        super();
        doSomething("Hello", "World");
    }
    
    public void doSomething(java.lang.String arg1,
                            java.lang.String arg2) {
        org.aspectj.testing.Tester.event(arg1 + " 1");
        org.aspectj.testing.Tester.event(arg2 + " 2");
    }
}
aspect A1 {
    void around (String arg1, String arg2):
    target(C) && call(public void (*).doSomething(String, String)) &&
      args(arg1, arg2) {
        org.aspectj.testing.Tester.event(arg1 + " " + arg2 +
                                         " around 1");
        this.proceed(arg1, arg2);
    }
    
    public static A1 aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A1() { super(); }
}
aspect A2 {
    void around (String arg1, String arg2):
    target(C) && call(public void (*).doSomething(String, String)) &&
      args(arg1, arg2) {
        org.aspectj.testing.Tester.event(arg1 + " " + arg2 +
                                         " around 2");
        this.proceed(arg1, arg2);
    }
    
    public static A2 aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A2() { super(); }
}
aspect A3 {
    void around (String arg1, String arg2):
    target(C) && call(public void (*).doSomething(String, String)) &&
      args(arg1, arg2) {
        org.aspectj.testing.Tester.event(arg1 + " " + arg2 +
                                         " around 3");
        this.proceed(arg1, arg2);
    }
    
    public static A3 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A3() { super(); }
}
aspect A4 {
    void around (String arg1, String arg2):
    target(C) && call(public void (*).doSomething(String, String)) &&
      args(arg1, arg2) {
        org.aspectj.testing.Tester.event(arg1 + " " + arg2 +
                                         " around 4");
        this.proceed(arg1, arg2);
    }
    
    public static A4 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A4() { super(); }
}
retrieve <PerTargetAndVariablesWithNumbersInTheirNames: void <init>()> from PerTargetAndVariablesWithNumbersInTheirNames
retrieve <PerTargetAndVariablesWithNumbersInTheirNames: void <clinit>()> from PerTargetAndVariablesWithNumbersInTheirNames
retrieve <PerTargetAndVariablesWithNumbersInTheirNames: void main(java.lang.String[])> from PerTargetAndVariablesWithNumbersInTheirNames
retrieve <C: void <init>()> from C
retrieve <C: void doSomething(java.lang.String,java.lang.String)> from C
retrieve <A1: void around$0(java.lang.String,java.lang.String)> from A1
retrieve <A1: A1 aspectOf(java.lang.Object)> from A1
retrieve <A1: boolean hasAspect(java.lang.Object)> from A1
retrieve <A1: void <init>()> from A1
retrieve <A1: void proceed$4(java.lang.String,java.lang.String)> from A1
retrieve <A2: void around$1(java.lang.String,java.lang.String)> from A2
retrieve <A2: A2 aspectOf(java.lang.Object)> from A2
retrieve <A2: boolean hasAspect(java.lang.Object)> from A2
retrieve <A2: void proceed$5(java.lang.String,java.lang.String)> from A2
retrieve <A2: void <init>()> from A2
retrieve <A3: void around$2(java.lang.String,java.lang.String)> from A3
retrieve <A3: A3 aspectOf()> from A3
retrieve <A3: boolean hasAspect()> from A3
retrieve <A3: void <init>()> from A3
retrieve <A3: void proceed$6(java.lang.String,java.lang.String)> from A3
retrieve <A4: void proceed$7(java.lang.String,java.lang.String)> from A4
retrieve <A4: boolean hasAspect()> from A4
retrieve <A4: void <init>()> from A4
retrieve <A4: void around$3(java.lang.String,java.lang.String)> from A4
retrieve <A4: A4 aspectOf()> from A4
Transforming A3... 
Transforming A4... 
Transforming PerTargetAndVariablesWithNumbersInTheirNames... 
Transforming A2... 
Transforming A1... 
Transforming C... 
Transforming A1$abc$PerTarget... 
Transforming A2$abc$PerTarget... 
Transforming abc$access$A1$around$0... 
Transforming abc$access$A2$around$1... 
Transforming abc$access$A3$around$2... 
Transforming abc$access$A4$around$3... 
Abc finished on Thu Jun 24 09:31:45 BST 2004. ( 0 min. 9 sec. )
PASS: . Binding variables with numbers in their name with pertarget(..)'s.()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 224 failed (check: 81), 338 passed (check: 83), 1 skipped.
Executing test 564 (new): second arg in formal on shared joinpoint with pcd if() causes verify error ??
================================================
Breakdown of abc phases  (total: 7816 millisec.)
------------------------------------------------
[ 00.499% ] Init. of Soot:  39
[ 00.038% ] Loading Jars:  3
[ 71.584% ] Polyglot phases:  5595
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.678% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.486% ] Intertype Adjuster:  38
[ 06.576% ] Retrieving bodies:  514
[ 00.000% ] Weave Initializers:  0
[ 00.281% ] Load shadow types:  22
[ 03.685% ] Compute advice lists:  288
[ 00.038% ] Intertype weave:  3
[ 00.461% ] Add aspect code:  36
[ 01.420% ] Weaving advice:  111
[ 00.000% ] Validate jimple:  0
[ 10.427% ] Soot Packs:  815
[ 03.774% ] Soot Writing Output:  295
================================================
Abc started on Thu Jun 24 09:31:48 BST 2004
<<<< PR554.java >>>>
import org.aspectj.testing.Tester;

public class PR554 {
    public static void main(java.lang.String[] args) {
        java.lang.String A =
          makeProduct("A", new java.lang.Integer(1));
        java.lang.String B =
          makeProduct("B", new java.lang.Integer(0));
        org.aspectj.testing.Tester.check("A".equals(A),
                                         "\"A\".equals(A): " +
                                         A);
        org.aspectj.testing.Tester.check("B".equals(B),
                                         "\"B\".equals(B): " +
                                         B);
    }
    
    static java.lang.String makeProduct(java.lang.String s,
                                        java.lang.Integer i) {
        return null;
    }
    
    public PR554() { super(); }
}
aspect a {
    String around (String whatKind, Integer deleteMeToFixBug):
    args(whatKind, deleteMeToFixBug) &&
      call(String (*).makeProduct(String, Integer)) &&
      if("A".equals(whatKind)) {
        return "A";
    }
    
    String around (String whatKind, Integer deleteMeToFixBug):
    args(whatKind, deleteMeToFixBug) &&
      call(String (*).makeProduct(String, Integer)) &&
      if("B".equals(whatKind)) {
        return "B";
    }
    
    public static a aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public a() { super(); }
}
retrieve <PR554: void <init>()> from PR554
retrieve <PR554: void main(java.lang.String[])> from PR554
retrieve <PR554: java.lang.String makeProduct(java.lang.String,java.lang.Integer)> from PR554
retrieve <a: java.lang.String around$0(java.lang.String,java.lang.Integer)> from a
retrieve <a: java.lang.String around$1(java.lang.String,java.lang.Integer)> from a
retrieve <a: a aspectOf()> from a
retrieve <a: boolean hasAspect()> from a
retrieve <a: void <init>()> from a
retrieve <a: boolean if$3(java.lang.String,java.lang.Integer)> from a
retrieve <a: java.lang.String proceed$2(java.lang.String,java.lang.Integer)> from a
retrieve <a: boolean if$5(java.lang.String,java.lang.Integer)> from a
retrieve <a: java.lang.String proceed$4(java.lang.String,java.lang.Integer)> from a
Transforming a... 
Transforming PR554... 
Transforming abc$access$a$around$1... 
Transforming abc$access$a$around$0... 
Abc finished on Thu Jun 24 09:31:56 BST 2004. ( 0 min. 7 sec. )
PASS: second arg in formal on shared joinpoint with pcd if() causes verify err...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 224 failed (check: 81), 339 passed (check: 83), 1 skipped.
Executing test 565 (new/privilegedAspects): access to private members from privileged aspect
Failed. Current status: 225 failed (check: 81), 339 passed (check: 83), 1 skipped.
Executing test 566 (new): inner classes of privileged aspects cannot see target class private members
Failed. Current status: 226 failed (check: 81), 339 passed (check: 83), 1 skipped.
Executing test 567 (new/packageAccessPR556): aspects should get package access outside the file
================================================
Breakdown of abc phases  (total: 7351 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 77.704% ] Polyglot phases:  5712
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.789% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.490% ] Intertype Adjuster:  36
[ 07.999% ] Retrieving bodies:  588
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 04.122% ] Compute advice lists:  303
[ 00.041% ] Intertype weave:  3
[ 00.177% ] Add aspect code:  13
[ 00.286% ] Weaving advice:  21
[ 00.000% ] Validate jimple:  0
[ 04.176% ] Soot Packs:  307
[ 03.306% ] Soot Writing Output:  243
================================================
Abc started on Thu Jun 24 09:32:07 BST 2004
<<<< C1.java >>>>
package p;

import p.*;
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public aspect C1 {
    private static int privateOne = 1;
    
    public static void main(java.lang.String[] args) {
        int i =
          p.C2/*p.C2*/.defaultOne + p.C2/*p.C2*/.protectedOne +
          p.C2/*p.C2*/.publicOne +
          p.A2/*p.A2*/.defaultOne +
          p.A2/*p.A2*/.protectedOne +
        p.A2/*p.A2*/.publicOne;
        org.aspectj.testing.Tester.expectEvent("C2");
        org.aspectj.testing.Tester.expectEvent("A2");
        org.aspectj.testing.Tester.check(i ==
                                         6,
                                         "initialization failed: " +
                                         i);
        try {
            java.lang.System.getProperty("ignore" + i);
        }
        catch (java.lang.Exception e) {  }
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    before():
    p() &&
      execution (static void (C1).main(String[])) {
        org.aspectj.testing.Tester.event("C2");
    }
    
    before():
    p() &&
      execution (static void (C1).main(String[])) {
        org.aspectj.testing.Tester.event("A2");
    }
    
    public static p.C1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public C1() { super(); }
}
<<<< C2.java >>>>
package p;

aspect A2 {
    private static int privateOne = 1;
    
    static int defaultOne = 1;
    
    protected static int protectedOne = 1;
    
    public static int publicOne = 1;
    
    pointcut p() : within(p..*);
    
    public static p.A2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A2() { super(); }
}
class C2 {
    private static int privateOne = 1;
    
    static int defaultOne = 1;
    
    protected static int protectedOne = 1;
    
    public static int publicOne = 1;
    
    pointcut p() : within(p..*);
    
    public C2() { super(); }
}
retrieve <p.C1: void main(java.lang.String[])> from p.C1
retrieve <p.C1: void before$0()> from p.C1
retrieve <p.C1: void before$1()> from p.C1
retrieve <p.C1: p.C1 aspectOf()> from p.C1
retrieve <p.C1: boolean hasAspect()> from p.C1
retrieve <p.C1: void <init>()> from p.C1
retrieve <p.C1: void <clinit>()> from p.C1
retrieve <p.A2: p.A2 aspectOf()> from p.A2
retrieve <p.A2: boolean hasAspect()> from p.A2
retrieve <p.A2: void <init>()> from p.A2
retrieve <p.A2: void <clinit>()> from p.A2
retrieve <p.C2: void <init>()> from p.C2
retrieve <p.C2: void <clinit>()> from p.C2
Transforming p.C1... 
Transforming p.C2... 
Transforming p.A2... 
Abc finished on Thu Jun 24 09:32:15 BST 2004. ( 0 min. 7 sec. )
PASS: aspects should get package access outside the file()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 226 failed (check: 81), 340 passed (check: 83), 1 skipped.
Executing test 568 (new): subclass advice not run for join points selected by superclass cflow-based pointcuts
Failed. Current status: 227 failed (check: 81), 340 passed (check: 83), 1 skipped.
Executing test 569 (new): more issues with abstract aspects and cflow pointcuts
Failed. Current status: 228 failed (check: 81), 340 passed (check: 83), 1 skipped.
Executing test 570 (new): compile fails for aspect derived from percflow base aspect unless pointcut excludes base aspect and subaspects
Failed. Current status: 229 failed (check: 81), 340 passed (check: 83), 1 skipped.
Executing test 571 (new): cyclic pointcut definitions
Failed. Current status: 230 failed (check: 82), 340 passed (check: 83), 1 skipped.
Executing test 572 (new): pertarget stack overflow getting name of anonymous (Interface) class
================================================
Breakdown of abc phases  (total: 7710 millisec.)
------------------------------------------------
[ 00.480% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 72.892% ] Polyglot phases:  5620
[ 00.039% ] Resolve class names:  3
[ 00.013% ] Declare Parents:  1
[ 00.428% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.739% ] Intertype Adjuster:  57
[ 06.770% ] Retrieving bodies:  522
[ 00.000% ] Weave Initializers:  0
[ 00.285% ] Load shadow types:  22
[ 03.774% ] Compute advice lists:  291
[ 00.052% ] Intertype weave:  4
[ 00.272% ] Add aspect code:  21
[ 00.493% ] Weaving advice:  38
[ 00.000% ] Validate jimple:  0
[ 10.000% ] Soot Packs:  771
[ 03.722% ] Soot Writing Output:  287
================================================
Failed. Current status: 231 failed (check: 82), 340 passed (check: 83), 1 skipped.
Executing test 573 (new): pertarget stack overflow getting name of anonymous (Object) class
================================================
Breakdown of abc phases  (total: 7762 millisec.)
------------------------------------------------
[ 00.477% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 72.043% ] Polyglot phases:  5592
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.618% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.477% ] Intertype Adjuster:  37
[ 06.738% ] Retrieving bodies:  523
[ 00.000% ] Weave Initializers:  0
[ 00.361% ] Load shadow types:  28
[ 10.345% ] Compute advice lists:  803
[ 00.039% ] Intertype weave:  3
[ 00.386% ] Add aspect code:  30
[ 00.399% ] Weaving advice:  31
[ 00.000% ] Validate jimple:  0
[ 04.483% ] Soot Packs:  348
[ 03.543% ] Soot Writing Output:  275
================================================
Abc started on Thu Jun 24 09:33:00 BST 2004
<<<< PR573_1.java >>>>
import org.aspectj.testing.Tester;

public class PR573_1 {
    public static void main(java.lang.String[] params) {
        final java.lang.Object o1 = new java.lang.Object();
        final java.lang.Object o =
          new java.lang.Object() {
            public void m() { o1.toString(); }
        };
        org.aspectj.testing.Tester.expectEvent("A.init0");
        org.aspectj.testing.Tester.check(null != o, "null != o");
        o.toString();
        org.aspectj.testing.Tester.check(1 ==
                                         A/*A*/.num,
                                         "1 == A.num: " +
                                         A/*A*/.num);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PR573_1() { super(); }
}
aspect A {
    public static int num;
    
    A() {
        super();
        org.aspectj.testing.Tester.event("A.init" + A/*A*/.num++);
    }
    
    public static A aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
}
retrieve <PR573_1: void <init>()> from PR573_1
retrieve <PR573_1: void main(java.lang.String[])> from PR573_1
retrieve <PR573_1$1: void <init>(java.lang.Object)> from PR573_1$1
retrieve <PR573_1$1: void m()> from PR573_1$1
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf(java.lang.Object)> from A
retrieve <A: boolean hasAspect(java.lang.Object)> from A
Transforming A... 
Transforming PR573_1... 
Transforming PR573_1$1... 
Transforming A$abc$PerTarget... 
Abc finished on Thu Jun 24 09:33:07 BST 2004. ( 0 min. 7 sec. )
PASS: pertarget stack overflow getting name of anonymous (Object) class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 231 failed (check: 82), 341 passed (check: 83), 1 skipped.
Executing test 574 (new): pertarget runtime stack overflow (getting name of anonymous (Object) class?)
================================================
Breakdown of abc phases  (total: 7596 millisec.)
------------------------------------------------
[ 00.474% ] Init. of Soot:  36
[ 00.053% ] Loading Jars:  4
[ 71.656% ] Polyglot phases:  5443
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.592% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.487% ] Intertype Adjuster:  37
[ 06.977% ] Retrieving bodies:  530
[ 00.000% ] Weave Initializers:  0
[ 00.290% ] Load shadow types:  22
[ 10.282% ] Compute advice lists:  781
[ 00.039% ] Intertype weave:  3
[ 00.461% ] Add aspect code:  35
[ 00.513% ] Weaving advice:  39
[ 00.000% ] Validate jimple:  0
[ 04.568% ] Soot Packs:  347
[ 03.555% ] Soot Writing Output:  270
================================================
Abc started on Thu Jun 24 09:33:10 BST 2004
<<<< PR573_2.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class PR573_2 {
    public static void main(java.lang.String[] params) {
        final java.lang.Object o =
          new java.lang.Object() {
            public void m() {  }
        };
        org.aspectj.testing.Tester.expectEvent("A.init0");
        org.aspectj.testing.Tester.check(null != o, "null != o");
        org.aspectj.testing.Tester.check(1 ==
                                         A/*A*/.num,
                                         "1 == A.num: " +
                                         A/*A*/.num);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PR573_2() { super(); }
}
aspect A {
    public static int num;
    
    A() {
        super();
        org.aspectj.testing.Tester.event("A.init" + A/*A*/.num++);
    }
    
    public static A aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
}
retrieve <PR573_2: void <init>()> from PR573_2
retrieve <PR573_2: void main(java.lang.String[])> from PR573_2
retrieve <PR573_2$1: void <init>()> from PR573_2$1
retrieve <PR573_2$1: void m()> from PR573_2$1
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf(java.lang.Object)> from A
retrieve <A: boolean hasAspect(java.lang.Object)> from A
Transforming A... 
Transforming PR573_2... 
Transforming PR573_2$1... 
Transforming A$abc$PerTarget... 
Abc finished on Thu Jun 24 09:33:18 BST 2004. ( 0 min. 7 sec. )
PASS: pertarget runtime stack overflow (getting name of anonymous (Object) cla...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 231 failed (check: 82), 342 passed (check: 83), 1 skipped.
Executing test 575 (new): PR584 Can construct inner classes using qualified expressions
================================================
Breakdown of abc phases  (total: 7339 millisec.)
------------------------------------------------
[ 00.518% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 73.171% ] Polyglot phases:  5370
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.586% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 00.518% ] Intertype Adjuster:  38
[ 07.113% ] Retrieving bodies:  522
[ 00.000% ] Weave Initializers:  0
[ 00.300% ] Load shadow types:  22
[ 04.933% ] Compute advice lists:  362
[ 00.041% ] Intertype weave:  3
[ 00.123% ] Add aspect code:  9
[ 00.177% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.279% ] Soot Packs:  681
[ 03.175% ] Soot Writing Output:  233
================================================
Abc started on Thu Jun 24 09:33:20 BST 2004
<<<< PR584.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.testing.Tester;

public class PR584 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("foo ok");
        org.aspectj.testing.Tester.expectEvent("foo test2");
        Foo foo = new Foo("foo");
        Foo.Test test1 = foo.new Test();
        Foo.Test test2 =
          foo.new Test() {
            public void foo() {
                Tester.event(getFoo()/*<unknown>*/.baz + " test2");
            }
        };
        test1.foo();
        test2.foo();
        Foo.StaticTest test3 = new Foo.StaticTest();
        org.aspectj.testing.Tester.expectEvent("static foo");
        test3/*null*/.staticBaz = "static foo";
        test3.staticFoo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PR584() { super(); }
}
class Foo {
    public java.lang.String baz;
    
    public Foo(java.lang.String baz) {
        super();
        this/*<unknown>*/.baz = baz;
    }
    
    public static class StaticTest {
        static java.lang.String staticBaz;
        
        public void staticFoo() {
            org.aspectj.testing.Tester.event(Foo.StaticTest/*Foo.StaticTest*/.staticBaz);
        }
        
        public StaticTest() { super(); }
    }
    
    
    public class Test {
        public Foo getFoo() { return Foo.this; }
        
        public void foo() {
            org.aspectj.testing.Tester.event(Foo.this/*null*/.baz +
                                             " ok");
        }
        
        public Test() { super(); }
    }
    
}
retrieve <PR584: void <init>()> from PR584
retrieve <PR584: void main(java.lang.String[])> from PR584
retrieve <PR584$1: void <init>(Foo)> from PR584$1
super outer type: Foo
outer local: r0
retrieve <PR584$1: void foo()> from PR584$1
retrieve <Foo: void <init>(java.lang.String)> from Foo
retrieve <Foo$StaticTest: void staticFoo()> from Foo$StaticTest
retrieve <Foo$StaticTest: void <init>()> from Foo$StaticTest
retrieve <Foo$Test: Foo getFoo()> from Foo$Test
retrieve <Foo$Test: void <init>(Foo)> from Foo$Test
retrieve <Foo$Test: void foo()> from Foo$Test
Transforming Foo... 
Transforming Foo$StaticTest... 
Transforming PR584... 
Transforming PR584$1... 
Transforming Foo$Test... 
Abc finished on Thu Jun 24 09:33:28 BST 2004. ( 0 min. 7 sec. )
PASS: PR584 Can construct inner classes using qualified expressions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 231 failed (check: 82), 343 passed (check: 83), 1 skipped.
Executing test 576 (new): subaspect method declaration on superaspect inner interface (names)
================================================
Breakdown of abc phases  (total: 7367 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 73.585% ] Polyglot phases:  5421
[ 00.041% ] Resolve class names:  3
[ 00.027% ] Declare Parents:  2
[ 00.611% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 02.063% ] Intertype Adjuster:  152
[ 05.443% ] Retrieving bodies:  401
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 02.443% ] Compute advice lists:  180
[ 00.041% ] Intertype weave:  3
[ 00.271% ] Add aspect code:  20
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.746% ] Soot Packs:  718
[ 04.710% ] Soot Writing Output:  347
================================================
Abc started on Thu Jun 24 09:33:30 BST 2004
<<<< InnerInterfaceNames.java >>>>
import org.aspectj.testing.*;

public class InnerInterfaceNames {
    public static void main(java.lang.String[] args) {
        java.lang.Object o = new C().getThis();
        org.aspectj.testing.Tester.check(null !=
                                         o,
                                         "null != new C().getThis()");
        ConcreteAspect cc = ConcreteAspect.aspectOf();
        org.aspectj.testing.Tester.check(null !=
                                         cc,
                                         "null != ConcreteAspect.aspectOf()");
        java.lang.Object p = cc.getField();
        org.aspectj.testing.Tester.check(null !=
                                         p,
                                         "null != cc.getField()");
    }
    
    public InnerInterfaceNames() { super(); }
}
class C implements AbstractAspect.InnerInterface {
    public C() { super(); }
}
abstract aspect AbstractAspect {
    static interface InnerInterface {}
    
    
    public java.lang.Object publicField = new java.lang.Object();
    
    java.lang.Object getField() { return this/*null*/.publicField; }
    
    public AbstractAspect() { super(); }
}
aspect ConcreteAspect extends AbstractAspect {
    public intertype java.lang.Object AbstractAspect.InnerInterface.getThis() {
        return hostAbstractAspect.InnerInterfacethis;
    }
    
    public static ConcreteAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ConcreteAspect() { super(); }
}
retrieve <InnerInterfaceNames: void <init>()> from InnerInterfaceNames
retrieve <InnerInterfaceNames: void main(java.lang.String[])> from InnerInterfaceNames
retrieve <C: void <init>()> from C
retrieve <C: java.lang.Object getThis()> from C
retrieve <AbstractAspect: void <init>()> from AbstractAspect
retrieve <AbstractAspect: java.lang.Object getField()> from AbstractAspect
retrieve <ConcreteAspect: java.lang.Object getThis(AbstractAspect$InnerInterface)> from ConcreteAspect
retrieve <ConcreteAspect: ConcreteAspect aspectOf()> from ConcreteAspect
retrieve <ConcreteAspect: boolean hasAspect()> from ConcreteAspect
retrieve <ConcreteAspect: void <init>()> from ConcreteAspect
Transforming ConcreteAspect... 
Transforming AbstractAspect... 
Transforming AbstractAspect$InnerInterface... 
Transforming InnerInterfaceNames... 
Transforming C... 
Abc finished on Thu Jun 24 09:33:38 BST 2004. ( 0 min. 7 sec. )
PASS: subaspect method declaration on superaspect inner interface (names)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 231 failed (check: 82), 344 passed (check: 83), 1 skipped.
Executing test 577 (new): subaspect method declaration on superaspect inner interface (access)
================================================
Breakdown of abc phases  (total: 7372 millisec.)
------------------------------------------------
[ 00.502% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 73.589% ] Polyglot phases:  5425
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.610% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 02.075% ] Intertype Adjuster:  153
[ 05.440% ] Retrieving bodies:  401
[ 00.000% ] Weave Initializers:  0
[ 00.298% ] Load shadow types:  22
[ 02.428% ] Compute advice lists:  179
[ 00.054% ] Intertype weave:  4
[ 00.271% ] Add aspect code:  20
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.753% ] Soot Packs:  719
[ 04.707% ] Soot Writing Output:  347
================================================
Abc started on Thu Jun 24 09:33:40 BST 2004
<<<< InnerInterfaceAccess.java >>>>
import org.aspectj.testing.*;

public class InnerInterfaceAccess {
    public static void main(java.lang.String[] args) {
        java.lang.Object o = new C().getThis();
        org.aspectj.testing.Tester.check(null !=
                                         o,
                                         "null != new C().getThis()");
        ConcreteAspect cc = ConcreteAspect.aspectOf();
        org.aspectj.testing.Tester.check(null !=
                                         cc,
                                         "null != ConcreteAspect.aspectOf()");
        java.lang.Object p = cc.getField();
        org.aspectj.testing.Tester.check(null !=
                                         p,
                                         "null != cc.getField()");
    }
    
    public InnerInterfaceAccess() { super(); }
}
class C implements AbstractAspect.InnerInterface {
    public C() { super(); }
}
abstract aspect AbstractAspect {
    static interface InnerInterface {}
    
    
    private java.lang.Object privateField = new java.lang.Object();
    
    java.lang.Object getField() { return this/*null*/.privateField; }
    
    public AbstractAspect() { super(); }
}
aspect ConcreteAspect extends AbstractAspect {
    public intertype java.lang.Object AbstractAspect.InnerInterface.getThis() {
        return hostAbstractAspect.InnerInterfacethis;
    }
    
    public static ConcreteAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ConcreteAspect() { super(); }
}
retrieve <InnerInterfaceAccess: void <init>()> from InnerInterfaceAccess
retrieve <InnerInterfaceAccess: void main(java.lang.String[])> from InnerInterfaceAccess
retrieve <C: void <init>()> from C
retrieve <C: java.lang.Object getThis()> from C
retrieve <AbstractAspect: void <init>()> from AbstractAspect
retrieve <AbstractAspect: java.lang.Object getField()> from AbstractAspect
retrieve <ConcreteAspect: java.lang.Object getThis(AbstractAspect$InnerInterface)> from ConcreteAspect
retrieve <ConcreteAspect: ConcreteAspect aspectOf()> from ConcreteAspect
retrieve <ConcreteAspect: boolean hasAspect()> from ConcreteAspect
retrieve <ConcreteAspect: void <init>()> from ConcreteAspect
Transforming ConcreteAspect... 
Transforming AbstractAspect... 
Transforming AbstractAspect$InnerInterface... 
Transforming InnerInterfaceAccess... 
Transforming C... 
Abc finished on Thu Jun 24 09:33:47 BST 2004. ( 0 min. 7 sec. )
PASS: subaspect method declaration on superaspect inner interface (access)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 231 failed (check: 82), 345 passed (check: 83), 1 skipped.
Executing test 578 (new): subaspect method declaration on superaspect inner interface (types)
================================================
Breakdown of abc phases  (total: 6924 millisec.)
------------------------------------------------
[ 00.534% ] Init. of Soot:  37
[ 00.043% ] Loading Jars:  3
[ 79.333% ] Polyglot phases:  5493
[ 00.029% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.650% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 02.224% ] Intertype Adjuster:  154
[ 05.705% ] Retrieving bodies:  395
[ 00.000% ] Weave Initializers:  0
[ 00.404% ] Load shadow types:  28
[ 02.542% ] Compute advice lists:  176
[ 00.144% ] Intertype weave:  10
[ 00.318% ] Add aspect code:  22
[ 00.188% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.434% ] Soot Packs:  307
[ 03.437% ] Soot Writing Output:  238
================================================
Abc started on Thu Jun 24 09:33:50 BST 2004
<<<< InnerInterfaceTypes.java >>>>
import org.aspectj.testing.*;
import java.util.Vector;

public class InnerInterfaceTypes {
    public static void main(java.lang.String[] args) {
        java.lang.Object o = new C().getThis();
        org.aspectj.testing.Tester.check(null !=
                                         o,
                                         "null != new C().getThis()");
        ConcreteAspect cc = ConcreteAspect.aspectOf();
        org.aspectj.testing.Tester.check(null !=
                                         cc,
                                         "null != ConcreteAspect.aspectOf()");
        java.lang.Object p = cc.getField();
        org.aspectj.testing.Tester.check(null !=
                                         p,
                                         "null != cc.getField()");
    }
    
    public InnerInterfaceTypes() { super(); }
}
class C implements AbstractAspect.InnerInterface {
    public C() { super(); }
}
abstract aspect AbstractAspect {
    static interface InnerInterface {}
    
    
    private java.lang.Object privateField = new java.lang.Object();
    
    java.lang.Object getField() { return new java.util.Vector(); }
    
    public AbstractAspect() { super(); }
}
<<<< InnerInterfaceTypesHelper.java >>>>
aspect ConcreteAspect extends AbstractAspect {
    public intertype java.lang.Object AbstractAspect.InnerInterface.getThis() {
        return new java.lang.Object();
    }
    
    public static ConcreteAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ConcreteAspect() { super(); }
}
retrieve <InnerInterfaceTypes: void <init>()> from InnerInterfaceTypes
retrieve <InnerInterfaceTypes: void main(java.lang.String[])> from InnerInterfaceTypes
retrieve <C: java.lang.Object getThis()> from C
retrieve <C: void <init>()> from C
retrieve <AbstractAspect: void <init>()> from AbstractAspect
retrieve <AbstractAspect: java.lang.Object getField()> from AbstractAspect
retrieve <ConcreteAspect: java.lang.Object getThis(AbstractAspect$InnerInterface)> from ConcreteAspect
retrieve <ConcreteAspect: ConcreteAspect aspectOf()> from ConcreteAspect
retrieve <ConcreteAspect: boolean hasAspect()> from ConcreteAspect
retrieve <ConcreteAspect: void <init>()> from ConcreteAspect
Transforming ConcreteAspect... 
Transforming AbstractAspect... 
Transforming AbstractAspect$InnerInterface... 
Transforming C... 
Transforming InnerInterfaceTypes... 
Abc finished on Thu Jun 24 09:33:57 BST 2004. ( 0 min. 7 sec. )
PASS: subaspect method declaration on superaspect inner interface (types)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 231 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 579 (new): around AST type XXX
Failed. Current status: 232 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 580 (new): around all execution with double assignment in initializer (simple)
Failed. Current status: 233 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 581 (new): around all execution with double assignment in initializer (coverage)
Failed. Current status: 234 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 582 (new): changing this in around's proceed reported by Rich Price
Failed. Current status: 235 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 583 (new): default package for aspect introductions is not the current package
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 8142 millisec.)
------------------------------------------------
[ 00.442% ] Init. of Soot:  36
[ 00.037% ] Loading Jars:  3
[ 69.799% ] Polyglot phases:  5683
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.676% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 02.751% ] Intertype Adjuster:  224
[ 05.269% ] Retrieving bodies:  429
[ 00.000% ] Weave Initializers:  0
[ 00.332% ] Load shadow types:  27
[ 10.685% ] Compute advice lists:  870
[ 00.037% ] Intertype weave:  3
[ 00.504% ] Add aspect code:  41
[ 01.069% ] Weaving advice:  87
[ 00.000% ] Validate jimple:  0
[ 04.827% ] Soot Packs:  393
[ 03.525% ] Soot Writing Output:  287
================================================
Failed. Current status: 236 failed (check: 82), 346 passed (check: 83), 1 skipped.
Executing test 584 (new/PR569): anon class written to wrong directory
================================================
Breakdown of abc phases  (total: 7402 millisec.)
------------------------------------------------
[ 00.500% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 76.952% ] Polyglot phases:  5696
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.446% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 07.106% ] Intertype Adjuster:  526
[ 05.107% ] Retrieving bodies:  378
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  22
[ 02.067% ] Compute advice lists:  153
[ 00.041% ] Intertype weave:  3
[ 00.446% ] Add aspect code:  33
[ 00.176% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.702% ] Soot Packs:  274
[ 03.067% ] Soot Writing Output:  227
================================================
Abc started on Thu Jun 24 09:34:41 BST 2004
<<<< IntroAnon.java >>>>
package a;

import org.aspectj.testing.Tester;
import b.Dest;

public class IntroAnon {
    private static aspect MI {
        public intertype java.lang.Object a.MyInterface.foo() {
            org.aspectj.testing.Tester.event("foo ran");
            return new java.lang.Object() {};
        }
        
        public static a.IntroAnon.MI aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public MI() { super(); }
    }
    
    
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("foo ran");
        new b.Dest().foo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public IntroAnon() { super(); }
}
<<<< Dest.java >>>>
package b;

import a.MyInterface;

public class Dest implements a.MyInterface {
    public Dest() { super(); }
}
<<<< MyInterface.java >>>>
package a;

public interface MyInterface {
    public abstract java.lang.Object foo();
}
retrieve <a.IntroAnon: void main(java.lang.String[])> from a.IntroAnon
retrieve <a.IntroAnon: void <init>()> from a.IntroAnon
retrieve <a.IntroAnon$MI: java.lang.Object foo(a.MyInterface)> from a.IntroAnon$MI
retrieve <a.IntroAnon$MI: a.IntroAnon$MI aspectOf()> from a.IntroAnon$MI
retrieve <a.IntroAnon$MI: boolean hasAspect()> from a.IntroAnon$MI
retrieve <a.IntroAnon$MI: void <init>()> from a.IntroAnon$MI
retrieve <a.IntroAnon$1: void <init>()> from a.IntroAnon$1
retrieve <b.Dest: void <init>()> from b.Dest
retrieve <b.Dest: java.lang.Object foo()> from b.Dest
Transforming b.Dest... 
Transforming a.MyInterface... 
Transforming a.IntroAnon... 
Transforming a.IntroAnon$MI... 
Transforming a.IntroAnon$1... 
Abc finished on Thu Jun 24 09:34:49 BST 2004. ( 0 min. 7 sec. )
PASS: anon class written to wrong directory()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 236 failed (check: 82), 347 passed (check: 83), 1 skipped.
Executing test 585 (new): unqualified transitive pointcut references not resolved
================================================
Breakdown of abc phases  (total: 7800 millisec.)
------------------------------------------------
[ 00.487% ] Init. of Soot:  38
[ 00.038% ] Loading Jars:  3
[ 73.141% ] Polyglot phases:  5705
[ 00.026% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.577% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.718% ] Intertype Adjuster:  56
[ 06.141% ] Retrieving bodies:  479
[ 00.000% ] Weave Initializers:  0
[ 00.269% ] Load shadow types:  21
[ 09.244% ] Compute advice lists:  721
[ 00.038% ] Intertype weave:  3
[ 00.449% ] Add aspect code:  35
[ 00.731% ] Weaving advice:  57
[ 00.000% ] Validate jimple:  0
[ 04.795% ] Soot Packs:  374
[ 03.333% ] Soot Writing Output:  260
================================================
Abc started on Thu Jun 24 09:34:51 BST 2004
<<<< PointcutQualification.java >>>>
import org.aspectj.testing.Tester;

public class PointcutQualification {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("before pc_reference");
        new TargetClass().doit();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PointcutQualification() { super(); }
}
class I {
    public static final void got(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public I() { super(); }
}
class TargetClass {
    void doit() {  }
    
    public TargetClass() { super(); }
}
aspect DebugAspect {
    before(): pc_reference() { I.got("before pc_reference"); }
    
    public static DebugAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public DebugAspect() { super(); }
}
aspect Aspect {
    pointcut pc_notfound() : execution (void (TargetClass).doit());
    
    pointcut someCallCflow() :
    !within(Aspect) && !within(DebugAspect) && !within(I) &&
      cflow(pc_notfound());
    
    pointcut pc_reference() : someCallCflow();
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <PointcutQualification: void main(java.lang.String[])> from PointcutQualification
retrieve <PointcutQualification: void <init>()> from PointcutQualification
retrieve <I: void <init>()> from I
retrieve <I: void got(java.lang.String)> from I
retrieve <TargetClass: void doit()> from TargetClass
retrieve <TargetClass: void <init>()> from TargetClass
retrieve <DebugAspect: DebugAspect aspectOf()> from DebugAspect
retrieve <DebugAspect: boolean hasAspect()> from DebugAspect
retrieve <DebugAspect: void <init>()> from DebugAspect
retrieve <DebugAspect: void before$0()> from DebugAspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
Transforming TargetClass... 
Transforming I... 
Transforming DebugAspect... 
Transforming PointcutQualification... 
Transforming Aspect... 
Abc finished on Thu Jun 24 09:34:59 BST 2004. ( 0 min. 7 sec. )
PASS: unqualified transitive pointcut references not resolved()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 236 failed (check: 82), 348 passed (check: 83), 1 skipped.
Executing test 586 (new): unqualified transitive pointcut references not resolved - 2
================================================
Breakdown of abc phases  (total: 7269 millisec.)
------------------------------------------------
[ 00.523% ] Init. of Soot:  38
[ 00.041% ] Loading Jars:  3
[ 74.783% ] Polyglot phases:  5436
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.729% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.495% ] Intertype Adjuster:  36
[ 06.658% ] Retrieving bodies:  484
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  22
[ 02.449% ] Compute advice lists:  178
[ 00.041% ] Intertype weave:  3
[ 00.454% ] Add aspect code:  33
[ 00.289% ] Weaving advice:  21
[ 00.000% ] Validate jimple:  0
[ 04.100% ] Soot Packs:  298
[ 09.093% ] Soot Writing Output:  661
================================================
Abc started on Thu Jun 24 09:35:02 BST 2004
<<<< PointcutQualification2.java >>>>
import org.aspectj.testing.Tester;

public class PointcutQualification2 {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("before pc_reference2");
        new TargetClass().doit();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public PointcutQualification2() { super(); }
}
class I {
    public static final void got(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public I() { super(); }
}
class TargetClass {
    void doit() {  }
    
    public TargetClass() { super(); }
}
aspect DebugAspect2 {
    before(): pc_reference2() { I.got("before pc_reference2"); }
    
    public static DebugAspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public DebugAspect2() { super(); }
}
aspect Aspect2 {
    pointcut pc_notfound2() : execution (void (TargetClass).doit());
    
    pointcut anotherRef() : pc_notfound2();
    
    pointcut pc_reference2() : anotherRef();
    
    public static Aspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect2() { super(); }
}
retrieve <PointcutQualification2: void <init>()> from PointcutQualification2
retrieve <PointcutQualification2: void main(java.lang.String[])> from PointcutQualification2
retrieve <I: void <init>()> from I
retrieve <I: void got(java.lang.String)> from I
retrieve <TargetClass: void doit()> from TargetClass
retrieve <TargetClass: void <init>()> from TargetClass
retrieve <DebugAspect2: void <init>()> from DebugAspect2
retrieve <DebugAspect2: void before$0()> from DebugAspect2
retrieve <DebugAspect2: DebugAspect2 aspectOf()> from DebugAspect2
retrieve <DebugAspect2: boolean hasAspect()> from DebugAspect2
retrieve <Aspect2: void <init>()> from Aspect2
retrieve <Aspect2: boolean hasAspect()> from Aspect2
retrieve <Aspect2: Aspect2 aspectOf()> from Aspect2
Transforming TargetClass... 
Transforming DebugAspect2... 
Transforming Aspect2... 
Transforming I... 
Transforming PointcutQualification2... 
Abc finished on Thu Jun 24 09:35:09 BST 2004. ( 0 min. 7 sec. )
PASS: unqualified transitive pointcut references not resolved - 2()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 236 failed (check: 82), 349 passed (check: 83), 1 skipped.
Executing test 587 (new): direct use outside aspect of defined abstract pointcut
================================================
Breakdown of abc phases  (total: 7029 millisec.)
------------------------------------------------
[ 00.526% ] Init. of Soot:  37
[ 00.043% ] Loading Jars:  3
[ 74.235% ] Polyglot phases:  5218
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.740% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.512% ] Intertype Adjuster:  36
[ 06.487% ] Retrieving bodies:  456
[ 00.000% ] Weave Initializers:  0
[ 00.313% ] Load shadow types:  22
[ 02.831% ] Compute advice lists:  199
[ 00.043% ] Intertype weave:  3
[ 00.512% ] Add aspect code:  36
[ 00.327% ] Weaving advice:  23
[ 00.000% ] Validate jimple:  0
[ 10.172% ] Soot Packs:  715
[ 03.215% ] Soot Writing Output:  226
================================================
Abc started on Thu Jun 24 09:35:12 BST 2004
<<<< AbstractPointcutAccess.java >>>>
import org.aspectj.testing.Tester;

public abstract aspect AbstractPointcutAccess {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.event("main");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("main");
               org.aspectj.testing.Tester.expectEvent("used");
           }
    
    abstract pointcut abstractPointcut();
    
    public AbstractPointcutAccess() { super(); }
}
aspect ConcretePointcutAccess extends AbstractPointcutAccess {
    pointcut abstractPointcut() : execution (void (*).main(..));
    
    public static ConcretePointcutAccess aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ConcretePointcutAccess() { super(); }
}
aspect AbstractPointcutUser {
    before():
    abstractPointcut() {
        org.aspectj.testing.Tester.event("used");
    }
    
    public static AbstractPointcutUser aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public AbstractPointcutUser() { super(); }
}
retrieve <AbstractPointcutAccess: void <init>()> from AbstractPointcutAccess
retrieve <AbstractPointcutAccess: void main(java.lang.String[])> from AbstractPointcutAccess
retrieve <AbstractPointcutAccess: void <clinit>()> from AbstractPointcutAccess
retrieve <ConcretePointcutAccess: ConcretePointcutAccess aspectOf()> from ConcretePointcutAccess
retrieve <ConcretePointcutAccess: boolean hasAspect()> from ConcretePointcutAccess
retrieve <ConcretePointcutAccess: void <init>()> from ConcretePointcutAccess
retrieve <AbstractPointcutUser: boolean hasAspect()> from AbstractPointcutUser
retrieve <AbstractPointcutUser: void <init>()> from AbstractPointcutUser
retrieve <AbstractPointcutUser: void before$0()> from AbstractPointcutUser
retrieve <AbstractPointcutUser: AbstractPointcutUser aspectOf()> from AbstractPointcutUser
Transforming ConcretePointcutAccess... 
Transforming AbstractPointcutUser... 
Transforming AbstractPointcutAccess... 
Abc finished on Thu Jun 24 09:35:19 BST 2004. ( 0 min. 7 sec. )
PASS: direct use outside aspect of defined abstract pointcut()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 236 failed (check: 82), 350 passed (check: 83), 1 skipped.
Executing test 588 (new): direct use outside aspect of undefined abstract pointcut
Failed. Current status: 237 failed (check: 83), 350 passed (check: 83), 1 skipped.
Executing test 589 (new): indirect use outside aspect of undefined abstract pointcut
Failed. Current status: 238 failed (check: 84), 350 passed (check: 83), 1 skipped.
Executing test 590 (new): simple call join point tests for JoinPoint SourceLocation context
================================================
Breakdown of abc phases  (total: 7809 millisec.)
------------------------------------------------
[ 00.512% ] Init. of Soot:  40
[ 00.038% ] Loading Jars:  3
[ 70.470% ] Polyglot phases:  5503
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.640% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.448% ] Intertype Adjuster:  35
[ 13.062% ] Retrieving bodies:  1020
[ 00.000% ] Weave Initializers:  0
[ 00.269% ] Load shadow types:  21
[ 05.711% ] Compute advice lists:  446
[ 00.038% ] Intertype weave:  3
[ 00.231% ] Add aspect code:  18
[ 01.268% ] Weaving advice:  99
[ 00.000% ] Validate jimple:  0
[ 04.175% ] Soot Packs:  326
[ 03.086% ] Soot Writing Output:  241
================================================
Abc started on Thu Jun 24 09:35:38 BST 2004
<<<< SourceLocationCall.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.*;

public class SourceLocationCall {
    public static void main(java.lang.String[] args) {
        new SourceLocationCall().maincall();
    }
    
    public void maincall() {  }
    
    public SourceLocationCall() { super(); }
}
aspect Tracing {
    static void check(java.lang.String label,
                      org.aspectj.lang.JoinPoint jp,
                      org.aspectj.lang.JoinPoint.StaticPart sp) {
        if (null == jp) {
            org.aspectj.testing.Tester.check(false,
                                             "null JoinPoint@" +
                                             label);
        } else {
            org.aspectj.testing.Tester.check(null !=
                                             jp.getSourceLocation(),
                                             "null jp source location@" +
                                             label);
        }
        if (null == sp) {
            org.aspectj.testing.Tester.check(false,
                                             "null JoinPoint.StaticPart@" +
                                             label);
        } else {
            org.aspectj.testing.Tester.check(null !=
                                             sp.getSourceLocation(),
                                             "null sp source location@" +
                                             label);
        }
    }
    
    pointcut trace1() : call(void (SourceLocationCall).maincall(..));
    
    before():
    trace1() {
        check("before() : trace1()",
              thisJoinPoint,
              thisJoinPointStaticPart);
    }
    
    after():
    trace1() {
        check("after() : trace1()",
              thisJoinPoint,
              thisJoinPointStaticPart);
    }
    
    before():
    call(void (SourceLocationCall).main(..)) {
        org.aspectj.testing.Tester.check(thisJoinPoint.getSourceLocation() ==
                                         null,
                                         "main call");
        org.aspectj.testing.Tester.check(thisJoinPoint.getThis() ==
                                         null,
                                         "main call");
    }
    
    public static Tracing aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Tracing() { super(); }
}
retrieve <SourceLocationCall: void main(java.lang.String[])> from SourceLocationCall
retrieve <SourceLocationCall: void maincall()> from SourceLocationCall
retrieve <SourceLocationCall: void <init>()> from SourceLocationCall
retrieve <Tracing: boolean hasAspect()> from Tracing
retrieve <Tracing: void <init>()> from Tracing
retrieve <Tracing: void check(java.lang.String,org.aspectj.lang.JoinPoint,org.aspectj.lang.JoinPoint$StaticPart)> from Tracing
retrieve <Tracing: void before$0(org.aspectj.lang.JoinPoint$StaticPart,org.aspectj.lang.JoinPoint)> from Tracing
retrieve <Tracing: void after$1(org.aspectj.lang.JoinPoint$StaticPart,org.aspectj.lang.JoinPoint)> from Tracing
retrieve <Tracing: void before$2(org.aspectj.lang.JoinPoint)> from Tracing
retrieve <Tracing: Tracing aspectOf()> from Tracing
Transforming SourceLocationCall... 
Transforming Tracing... 
Abc finished on Thu Jun 24 09:35:46 BST 2004. ( 0 min. 7 sec. )
PASS: simple call join point tests for JoinPoint SourceLocation context()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 238 failed (check: 84), 351 passed (check: 83), 1 skipped.
Executing test 591 (new): !target with second advice on casted call
================================================
Breakdown of abc phases  (total: 7668 millisec.)
------------------------------------------------
[ 00.522% ] Init. of Soot:  40
[ 00.039% ] Loading Jars:  3
[ 72.535% ] Polyglot phases:  5562
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.691% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.509% ] Intertype Adjuster:  39
[ 13.198% ] Retrieving bodies:  1012
[ 00.000% ] Weave Initializers:  0
[ 00.287% ] Load shadow types:  22
[ 03.951% ] Compute advice lists:  303
[ 00.039% ] Intertype weave:  3
[ 00.287% ] Add aspect code:  22
[ 00.391% ] Weaving advice:  30
[ 00.000% ] Validate jimple:  0
[ 04.238% ] Soot Packs:  325
[ 03.260% ] Soot Writing Output:  250
================================================
Abc started on Thu Jun 24 09:35:49 BST 2004
<<<< CallNotTarget.java >>>>
import org.aspectj.testing.*;

public class CallNotTarget {
    public static void main(java.lang.String[] args) {
        ((I) new B()).go();
        org.aspectj.testing.Tester.checkAllEvents();
        doit(new B());
        doit(new A());
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("A.before");
               org.aspectj.testing.Tester.expectEvent("A.before-not");
               org.aspectj.testing.Tester.expectEvent("Aspect.before-not");
               org.aspectj.testing.Tester.expectEvent("go");
           }
    
    static void doit(I i) {
        org.aspectj.testing.Tester.check(i != null, "null i");
    }
    
    public CallNotTarget() { super(); }
}
interface I {
    public abstract void go();
}
class A implements I {
    public void go() { org.aspectj.testing.Tester.check(false, "A"); }
    
    public A() { super(); }
}
class B implements I {
    public void go() { org.aspectj.testing.Tester.event("go"); }
    
    public B() { super(); }
}
aspect Aspect {
    pointcut pc() : call(void (I).go());
    
    before(): pc() { org.aspectj.testing.Tester.event("A.before"); }
    
    before():
    pc() &&
      !target(A) {
        org.aspectj.testing.Tester.event("A.before-not");
    }
    
    before():
    pc() &&
      !target(Aspect) {
        org.aspectj.testing.Tester.event("Aspect.before-not");
    }
    
    public static Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
retrieve <CallNotTarget: void main(java.lang.String[])> from CallNotTarget
retrieve <CallNotTarget: void doit(I)> from CallNotTarget
retrieve <CallNotTarget: void <clinit>()> from CallNotTarget
retrieve <CallNotTarget: void <init>()> from CallNotTarget
retrieve <A: void go()> from A
retrieve <A: void <init>()> from A
retrieve <B: void go()> from B
retrieve <B: void <init>()> from B
retrieve <Aspect: void before$0()> from Aspect
retrieve <Aspect: void before$1()> from Aspect
retrieve <Aspect: void before$2()> from Aspect
retrieve <Aspect: Aspect aspectOf()> from Aspect
retrieve <Aspect: boolean hasAspect()> from Aspect
retrieve <Aspect: void <init>()> from Aspect
Transforming I... 
Transforming Aspect... 
Transforming B... 
Transforming A... 
Transforming CallNotTarget... 
Abc finished on Thu Jun 24 09:35:56 BST 2004. ( 0 min. 7 sec. )
PASS: !target with second advice on casted call()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 238 failed (check: 84), 352 passed (check: 83), 1 skipped.
Executing test 592 (new): name binding in around cflow
Failed. Current status: 239 failed (check: 84), 352 passed (check: 83), 1 skipped.
Executing test 593 (new): name binding in around cflow - 2
Failed. Current status: 240 failed (check: 84), 352 passed (check: 83), 1 skipped.
Executing test 594 (new): around name-binding in cflows using factorial
Failed. Current status: 241 failed (check: 84), 352 passed (check: 83), 1 skipped.
Executing test 595 (new): incrementing objects, arrays - 2
Failed. Current status: 242 failed (check: 85), 352 passed (check: 83), 1 skipped.
Executing test 596 (new): incrementing objects, arrays CE
Failed. Current status: 243 failed (check: 86), 352 passed (check: 83), 1 skipped.
Executing test 597 (new): incrementing objects, arrays - 3
Failed. Current status: 244 failed (check: 87), 352 passed (check: 83), 1 skipped.
Executing test 598 (new): incrementing objects, arrays
================================================
Breakdown of abc phases  (total: 8038 millisec.)
------------------------------------------------
[ 00.460% ] Init. of Soot:  37
[ 00.037% ] Loading Jars:  3
[ 69.532% ] Polyglot phases:  5589
[ 00.012% ] Resolve class names:  1
[ 00.012% ] Declare Parents:  1
[ 00.523% ] Recompute name pattern matches:  42
[ 00.012% ] Compute precedence relation:  1
[ 00.722% ] Intertype Adjuster:  58
[ 08.945% ] Retrieving bodies:  719
[ 00.000% ] Weave Initializers:  0
[ 00.274% ] Load shadow types:  22
[ 12.254% ] Compute advice lists:  985
[ 00.037% ] Intertype weave:  3
[ 00.112% ] Add aspect code:  9
[ 00.149% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.459% ] Soot Packs:  278
[ 03.459% ] Soot Writing Output:  278
================================================
Abc started on Thu Jun 24 09:36:38 BST 2004
<<<< ArrayInc.java >>>>
import org.aspectj.testing.Tester;

public class ArrayInc {
    private static void testCheck(boolean b, java.lang.String s) {
        org.aspectj.testing.Tester.check(b, s);
    }
    
    private static int[] IRA = new int[] { 0, 1, 2 };
    
    static int[] getIRA() { return ArrayInc/*ArrayInc*/.IRA; }
    
    static int[] throwError() { throw new java.lang.Error(""); }
    
    public static void main(java.lang.String[] args) {
        ArrayInc me = new ArrayInc();
        me.testArrayExpressionOrdering();
        me.testArrayExpression();
    }
    
    public void testArrayExpression() {
        ArrayInc/*ArrayInc*/.IRA = (new int[] { 0 });
        java.lang.String[] sra = new java.lang.String[] { "" };
        sra[0] += "1";
        sra[0] += "string concat";
        testCheck(0 ==
                  getIRA()[0],
                  "0==getIRA()[0]: " +
                  ArrayInc/*ArrayInc*/.IRA[0]);
        testCheck(0 ==
                  ArrayInc/*ArrayInc*/.IRA[0]++,
                  "0==IRA[0]++: " +
                  ArrayInc/*ArrayInc*/.IRA[0]);
        testCheck(1 ==
                  ArrayInc/*ArrayInc*/.IRA[0],
                  "1==IRA[0]: " +
                  ArrayInc/*ArrayInc*/.IRA[0]);
        testCheck(2 ==
                  ++getIRA()[0],
                  "2==++getIRA()[0]: " +
                  ArrayInc/*ArrayInc*/.IRA[0]);
        ;
        testCheck(2 ==
                  ArrayInc/*ArrayInc*/.IRA[0],
                  "2==IRA[0]: " +
                  ArrayInc/*ArrayInc*/.IRA[0]);
    }
    
    public void testArrayExpressionOrdering() {
        boolean gotError = false;
        int i = 0;
        try {
            int k = throwError()[++i];
        }
        catch (java.lang.Error e) { gotError = true; }
        testCheck(i == 0, "i=" + i);
        testCheck(gotError, "no error");
        i = 0;
        gotError = false;
        try {
            int k = throwError()[i++];
        }
        catch (java.lang.Error e) { gotError = true; }
        testCheck(i == 0, "i++ !=0: " + i);
        testCheck(gotError, "no error");
    }
    
    public ArrayInc() { super(); }
}
retrieve <ArrayInc: void testCheck(boolean,java.lang.String)> from ArrayInc
retrieve <ArrayInc: int[] getIRA()> from ArrayInc
retrieve <ArrayInc: int[] throwError()> from ArrayInc
retrieve <ArrayInc: void main(java.lang.String[])> from ArrayInc
retrieve <ArrayInc: void testArrayExpression()> from ArrayInc
retrieve <ArrayInc: void testArrayExpressionOrdering()> from ArrayInc
retrieve <ArrayInc: void <init>()> from ArrayInc
retrieve <ArrayInc: void <clinit>()> from ArrayInc
Transforming ArrayInc... 
Abc finished on Thu Jun 24 09:36:46 BST 2004. ( 0 min. 8 sec. )
PASS: incrementing objects, arrays()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 244 failed (check: 87), 353 passed (check: 83), 1 skipped.
Executing test 599 (new): replacing this or target in around advice
================================================
Breakdown of abc phases  (total: 8243 millisec.)
------------------------------------------------
[ 00.449% ] Init. of Soot:  37
[ 00.049% ] Loading Jars:  4
[ 69.198% ] Polyglot phases:  5704
[ 00.024% ] Resolve class names:  2
[ 00.024% ] Declare Parents:  2
[ 00.631% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.449% ] Intertype Adjuster:  37
[ 06.818% ] Retrieving bodies:  562
[ 00.000% ] Weave Initializers:  0
[ 00.267% ] Load shadow types:  22
[ 11.294% ] Compute advice lists:  931
[ 00.036% ] Intertype weave:  3
[ 00.412% ] Add aspect code:  34
[ 01.177% ] Weaving advice:  97
[ 00.000% ] Validate jimple:  0
[ 05.192% ] Soot Packs:  428
[ 03.979% ] Soot Writing Output:  328
================================================
Failed. Current status: 245 failed (check: 87), 353 passed (check: 83), 1 skipped.
Executing test 600 (new): after returning from initialization and after executing constructor
Failed. Current status: 246 failed (check: 87), 353 passed (check: 83), 1 skipped.
Executing test 601 (new): after returning from initialization causes ExceptionInInitializer in aspect
Failed. Current status: 247 failed (check: 87), 353 passed (check: 83), 1 skipped.
Executing test 602 (new): name binding in before cflow containing cflowbelow
Failed. Current status: 248 failed (check: 88), 353 passed (check: 83), 1 skipped.
Executing test 603 (pureJava): no circularity errors simply because of inners (1)
================================================
Breakdown of abc phases  (total: 6579 millisec.)
------------------------------------------------
[ 00.562% ] Init. of Soot:  37
[ 00.061% ] Loading Jars:  4
[ 76.668% ] Polyglot phases:  5044
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.456% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 01.064% ] Intertype Adjuster:  70
[ 13.209% ] Retrieving bodies:  869
[ 00.000% ] Weave Initializers:  0
[ 00.334% ] Load shadow types:  22
[ 00.897% ] Compute advice lists:  59
[ 00.046% ] Intertype weave:  3
[ 00.137% ] Add aspect code:  9
[ 00.213% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.070% ] Soot Packs:  202
[ 03.253% ] Soot Writing Output:  214
================================================
Abc started on Thu Jun 24 09:37:10 BST 2004
<<<< Test1CP.java >>>>
package circle;

public class Test1CP {
    public static void main(java.lang.String[] args) {
        new circle.Base();
    }
    
    public Test1CP() { super(); }
}
class Base implements circle.Type.Reflexive {
    public Base() { super(); }
}
class Type {
    public static interface Reflexive {}
    
    
    public class Concrete extends circle.Base {
        public Concrete() { super(); }
    }
    
    
    public Type() { super(); }
}
retrieve <circle.Test1CP: void main(java.lang.String[])> from circle.Test1CP
retrieve <circle.Test1CP: void <init>()> from circle.Test1CP
retrieve <circle.Base: void <init>()> from circle.Base
retrieve <circle.Type: void <init>()> from circle.Type
retrieve <circle.Type$Concrete: void <init>(circle.Type)> from circle.Type$Concrete
Transforming circle.Test1CP... 
Transforming circle.Type... 
Transforming circle.Type$Reflexive... 
Transforming circle.Type$Concrete... 
Transforming circle.Base... 
Abc finished on Thu Jun 24 09:37:17 BST 2004. ( 0 min. 6 sec. )
PASS: no circularity errors simply because of inners (1)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 248 failed (check: 88), 354 passed (check: 83), 1 skipped.
Executing test 604 (pureJava): no circularity errors simply because of inners (2)
================================================
Breakdown of abc phases  (total: 6442 millisec.)
------------------------------------------------
[ 00.574% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  3
[ 77.414% ] Polyglot phases:  4987
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.481% ] Recompute name pattern matches:  31
[ 00.000% ] Compute precedence relation:  0
[ 00.916% ] Intertype Adjuster:  59
[ 12.589% ] Retrieving bodies:  811
[ 00.000% ] Weave Initializers:  0
[ 00.342% ] Load shadow types:  22
[ 00.885% ] Compute advice lists:  57
[ 00.047% ] Intertype weave:  3
[ 00.124% ] Add aspect code:  8
[ 00.202% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.043% ] Soot Packs:  196
[ 03.306% ] Soot Writing Output:  213
================================================
Abc started on Thu Jun 24 09:37:20 BST 2004
<<<< Test2CP.java >>>>
package circle;

public class Test2CP {
    public static void main(java.lang.String[] args) {
        new circle.Base();
    }
    
    public Test2CP() { super(); }
}
class Base implements circle.Type.Reflexive {
    public static interface I {}
    
    
    public Base() { super(); }
}
class Type {
    public static interface Reflexive {}
    
    
    public class Concrete implements circle.Base.I {
        public Concrete() { super(); }
    }
    
    
    public Type() { super(); }
}
retrieve <circle.Test2CP: void main(java.lang.String[])> from circle.Test2CP
retrieve <circle.Test2CP: void <init>()> from circle.Test2CP
retrieve <circle.Base: void <init>()> from circle.Base
retrieve <circle.Type: void <init>()> from circle.Type
retrieve <circle.Type$Concrete: void <init>(circle.Type)> from circle.Type$Concrete
Transforming circle.Test2CP... 
Transforming circle.Type... 
Transforming circle.Type$Concrete... 
Transforming circle.Type$Reflexive... 
Transforming circle.Base... 
Transforming circle.Base$I... 
Abc finished on Thu Jun 24 09:37:26 BST 2004. ( 0 min. 6 sec. )
PASS: no circularity errors simply because of inners (2)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 248 failed (check: 88), 355 passed (check: 83), 1 skipped.
Executing test 605 (pureJava): should have circular inheritance errors (1)
Failed. Current status: 249 failed (check: 89), 355 passed (check: 83), 1 skipped.
Executing test 606 (pureJava): should have circular inheritance errors (2)
================================================
Breakdown of abc phases  (total: 6480 millisec.)
------------------------------------------------
[ 00.586% ] Init. of Soot:  38
[ 00.062% ] Loading Jars:  4
[ 78.410% ] Polyglot phases:  5081
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.725% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.633% ] Intertype Adjuster:  41
[ 12.145% ] Retrieving bodies:  787
[ 00.000% ] Weave Initializers:  0
[ 00.340% ] Load shadow types:  22
[ 00.880% ] Compute advice lists:  57
[ 00.046% ] Intertype weave:  3
[ 00.139% ] Add aspect code:  9
[ 00.201% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.515% ] Soot Packs:  163
[ 03.287% ] Soot Writing Output:  213
================================================
Failed. Current status: 250 failed (check: 90), 355 passed (check: 83), 1 skipped.
Executing test 607 (new/pr728): file order in type searching
================================================
Breakdown of abc phases  (total: 6921 millisec.)
------------------------------------------------
[ 00.564% ] Init. of Soot:  39
[ 00.058% ] Loading Jars:  4
[ 79.974% ] Polyglot phases:  5535
[ 00.029% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.694% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.809% ] Intertype Adjuster:  56
[ 06.878% ] Retrieving bodies:  476
[ 00.000% ] Weave Initializers:  0
[ 00.318% ] Load shadow types:  22
[ 02.789% ] Compute advice lists:  193
[ 00.043% ] Intertype weave:  3
[ 00.535% ] Add aspect code:  37
[ 00.188% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.916% ] Soot Packs:  271
[ 03.193% ] Soot Writing Output:  221
================================================
Failed. Current status: 251 failed (check: 90), 355 passed (check: 83), 1 skipped.
Executing test 608 (pureJava): interface using preceding subinterface in its definition
Failed. Current status: 252 failed (check: 90), 355 passed (check: 83), 1 skipped.
Executing test 609 (new): Parent interface using public inner interface of child in same file
Failed. Current status: 253 failed (check: 90), 355 passed (check: 83), 1 skipped.
Executing test 610 (errors): a type is not allowed to extend or implement its own innner type
================================================
Breakdown of abc phases  (total: 6452 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  35
[ 00.062% ] Loading Jars:  4
[ 79.355% ] Polyglot phases:  5120
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.713% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.604% ] Intertype Adjuster:  39
[ 12.337% ] Retrieving bodies:  796
[ 00.000% ] Weave Initializers:  0
[ 00.341% ] Load shadow types:  22
[ 00.713% ] Compute advice lists:  46
[ 00.046% ] Intertype weave:  3
[ 00.139% ] Add aspect code:  9
[ 00.186% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.433% ] Soot Packs:  157
[ 02.495% ] Soot Writing Output:  161
================================================
Failed. Current status: 254 failed (check: 91), 355 passed (check: 83), 1 skipped.
Executing test 611 (pureJava): try requires block JLS 14.19
Abc started on Thu Jun 24 09:38:18 BST 2004
PASS: try requires block JLS 14.19()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 254 failed (check: 91), 356 passed (check: 84), 1 skipped.
Executing test 612 (pureJava): loop expressions not declarations
Abc started on Thu Jun 24 09:38:22 BST 2004
PASS: loop expressions not declarations()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 254 failed (check: 91), 357 passed (check: 85), 1 skipped.
Executing test 613 (new): no error when public class is in file of a different name
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(1 options 1 paths 1 messages)" because old ajc 1.0 option: strict
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 254 failed (check: 91), 357 passed (check: 85), 2 skipped.
Executing test 614 (pureJava): local variables must be final to be accessed from inner class
Failed. Current status: 255 failed (check: 92), 357 passed (check: 85), 2 skipped.
Executing test 615 (pureJava): final local variables may be accessed from inner class
================================================
Breakdown of abc phases  (total: 8908 millisec.)
------------------------------------------------
[ 00.404% ] Init. of Soot:  36
[ 00.045% ] Loading Jars:  4
[ 65.177% ] Polyglot phases:  5806
[ 00.011% ] Resolve class names:  1
[ 00.112% ] Declare Parents:  10
[ 00.370% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.685% ] Intertype Adjuster:  61
[ 08.038% ] Retrieving bodies:  716
[ 00.000% ] Weave Initializers:  0
[ 00.247% ] Load shadow types:  22
[ 15.918% ] Compute advice lists:  1418
[ 00.045% ] Intertype weave:  4
[ 00.090% ] Add aspect code:  8
[ 00.202% ] Weaving advice:  18
[ 00.000% ] Validate jimple:  0
[ 04.546% ] Soot Packs:  405
[ 04.109% ] Soot Writing Output:  366
================================================
Abc started on Thu Jun 24 09:38:30 BST 2004
<<<< LocalsFromInnerCP.java >>>>
import org.aspectj.testing.*;

public class LocalsFromInnerCP {
    public static void main(java.lang.String[] args) {
        LocalsFromInnerCP.registerAll();
        LocalsFromInnerCP me = new LocalsFromInnerCP();
        me = new LocalsFromInnerCP(1);
        me.f();
        LocalsFromInnerCP.sf();
        me.f(1);
        LocalsFromInnerCP.sf(1);
        me.m();
        me.m(1);
        me.new m().f();
        me.new m().f(1);
        org.aspectj.testing.Tester.check(LocalsFromInnerCP/*LocalsFromInnerCP*/.globali ==
                                         11,
                                         "globali: " +
                                         LocalsFromInnerCP/*LocalsFromInnerCP*/.globali);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    void f() {
        final int i = 1;
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.f().Runnable.run()", i);
            }
        }.run();
    }
    
    static void sf() {
        final int i = 1;
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.sf().Runnable.run()", i);
            }
        }.run();
    }
    
    void f(final int i) {
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.f(int).Runnable.run()", i);
            }
        }.run();
    }
    
    static void sf(final int i) {
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.sf(int).Runnable.run()", i);
            }
        }.run();
    }
    
    static {
               final int i = 1;
               new java.lang.Runnable() {
                   public void run() {
                       signal("LocalsFromInnerCP.<clinit>.Runnable.run()",
                              i);
                   }
               }.run();
           }
    
    void m(final int i) {
        class m {
            void f() {
                new java.lang.Runnable() {
                    public void run() {
                        signal("LocalsFromInnerCP.m(int).m.f().Runnable.run()",
                               i);
                    }
                }.run();
            }
            
            public m() { super(); }
        }
        ;
        new m().f();
    }
    
    void m() {
        final int i = 1;
        class m {
            void f() {
                new java.lang.Runnable() {
                    public void run() {
                        signal("LocalsFromInnerCP.m().m.f().Runnable.run()",
                               i);
                    }
                }.run();
            }
            
            public m() { super(); }
        }
        ;
        new m().f();
    }
    
    class m {
        void f() {
            final int i = 1;
            new java.lang.Runnable() {
                public void run() {
                    signal("LocalsFromInnerCP.m.f().Runnable.run()",
                           i);
                }
            }.run();
        }
        
        void f(final int i) {
            new java.lang.Runnable() {
                public void run() {
                    signal("LocalsFromInnerCP.m.f(int).Runnable.run()",
                           i);
                }
            }.run();
        }
        
        public m() { super(); }
    }
    
    
    LocalsFromInnerCP() {
        super();
        final int i = 1;
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.LocalsFromInnerCP().Runnable.run()",
                       i);
            }
        }.run();
    }
    
    LocalsFromInnerCP(final int i) {
        super();
        new java.lang.Runnable() {
            public void run() {
                signal("LocalsFromInnerCP.LocalsFromInnerCP(int).Runnable.run()",
                       i);
            }
        }.run();
    }
    
    static void registerAll() {
        register("LocalsFromInnerCP.f().Runnable.run()");
        register("LocalsFromInnerCP.sf().Runnable.run()");
        register("LocalsFromInnerCP.f(int).Runnable.run()");
        register("LocalsFromInnerCP.sf(int).Runnable.run()");
        register("LocalsFromInnerCP.<clinit>.Runnable.run()");
        register("LocalsFromInnerCP.m(int).m.f().Runnable.run()");
        register("LocalsFromInnerCP.m().m.f().Runnable.run()");
        register("LocalsFromInnerCP.m.f().Runnable.run()");
        register("LocalsFromInnerCP.m.f(int).Runnable.run()");
        register("LocalsFromInnerCP.LocalsFromInnerCP().Runnable.run()");
        register("LocalsFromInnerCP.LocalsFromInnerCP(int).Runnable.run()");
    }
    
    static void register(java.lang.String s) {
        org.aspectj.testing.Tester.expectEvent(s);
    }
    
    static int globali;
    
    static void signal(java.lang.String s, int i) {
        org.aspectj.testing.Tester.event(s);
        org.aspectj.testing.Tester.check(i ==
                                         1,
                                         "1 != i=" + i + " for " +
                                         s);
        LocalsFromInnerCP/*LocalsFromInnerCP*/.globali++;
    }
}
retrieve <LocalsFromInnerCP: void main(java.lang.String[])> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void f()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void sf()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void f(int)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void sf(int)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void m(int)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void m()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void <init>()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void <init>(int)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void registerAll()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void register(java.lang.String)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void signal(java.lang.String,int)> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP: void <clinit>()> from LocalsFromInnerCP
retrieve <LocalsFromInnerCP$5: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$5
retrieve <LocalsFromInnerCP$5: void run()> from LocalsFromInnerCP$5
retrieve <LocalsFromInnerCP$9: void <init>(int)> from LocalsFromInnerCP$9
retrieve <LocalsFromInnerCP$9: void run()> from LocalsFromInnerCP$9
retrieve <LocalsFromInnerCP$2: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$2
retrieve <LocalsFromInnerCP$2: void run()> from LocalsFromInnerCP$2
retrieve <LocalsFromInnerCP$3: void <init>(int)> from LocalsFromInnerCP$3
retrieve <LocalsFromInnerCP$3: void run()> from LocalsFromInnerCP$3
retrieve <LocalsFromInnerCP$6: void <init>(int)> from LocalsFromInnerCP$6
retrieve <LocalsFromInnerCP$6: void run()> from LocalsFromInnerCP$6
retrieve <LocalsFromInnerCP$2m: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$2m
retrieve <LocalsFromInnerCP$2m: void f()> from LocalsFromInnerCP$2m
retrieve <LocalsFromInnerCP$8: void <init>(LocalsFromInnerCP$2m)> from LocalsFromInnerCP$8
retrieve <LocalsFromInnerCP$8: void run()> from LocalsFromInnerCP$8
retrieve <LocalsFromInnerCP$1m: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$1m
retrieve <LocalsFromInnerCP$1m: void f()> from LocalsFromInnerCP$1m
retrieve <LocalsFromInnerCP$7: void <init>(LocalsFromInnerCP$1m)> from LocalsFromInnerCP$7
retrieve <LocalsFromInnerCP$7: void run()> from LocalsFromInnerCP$7
retrieve <LocalsFromInnerCP$m: void <init>(LocalsFromInnerCP)> from LocalsFromInnerCP$m
retrieve <LocalsFromInnerCP$m: void f()> from LocalsFromInnerCP$m
retrieve <LocalsFromInnerCP$m: void f(int)> from LocalsFromInnerCP$m
retrieve <LocalsFromInnerCP$4: void <init>(LocalsFromInnerCP$m,int)> from LocalsFromInnerCP$4
retrieve <LocalsFromInnerCP$4: void run()> from LocalsFromInnerCP$4
retrieve <LocalsFromInnerCP$11: void <init>(LocalsFromInnerCP$m,int)> from LocalsFromInnerCP$11
retrieve <LocalsFromInnerCP$11: void run()> from LocalsFromInnerCP$11
retrieve <LocalsFromInnerCP$10: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$10
retrieve <LocalsFromInnerCP$10: void run()> from LocalsFromInnerCP$10
retrieve <LocalsFromInnerCP$1: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$1
retrieve <LocalsFromInnerCP$1: void run()> from LocalsFromInnerCP$1
retrieve <LocalsFromInnerCP$2m: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$2m
retrieve <LocalsFromInnerCP$2m: void f()> from LocalsFromInnerCP$2m
retrieve <LocalsFromInnerCP$2m: int access$000(LocalsFromInnerCP$2m)> from LocalsFromInnerCP$2m
retrieve <LocalsFromInnerCP$8: void <init>(LocalsFromInnerCP$2m)> from LocalsFromInnerCP$8
retrieve <LocalsFromInnerCP$8: void run()> from LocalsFromInnerCP$8
retrieve <LocalsFromInnerCP$1m: void <init>(LocalsFromInnerCP,int)> from LocalsFromInnerCP$1m
retrieve <LocalsFromInnerCP$1m: void f()> from LocalsFromInnerCP$1m
retrieve <LocalsFromInnerCP$1m: int access$100(LocalsFromInnerCP$1m)> from LocalsFromInnerCP$1m
retrieve <LocalsFromInnerCP$7: void <init>(LocalsFromInnerCP$1m)> from LocalsFromInnerCP$7
retrieve <LocalsFromInnerCP$7: void run()> from LocalsFromInnerCP$7
Transforming LocalsFromInnerCP... 
Transforming LocalsFromInnerCP$1... 
Transforming LocalsFromInnerCP$2... 
Transforming LocalsFromInnerCP$3... 
Transforming LocalsFromInnerCP$m... 
Transforming LocalsFromInnerCP$4... 
Transforming LocalsFromInnerCP$5... 
Transforming LocalsFromInnerCP$6... 
Transforming LocalsFromInnerCP$1m... 
Transforming LocalsFromInnerCP$7... 
Transforming LocalsFromInnerCP$2m... 
Transforming LocalsFromInnerCP$8... 
Transforming LocalsFromInnerCP$9... 
Transforming LocalsFromInnerCP$10... 
Transforming LocalsFromInnerCP$11... 
Abc finished on Thu Jun 24 09:38:39 BST 2004. ( 0 min. 9 sec. )
PASS: final local variables may be accessed from inner class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 10 seconds
Passed. Current status: 255 failed (check: 92), 358 passed (check: 85), 2 skipped.
Executing test 616 (pureJava): missing package identifier
Abc started on Thu Jun 24 09:38:42 BST 2004
PASS: missing package identifier()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 255 failed (check: 92), 359 passed (check: 86), 2 skipped.
Executing test 617 (pureJava): interface declaration not permitted in local method scope
================================================
Breakdown of abc phases  (total: 6589 millisec.)
------------------------------------------------
[ 00.546% ] Init. of Soot:  36
[ 00.046% ] Loading Jars:  3
[ 78.206% ] Polyglot phases:  5153
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.455% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 00.926% ] Intertype Adjuster:  61
[ 12.248% ] Retrieving bodies:  807
[ 00.000% ] Weave Initializers:  0
[ 00.319% ] Load shadow types:  21
[ 00.865% ] Compute advice lists:  57
[ 00.046% ] Intertype weave:  3
[ 00.121% ] Add aspect code:  8
[ 00.212% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 02.747% ] Soot Packs:  181
[ 03.233% ] Soot Writing Output:  213
================================================
Failed. Current status: 256 failed (check: 93), 359 passed (check: 86), 2 skipped.
Executing test 618 (new): simple declare warning (NPE)
================================================
Breakdown of abc phases  (total: 7050 millisec.)
------------------------------------------------
[ 00.426% ] Init. of Soot:  30
[ 00.071% ] Loading Jars:  5
[ 74.738% ] Polyglot phases:  5269
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.709% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.525% ] Intertype Adjuster:  37
[ 13.376% ] Retrieving bodies:  943
[ 00.000% ] Weave Initializers:  0
[ 00.326% ] Load shadow types:  23
[ 02.156% ] Compute advice lists:  152
[ 00.043% ] Intertype weave:  3
[ 00.496% ] Add aspect code:  35
[ 00.340% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 03.801% ] Soot Packs:  268
[ 02.936% ] Soot Writing Output:  207
================================================
Failed. Current status: 257 failed (check: 94), 359 passed (check: 86), 2 skipped.
Executing test 619 (new): package typepattern with no packages (in default package)
Failed. Current status: 258 failed (check: 95), 359 passed (check: 86), 2 skipped.
Executing test 620 (new): CE for ambiguous type reference (two files in package)
================================================
Breakdown of abc phases  (total: 6325 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  35
[ 00.063% ] Loading Jars:  4
[ 79.399% ] Polyglot phases:  5022
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.458% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.949% ] Intertype Adjuster:  60
[ 12.000% ] Retrieving bodies:  759
[ 00.000% ] Weave Initializers:  0
[ 00.601% ] Load shadow types:  38
[ 00.743% ] Compute advice lists:  47
[ 00.047% ] Intertype weave:  3
[ 00.126% ] Add aspect code:  8
[ 00.206% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.292% ] Soot Packs:  145
[ 02.530% ] Soot Writing Output:  160
================================================
Failed. Current status: 259 failed (check: 96), 359 passed (check: 86), 2 skipped.
Executing test 621 (new): initializer can throw so long as all constructors declare so
Failed. Current status: 260 failed (check: 96), 359 passed (check: 86), 2 skipped.
Executing test 622 (pureJava): interfaces may not contain initializers (bug found by jacks)
Failed. Current status: 261 failed (check: 97), 359 passed (check: 86), 2 skipped.
Executing test 623 (new): ajc dies on cflow into field init anon class see knownbugs.txt
================================================
Breakdown of abc phases  (total: 7916 millisec.)
------------------------------------------------
[ 00.467% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 70.894% ] Polyglot phases:  5612
[ 00.025% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.733% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.455% ] Intertype Adjuster:  36
[ 11.382% ] Retrieving bodies:  901
[ 00.000% ] Weave Initializers:  0
[ 00.291% ] Load shadow types:  23
[ 03.765% ] Compute advice lists:  298
[ 00.038% ] Intertype weave:  3
[ 00.455% ] Add aspect code:  36
[ 01.061% ] Weaving advice:  84
[ 00.000% ] Validate jimple:  0
[ 06.367% ] Soot Packs:  504
[ 04.017% ] Soot Writing Output:  318
================================================
Abc started on Thu Jun 24 09:39:23 BST 2004
<<<< CflowOfFieldInitAnonMethods.java >>>>
import org.aspectj.testing.Tester;

public class CflowOfFieldInitAnonMethods {
    public static void main(java.lang.String[] args) {
        new CflowOfFieldInitAnonMethods()/*<unknown>*/.r.run();
    }
    
    java.lang.Runnable r =
      new java.lang.Runnable() {
        public void run() { calc(1); }
        
        public void calc(int i) {  }
    };
    
    public CflowOfFieldInitAnonMethods() { super(); }
}
aspect ThreadTracer {
    pointcut safe() : !within(ThreadTracer);
    
    before():
    safe() &&
      cflow(call(void (Runnable).run())) {
        org.aspectj.testing.Tester.event("before(): cflow(call(void Runnable.run()))");
    }
    
    before():
    safe() &&
      cflowbelow(call(void (Runnable).run())) {
        org.aspectj.testing.Tester.event("before(): cflowbelow(call(void Runnable.run()))");
    }
    
    before():
    safe() &&
      cflow(execution (void (Runnable).run())) {
        org.aspectj.testing.Tester.event("before(): cflow(execution(void Runnable.run()))");
    }
    
    before():
    safe() &&
      cflowbelow(execution (void (Runnable).run())) {
        org.aspectj.testing.Tester.event("before(): cflowbelow(execution(void Runnable.run()))");
    }
    
    before():
    execution (void (Runnable).run()) {
        org.aspectj.testing.Tester.event("before(): execution(void Runnable.run())");
    }
    
    static {
               org.aspectj.testing.Tester.expectEvent("before(): cflow(call(void Runnable.run()))");
               org.aspectj.testing.Tester.expectEvent("before(): cflowbelow(call(void Runnable.run()))");
               org.aspectj.testing.Tester.expectEvent("before(): cflow(execution(void Runnable.run()))");
               org.aspectj.testing.Tester.expectEvent("before(): cflowbelow(execution(void Runnable.run()))");
               org.aspectj.testing.Tester.expectEvent("before(): execution(void Runnable.run())");
           }
    
    public static ThreadTracer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ThreadTracer() { super(); }
}
retrieve <CflowOfFieldInitAnonMethods: void <init>()> from CflowOfFieldInitAnonMethods
retrieve <CflowOfFieldInitAnonMethods: void main(java.lang.String[])> from CflowOfFieldInitAnonMethods
retrieve <CflowOfFieldInitAnonMethods$1: void <init>(CflowOfFieldInitAnonMethods)> from CflowOfFieldInitAnonMethods$1
retrieve <CflowOfFieldInitAnonMethods$1: void run()> from CflowOfFieldInitAnonMethods$1
retrieve <CflowOfFieldInitAnonMethods$1: void calc(int)> from CflowOfFieldInitAnonMethods$1
retrieve <ThreadTracer: void before$0()> from ThreadTracer
retrieve <ThreadTracer: void before$1()> from ThreadTracer
retrieve <ThreadTracer: void before$2()> from ThreadTracer
retrieve <ThreadTracer: void before$3()> from ThreadTracer
retrieve <ThreadTracer: void before$4()> from ThreadTracer
retrieve <ThreadTracer: ThreadTracer aspectOf()> from ThreadTracer
retrieve <ThreadTracer: boolean hasAspect()> from ThreadTracer
retrieve <ThreadTracer: void <init>()> from ThreadTracer
retrieve <ThreadTracer: void <clinit>()> from ThreadTracer
Transforming ThreadTracer... 
Transforming CflowOfFieldInitAnonMethods... 
Transforming CflowOfFieldInitAnonMethods$1... 
Abc finished on Thu Jun 24 09:39:31 BST 2004. ( 0 min. 8 sec. )
PASS: ajc dies on cflow into field init anon class see knownbugs.txt()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 261 failed (check: 97), 360 passed (check: 86), 2 skipped.
Executing test 624 (pureJava): initializers must be able to complete normally (found by jacks)
================================================
Breakdown of abc phases  (total: 6384 millisec.)
------------------------------------------------
[ 00.548% ] Init. of Soot:  35
[ 00.047% ] Loading Jars:  3
[ 78.430% ] Polyglot phases:  5007
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.642% ] Recompute name pattern matches:  41
[ 00.000% ] Compute precedence relation:  0
[ 00.595% ] Intertype Adjuster:  38
[ 13.095% ] Retrieving bodies:  836
[ 00.000% ] Weave Initializers:  0
[ 00.345% ] Load shadow types:  22
[ 00.815% ] Compute advice lists:  52
[ 00.047% ] Intertype weave:  3
[ 00.125% ] Add aspect code:  8
[ 00.188% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.632% ] Soot Packs:  168
[ 02.459% ] Soot Writing Output:  157
================================================
Failed. Current status: 262 failed (check: 98), 360 passed (check: 86), 2 skipped.
Executing test 625 (new): Incrementing interface-introduced field
================================================
Breakdown of abc phases  (total: 7489 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  36
[ 00.053% ] Loading Jars:  4
[ 73.615% ] Polyglot phases:  5513
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.681% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 01.803% ] Intertype Adjuster:  135
[ 05.849% ] Retrieving bodies:  438
[ 00.120% ] Weave Initializers:  9
[ 00.361% ] Load shadow types:  27
[ 09.107% ] Compute advice lists:  682
[ 00.040% ] Intertype weave:  3
[ 00.227% ] Add aspect code:  17
[ 00.174% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.246% ] Soot Packs:  318
[ 03.191% ] Soot Writing Output:  239
================================================
Failed. Current status: 263 failed (check: 98), 360 passed (check: 86), 2 skipped.
Executing test 626 (pureJava): more tests of super alone
Failed. Current status: 264 failed (check: 99), 360 passed (check: 86), 2 skipped.
Executing test 627 (new): The dynamic type, not the static one, should be used in if pcds
Failed. Current status: 265 failed (check: 99), 360 passed (check: 86), 2 skipped.
Executing test 628 (new): bad interaction with after returning, around and void methods (from Rich Price)
Failed. Current status: 266 failed (check: 99), 360 passed (check: 86), 2 skipped.
Executing test 629 (new): type pattern matching for inner classes (from Ken Horn)
================================================
Breakdown of abc phases  (total: 8716 millisec.)
------------------------------------------------
[ 00.425% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  4
[ 64.892% ] Polyglot phases:  5656
[ 00.023% ] Resolve class names:  2
[ 00.023% ] Declare Parents:  2
[ 00.883% ] Recompute name pattern matches:  77
[ 00.000% ] Compute precedence relation:  0
[ 00.413% ] Intertype Adjuster:  36
[ 06.838% ] Retrieving bodies:  596
[ 00.000% ] Weave Initializers:  0
[ 00.241% ] Load shadow types:  21
[ 12.506% ] Compute advice lists:  1090
[ 00.034% ] Intertype weave:  3
[ 00.333% ] Add aspect code:  29
[ 01.388% ] Weaving advice:  121
[ 00.000% ] Validate jimple:  0
[ 06.815% ] Soot Packs:  594
[ 05.140% ] Soot Writing Output:  448
================================================
Failed. Current status: 267 failed (check: 99), 360 passed (check: 86), 2 skipped.
Executing test 630 (new): static initializer member name
================================================
Breakdown of abc phases  (total: 7882 millisec.)
------------------------------------------------
[ 00.469% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 73.319% ] Polyglot phases:  5779
[ 00.025% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.634% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.457% ] Intertype Adjuster:  36
[ 06.953% ] Retrieving bodies:  548
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  22
[ 08.323% ] Compute advice lists:  656
[ 00.051% ] Intertype weave:  4
[ 00.140% ] Add aspect code:  11
[ 01.231% ] Weaving advice:  97
[ 00.000% ] Validate jimple:  0
[ 04.402% ] Soot Packs:  347
[ 03.667% ] Soot Writing Output:  289
================================================
Abc started on Thu Jun 24 09:40:25 BST 2004
<<<< StaticInitName.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class StaticInitName {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("C");
        org.aspectj.testing.Tester.event("" + C.class.getName());
        org.aspectj.testing.Tester.expectEvent("D");
        org.aspectj.testing.Tester.event("" + D.class.getName());
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public StaticInitName() { super(); }
}
class C {
    static int i = 1;
    
    public C() { super(); }
}
class D {
    static int i;
    
    static { D/*D*/.i = 2; }
    
    public D() { super(); }
}
aspect A {
    static {
               org.aspectj.testing.Tester.expectEvent("before");
               org.aspectj.testing.Tester.expectEvent("before-D");
           }
    
    before():
    within(C) &&
      !set( * (*).*) {
        org.aspectj.testing.Tester.event("before");
        java.lang.String memberName =
          thisJoinPoint.getSignature().getName();
        org.aspectj.testing.Tester.check("<clinit>".equals(memberName),
                                         "\"<clinit>\".equals(\"" +
                                         memberName +
                                         "\")");
    }
    
    before():
    within(D) &&
      !set( * (*).*) {
        org.aspectj.testing.Tester.event("before-D");
        java.lang.String memberName =
          thisJoinPoint.getSignature().getName();
        org.aspectj.testing.Tester.check("<clinit>".equals(memberName),
                                         "\"<clinit>\".equals(\"" +
                                         memberName +
                                         "\")");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <StaticInitName: void <init>()> from StaticInitName
retrieve <StaticInitName: java.lang.Class class$(java.lang.String)> from StaticInitName
retrieve <StaticInitName: void main(java.lang.String[])> from StaticInitName
retrieve <C: void <init>()> from C
retrieve <C: void <clinit>()> from C
retrieve <D: void <init>()> from D
retrieve <D: void <clinit>()> from D
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
Transforming D... 
Transforming A... 
Transforming C... 
Transforming StaticInitName... 
Abc finished on Thu Jun 24 09:40:33 BST 2004. ( 0 min. 7 sec. )
PASS: static initializer member name()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 267 failed (check: 99), 361 passed (check: 86), 2 skipped.
Executing test 631 (new): cflow pcd syntax error
Abc started on Thu Jun 24 09:40:36 BST 2004
PASS: cflow pcd syntax error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 267 failed (check: 99), 362 passed (check: 87), 2 skipped.
Executing test 632 (new): binding args with indeterminate prefix and suffix
Failed. Current status: 268 failed (check: 99), 362 passed (check: 87), 2 skipped.
Executing test 633 (new): flag errors when binding args with indeterminate prefix and suffix
================================================
Breakdown of abc phases  (total: 6201 millisec.)
------------------------------------------------
[ 00.581% ] Init. of Soot:  36
[ 00.048% ] Loading Jars:  3
[ 88.566% ] Polyglot phases:  5492
[ 00.032% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  1
[ 00.677% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.613% ] Intertype Adjuster:  38
[ 09.111% ] Retrieving bodies:  565
[ 00.000% ] Weave Initializers:  0
[ 00.355% ] Load shadow types:  22
================================================
Failed. Current status: 269 failed (check: 100), 362 passed (check: 87), 2 skipped.
Executing test 634 (new): check arg types with indeterminate prefix and suffix
================================================
Breakdown of abc phases  (total: 9451 millisec.)
------------------------------------------------
[ 00.381% ] Init. of Soot:  36
[ 00.042% ] Loading Jars:  4
[ 65.295% ] Polyglot phases:  6171
[ 00.011% ] Resolve class names:  1
[ 00.021% ] Declare Parents:  2
[ 00.540% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.381% ] Intertype Adjuster:  36
[ 06.994% ] Retrieving bodies:  661
[ 00.000% ] Weave Initializers:  0
[ 00.265% ] Load shadow types:  25
[ 06.888% ] Compute advice lists:  651
[ 00.032% ] Intertype weave:  3
[ 00.360% ] Add aspect code:  34
[ 02.825% ] Weaving advice:  267
[ 00.000% ] Validate jimple:  0
[ 09.512% ] Soot Packs:  899
[ 06.454% ] Soot Writing Output:  610
================================================
Failed. Current status: 270 failed (check: 100), 362 passed (check: 87), 2 skipped.
Executing test 635 (new): testing and binding args with single indeterminate prefix and suffix
================================================
Breakdown of abc phases  (total: 17226 millisec.)
------------------------------------------------
[ 00.238% ] Init. of Soot:  41
[ 00.023% ] Loading Jars:  4
[ 38.285% ] Polyglot phases:  6595
[ 00.012% ] Resolve class names:  2
[ 00.012% ] Declare Parents:  2
[ 00.279% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.215% ] Intertype Adjuster:  37
[ 04.952% ] Retrieving bodies:  853
[ 00.000% ] Weave Initializers:  0
[ 00.145% ] Load shadow types:  25
[ 14.983% ] Compute advice lists:  2581
[ 00.017% ] Intertype weave:  3
[ 00.128% ] Add aspect code:  22
[ 08.719% ] Weaving advice:  1502
[ 00.000% ] Validate jimple:  0
[ 21.920% ] Soot Packs:  3776
[ 10.072% ] Soot Writing Output:  1735
================================================
Abc started on Thu Jun 24 09:41:12 BST 2004
<<<< IndeterminateArg.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;
import java.util.Arrays;

public class IndeterminateArg {
    public static void main(java.lang.String[] args) {
        java.lang.Object o1 = new OObject("o1");
        java.lang.Object o2 = new OObject("o2");
        java.lang.Object o3 = new OObject("o3");
        java.lang.String s1 = "s1";
        java.lang.String s2 = "s2";
        java.lang.String s3 = "s3";
        SClass c;
        c = new SClass();
        c = new SClass(s1);
        c = new SClass(s1, s2);
        c = new SClass(s1, s2, s3);
        c.f();
        c.f(s1);
        c.f(s1, s2);
        c.f(s1, s2, s3);
        OClass o;
        o = new OClass();
        o = new OClass(o1);
        o = new OClass(s1);
        o = new OClass(o1, o2);
        o = new OClass(o1, s2);
        o = new OClass(s1, o2);
        o = new OClass(s1, s2);
        o = new OClass(o1, o2, o3);
        o = new OClass(o1, o2, s3);
        o = new OClass(o1, s2, o3);
        o = new OClass(o1, s2, s3);
        o = new OClass(s1, o2, o3);
        o = new OClass(s1, o2, s3);
        o = new OClass(s1, s2, o3);
        o = new OClass(s1, s2, s3);
        o.f();
        o.f(o1);
        o.f(s1);
        o.f(o1, o2);
        o.f(o1, s2);
        o.f(s1, o2);
        o.f(s1, s2);
        o.f(o1, o2, o3);
        o.f(o1, o2, s3);
        o.f(o1, s2, o3);
        o.f(o1, s2, s3);
        o.f(s1, o2, o3);
        o.f(s1, o2, s3);
        o.f(s1, s2, o3);
        o.f(s1, s2, s3);
        org.aspectj.testing.Tester.checkEventsFromFile("IndeterminateArg.events");
    }
    
    public IndeterminateArg() { super(); }
}
class OObject {
    final java.lang.String s;
    
    OObject(java.lang.String s) {
        super();
        this/*<unknown>*/.s = s;
    }
    
    public java.lang.String toString() { return this/*null*/.s; }
}
class T {
    static void e(java.lang.String s) {
        org.aspectj.testing.Tester.event(s);
    }
    
    public T() { super(); }
}
interface C {}
class SClass implements C {
    SClass() {
        super();
        T.e("SClass()");
    }
    
    SClass(java.lang.String s1) {
        super();
        T.e("SClass(" + s1 + ")");
    }
    
    SClass(java.lang.String s1, java.lang.String s2) {
        super();
        T.e("SClass(" + s1 + ", " + s2 + ")");
    }
    
    SClass(java.lang.String s1,
           java.lang.String s2,
           java.lang.String s3) {
        super();
        T.e("SClass(" + s1 + ", " + s2 + ", " + s3 + ")");
    }
    
    void f() { T.e("SClass.f()"); }
    
    void f(java.lang.String s1) { T.e("SClass.f(" + s1 + ")"); }
    
    void f(java.lang.String s1, java.lang.String s2) {
        T.e("SClass.f(" + s1 + ", " + s2 + ")");
    }
    
    void f(java.lang.String s1,
           java.lang.String s2,
           java.lang.String s3) {
        T.e("SClass.f(" + s1 + ", " + s2 + ", " + s3 + ")");
    }
}
class OClass implements C {
    OClass() {
        super();
        T.e("OClass()");
    }
    
    OClass(java.lang.Object s1) {
        super();
        T.e("OClass(" + s1 + ")");
    }
    
    OClass(java.lang.Object s1, java.lang.Object s2) {
        super();
        T.e("OClass(" + s1 + ", " + s2 + ")");
    }
    
    OClass(java.lang.Object s1,
           java.lang.Object s2,
           java.lang.Object s3) {
        super();
        T.e("OClass(" + s1 + ", " + s2 + ", " + s3 + ")");
    }
    
    void f() { T.e("OClass.f()"); }
    
    void f(java.lang.Object s1) { T.e("OClass.f(" + s1 + ")"); }
    
    void f(java.lang.Object s1, java.lang.Object s2) {
        T.e("OClass.f(" + s1 + ", " + s2 + ")");
    }
    
    void f(java.lang.Object s1,
           java.lang.Object s2,
           java.lang.Object s3) {
        T.e("OClass.f(" + s1 + ", " + s2 + ", " + s3 + ")");
    }
}
aspect A {
    java.lang.String actualTypes(org.aspectj.lang.JoinPoint jp) {
        java.lang.Object[] types = jp.getArgs();
        java.lang.StringBuffer sb = new java.lang.StringBuffer();
        sb.append("[");
        for (int i = 0; i < types/*null*/.length; i++) {
            sb.append(types[i].getClass().getName());
            if (1 + i < types/*null*/.length) { sb.append(", "); }
        }
        sb.append("]");
        return sb.toString();
    }
    
    void check(java.lang.String pc, org.aspectj.lang.JoinPoint jp) {
        java.lang.Class[] types =
          ((org.aspectj.lang.reflect.CodeSignature)
             jp.getSignature()).getParameterTypes();
        java.lang.String name =
          jp.toLongString() + " " + actualTypes(jp) + ": " +
        pc;
        T.e(name);
    }
    
    pointcut safe() :
    call((C+).new(..)) ||
      call(* (*).*(..)) && target(C);
    
    pointcut none() : args();
    
    pointcut o1() : args(java.lang.Object);
    
    pointcut o2() : args(java.lang.Object, java.lang.Object);
    
    pointcut o3() :
    args(java.lang.Object,
        java.lang.Object,
        java.lang.Object);
    
    pointcut o1Start() : args(java.lang.Object, );
    
    pointcut o1End() : args(, java.lang.Object);
    
    pointcut o2Start() : args(java.lang.Object, java.lang.Object, );
    
    pointcut o2End() : args(, java.lang.Object, java.lang.Object);
    
    pointcut s1() : args(java.lang.String);
    
    pointcut s2() : args(java.lang.String, java.lang.String);
    
    pointcut s3() :
    args(java.lang.String,
        java.lang.String,
        java.lang.String);
    
    pointcut s1Start() : args(java.lang.String, );
    
    pointcut s1End() : args(, java.lang.String);
    
    pointcut s2Start() : args(java.lang.String, java.lang.String, );
    
    pointcut s2End() : args(, java.lang.String, java.lang.String);
    
    pointcut bo1(java.lang.Object o1) : args(o1);
    
    pointcut bo2(java.lang.Object o1, java.lang.Object o2) :
    args(o1,
        o2);
    
    pointcut bo3(java.lang.Object o1,
                 java.lang.Object o2,
                 java.lang.Object o3) :
    args(o1,
        o2,
        o3);
    
    pointcut bo1Start(java.lang.Object o1) : args(o1, );
    
    pointcut bo1End(java.lang.Object o1) : args(, o1);
    
    pointcut bo2Start(java.lang.Object o1, java.lang.Object o2) :
    args(o1,
        o2,
        );
    
    pointcut bo2End(java.lang.Object o1, java.lang.Object o2) :
    args(,
        o1,
        o2);
    
    pointcut bs1(java.lang.String s1) : args(s1);
    
    pointcut bs2(java.lang.String s1, java.lang.String s2) :
    args(s1,
        s2);
    
    pointcut bs3(java.lang.String s1,
                 java.lang.String s2,
                 java.lang.String s3) :
    args(s1,
        s2,
        s3);
    
    pointcut bs1Start(java.lang.String s1) : args(s1, );
    
    pointcut bs1End(java.lang.String s1) : args(, s1);
    
    pointcut bs2Start(java.lang.String s1, java.lang.String s2) :
    args(s1,
        s2,
        );
    
    pointcut bs2End(java.lang.String s1, java.lang.String s2) :
    args(,
        s1,
        s2);
    
    before(): safe() && none() { check("none()", thisJoinPoint); }
    
    before(): safe() && o1() { check("o1()", thisJoinPoint); }
    
    before(): safe() && o2() { check("o2()", thisJoinPoint); }
    
    before(): safe() && o3() { check("o3()", thisJoinPoint); }
    
    before():
    safe() &&
      o1Start() {
        check("o1Start()", thisJoinPoint);
    }
    
    before(): safe() && o1End() { check("o1End()", thisJoinPoint); }
    
    before():
    safe() &&
      o2Start() {
        check("o2Start()", thisJoinPoint);
    }
    
    before(): safe() && o2End() { check("o2End()", thisJoinPoint); }
    
    before(): safe() && s1() { check("s1()", thisJoinPoint); }
    
    before(): safe() && s2() { check("s2()", thisJoinPoint); }
    
    before(): safe() && s3() { check("s3()", thisJoinPoint); }
    
    before():
    safe() &&
      s1Start() {
        check("s1Start()", thisJoinPoint);
    }
    
    before(): safe() && s1End() { check("s1End()", thisJoinPoint); }
    
    before():
    safe() &&
      s2Start() {
        check("s2Start()", thisJoinPoint);
    }
    
    before(): safe() && s2End() { check("s2End()", thisJoinPoint); }
    
    before(Object o1):
    safe() &&
      bo1(o1) {
        check("bo1()", thisJoinPoint);
    }
    
    before(Object o1, Object o2):
    safe() &&
      bo2(o1, o2) {
        check("bo2()", thisJoinPoint);
    }
    
    before(Object o1, Object o2, Object o3):
    safe() &&
      bo3(o1, o2, o3) {
        check("bo3()", thisJoinPoint);
    }
    
    before(Object o1):
    safe() &&
      bo1Start(o1) {
        check("bo1Start()", thisJoinPoint);
    }
    
    before(Object o1):
    safe() &&
      bo1End(o1) {
        check("bo1End()", thisJoinPoint);
    }
    
    before(Object o1, Object o2):
    safe() &&
      bo2Start(o1, o2) {
        check("bo2Start()", thisJoinPoint);
    }
    
    before(Object o1, Object o2):
    safe() &&
      bo2End(o1, o2) {
        check("bo2End()", thisJoinPoint);
    }
    
    before(String s1):
    safe() &&
      bs1(s1) {
        check("bs1()", thisJoinPoint);
    }
    
    before(String s1, String s2):
    safe() &&
      bs2(s1, s2) {
        check("bs2()", thisJoinPoint);
    }
    
    before(String s1, String s2, String s3):
    safe() &&
      bs3(s1, s2, s3) {
        check("bs3()", thisJoinPoint);
    }
    
    before(String s1):
    safe() &&
      bs1Start(s1) {
        check("bs1Start()", thisJoinPoint);
    }
    
    before(String s1):
    safe() &&
      bs1End(s1) {
        check("bs1End()", thisJoinPoint);
    }
    
    before(String s1, String s2):
    safe() &&
      bs2Start(s1, s2) {
        check("bs2Start()", thisJoinPoint);
    }
    
    before(String s1, String s2):
    safe() &&
      bs2End(s1, s2) {
        check("bs2End()", thisJoinPoint);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <IndeterminateArg: void <init>()> from IndeterminateArg
retrieve <IndeterminateArg: void main(java.lang.String[])> from IndeterminateArg
retrieve <OObject: void <init>(java.lang.String)> from OObject
retrieve <OObject: java.lang.String toString()> from OObject
retrieve <T: void <init>()> from T
retrieve <T: void e(java.lang.String)> from T
retrieve <SClass: void f(java.lang.String,java.lang.String,java.lang.String)> from SClass
retrieve <SClass: void <init>(java.lang.String)> from SClass
retrieve <SClass: void <init>()> from SClass
retrieve <SClass: void <init>(java.lang.String,java.lang.String)> from SClass
retrieve <SClass: void <init>(java.lang.String,java.lang.String,java.lang.String)> from SClass
retrieve <SClass: void f()> from SClass
retrieve <SClass: void f(java.lang.String)> from SClass
retrieve <SClass: void f(java.lang.String,java.lang.String)> from SClass
retrieve <OClass: void <init>(java.lang.Object,java.lang.Object)> from OClass
retrieve <OClass: void <init>(java.lang.Object,java.lang.Object,java.lang.Object)> from OClass
retrieve <OClass: void f(java.lang.Object)> from OClass
retrieve <OClass: void <init>()> from OClass
retrieve <OClass: void f(java.lang.Object,java.lang.Object)> from OClass
retrieve <OClass: void f(java.lang.Object,java.lang.Object,java.lang.Object)> from OClass
retrieve <OClass: void f()> from OClass
retrieve <OClass: void <init>(java.lang.Object)> from OClass
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String actualTypes(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void check(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$2(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$3(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$4(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$5(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$6(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$7(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$8(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$9(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$10(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$11(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$12(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$13(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$14(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$15(java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$16(java.lang.Object,java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$17(java.lang.Object,java.lang.Object,java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$18(java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$19(java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$20(java.lang.Object,java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$21(java.lang.Object,java.lang.Object,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$22(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$23(java.lang.String,java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$24(java.lang.String,java.lang.String,java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$25(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$26(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$27(java.lang.String,java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$28(java.lang.String,java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming OObject... 
Transforming A... 
Transforming T... 
Transforming C... 
Transforming SClass... 
Transforming IndeterminateArg... 
Transforming OClass... 
Abc finished on Thu Jun 24 09:41:29 BST 2004. ( 0 min. 17 sec. )
PASS: testing and binding args with single indeterminate prefix and suffix()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 18 seconds
Passed. Current status: 270 failed (check: 100), 363 passed (check: 87), 2 skipped.
Executing test 636 (new): binding handler args with indeterminate prefix and suffix
================================================
Breakdown of abc phases  (total: 8994 millisec.)
------------------------------------------------
[ 00.411% ] Init. of Soot:  37
[ 00.033% ] Loading Jars:  3
[ 68.301% ] Polyglot phases:  6143
[ 00.022% ] Resolve class names:  2
[ 00.011% ] Declare Parents:  1
[ 00.356% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 00.700% ] Intertype Adjuster:  63
[ 07.738% ] Retrieving bodies:  696
[ 00.000% ] Weave Initializers:  0
[ 00.245% ] Load shadow types:  22
[ 09.829% ] Compute advice lists:  884
[ 00.033% ] Intertype weave:  3
[ 00.222% ] Add aspect code:  20
[ 01.356% ] Weaving advice:  122
[ 00.000% ] Validate jimple:  0
[ 06.727% ] Soot Packs:  605
[ 04.014% ] Soot Writing Output:  361
================================================
Failed. Current status: 271 failed (check: 100), 363 passed (check: 87), 2 skipped.
Executing test 637 (pureJava): Locals inside other locals, ordering of processing [eh]
================================================
Breakdown of abc phases  (total: 6710 millisec.)
------------------------------------------------
[ 00.551% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 74.516% ] Polyglot phases:  5000
[ 00.000% ] Resolve class names:  0
[ 00.030% ] Declare Parents:  2
[ 00.626% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.566% ] Intertype Adjuster:  38
[ 12.534% ] Retrieving bodies:  841
[ 00.000% ] Weave Initializers:  0
[ 00.328% ] Load shadow types:  22
[ 03.577% ] Compute advice lists:  240
[ 00.045% ] Intertype weave:  3
[ 00.119% ] Add aspect code:  8
[ 00.209% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 03.502% ] Soot Packs:  235
[ 03.353% ] Soot Writing Output:  225
================================================
Abc started on Thu Jun 24 09:41:43 BST 2004
<<<< LocalInners2.java >>>>
public class LocalInners2 {
    public static void main(final java.lang.String[] args) {
        class Local {
            class Inner0 extends Local {
                public Inner0() { super(); }
            }
            
            
            class Inner1 extends Local {
                int arglen = args/*null*/.length;
                
                public Inner1() { super(); }
            }
            
            
            public Local() { super(); }
        }
        ;
        new Local().new Inner0();
        new Local().new Inner1();
        foo(new Local().new Inner1()/*<unknown>*/.arglen);
    }
    
    static void foo(int i) {  }
    
    public LocalInners2() { super(); }
}
retrieve <LocalInners2: void main(java.lang.String[])> from LocalInners2
retrieve <LocalInners2: void foo(int)> from LocalInners2
retrieve <LocalInners2: void <init>()> from LocalInners2
retrieve <LocalInners2$1Local: void <init>(java.lang.String[])> from LocalInners2$1Local
retrieve <LocalInners2$1Local$Inner0: void <init>(LocalInners2$1Local)> from LocalInners2$1Local$Inner0
retrieve <LocalInners2$1Local$Inner1: void <init>(LocalInners2$1Local)> from LocalInners2$1Local$Inner1
retrieve <LocalInners2$1Local: java.lang.String[] access$000(LocalInners2$1Local)> from LocalInners2$1Local
retrieve <LocalInners2$1Local: java.lang.String[] access$100(LocalInners2$1Local)> from LocalInners2$1Local
retrieve <LocalInners2$1Local: void <init>(java.lang.String[])> from LocalInners2$1Local
retrieve <LocalInners2$1Local: java.lang.String[] access$200(LocalInners2$1Local)> from LocalInners2$1Local
retrieve <LocalInners2$1Local$Inner0: void <init>(LocalInners2$1Local)> from LocalInners2$1Local$Inner0
retrieve <LocalInners2$1Local$Inner1: void <init>(LocalInners2$1Local)> from LocalInners2$1Local$Inner1
Transforming LocalInners2... 
Transforming LocalInners2$1Local... 
Transforming LocalInners2$1Local$Inner0... 
Transforming LocalInners2$1Local$Inner1... 
Abc finished on Thu Jun 24 09:41:50 BST 2004. ( 0 min. 6 sec. )
PASS: Locals inside other locals, ordering of processing [eh]()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 271 failed (check: 100), 364 passed (check: 87), 2 skipped.
Executing test 638 (pureJava): subclass access to enclosing super class private members
================================================
Breakdown of abc phases  (total: 10358 millisec.)
------------------------------------------------
[ 00.348% ] Init. of Soot:  36
[ 00.039% ] Loading Jars:  4
[ 57.550% ] Polyglot phases:  5961
[ 00.000% ] Resolve class names:  0
[ 00.019% ] Declare Parents:  2
[ 00.502% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.396% ] Intertype Adjuster:  41
[ 07.048% ] Retrieving bodies:  730
[ 00.000% ] Weave Initializers:  0
[ 00.212% ] Load shadow types:  22
[ 24.387% ] Compute advice lists:  2526
[ 00.029% ] Intertype weave:  3
[ 00.077% ] Add aspect code:  8
[ 00.154% ] Weaving advice:  16
[ 00.000% ] Validate jimple:  0
[ 04.818% ] Soot Packs:  499
[ 04.422% ] Soot Writing Output:  458
================================================
Abc started on Thu Jun 24 09:41:53 BST 2004
<<<< SubclassAccessToEnclosingSuperClassPrivate.java >>>>
import org.aspectj.testing.Tester;

public class SubclassAccessToEnclosingSuperClassPrivate {
    public static void main(java.lang.String[] args) {
        java.lang.ClassLoader loader = Expect.class.getClassLoader();
        new SuperEnclosing.SubNested().doit();
        new SuperEnclosing.SubNested.SubSubNested().doit();
        new SuperEnclosing.SubNested.SubSubNestedNoExtends().doit();
        SuperEnclosing me = new SuperEnclosing();
        me.new SubInner("main").doit();
        me.runSubInner();
        me.runMethodLocalInnerSubclass();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public SubclassAccessToEnclosingSuperClassPrivate() { super(); }
}
class SuperEnclosing {
    private static int staticPrivateInt = 42;
    
    private int privateInt = 84;
    
    private static void staticPrivateMethod(java.lang.String caller) {
        org.aspectj.testing.Tester.event(caller +
                                         " -> SuperEnclosing.staticPrivateMethod()");
    }
    
    private void privateMethod(java.lang.String caller) {
        org.aspectj.testing.Tester.event(caller +
                                         " -> SuperEnclosing.privateMethod()");
    }
    
    static class SubNested extends SuperEnclosing {
        static void doit() {
            java.lang.String label = "SubNested.run()";
            label =
              label + "(" +
              SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
              ")";
            org.aspectj.testing.Tester.event(label);
            staticPrivateMethod(label);
        }
        
        static class SubSubNestedNoExtends {
            static void doit() {
                java.lang.String label =
                  "SubSubNestedNoExtends.run()";
                label =
                  label + "(" +
                  SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
                  ")";
                org.aspectj.testing.Tester.event(label);
                staticPrivateMethod(label);
            }
            
            public SubSubNestedNoExtends() { super(); }
        }
        
        
        static class SubSubNested extends SuperEnclosing {
            static void doit() {
                java.lang.String label =
                  "SubSubNestedNoExtends.run()";
                label =
                  label + "(" +
                  SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
                  ")";
                org.aspectj.testing.Tester.event(label);
                staticPrivateMethod(label);
            }
            
            public SubSubNested() { super(); }
        }
        
        
        public SubNested() { super(); }
    }
    
    
    void runSubInner() {
        this.new SuperEnclosing.SubInner("Constructed in SuperEnclosing.run()").doit();
    }
    
    void runMethodLocalInnerSubclass() {
        new SuperEnclosing() {
            void doit() {
                String label =
                  ("runMethodLocalInnerSubclass anonymous SuperEnclosing subclas" +
                   "s");
                label =
                  label + "(" + staticPrivateInt + ", " + privateInt +
                  ")";
                Tester.event(label);
                privateMethod(label);
                staticPrivateMethod(label);
            }
        }.doit();
        new SuperEnclosing() {
            void doit() {
                new SuperEnclosing() {
                    void doit() {
                        String label =
                          ("runMethodLocalInnerSubclass anonymous SuperEnclosing (inner)" +
                           " subclass");
                        label =
                          label + "(" + staticPrivateInt + ", " +
                          privateInt +
                          ")";
                        Tester.event(label);
                        privateMethod(label);
                        staticPrivateMethod(label);
                    }
                }.doit();
            }
        }.doit();
    }
    
    class SubInner extends SuperEnclosing {
        java.lang.String name;
        
        SubInner(java.lang.String name) {
            super();
            this/*<unknown>*/.name = name;
        }
        
        void doit() {
            java.lang.String label =
              "SubInner=\"" + this/*null*/.name +
            "\".run() ";
            label =
              label + "(" +
              SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
              ", " +
              this/*null*/.privateInt +
              ")";
            org.aspectj.testing.Tester.event(label);
            privateMethod(label);
            staticPrivateMethod(label);
        }
        
        class SubSubInnerNoExtends {
            void doit() {
                java.lang.String label = "SubSubInnerNoExtends.run()";
                label =
                  label + "(" +
                  SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
                  ", " +
                  SuperEnclosing.SubInner.this/*null*/.privateInt +
                  ")";
                org.aspectj.testing.Tester.event(label);
                staticPrivateMethod(label);
                privateMethod(label);
            }
            
            public SubSubInnerNoExtends() { super(); }
        }
        
        
        class SubSubInner extends SuperEnclosing {
            void doit() {
                java.lang.String label = "SubSubInnerNoExtends.run()";
                label =
                  label + "(" +
                  SuperEnclosing/*SuperEnclosing*/.staticPrivateInt +
                  ", " +
                  this/*null*/.privateInt +
                  ")";
                org.aspectj.testing.Tester.event(label);
                staticPrivateMethod(label);
                privateMethod(label);
            }
            
            public SubSubInner() { super(); }
        }
        
    }
    
    
    public SuperEnclosing() { super(); }
}
class Expect {
    static {
               org.aspectj.testing.Tester.expectEvent("SubNested.run()(42)");
               org.aspectj.testing.Tester.expectEvent("SubNested.run()(42) -> SuperEnclosing.staticPrivateMethod()");
               org.aspectj.testing.Tester.expectEvent("SubSubNestedNoExtends.run()(42)");
               org.aspectj.testing.Tester.expectEvent(("SubSubNestedNoExtends.run()(42) -> SuperEnclosing.staticPriv" +
                                                       "ateMethod()"));
               org.aspectj.testing.Tester.expectEvent("SubSubNestedNoExtends.run()(42)");
               org.aspectj.testing.Tester.expectEvent(("SubSubNestedNoExtends.run()(42) -> SuperEnclosing.staticPriv" +
                                                       "ateMethod()"));
               org.aspectj.testing.Tester.expectEvent("SubInner=\"main\".run() (42, 84)");
               org.aspectj.testing.Tester.expectEvent(("SubInner=\"main\".run() (42, 84) -> SuperEnclosing.privateMe" +
                                                       "thod()"));
               org.aspectj.testing.Tester.expectEvent(("SubInner=\"main\".run() (42, 84) -> SuperEnclosing.staticPri" +
                                                       "vateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("SubInner=\"Constructed in SuperEnclosing.run()\".run() (42, " +
                                                       "84)"));
               org.aspectj.testing.Tester.expectEvent(("SubInner=\"Constructed in SuperEnclosing.run()\".run() (42, " +
                                                       "84) -> SuperEnclosing.privateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("SubInner=\"Constructed in SuperEnclosing.run()\".run() (42, " +
                                                       "84) -> SuperEnclosing.staticPrivateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing subclas" +
                                                       "s(42, 84)"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing subclas" +
                                                       "s(42, 84) -> SuperEnclosing.privateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing subclas" +
                                                       "s(42, 84) -> SuperEnclosing.staticPrivateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing (inner)" +
                                                       " subclass(42, 84)"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing (inner)" +
                                                       " subclass(42, 84) -> SuperEnclosing.privateMethod()"));
               org.aspectj.testing.Tester.expectEvent(("runMethodLocalInnerSubclass anonymous SuperEnclosing (inner)" +
                                                       " subclass(42, 84) -> SuperEnclosing.staticPrivateMethod()"));
           }
    
    public Expect() { super(); }
}
retrieve <SubclassAccessToEnclosingSuperClassPrivate: java.lang.Class class$(java.lang.String)> from SubclassAccessToEnclosingSuperClassPrivate
retrieve <SubclassAccessToEnclosingSuperClassPrivate: void main(java.lang.String[])> from SubclassAccessToEnclosingSuperClassPrivate
retrieve <SubclassAccessToEnclosingSuperClassPrivate: void <init>()> from SubclassAccessToEnclosingSuperClassPrivate
retrieve <SuperEnclosing: void <init>()> from SuperEnclosing
retrieve <SuperEnclosing: void staticPrivateMethod(java.lang.String)> from SuperEnclosing
retrieve <SuperEnclosing: void privateMethod(java.lang.String)> from SuperEnclosing
retrieve <SuperEnclosing: void runSubInner()> from SuperEnclosing
retrieve <SuperEnclosing: void runMethodLocalInnerSubclass()> from SuperEnclosing
retrieve <SuperEnclosing: int access$000()> from SuperEnclosing
retrieve <SuperEnclosing: void access$100(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$200()> from SuperEnclosing
retrieve <SuperEnclosing: void access$300(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$400()> from SuperEnclosing
retrieve <SuperEnclosing: void access$500(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$600()> from SuperEnclosing
retrieve <SuperEnclosing: void access$700(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$800()> from SuperEnclosing
retrieve <SuperEnclosing: void access$900(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$1000()> from SuperEnclosing
retrieve <SuperEnclosing: int access$1100(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$1200(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$1300(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$1400()> from SuperEnclosing
retrieve <SuperEnclosing: int access$1500(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$1600(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$1700(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$1800()> from SuperEnclosing
retrieve <SuperEnclosing: int access$1900(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$2000(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$2100(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$2200()> from SuperEnclosing
retrieve <SuperEnclosing: int access$2300(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$2400(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$2500(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$2600()> from SuperEnclosing
retrieve <SuperEnclosing: int access$2700(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$2800(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$2900(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$3000()> from SuperEnclosing
retrieve <SuperEnclosing: int access$3100(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$3200(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$3300(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$3400()> from SuperEnclosing
retrieve <SuperEnclosing: int access$3500(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$3600(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$3700(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: int access$3800()> from SuperEnclosing
retrieve <SuperEnclosing: int access$3900(SuperEnclosing)> from SuperEnclosing
retrieve <SuperEnclosing: void access$4000(java.lang.String)> from SuperEnclosing
next paramType: java.lang.String
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void access$4100(java.lang.String,SuperEnclosing)> from SuperEnclosing
next paramType: java.lang.String
next paramType: SuperEnclosing
meth param types: [java.lang.String]
retrieve <SuperEnclosing: void <clinit>()> from SuperEnclosing
retrieve <SuperEnclosing$SubNested: void doit()> from SuperEnclosing$SubNested
retrieve <SuperEnclosing$SubNested: void <init>()> from SuperEnclosing$SubNested
retrieve <SuperEnclosing$SubNested$SubSubNestedNoExtends: void doit()> from SuperEnclosing$SubNested$SubSubNestedNoExtends
retrieve <SuperEnclosing$SubNested$SubSubNestedNoExtends: void <init>()> from SuperEnclosing$SubNested$SubSubNestedNoExtends
retrieve <SuperEnclosing$SubNested$SubSubNested: void doit()> from SuperEnclosing$SubNested$SubSubNested
retrieve <SuperEnclosing$SubNested$SubSubNested: void <init>()> from SuperEnclosing$SubNested$SubSubNested
retrieve <SuperEnclosing$2: void <init>(SuperEnclosing)> from SuperEnclosing$2
retrieve <SuperEnclosing$2: void doit()> from SuperEnclosing$2
retrieve <SuperEnclosing$1: void <init>(SuperEnclosing)> from SuperEnclosing$1
retrieve <SuperEnclosing$1: void doit()> from SuperEnclosing$1
retrieve <SuperEnclosing$3: void <init>(SuperEnclosing$1)> from SuperEnclosing$3
retrieve <SuperEnclosing$3: void doit()> from SuperEnclosing$3
retrieve <SuperEnclosing$SubInner: void doit()> from SuperEnclosing$SubInner
retrieve <SuperEnclosing$SubInner: void <init>(SuperEnclosing,java.lang.String)> from SuperEnclosing$SubInner
retrieve <SuperEnclosing$SubInner$SubSubInnerNoExtends: void doit()> from SuperEnclosing$SubInner$SubSubInnerNoExtends
retrieve <SuperEnclosing$SubInner$SubSubInnerNoExtends: void <init>(SuperEnclosing$SubInner)> from SuperEnclosing$SubInner$SubSubInnerNoExtends
retrieve <SuperEnclosing$SubInner$SubSubInner: void doit()> from SuperEnclosing$SubInner$SubSubInner
retrieve <SuperEnclosing$SubInner$SubSubInner: void <init>(SuperEnclosing$SubInner)> from SuperEnclosing$SubInner$SubSubInner
retrieve <Expect: void <clinit>()> from Expect
retrieve <Expect: void <init>()> from Expect
retrieve <SuperEnclosing$3: void <init>(SuperEnclosing$1)> from SuperEnclosing$3
retrieve <SuperEnclosing$3: void doit()> from SuperEnclosing$3
Transforming SubclassAccessToEnclosingSuperClassPrivate... 
Transforming SuperEnclosing... 
Transforming SuperEnclosing$1... 
Transforming SuperEnclosing$SubNested... 
Transforming SuperEnclosing$SubNested$SubSubNested... 
Transforming SuperEnclosing$2... 
Transforming SuperEnclosing$SubInner... 
Transforming SuperEnclosing$SubInner$SubSubInnerNoExtends... 
Transforming SuperEnclosing$3... 
Transforming SuperEnclosing$SubInner$SubSubInner... 
Transforming SuperEnclosing$SubNested$SubSubNestedNoExtends... 
Transforming Expect... 
Abc finished on Thu Jun 24 09:42:03 BST 2004. ( 0 min. 10 sec. )
PASS: subclass access to enclosing super class private members()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 11 seconds
Passed. Current status: 271 failed (check: 100), 365 passed (check: 87), 2 skipped.
Executing test 639 (new/nolang): Compiling java.lang.Object with ajc yields non-verifying bytecode
Failed. Current status: 272 failed (check: 100), 365 passed (check: 87), 2 skipped.
Executing test 640 (new): method-local class defined in around return statement
================================================
Breakdown of abc phases  (total: 7325 millisec.)
------------------------------------------------
[ 00.505% ] Init. of Soot:  37
[ 00.055% ] Loading Jars:  4
[ 72.887% ] Polyglot phases:  5339
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.710% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.505% ] Intertype Adjuster:  37
[ 07.085% ] Retrieving bodies:  519
[ 00.000% ] Weave Initializers:  0
[ 00.314% ] Load shadow types:  23
[ 03.044% ] Compute advice lists:  223
[ 00.041% ] Intertype weave:  3
[ 00.300% ] Add aspect code:  22
[ 01.010% ] Weaving advice:  74
[ 00.000% ] Validate jimple:  0
[ 10.007% ] Soot Packs:  733
[ 03.481% ] Soot Writing Output:  255
================================================
Abc started on Thu Jun 24 09:42:13 BST 2004
<<<< MethodLocalAroundReturns.java >>>>
import org.aspectj.testing.Tester;

public class MethodLocalAroundReturns {
    public static void main(java.lang.String[] args) {
        C c = C.make();
        org.aspectj.testing.Tester.check(null != c, "null c");
        org.aspectj.testing.Tester.check("ok".equals(c.toString()),
                                         "bad c: " +
                                         c);
    }
    
    public MethodLocalAroundReturns() { super(); }
}
class C {
    static C make() { return null; }
    
    public C() { super(); }
}
aspect A {
    C around ():
    call(C (C).make()) {
        return new C() {
            public String toString() { return "ok"; }
        };
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <MethodLocalAroundReturns: void <init>()> from MethodLocalAroundReturns
retrieve <MethodLocalAroundReturns: void main(java.lang.String[])> from MethodLocalAroundReturns
retrieve <C: C make()> from C
retrieve <C: void <init>()> from C
retrieve <A: C around$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: C proceed$1()> from A
retrieve <A$1: java.lang.String toString()> from A$1
retrieve <A$1: void <init>(A)> from A$1
Transforming A... 
Transforming MethodLocalAroundReturns... 
Transforming A$1... 
Transforming C... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 09:42:21 BST 2004. ( 0 min. 7 sec. )
PASS: method-local class defined in around return statement()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 272 failed (check: 100), 366 passed (check: 87), 2 skipped.
Executing test 641 (new): CE expected for assignment to arg in if pcd
================================================
Breakdown of abc phases  (total: 6482 millisec.)
------------------------------------------------
[ 00.540% ] Init. of Soot:  35
[ 00.046% ] Loading Jars:  3
[ 79.219% ] Polyglot phases:  5135
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.771% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.571% ] Intertype Adjuster:  37
[ 07.405% ] Retrieving bodies:  480
[ 00.000% ] Weave Initializers:  0
[ 00.339% ] Load shadow types:  22
[ 01.820% ] Compute advice lists:  118
[ 00.031% ] Intertype weave:  2
[ 00.571% ] Add aspect code:  37
[ 00.540% ] Weaving advice:  35
[ 00.000% ] Validate jimple:  0
[ 04.566% ] Soot Packs:  296
[ 03.517% ] Soot Writing Output:  228
================================================
Failed. Current status: 273 failed (check: 101), 366 passed (check: 87), 2 skipped.
Executing test 642 (new): advising field get/sets when accessing via super
================================================
Breakdown of abc phases  (total: 8061 millisec.)
------------------------------------------------
[ 00.459% ] Init. of Soot:  37
[ 00.037% ] Loading Jars:  3
[ 70.748% ] Polyglot phases:  5703
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.459% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 00.707% ] Intertype Adjuster:  57
[ 06.587% ] Retrieving bodies:  531
[ 00.000% ] Weave Initializers:  0
[ 00.285% ] Load shadow types:  23
[ 11.587% ] Compute advice lists:  934
[ 00.037% ] Intertype weave:  3
[ 00.496% ] Add aspect code:  40
[ 00.409% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 04.689% ] Soot Packs:  378
[ 03.449% ] Soot Writing Output:  278
================================================
Abc started on Thu Jun 24 09:42:32 BST 2004
<<<< SuperField.java >>>>
import org.aspectj.testing.Tester;

public class SuperField {
    public static void main(java.lang.String[] args) {
        Derived d = new Derived();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "set Base on <Derived>", "set Derived on <Derived>" });
        d.m1();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "get Derived on <Derived>", "Derived" });
        d.m2();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "get Derived on <Derived>", "Derived" });
        d.m3();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "get Base on <Derived>", "Base" });
        d.m4();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "get Base on <Derived>", "set BaseNew on <Derived>", "get BaseNew on <Derived>", "BaseNew" });
        org.aspectj.testing.Tester.printEvents();
    }
    
    public SuperField() { super(); }
}
class Base {
    java.lang.String s = "Base";
    
    public java.lang.String toString() { return "<Base>"; }
    
    public Base() { super(); }
}
class Derived extends Base {
    java.lang.String s = "Derived";
    
    void m1() { org.aspectj.testing.Tester.event(this/*null*/.s); }
    
    void m2() {
        org.aspectj.testing.Tester.event(this/*<unknown>*/.s);
    }
    
    void m3() {
        org.aspectj.testing.Tester.event(super/*<unknown>*/.s);
    }
    
    void m4() {
        super/*<unknown>*/.s += "New";
        org.aspectj.testing.Tester.event(super/*<unknown>*/.s);
    }
    
    public java.lang.String toString() { return "<Derived>"; }
    
    public Derived() { super(); }
}
aspect A {
    after(Object o) returning(String v):
    target(o) &&
      get( String (*).s) {
        org.aspectj.testing.Tester.event("get " + v + " on " + o);
    }
    
    before(Object o, String v):
    target(o) && set( String (*).s) &&
      args(v) {
        org.aspectj.testing.Tester.event("set " + v + " on " + o);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <SuperField: void main(java.lang.String[])> from SuperField
retrieve <SuperField: void <init>()> from SuperField
retrieve <Base: java.lang.String toString()> from Base
retrieve <Base: void <init>()> from Base
retrieve <Derived: void m1()> from Derived
retrieve <Derived: void m2()> from Derived
retrieve <Derived: void m3()> from Derived
retrieve <Derived: void m4()> from Derived
retrieve <Derived: java.lang.String toString()> from Derived
retrieve <Derived: void <init>()> from Derived
retrieve <A: void afterReturning$0(java.lang.Object,java.lang.String)> from A
retrieve <A: void before$1(java.lang.Object,java.lang.String)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming Derived... 
Transforming A... 
Transforming Base... 
Transforming SuperField... 
Abc finished on Thu Jun 24 09:42:41 BST 2004. ( 0 min. 8 sec. )
PASS: advising field get/sets when accessing via super()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 273 failed (check: 101), 367 passed (check: 87), 2 skipped.
Executing test 643 (new): accessing private members in outer types
================================================
Breakdown of abc phases  (total: 7485 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  36
[ 00.053% ] Loading Jars:  4
[ 72.572% ] Polyglot phases:  5432
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.588% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.494% ] Intertype Adjuster:  37
[ 07.081% ] Retrieving bodies:  530
[ 00.000% ] Weave Initializers:  0
[ 00.294% ] Load shadow types:  22
[ 05.478% ] Compute advice lists:  410
[ 00.040% ] Intertype weave:  3
[ 00.107% ] Add aspect code:  8
[ 00.187% ] Weaving advice:  14
[ 00.000% ] Validate jimple:  0
[ 09.245% ] Soot Packs:  692
[ 03.353% ] Soot Writing Output:  251
================================================
Abc started on Thu Jun 24 09:42:43 BST 2004
<<<< FieldInnerAccess.java >>>>
import org.aspectj.testing.Tester;

public class FieldInnerAccess {
    public static void main(java.lang.String[] args) {
        Derived d = new Derived();
        d.m();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "lock: 1" });
        d.mi();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "lock: 1" });
        d.mib();
        org.aspectj.testing.Tester.checkAndClearEvents(new java.lang.String[] { "lock: foo" });
    }
    
    public FieldInnerAccess() { super(); }
}
class Base {
    private static java.lang.String lock = "foo";
    
    public void mib() {
        java.lang.Runnable r =
          new java.lang.Runnable() {
            public void run() { Tester.event("lock: " + lock); }
        };
        r.run();
    }
    
    public Base() { super(); }
}
class Derived extends Base {
    private static java.lang.Object lock = new java.lang.Integer(1);
    
    public void m() {
        org.aspectj.testing.Tester.event("lock: " +
                                         Derived/*Derived*/.lock);
    }
    
    public void mi() {
        java.lang.Runnable r =
          new java.lang.Runnable() {
            public void run() { Tester.event("lock: " + lock); }
        };
        r.run();
    }
    
    public Derived() { super(); }
}
retrieve <FieldInnerAccess: void <init>()> from FieldInnerAccess
retrieve <FieldInnerAccess: void main(java.lang.String[])> from FieldInnerAccess
retrieve <Base: void mib()> from Base
retrieve <Base: java.lang.String access$100()> from Base
retrieve <Base: void <init>()> from Base
retrieve <Base: void <clinit>()> from Base
retrieve <Base$1: void <init>(Base)> from Base$1
retrieve <Base$1: void run()> from Base$1
retrieve <Derived: void m()> from Derived
retrieve <Derived: void mi()> from Derived
retrieve <Derived: void <init>()> from Derived
retrieve <Derived: java.lang.Object access$000()> from Derived
retrieve <Derived: void <clinit>()> from Derived
retrieve <Derived$1: void <init>(Derived)> from Derived$1
retrieve <Derived$1: void run()> from Derived$1
Transforming Derived... 
Transforming FieldInnerAccess... 
Transforming Derived$1... 
Transforming Base... 
Transforming Base$1... 
Abc finished on Thu Jun 24 09:42:51 BST 2004. ( 0 min. 7 sec. )
PASS: accessing private members in outer types()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 273 failed (check: 101), 368 passed (check: 87), 2 skipped.
Executing test 644 (pureJava): various tests of switch bounds
================================================
Breakdown of abc phases  (total: 7636 millisec.)
------------------------------------------------
[ 00.485% ] Init. of Soot:  37
[ 00.052% ] Loading Jars:  4
[ 73.324% ] Polyglot phases:  5599
[ 00.000% ] Resolve class names:  0
[ 00.026% ] Declare Parents:  2
[ 00.589% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 05.605% ] Intertype Adjuster:  428
[ 06.993% ] Retrieving bodies:  534
[ 00.000% ] Weave Initializers:  0
[ 00.288% ] Load shadow types:  22
[ 06.351% ] Compute advice lists:  485
[ 00.039% ] Intertype weave:  3
[ 00.118% ] Add aspect code:  9
[ 00.157% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.274% ] Soot Packs:  250
[ 02.698% ] Soot Writing Output:  206
================================================
Abc started on Thu Jun 24 09:42:53 BST 2004
<<<< SwitchBounds.java >>>>
import org.aspectj.testing.Tester;

public class SwitchBounds {
    static int minZero(int key) {
        switch (key) {
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE;
            case 0:
                return 0;
            default:
                return key;
        }
    }
    
    static int maxZero(int key) {
        switch (key) {
            case java.lang.Integer/*java.lang.Integer*/.MAX_VALUE:
                return java.lang.Integer/*java.lang.Integer*/.MAX_VALUE;
            case 0:
                return 0;
            default:
                return key;
        }
    }
    
    static int minMax(int key) {
        switch (key) {
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE;
            case java.lang.Integer/*java.lang.Integer*/.MAX_VALUE:
                return java.lang.Integer/*java.lang.Integer*/.MAX_VALUE;
            default:
                return key;
        }
    }
    
    static int fiveMins(int key) {
        switch (key) {
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE;
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE + 1:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE +
                1;
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE + 2:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE +
                2;
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE + 3:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE +
                3;
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE + 4:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE +
                4;
            case java.lang.Integer/*java.lang.Integer*/.MIN_VALUE + 5:
                return java.lang.Integer/*java.lang.Integer*/.MIN_VALUE +
                5;
            default:
                return key;
        }
    }
    
    public static void main(java.lang.String[] args) {
        int MIN = java.lang.Integer/*java.lang.Integer*/.MIN_VALUE;
        int MAX = java.lang.Integer/*java.lang.Integer*/.MAX_VALUE;
        org.aspectj.testing.Tester.checkEqual(MIN, minZero(MIN));
        org.aspectj.testing.Tester.checkEqual(0, minZero(0));
        org.aspectj.testing.Tester.checkEqual(37, minZero(37));
        org.aspectj.testing.Tester.checkEqual(MAX, maxZero(MAX));
        org.aspectj.testing.Tester.checkEqual(0, maxZero(0));
        org.aspectj.testing.Tester.checkEqual(37, maxZero(37));
        org.aspectj.testing.Tester.checkEqual(MIN, minMax(MIN));
        org.aspectj.testing.Tester.checkEqual(MAX, minMax(MAX));
        org.aspectj.testing.Tester.checkEqual(37, minMax(37));
        org.aspectj.testing.Tester.checkEqual(MIN, fiveMins(MIN));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              1,
                                              fiveMins(MIN + 1));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              2,
                                              fiveMins(MIN + 2));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              3,
                                              fiveMins(MIN + 3));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              4,
                                              fiveMins(MIN + 4));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              5,
                                              fiveMins(MIN + 5));
        org.aspectj.testing.Tester.checkEqual(MIN +
                                              37,
                                              fiveMins(MIN + 37));
    }
    
    public SwitchBounds() { super(); }
}
retrieve <SwitchBounds: int minZero(int)> from SwitchBounds
retrieve <SwitchBounds: int maxZero(int)> from SwitchBounds
retrieve <SwitchBounds: int minMax(int)> from SwitchBounds
retrieve <SwitchBounds: int fiveMins(int)> from SwitchBounds
retrieve <SwitchBounds: void main(java.lang.String[])> from SwitchBounds
retrieve <SwitchBounds: void <init>()> from SwitchBounds
Transforming SwitchBounds... 
Abc finished on Thu Jun 24 09:43:01 BST 2004. ( 0 min. 7 sec. )
PASS: various tests of switch bounds()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 273 failed (check: 101), 369 passed (check: 87), 2 skipped.
Executing test 645 (new): VerifyError if nested sync returning result
================================================
Breakdown of abc phases  (total: 7494 millisec.)
------------------------------------------------
[ 00.480% ] Init. of Soot:  36
[ 00.053% ] Loading Jars:  4
[ 76.007% ] Polyglot phases:  5696
[ 00.013% ] Resolve class names:  1
[ 00.027% ] Declare Parents:  2
[ 00.587% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.507% ] Intertype Adjuster:  38
[ 09.728% ] Retrieving bodies:  729
[ 00.000% ] Weave Initializers:  0
[ 00.294% ] Load shadow types:  22
[ 04.924% ] Compute advice lists:  369
[ 00.040% ] Intertype weave:  3
[ 00.107% ] Add aspect code:  8
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.630% ] Soot Packs:  272
[ 03.429% ] Soot Writing Output:  257
================================================
Abc started on Thu Jun 24 09:43:03 BST 2004
<<<< NestedSyncWithResult.java >>>>
import org.aspectj.testing.Tester;

public class NestedSyncWithResult {
    public static boolean holdA;
    
    public static boolean aWaiterDone;
    
    public static boolean aHolderDone;
    
    public static void main(java.lang.String[] args) {
        int result = Bug.bug();
        org.aspectj.testing.Tester.check(0 == result, "0 == result");
        checkSynchronization();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void checkSynchronization() {
        final java.lang.StringBuffer sb =
          new java.lang.StringBuffer();
        org.aspectj.testing.Tester.expectEvent("holding A; releasing A; invoked bug; ");
        final boolean[] holdAstarted = new boolean[] { false };
        NestedSyncWithResult/*NestedSyncWithResult*/.holdA = true;
        java.lang.Runnable aHolder =
          new java.lang.Runnable() {
            public void run() {
                boolean wroteWait = false;
                synchronized (Bug/*<unknown>*/.lockB)  {
                    holdAstarted[0] = true;
                    while (holdA) {
                        if (!wroteWait) {
                            wroteWait = true;
                            sb.append("holding A; ");
                        }
                        sleep();
                    }
                    sb.append("releasing A; ");
                }
                aHolderDone = true;
            }
        };
        java.lang.Runnable aWaiter =
          new java.lang.Runnable() {
            public void run() {
                while (!holdAstarted[0]) { sleep(); }
                Bug.bug();
                sb.append("invoked bug; ");
                aWaiterDone = true;
            }
        };
        new java.lang.Thread(aHolder).start();
        new java.lang.Thread(aWaiter).start();
        sleep();
        NestedSyncWithResult/*NestedSyncWithResult*/.holdA = false;
        while (!NestedSyncWithResult/*NestedSyncWithResult*/.aWaiterDone &&
               !NestedSyncWithResult/*NestedSyncWithResult*/.aHolderDone) {
            sleep();
        }
        org.aspectj.testing.Tester.event(sb.toString());
    }
    
    public static void sleep() {
        try {
            java.lang.Thread.currentThread().sleep(300);
        }
        catch (java.lang.InterruptedException e) {  }
    }
    
    public NestedSyncWithResult() { super(); }
}
class Bug {
    public static java.lang.Object lockA = new java.lang.Object();
    
    public static java.lang.Object lockB = new java.lang.Object();
    
    static int bug() {
        synchronized (Bug/*Bug*/.lockA)  {
            synchronized (Bug/*Bug*/.lockB)  { return 0; }
        }
    }
    
    public Bug() { super(); }
}
retrieve <NestedSyncWithResult: void main(java.lang.String[])> from NestedSyncWithResult
retrieve <NestedSyncWithResult: void checkSynchronization()> from NestedSyncWithResult
retrieve <NestedSyncWithResult: void sleep()> from NestedSyncWithResult
retrieve <NestedSyncWithResult: void <init>()> from NestedSyncWithResult
retrieve <NestedSyncWithResult$2: void run()> from NestedSyncWithResult$2
retrieve <NestedSyncWithResult$2: void <init>(boolean[],java.lang.StringBuffer)> from NestedSyncWithResult$2
retrieve <NestedSyncWithResult$1: void run()> from NestedSyncWithResult$1
retrieve <NestedSyncWithResult$1: void <init>(boolean[],java.lang.StringBuffer)> from NestedSyncWithResult$1
retrieve <Bug: int bug()> from Bug
retrieve <Bug: void <init>()> from Bug
retrieve <Bug: void <clinit>()> from Bug
Transforming NestedSyncWithResult... 
Transforming Bug... 
Transforming NestedSyncWithResult$1... 
Transforming NestedSyncWithResult$2... 
Abc finished on Thu Jun 24 09:43:11 BST 2004. ( 0 min. 7 sec. )
PASS: VerifyError if nested sync returning result()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 273 failed (check: 101), 370 passed (check: 87), 2 skipped.
Executing test 646 (new): declare interface extends class
================================================
Breakdown of abc phases  (total: 6511 millisec.)
------------------------------------------------
[ 00.538% ] Init. of Soot:  35
[ 00.061% ] Loading Jars:  4
[ 76.839% ] Polyglot phases:  5003
[ 00.046% ] Resolve class names:  3
[ 00.046% ] Declare Parents:  3
[ 00.737% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 06.113% ] Intertype Adjuster:  398
[ 06.466% ] Retrieving bodies:  421
[ 00.000% ] Weave Initializers:  0
[ 00.338% ] Load shadow types:  22
[ 00.630% ] Compute advice lists:  41
[ 00.061% ] Intertype weave:  4
[ 00.783% ] Add aspect code:  51
[ 00.200% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.916% ] Soot Packs:  255
[ 03.225% ] Soot Writing Output:  210
================================================
Failed. Current status: 274 failed (check: 102), 370 passed (check: 87), 2 skipped.
Executing test 647 (new): declare interface implements class
Abc started on Thu Jun 24 09:43:23 BST 2004
PASS: declare interface implements class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 274 failed (check: 102), 371 passed (check: 88), 2 skipped.
Executing test 648 (pureJava): assert flow
Failed. Current status: 275 failed (check: 103), 371 passed (check: 88), 2 skipped.
Executing test 649 (pureJava): assert flow - 2
Failed. Current status: 276 failed (check: 104), 371 passed (check: 88), 2 skipped.
Executing test 650 (pureJava): assert typing
Failed. Current status: 277 failed (check: 105), 371 passed (check: 88), 2 skipped.
Executing test 651 (pureJava): asserts
Failed. Current status: 278 failed (check: 105), 371 passed (check: 88), 2 skipped.
Executing test 652 (pureJava): assert coverage tests [requires 1.4]
Failed. Current status: 279 failed (check: 105), 371 passed (check: 88), 2 skipped.
Executing test 653 (pureJava): assert coverage tests in one package [requires 1.4]
Failed. Current status: 280 failed (check: 105), 371 passed (check: 88), 2 skipped.
Executing test 654 (new): assert tests in introduction [requires 1.4]
Failed. Current status: 281 failed (check: 105), 371 passed (check: 88), 2 skipped.
Executing test 655 (pureJava): compiling asserts in methods
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(3 options 1 paths)" because old ajc 1.0 option: usejavac
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 281 failed (check: 105), 371 passed (check: 88), 3 skipped.
Executing test 656 (pureJava): asserts in aspect and declared methods [requires 1.4]
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(3 options 1 paths)" because old ajc 1.0 option: usejavac
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 281 failed (check: 105), 371 passed (check: 88), 4 skipped.
Executing test 657 (design/around): around and return types + inlining optimizations
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(3 options 2 paths 1 messages)" because old ajc 1.0 option: XOcodeSize
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 281 failed (check: 105), 371 passed (check: 88), 5 skipped.
Executing test 658 (base/test131): various forms of package name pattern matching work
================================================
Breakdown of abc phases  (total: 7734 millisec.)
------------------------------------------------
[ 00.465% ] Init. of Soot:  36
[ 00.039% ] Loading Jars:  3
[ 72.071% ] Polyglot phases:  5574
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.659% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.478% ] Intertype Adjuster:  37
[ 06.775% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.284% ] Load shadow types:  22
[ 02.715% ] Compute advice lists:  210
[ 00.039% ] Intertype weave:  3
[ 00.569% ] Add aspect code:  44
[ 01.241% ] Weaving advice:  96
[ 00.000% ] Validate jimple:  0
[ 10.590% ] Soot Packs:  819
[ 04.021% ] Soot Writing Output:  311
================================================
Abc started on Thu Jun 24 09:43:48 BST 2004
<<<< Driver.java >>>>
import org.aspectj.testing.Tester;
import p1.C1;
import p1.p2.C2;

public class Driver {
    public static void test() {
        Top t = new Top();
        p1.C1 c1 = new p1.C1();
        p1.p2.C2 c2 = new p1.p2.C2();
        org.aspectj.testing.Tester.checkEqual(t.bar(),
                                              11,
                                              "top.bar()");
        org.aspectj.testing.Tester.checkEqual(c1.bar(),
                                              1111,
                                              "c1.bar()");
        org.aspectj.testing.Tester.checkEqual(c2.bar(),
                                              1011,
                                              "c2.bar()");
    }
    
    public static void main(java.lang.String[] args) { test(); }
    
    public Driver() { super(); }
}
class Top {
    public int bar() { return 1; }
    
    public Top() { super(); }
}
aspect TopAdvice {
    int around ():
    target() &&
      call(int (*).*()) {
        int result = this.proceed();
        return result + 10;
    }
    
    int around ():
    call(int (p1.*).*()) {
        int result = this.proceed();
        return result + 100;
    }
    
    int around ():
    call(int (p1..*).*()) {
        int result = this.proceed();
        return result + 1000;
    }
    
    public static TopAdvice aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public TopAdvice() { super(); }
}
<<<< C2.java >>>>
package p1.p2;

public class C2 {
    public int bar() { return 1; }
    
    public C2() { super(); }
}
<<<< C1.java >>>>
package p1;

public class C1 {
    public int bar() { return 1; }
    
    public C1() { super(); }
}
retrieve <Driver: void main(java.lang.String[])> from Driver
retrieve <Driver: void test()> from Driver
retrieve <Driver: void <init>()> from Driver
retrieve <Top: int bar()> from Top
retrieve <Top: void <init>()> from Top
retrieve <TopAdvice: void <init>()> from TopAdvice
retrieve <TopAdvice: int around$0()> from TopAdvice
retrieve <TopAdvice: int around$1()> from TopAdvice
retrieve <TopAdvice: int around$2()> from TopAdvice
retrieve <TopAdvice: TopAdvice aspectOf()> from TopAdvice
retrieve <TopAdvice: boolean hasAspect()> from TopAdvice
retrieve <TopAdvice: int proceed$3()> from TopAdvice
retrieve <TopAdvice: int proceed$4()> from TopAdvice
retrieve <TopAdvice: int proceed$5()> from TopAdvice
retrieve <p1.p2.C2: int bar()> from p1.p2.C2
retrieve <p1.p2.C2: void <init>()> from p1.p2.C2
retrieve <p1.C1: int bar()> from p1.C1
retrieve <p1.C1: void <init>()> from p1.C1
Transforming p1.C1... 
Transforming Top... 
Transforming Driver... 
Transforming p1.p2.C2... 
Transforming TopAdvice... 
Transforming abc$access$TopAdvice$around$0... 
Transforming abc$access$TopAdvice$around$2... 
Transforming abc$access$TopAdvice$around$1... 
Abc finished on Thu Jun 24 09:43:56 BST 2004. ( 0 min. 7 sec. )
PASS: various forms of package name pattern matching work()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 281 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 659 (new): import of a class in the default package
Failed. Current status: 282 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 660 (pureJava): Referencing static interfaces with import statements
================================================
Breakdown of abc phases  (total: 6159 millisec.)
------------------------------------------------
[ 00.601% ] Init. of Soot:  37
[ 00.065% ] Loading Jars:  4
[ 78.503% ] Polyglot phases:  4835
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.471% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.974% ] Intertype Adjuster:  60
[ 12.323% ] Retrieving bodies:  759
[ 00.000% ] Weave Initializers:  0
[ 00.617% ] Load shadow types:  38
[ 00.731% ] Compute advice lists:  45
[ 00.049% ] Intertype weave:  3
[ 00.146% ] Add aspect code:  9
[ 00.211% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.338% ] Soot Packs:  144
[ 02.939% ] Soot Writing Output:  181
================================================
Failed. Current status: 283 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 661 (pureJava): Referencing static interfaces with import statements stars
================================================
Breakdown of abc phases  (total: 6170 millisec.)
------------------------------------------------
[ 00.583% ] Init. of Soot:  36
[ 00.065% ] Loading Jars:  4
[ 78.558% ] Polyglot phases:  4847
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.454% ] Recompute name pattern matches:  28
[ 00.000% ] Compute precedence relation:  0
[ 00.972% ] Intertype Adjuster:  60
[ 12.301% ] Retrieving bodies:  759
[ 00.000% ] Weave Initializers:  0
[ 00.632% ] Load shadow types:  39
[ 00.729% ] Compute advice lists:  45
[ 00.049% ] Intertype weave:  3
[ 00.130% ] Add aspect code:  8
[ 00.211% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.350% ] Soot Packs:  145
[ 02.934% ] Soot Writing Output:  181
================================================
Failed. Current status: 284 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 662 (pureJava): Referencing static interfaces with import statements stars 2
================================================
Breakdown of abc phases  (total: 6170 millisec.)
------------------------------------------------
[ 00.600% ] Init. of Soot:  37
[ 00.049% ] Loading Jars:  3
[ 78.509% ] Polyglot phases:  4844
[ 00.016% ] Resolve class names:  1
[ 00.016% ] Declare Parents:  1
[ 00.470% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.972% ] Intertype Adjuster:  60
[ 12.334% ] Retrieving bodies:  761
[ 00.000% ] Weave Initializers:  0
[ 00.616% ] Load shadow types:  38
[ 00.729% ] Compute advice lists:  45
[ 00.049% ] Intertype weave:  3
[ 00.146% ] Add aspect code:  9
[ 00.194% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.350% ] Soot Packs:  145
[ 02.950% ] Soot Writing Output:  182
================================================
Failed. Current status: 285 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 663 (pureJava): Referencing static interfaces with import statements stars 3
================================================
Breakdown of abc phases  (total: 6163 millisec.)
------------------------------------------------
[ 00.600% ] Init. of Soot:  37
[ 00.049% ] Loading Jars:  3
[ 78.517% ] Polyglot phases:  4839
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.471% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.957% ] Intertype Adjuster:  59
[ 12.332% ] Retrieving bodies:  760
[ 00.000% ] Weave Initializers:  0
[ 00.633% ] Load shadow types:  39
[ 00.730% ] Compute advice lists:  45
[ 00.049% ] Intertype weave:  3
[ 00.130% ] Add aspect code:  8
[ 00.211% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 02.353% ] Soot Packs:  145
[ 02.937% ] Soot Writing Output:  181
================================================
Failed. Current status: 286 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 664 (pureJava): Referencing interfaces with import statements
Failed. Current status: 287 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 665 (pureJava): Referencing interfaces with import statements stars
Failed. Current status: 288 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 666 (pureJava): Referencing interfaces with import statements stars 2
Failed. Current status: 289 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 667 (pureJava): Referencing interfaces with import statements stars 3
Failed. Current status: 290 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 668 (new): assert statement in advice coverage [requires 1.4]
Failed. Current status: 291 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 669 (new): assert statement in advice  [requires 1.4]
Failed. Current status: 292 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 670 (new): declaring a private method on an inner interface
Failed. Current status: 293 failed (check: 105), 372 passed (check: 88), 5 skipped.
Executing test 671 (new): CE expected when declaring fields on arrays
Abc started on Thu Jun 24 09:45:12 BST 2004
PASS: CE expected when declaring fields on arrays()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 293 failed (check: 105), 373 passed (check: 89), 5 skipped.
Executing test 672 (pureJava): non-constant static final fields marked as final in .class
================================================
Breakdown of abc phases  (total: 7441 millisec.)
------------------------------------------------
[ 00.497% ] Init. of Soot:  37
[ 00.040% ] Loading Jars:  3
[ 76.804% ] Polyglot phases:  5715
[ 00.000% ] Resolve class names:  0
[ 00.027% ] Declare Parents:  2
[ 00.443% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.820% ] Intertype Adjuster:  61
[ 07.674% ] Retrieving bodies:  571
[ 00.000% ] Weave Initializers:  0
[ 00.296% ] Load shadow types:  22
[ 06.236% ] Compute advice lists:  464
[ 00.054% ] Intertype weave:  4
[ 00.108% ] Add aspect code:  8
[ 00.175% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.481% ] Soot Packs:  259
[ 03.346% ] Soot Writing Output:  249
================================================
Abc started on Thu Jun 24 09:45:16 BST 2004
<<<< FinalStaticField.java >>>>
import java.lang.reflect.*;
import org.aspectj.testing.Tester;

class C {
    public C() { super(); }
}
class D {
    public static final C public_c = new C();
    
    private static final C private_c = new C();
    
    protected static final C protected_c = new C();
    
    static final C default_c = new C();
    
    public D() { super(); }
}
public class FinalStaticField {
    public static final java.lang.String[] FIELDS =
      new java.lang.String[] { "public_c", "private_c", "protected_c", "default_c" };
    
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvents(FinalStaticField/*FinalStaticField*/.FIELDS);
        java.lang.reflect.Field[] fields =
          D.class.getDeclaredFields();
        java.lang.StringBuffer failures =
          new java.lang.StringBuffer();
        for (int i = 0; i < fields/*null*/.length; i++) {
            java.lang.String fieldName = fields[i].getName();
            org.aspectj.testing.Tester.event(fieldName);
            if (!fieldName.endsWith("_c")) {
                org.aspectj.testing.Tester.check(false,
                                                 "unexpected field: " +
                                                 fieldName);
            } else
                if (!java.lang.reflect.Modifier.isFinal(fields[i].getModifiers())) {
                    failures.append(fieldName + " ");
                }
        }
        org.aspectj.testing.Tester.checkAllEvents();
        if (0 < failures.length()) {
            org.aspectj.testing.Tester.check(false,
                                             failures.toString());
        }
    }
    
    public FinalStaticField() { super(); }
}
retrieve <C: void <init>()> from C
retrieve <D: void <init>()> from D
retrieve <D: void <clinit>()> from D
retrieve <FinalStaticField: void <init>()> from FinalStaticField
retrieve <FinalStaticField: void <clinit>()> from FinalStaticField
retrieve <FinalStaticField: java.lang.Class class$(java.lang.String)> from FinalStaticField
retrieve <FinalStaticField: void main(java.lang.String[])> from FinalStaticField
Transforming D... 
Transforming FinalStaticField... 
Transforming C... 
Abc finished on Thu Jun 24 09:45:23 BST 2004. ( 0 min. 7 sec. )
PASS: non-constant static final fields marked as final in .class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 293 failed (check: 105), 374 passed (check: 89), 5 skipped.
Executing test 673 (new): signature of handler join point
================================================
Breakdown of abc phases  (total: 7189 millisec.)
------------------------------------------------
[ 00.501% ] Init. of Soot:  36
[ 00.056% ] Loading Jars:  4
[ 77.563% ] Polyglot phases:  5576
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.709% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.501% ] Intertype Adjuster:  36
[ 07.817% ] Retrieving bodies:  562
[ 00.000% ] Weave Initializers:  0
[ 00.306% ] Load shadow types:  22
[ 03.547% ] Compute advice lists:  255
[ 00.042% ] Intertype weave:  3
[ 00.306% ] Add aspect code:  22
[ 01.321% ] Weaving advice:  95
[ 00.000% ] Validate jimple:  0
[ 03.992% ] Soot Packs:  287
[ 03.297% ] Soot Writing Output:  237
================================================
before handler
caught
Abc started on Thu Jun 24 09:45:26 BST 2004
<<<< HandlerSignature.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class HandlerSignature {
    public static void main(java.lang.String[] args) {
        C c = new C();
        U.ee("caught");
        try {
            c.run();
        }
        catch (java.lang.Error e) { U.e("caught"); }
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    static {  }
    
    public HandlerSignature() { super(); }
}
class C {
    public void run() { throw new java.lang.Error(""); }
    
    public C() { super(); }
}
class U {
    static void e(java.lang.String event) {
        java.lang.System/*java.lang.System*/.err.println(event);
        org.aspectj.testing.Tester.event(event);
    }
    
    static void ee(java.lang.String event) {
        org.aspectj.testing.Tester.expectEvent(event);
    }
    
    public U() { super(); }
}
aspect A {
    static { U.ee("before handler"); }
    
    before():
    handler(*) {
        thisJoinPoint.getSignature().getModifiers();
        U.e("before handler");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <HandlerSignature: void main(java.lang.String[])> from HandlerSignature
retrieve <HandlerSignature: void <init>()> from HandlerSignature
retrieve <HandlerSignature: void <clinit>()> from HandlerSignature
retrieve <C: void run()> from C
retrieve <C: void <init>()> from C
retrieve <U: void <init>()> from U
retrieve <U: void e(java.lang.String)> from U
retrieve <U: void ee(java.lang.String)> from U
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void <clinit>()> from A
Transforming A... 
Transforming C... 
Transforming HandlerSignature... 
Transforming U... 
Abc finished on Thu Jun 24 09:45:33 BST 2004. ( 0 min. 7 sec. )
PASS: signature of handler join point()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 293 failed (check: 105), 375 passed (check: 89), 5 skipped.
Executing test 674 (new): source locations within expressions
================================================
Breakdown of abc phases  (total: 7898 millisec.)
------------------------------------------------
[ 00.468% ] Init. of Soot:  37
[ 00.038% ] Loading Jars:  3
[ 74.854% ] Polyglot phases:  5912
[ 00.013% ] Resolve class names:  1
[ 00.025% ] Declare Parents:  2
[ 00.684% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.494% ] Intertype Adjuster:  39
[ 06.635% ] Retrieving bodies:  524
[ 00.000% ] Weave Initializers:  0
[ 00.279% ] Load shadow types:  22
[ 06.318% ] Compute advice lists:  499
[ 00.051% ] Intertype weave:  4
[ 00.595% ] Add aspect code:  47
[ 01.165% ] Weaving advice:  92
[ 00.000% ] Validate jimple:  0
[ 04.697% ] Soot Packs:  371
[ 03.684% ] Soot Writing Output:  291
================================================
Abc started on Thu Jun 24 09:45:35 BST 2004
<<<< SourceLocationWithinExpr.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class SourceLocationWithinExpr {
    public static void main(java.lang.String[] args) {
        new C().getD().getE().getF();
        org.aspectj.testing.Tester.expectEvent("setup");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public SourceLocationWithinExpr() { super(); }
}
class C {
    D getD() { return new D(); }
    
    public C() { super(); }
}
class D {
    E getE() { return new E(); }
    
    public D() { super(); }
}
class E {
    F getF() { return new F(); }
    
    public E() { super(); }
}
class F {
    public F() { super(); }
}
aspect A {
    private static final java.lang.String SEP = " - ";
    
    static {
               org.aspectj.testing.Tester.expectEvent("C()" +
                                                      A/*A*/.SEP +
                                                      "9");
               org.aspectj.testing.Tester.expectEvent("getD()" +
                                                      A/*A*/.SEP +
                                                      "12");
               org.aspectj.testing.Tester.expectEvent("getE()" +
                                                      A/*A*/.SEP +
                                                      "14");
               org.aspectj.testing.Tester.expectEvent("getF()" +
                                                      A/*A*/.SEP +
                                                      "16");
               org.aspectj.testing.Tester.event("setup");
           }
    
    pointcut filter() :
    withincode(static void (SourceLocationWithinExpr).main(String[]));
    
    before():
    filter() &&
      call((C).new()) {
        signal("C()", thisJoinPoint);
    }
    
    before():
    filter() &&
      call(D (C).getD()) {
        signal("getD()", thisJoinPoint);
    }
    
    before():
    filter() &&
      call(E (D).getE()) {
        signal("getE()", thisJoinPoint);
    }
    
    before():
    filter() &&
      call(F (E).getF()) {
        signal("getF()", thisJoinPoint);
    }
    
    void signal(java.lang.String prefix,
                org.aspectj.lang.JoinPoint jp) {
        org.aspectj.lang.reflect.SourceLocation sl =
          jp.getSourceLocation();
        java.lang.System/*java.lang.System*/.out.println(prefix +
                                                         A/*A*/.SEP +
                                                         sl.getLine());
        org.aspectj.testing.Tester.event(prefix + A/*A*/.SEP +
                                         sl.getLine());
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <SourceLocationWithinExpr: void <init>()> from SourceLocationWithinExpr
retrieve <SourceLocationWithinExpr: void main(java.lang.String[])> from SourceLocationWithinExpr
retrieve <C: void <init>()> from C
retrieve <C: D getD()> from C
retrieve <D: E getE()> from D
retrieve <D: void <init>()> from D
retrieve <E: void <init>()> from E
retrieve <E: F getF()> from E
retrieve <F: void <init>()> from F
retrieve <A: void <init>()> from A
retrieve <A: void before$0(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$1(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$2(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void before$3(org.aspectj.lang.JoinPoint)> from A
retrieve <A: void signal(java.lang.String,org.aspectj.lang.JoinPoint)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <clinit>()> from A
Transforming D... 
Transforming C... 
Transforming E... 
Transforming A... 
Transforming F... 
Transforming SourceLocationWithinExpr... 
Abc finished on Thu Jun 24 09:45:43 BST 2004. ( 0 min. 8 sec. )
C() - 9
getD() - 12
getE() - 14
getF() - 16
PASS: source locations within expressions()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 293 failed (check: 105), 376 passed (check: 89), 5 skipped.
Executing test 675 (new): source locations within expressions (hard case of constructor start)
================================================
Breakdown of abc phases  (total: 7686 millisec.)
------------------------------------------------
[ 00.481% ] Init. of Soot:  37
[ 00.039% ] Loading Jars:  3
[ 76.060% ] Polyglot phases:  5846
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.729% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.468% ] Intertype Adjuster:  36
[ 06.792% ] Retrieving bodies:  522
[ 00.000% ] Weave Initializers:  0
[ 00.364% ] Load shadow types:  28
[ 06.232% ] Compute advice lists:  479
[ 00.052% ] Intertype weave:  4
[ 00.494% ] Add aspect code:  38
[ 00.273% ] Weaving advice:  21
[ 00.000% ] Validate jimple:  0
[ 04.567% ] Soot Packs:  351
[ 03.396% ] Soot Writing Output:  261
================================================
Failed. Current status: 294 failed (check: 105), 376 passed (check: 89), 5 skipped.
Executing test 676 (new): crashes given method in declared method
Abc started on Thu Jun 24 09:45:56 BST 2004
PASS: crashes given method in declared method()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 294 failed (check: 105), 377 passed (check: 90), 5 skipped.
Executing test 677 (new): after returning advice on interface constructor
================================================
Breakdown of abc phases  (total: 7508 millisec.)
------------------------------------------------
[ 00.493% ] Init. of Soot:  37
[ 00.053% ] Loading Jars:  4
[ 73.881% ] Polyglot phases:  5547
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.693% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 02.198% ] Intertype Adjuster:  165
[ 04.848% ] Retrieving bodies:  364
[ 00.000% ] Weave Initializers:  0
[ 00.360% ] Load shadow types:  27
[ 09.830% ] Compute advice lists:  738
[ 00.040% ] Intertype weave:  3
[ 00.493% ] Add aspect code:  37
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.743% ] Soot Packs:  281
[ 03.143% ] Soot Writing Output:  236
================================================
Failed. Current status: 295 failed (check: 105), 377 passed (check: 90), 5 skipped.
Executing test 678 (new): after returning advice on interface constructor - error
Abc started on Thu Jun 24 09:46:10 BST 2004
<<<< AfterReturningInterfaceConstructorCE.java >>>>
import org.aspectj.testing.Tester;

public class AfterReturningInterfaceConstructorCE {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("constructor");
        org.aspectj.testing.Tester.expectEvent("advice");
        I i = new C();
        java.lang.System/*java.lang.System*/.out.println("i.i: " +
                                                         i/*null*/.i);
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public AfterReturningInterfaceConstructorCE() { super(); }
}
interface I {}
class C implements I {
    C() {
        super();
        org.aspectj.testing.Tester.event("constructor");
    }
}
aspect A {
    int I.i;
    
    I.new() {
        super();
        hostIthis/*null*/.i = 2;
        java.lang.System/*java.lang.System*/.out.println("running I.new()");
    }
    
    after() returning:
    execution ((I).new()) {
        org.aspectj.testing.Tester.event("advice");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: after returning advice on interface constructor - error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 3 seconds
Passed. Current status: 295 failed (check: 105), 378 passed (check: 91), 5 skipped.
Executing test 679 (bugs): after advice on static call join point
================================================
Breakdown of abc phases  (total: 6637 millisec.)
------------------------------------------------
[ 00.557% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 79.599% ] Polyglot phases:  5283
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.738% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.557% ] Intertype Adjuster:  37
[ 06.825% ] Retrieving bodies:  453
[ 00.000% ] Weave Initializers:  0
[ 00.316% ] Load shadow types:  21
[ 03.044% ] Compute advice lists:  202
[ 00.045% ] Intertype weave:  3
[ 00.527% ] Add aspect code:  35
[ 00.452% ] Weaving advice:  30
[ 00.000% ] Validate jimple:  0
[ 03.948% ] Soot Packs:  262
[ 03.285% ] Soot Writing Output:  218
================================================
Abc started on Thu Jun 24 09:46:14 BST 2004
<<<< AfterStaticCall.java >>>>
import org.aspectj.testing.Tester;

public class AfterStaticCall {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("foo()");
        org.aspectj.testing.Tester.expectEvent("after() : call(void Test.foo())");
        foo();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void foo() {
        org.aspectj.testing.Tester.event("foo()");
    }
    
    public AfterStaticCall() { super(); }
}
aspect LogFooCall {
    after():
    call(static void (*).foo()) {
        org.aspectj.testing.Tester.event("after() : call(void Test.foo())");
    }
    
    public static LogFooCall aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public LogFooCall() { super(); }
}
retrieve <AfterStaticCall: void main(java.lang.String[])> from AfterStaticCall
retrieve <AfterStaticCall: void foo()> from AfterStaticCall
retrieve <AfterStaticCall: void <init>()> from AfterStaticCall
retrieve <LogFooCall: void <init>()> from LogFooCall
retrieve <LogFooCall: void after$0()> from LogFooCall
retrieve <LogFooCall: LogFooCall aspectOf()> from LogFooCall
retrieve <LogFooCall: boolean hasAspect()> from LogFooCall
Transforming AfterStaticCall... 
Transforming LogFooCall... 
Abc finished on Thu Jun 24 09:46:21 BST 2004. ( 0 min. 6 sec. )
PASS: after advice on static call join point()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 295 failed (check: 105), 379 passed (check: 91), 5 skipped.
Executing test 680 (bugs): incompatible class change error
================================================
Breakdown of abc phases  (total: 7414 millisec.)
------------------------------------------------
[ 00.499% ] Init. of Soot:  37
[ 00.040% ] Loading Jars:  3
[ 73.132% ] Polyglot phases:  5422
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.715% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.486% ] Intertype Adjuster:  36
[ 06.609% ] Retrieving bodies:  490
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  22
[ 08.201% ] Compute advice lists:  608
[ 00.040% ] Intertype weave:  3
[ 00.297% ] Add aspect code:  22
[ 02.711% ] Weaving advice:  201
[ 00.000% ] Validate jimple:  0
[ 03.696% ] Soot Packs:  274
[ 03.224% ] Soot Writing Output:  239
================================================
Abc started on Thu Jun 24 09:46:23 BST 2004
<<<< IncompatibleClassChangeErrorBug.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class IncompatibleClassChangeErrorBug {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("printed");
        method1();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static void method1() {  }
    
    public IncompatibleClassChangeErrorBug() { super(); }
}
aspect JoinpointTestAspect {
    before():
    call(static void (*).method1()) {
        printArgs(thisJoinPoint);
        printStaticInfo(thisJoinPointStaticPart);
    }
    
    private void printArgs(org.aspectj.lang.JoinPoint joinPoint) {
        java.lang.Object[] args = joinPoint.getArgs();
    }
    
    private void printStaticInfo(org.aspectj.lang.JoinPoint.StaticPart joinPointStaticPart) {
        org.aspectj.testing.Tester.check(null !=
                                         joinPointStaticPart,
                                         "null parm");
        org.aspectj.testing.Tester.event("printed");
    }
    
    public static JoinpointTestAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public JoinpointTestAspect() { super(); }
}
retrieve <IncompatibleClassChangeErrorBug: void main(java.lang.String[])> from IncompatibleClassChangeErrorBug
retrieve <IncompatibleClassChangeErrorBug: void method1()> from IncompatibleClassChangeErrorBug
retrieve <IncompatibleClassChangeErrorBug: void <init>()> from IncompatibleClassChangeErrorBug
retrieve <JoinpointTestAspect: void before$0(org.aspectj.lang.JoinPoint$StaticPart,org.aspectj.lang.JoinPoint)> from JoinpointTestAspect
retrieve <JoinpointTestAspect: void printArgs(org.aspectj.lang.JoinPoint)> from JoinpointTestAspect
retrieve <JoinpointTestAspect: void printStaticInfo(org.aspectj.lang.JoinPoint$StaticPart)> from JoinpointTestAspect
retrieve <JoinpointTestAspect: JoinpointTestAspect aspectOf()> from JoinpointTestAspect
retrieve <JoinpointTestAspect: boolean hasAspect()> from JoinpointTestAspect
retrieve <JoinpointTestAspect: void <init>()> from JoinpointTestAspect
Transforming JoinpointTestAspect... 
Transforming IncompatibleClassChangeErrorBug... 
Abc finished on Thu Jun 24 09:46:31 BST 2004. ( 0 min. 7 sec. )
PASS: incompatible class change error()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 295 failed (check: 105), 380 passed (check: 91), 5 skipped.
Executing test 681 (bugs): simple cflow of method execution
================================================
Breakdown of abc phases  (total: 7087 millisec.)
------------------------------------------------
[ 00.522% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 74.108% ] Polyglot phases:  5252
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.762% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.522% ] Intertype Adjuster:  37
[ 11.980% ] Retrieving bodies:  849
[ 00.000% ] Weave Initializers:  0
[ 00.325% ] Load shadow types:  23
[ 03.655% ] Compute advice lists:  259
[ 00.042% ] Intertype weave:  3
[ 00.494% ] Add aspect code:  35
[ 00.649% ] Weaving advice:  46
[ 00.000% ] Validate jimple:  0
[ 03.866% ] Soot Packs:  274
[ 02.991% ] Soot Writing Output:  212
================================================
Abc started on Thu Jun 24 09:46:33 BST 2004
<<<< ExecutionCflow.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class ExecutionCflow {
    static int field;
    
    public static void main(java.lang.String[] args) {
        ExecutionCflow/*ExecutionCflow*/.field = 0;
        org.aspectj.testing.Tester.expectEvent("before");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public ExecutionCflow() { super(); }
}
aspect A {
    before():
    cflow(execution (static void (*).main(String[]))) &&
      set( int (*).field) {
        org.aspectj.testing.Tester.event("before");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <ExecutionCflow: void main(java.lang.String[])> from ExecutionCflow
retrieve <ExecutionCflow: void <init>()> from ExecutionCflow
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming ExecutionCflow... 
Abc finished on Thu Jun 24 09:46:40 BST 2004. ( 0 min. 7 sec. )
PASS: simple cflow of method execution()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 295 failed (check: 105), 381 passed (check: 91), 5 skipped.
Executing test 682 (bugs): using instance as class reference to constant field
================================================
Breakdown of abc phases  (total: 6475 millisec.)
------------------------------------------------
[ 00.571% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  3
[ 80.340% ] Polyglot phases:  5202
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.710% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.602% ] Intertype Adjuster:  39
[ 08.448% ] Retrieving bodies:  547
[ 00.000% ] Weave Initializers:  0
[ 00.417% ] Load shadow types:  27
[ 00.927% ] Compute advice lists:  60
[ 00.046% ] Intertype weave:  3
[ 00.139% ] Add aspect code:  9
[ 00.201% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.876% ] Soot Packs:  251
[ 03.645% ] Soot Writing Output:  236
================================================
Abc started on Thu Jun 24 09:46:43 BST 2004
<<<< InstanceAsClassRefToConstant.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class InstanceAsClassRefToConstant {
    public static void main(java.lang.String[] args) {
        throw new java.lang.Error("XXX not set up to run");
    }
    
    public InstanceAsClassRefToConstant() { super(); }
}
abstract class CWithLongConst {
    public static final long MAX = 1000000;
    
    public CWithLongConst() { super(); }
}
class A extends CWithLongConst {
    public A() { super(); }
}
class TestCase {
    public static final void main(java.lang.String[] argv) {
        A aL = new A();
        for (long l = 0; l < 2000000; l += 100000) {
            if (l > aL/*null*/.MAX) { break; }
        }
        java.lang.String[] stringsL = null;
        for (long k = 0;
             k < 2000000 && stringsL == null;
             k += 100000) {
            if (k > aL/*null*/.MAX) {
                stringsL = (new java.lang.String[1]);
            }
        }
    }
    
    public TestCase() { super(); }
}
retrieve <InstanceAsClassRefToConstant: void <init>()> from InstanceAsClassRefToConstant
retrieve <InstanceAsClassRefToConstant: void main(java.lang.String[])> from InstanceAsClassRefToConstant
retrieve <CWithLongConst: void <init>()> from CWithLongConst
retrieve <CWithLongConst: void <clinit>()> from CWithLongConst
retrieve <A: void <init>()> from A
retrieve <TestCase: void <init>()> from TestCase
retrieve <TestCase: void main(java.lang.String[])> from TestCase
Transforming CWithLongConst... 
Transforming A... 
Transforming TestCase... 
Transforming InstanceAsClassRefToConstant... 
Abc finished on Thu Jun 24 09:46:49 BST 2004. ( 0 min. 6 sec. )
PASS: using instance as class reference to constant field()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 295 failed (check: 105), 382 passed (check: 91), 5 skipped.
Executing test 683 (options/deprecated): options -warn:deprecation
Failed. Current status: 296 failed (check: 106), 382 passed (check: 91), 5 skipped.
Executing test 684 (options/deprecated): options -warn:deprecation not enabled
================================================
Breakdown of abc phases  (total: 6536 millisec.)
------------------------------------------------
[ 00.551% ] Init. of Soot:  36
[ 00.061% ] Loading Jars:  4
[ 78.473% ] Polyglot phases:  5129
[ 00.000% ] Resolve class names:  0
[ 00.031% ] Declare Parents:  2
[ 00.444% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.933% ] Intertype Adjuster:  61
[ 12.271% ] Retrieving bodies:  802
[ 00.000% ] Weave Initializers:  0
[ 00.337% ] Load shadow types:  22
[ 01.270% ] Compute advice lists:  83
[ 00.046% ] Intertype weave:  3
[ 00.138% ] Add aspect code:  9
[ 00.184% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.708% ] Soot Packs:  177
[ 02.555% ] Soot Writing Output:  167
================================================
Abc started on Thu Jun 24 09:46:54 BST 2004
<<<< WarnDeprecated.java >>>>
public class WarnDeprecated {
    public static void main(java.lang.String[] args) {
        if (null == args) { OldStuff.foo(); }
    }
    
    public WarnDeprecated() { super(); }
}
<<<< OldStuff.java >>>>
class OldStuff {
    public static void foo() {  }
    
    public OldStuff() { super(); }
}
retrieve <WarnDeprecated: void main(java.lang.String[])> from WarnDeprecated
retrieve <WarnDeprecated: void <init>()> from WarnDeprecated
retrieve <OldStuff: void foo()> from OldStuff
retrieve <OldStuff: void <init>()> from OldStuff
Transforming OldStuff... 
Transforming WarnDeprecated... 
Abc finished on Thu Jun 24 09:47:01 BST 2004. ( 0 min. 6 sec. )
PASS: options -warn:deprecation not enabled()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 296 failed (check: 106), 383 passed (check: 91), 5 skipped.
Executing test 685 (options): options -Xlint args()
Failed. Current status: 297 failed (check: 107), 383 passed (check: 91), 5 skipped.
Executing test 686 (options): options declare field on bad type
Abc started on Thu Jun 24 09:47:06 BST 2004
PASS: options declare field on bad type()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 297 failed (check: 107), 384 passed (check: 92), 5 skipped.
Executing test 687 (options): options declare method on bad type
Abc started on Thu Jun 24 09:47:09 BST 2004
PASS: options declare method on bad type()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 297 failed (check: 107), 385 passed (check: 93), 5 skipped.
Executing test 688 (options): options -Xlint declare parent
Failed. Current status: 298 failed (check: 108), 385 passed (check: 93), 5 skipped.
Executing test 689 (options): options -Xlint target()
Failed. Current status: 299 failed (check: 109), 385 passed (check: 93), 5 skipped.
Executing test 690 (options): options -Xlint this()
Failed. Current status: 300 failed (check: 110), 385 passed (check: 93), 5 skipped.
Executing test 691 (options): options negative -Xlint args()
Illegal arguments: Unknown option -Xlint:ignore
PASS: options negative -Xlint args()()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 300 failed (check: 110), 386 passed (check: 93), 5 skipped.
Executing test 692 (options): options negative -Xlint declare parent
Illegal arguments: Unknown option -Xlint:ignore
PASS: options negative -Xlint declare parent()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 300 failed (check: 110), 387 passed (check: 93), 5 skipped.
Executing test 693 (options): options negative -Xlint target()
Illegal arguments: Unknown option -Xlint:ignore
PASS: options negative -Xlint target()()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 300 failed (check: 110), 388 passed (check: 93), 5 skipped.
Executing test 694 (options): options negative -Xlint this()
Illegal arguments: Unknown option -Xlint:ignore
PASS: options negative -Xlint this()()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 300 failed (check: 110), 389 passed (check: 93), 5 skipped.
Executing test 695 (options/injars/simple): source for options -injars
================================================
Breakdown of abc phases  (total: 7267 millisec.)
------------------------------------------------
[ 00.509% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 75.148% ] Polyglot phases:  5461
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.729% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.578% ] Intertype Adjuster:  42
[ 06.991% ] Retrieving bodies:  508
[ 00.000% ] Weave Initializers:  0
[ 00.303% ] Load shadow types:  22
[ 02.477% ] Compute advice lists:  180
[ 00.041% ] Intertype weave:  3
[ 00.440% ] Add aspect code:  32
[ 00.275% ] Weaving advice:  20
[ 00.000% ] Validate jimple:  0
[ 03.674% ] Soot Packs:  267
[ 08.738% ] Soot Writing Output:  635
================================================
Abc started on Thu Jun 24 09:47:31 BST 2004
<<<< Simple.java >>>>
import org.aspectj.testing.Tester;

aspect Simple {
    before():
    execution (void (*).run()) {
        org.aspectj.testing.Tester.event("run");
    }
    
    public static Simple aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Simple() { super(); }
}
<<<< Main.java >>>>
import org.aspectj.testing.Tester;

public class Main {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("run");
        new Main().run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public void run() {  }
    
    public Main() { super(); }
}
retrieve <Simple: void before$0()> from Simple
retrieve <Simple: Simple aspectOf()> from Simple
retrieve <Simple: boolean hasAspect()> from Simple
retrieve <Simple: void <init>()> from Simple
retrieve <Main: void run()> from Main
retrieve <Main: void <init>()> from Main
retrieve <Main: void main(java.lang.String[])> from Main
Transforming Simple... 
Transforming Main... 
Abc finished on Thu Jun 24 09:47:38 BST 2004. ( 0 min. 7 sec. )
PASS: source for options -injars()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 300 failed (check: 110), 390 passed (check: 93), 5 skipped.
Executing test 696 (options/injars/simple): options -injars
Failed. Current status: 301 failed (check: 110), 390 passed (check: 93), 5 skipped.
Executing test 697 (new/options11): testing new options
Illegal arguments: Unknown option -aspectpath
PASS: testing new options()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 301 failed (check: 110), 391 passed (check: 93), 5 skipped.
Executing test 698 (new): interface self-reference in anonymous instance
================================================
Breakdown of abc phases  (total: 7389 millisec.)
------------------------------------------------
[ 00.501% ] Init. of Soot:  37
[ 00.054% ] Loading Jars:  4
[ 73.542% ] Polyglot phases:  5434
[ 00.027% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.677% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 07.322% ] Intertype Adjuster:  541
[ 06.456% ] Retrieving bodies:  477
[ 00.122% ] Weave Initializers:  9
[ 00.284% ] Load shadow types:  21
[ 02.788% ] Compute advice lists:  206
[ 00.041% ] Intertype weave:  3
[ 00.568% ] Add aspect code:  42
[ 00.217% ] Weaving advice:  16
[ 00.000% ] Validate jimple:  0
[ 04.060% ] Soot Packs:  300
[ 03.329% ] Soot Writing Output:  246
================================================
Abc started on Thu Jun 24 09:47:51 BST 2004
<<<< AnonymousSelfReference.java >>>>
import org.aspectj.testing.Tester;

public class AnonymousSelfReference {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("run");
        org.aspectj.testing.Tester.expectEvent("im");
        I it =
          new I() {
            public void im() { Tester.event("im"); }
        };
        it/*null*/.runnable.run();
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public AnonymousSelfReference() { super(); }
}
interface I {
    public abstract void im();
}
aspect A {
    java.lang.Runnable I.runnable =
      new java.lang.Runnable() {
        public void run() {
            im();
            Tester.event("run");
        }
    };
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AnonymousSelfReference: void main(java.lang.String[])> from AnonymousSelfReference
retrieve <AnonymousSelfReference: void <init>()> from AnonymousSelfReference
retrieve <AnonymousSelfReference$1: void im()> from AnonymousSelfReference$1
retrieve <AnonymousSelfReference$1: void <init>()> from AnonymousSelfReference$1
retrieve <AnonymousSelfReference$1: java.lang.Runnable get$runnable$3()> from AnonymousSelfReference$1
retrieve <AnonymousSelfReference$1: java.lang.Runnable set$runnable$2(java.lang.Runnable)> from AnonymousSelfReference$1
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: java.lang.Runnable init$runnable$5(I)> from A
retrieve <A$1: void run()> from A$1
retrieve <A$1: void <init>(I)> from A$1
Transforming I... 
Transforming AnonymousSelfReference... 
Transforming AnonymousSelfReference$1... 
Transforming A... 
Transforming A$1... 
Abc finished on Thu Jun 24 09:47:58 BST 2004. ( 0 min. 7 sec. )
PASS: interface self-reference in anonymous instance()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 301 failed (check: 110), 392 passed (check: 93), 5 skipped.
Executing test 699 (new): self-reference from (aspect-declared) method-local class
Failed. Current status: 302 failed (check: 110), 392 passed (check: 93), 5 skipped.
Executing test 700 (new): expect CE for unterminated declare error
Failed. Current status: 303 failed (check: 111), 392 passed (check: 93), 5 skipped.
Executing test 701 (new): expect CE for declaration collision between subaspects instead of domination order
Failed. Current status: 304 failed (check: 112), 392 passed (check: 93), 5 skipped.
Executing test 702 (new): subtype pattern in dominates should pick out aspect subtypes
================================================
Breakdown of abc phases  (total: 7236 millisec.)
------------------------------------------------
[ 00.511% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 74.489% ] Polyglot phases:  5390
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.802% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 01.893% ] Intertype Adjuster:  137
[ 05.362% ] Retrieving bodies:  388
[ 00.000% ] Weave Initializers:  0
[ 00.304% ] Load shadow types:  22
[ 02.681% ] Compute advice lists:  194
[ 00.041% ] Intertype weave:  3
[ 00.456% ] Add aspect code:  33
[ 00.166% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 04.077% ] Soot Packs:  295
[ 09.121% ] Soot Writing Output:  660
================================================
Abc started on Thu Jun 24 09:48:13 BST 2004
<<<< DominatesTypePattern.java >>>>
import org.aspectj.testing.Tester;

public class DominatesTypePattern {
    public static void main(java.lang.String[] args) {
        java.lang.String s = new C().method();
        org.aspectj.testing.Tester.check("pass".equals(s),
                                         "\"pass\".equals(\"" + s +
                                         "\")");
    }
    
    public DominatesTypePattern() { super(); }
}
class C {
    public C() { super(); }
}
abstract aspect AA {
    declare precedence : AA, AA+ && !AA;
    
    public intertype java.lang.String C.method() { return "pass"; }
    
    public AA() { super(); }
}
aspect A extends AA {
    public intertype java.lang.String C.method() { return "fail"; }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <DominatesTypePattern: void <init>()> from DominatesTypePattern
retrieve <DominatesTypePattern: void main(java.lang.String[])> from DominatesTypePattern
retrieve <C: void <init>()> from C
retrieve <C: java.lang.String method()> from C
retrieve <AA: java.lang.String method(C)> from AA
retrieve <AA: void <init>()> from AA
retrieve <A: java.lang.String method(C)> from A
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
Transforming AA... 
Transforming C... 
Transforming A... 
Transforming DominatesTypePattern... 
Abc finished on Thu Jun 24 09:48:20 BST 2004. ( 0 min. 7 sec. )
PASS: subtype pattern in dominates should pick out aspect subtypes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 304 failed (check: 112), 393 passed (check: 93), 5 skipped.
Executing test 703 (new): subtype pattern in dominates will conflict with type pattern
================================================
Breakdown of abc phases  (total: 5369 millisec.)
------------------------------------------------
[ 00.671% ] Init. of Soot:  36
[ 00.056% ] Loading Jars:  3
[ 98.212% ] Polyglot phases:  5273
[ 00.037% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  1
[ 01.006% ] Recompute name pattern matches:  54
================================================
Failed. Current status: 305 failed (check: 113), 393 passed (check: 93), 5 skipped.
Executing test 704 (new): after returning advice on interface and implementation constructor
Failed. Current status: 306 failed (check: 113), 393 passed (check: 93), 5 skipped.
Executing test 705 (new): after throwing advice with non-throwable formal
Abc started on Thu Jun 24 09:48:34 BST 2004
<<<< AfterThrowingNonThrowable.java >>>>
import org.aspectj.testing.Tester;
import java.util.*;

public class AfterThrowingNonThrowable {
    public static void main(java.lang.String[] args) {
        U.ee("after() throwing (Object o) : call(void C.run())");
        U.ee("run()");
        C c = new C();
        boolean gotError = false;
        try {
            c.run();
        }
        catch (java.lang.Error e) { gotError = true; }
        org.aspectj.testing.Tester.check(gotError,
                                         "failed to get error");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public AfterThrowingNonThrowable() { super(); }
}
class C {
    public void run() {
        U.e("run()");
        throw new java.lang.Error("");
    }
    
    public C() { super(); }
}
class U {
    static void e(java.lang.String event) {
        org.aspectj.testing.Tester.event(event);
    }
    
    static void ee(java.lang.String event) {
        org.aspectj.testing.Tester.expectEvent(event);
    }
    
    public U() { super(); }
}
aspect A {
    after() throwing(Object o):
    call(void (C).run()) {
        U.e("after() throwing (Object o) : call(void C.run())");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: after throwing advice with non-throwable formal()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 306 failed (check: 113), 394 passed (check: 94), 5 skipped.
Executing test 706 (new): declare array field using postfix
Abc started on Thu Jun 24 09:48:38 BST 2004
PASS: declare array field using postfix()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 306 failed (check: 113), 395 passed (check: 95), 5 skipped.
Executing test 707 (new): prohibit declaring new aspect constructor with arguments
================================================
Breakdown of abc phases  (total: 6652 millisec.)
------------------------------------------------
[ 00.541% ] Init. of Soot:  36
[ 00.045% ] Loading Jars:  3
[ 76.804% ] Polyglot phases:  5109
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.707% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 07.456% ] Intertype Adjuster:  496
[ 05.096% ] Retrieving bodies:  339
[ 00.000% ] Weave Initializers:  0
[ 00.331% ] Load shadow types:  22
[ 00.631% ] Compute advice lists:  42
[ 00.045% ] Intertype weave:  3
[ 00.737% ] Add aspect code:  49
[ 00.195% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.954% ] Soot Packs:  263
[ 03.397% ] Soot Writing Output:  226
================================================
Failed. Current status: 307 failed (check: 114), 395 passed (check: 95), 5 skipped.
Executing test 708 (new): prohibit declaring only aspect constructor with arguments
================================================
Breakdown of abc phases  (total: 6885 millisec.)
------------------------------------------------
[ 00.508% ] Init. of Soot:  35
[ 00.058% ] Loading Jars:  4
[ 76.442% ] Polyglot phases:  5263
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.726% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 07.524% ] Intertype Adjuster:  518
[ 05.214% ] Retrieving bodies:  359
[ 00.000% ] Weave Initializers:  0
[ 00.334% ] Load shadow types:  23
[ 00.654% ] Compute advice lists:  45
[ 00.044% ] Intertype weave:  3
[ 00.770% ] Add aspect code:  53
[ 00.189% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.023% ] Soot Packs:  277
[ 03.457% ] Soot Writing Output:  238
================================================
Failed. Current status: 308 failed (check: 115), 395 passed (check: 95), 5 skipped.
Executing test 709 (new): declare class extends interface
Failed. Current status: 309 failed (check: 115), 395 passed (check: 95), 5 skipped.
Executing test 710 (new): declare class implements class
Failed. Current status: 310 failed (check: 115), 395 passed (check: 95), 5 skipped.
Executing test 711 (new): declare interface implements interface
================================================
Breakdown of abc phases  (total: 6579 millisec.)
------------------------------------------------
[ 00.562% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  3
[ 76.775% ] Polyglot phases:  5051
[ 00.030% ] Resolve class names:  2
[ 00.046% ] Declare Parents:  3
[ 00.775% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 06.156% ] Intertype Adjuster:  405
[ 06.536% ] Retrieving bodies:  430
[ 00.000% ] Weave Initializers:  0
[ 00.380% ] Load shadow types:  25
[ 00.623% ] Compute advice lists:  41
[ 00.046% ] Intertype weave:  3
[ 00.775% ] Add aspect code:  51
[ 00.198% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.785% ] Soot Packs:  249
[ 03.268% ] Soot Writing Output:  215
================================================
Abc started on Thu Jun 24 09:49:08 BST 2004
<<<< DeclareInterfaceImplementsInterface.java >>>>
interface I {}
interface I2 {}
aspect A {
    declare parents : I implements I2;
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming I... 
Transforming A... 
Transforming I2... 
Abc finished on Thu Jun 24 09:49:15 BST 2004. ( 0 min. 6 sec. )
PASS: declare interface implements interface()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 310 failed (check: 115), 396 passed (check: 95), 5 skipped.
Executing test 712 (new): if and cflow arg binding
Failed. Current status: 311 failed (check: 116), 396 passed (check: 95), 5 skipped.
Executing test 713 (bugs): circularity in declare dominates
Abc started on Thu Jun 24 09:49:25 BST 2004
PASS: circularity in declare dominates()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 311 failed (check: 116), 397 passed (check: 96), 5 skipped.
Executing test 714 (bugs): percflow code hangs compiler
================================================
Breakdown of abc phases  (total: 7014 millisec.)
------------------------------------------------
[ 00.542% ] Init. of Soot:  38
[ 00.043% ] Loading Jars:  3
[ 75.948% ] Polyglot phases:  5327
[ 00.029% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.727% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.513% ] Intertype Adjuster:  36
[ 07.143% ] Retrieving bodies:  501
[ 00.000% ] Weave Initializers:  0
[ 00.314% ] Load shadow types:  22
[ 02.495% ] Compute advice lists:  175
[ 00.043% ] Intertype weave:  3
[ 00.385% ] Add aspect code:  27
[ 01.041% ] Weaving advice:  73
[ 00.000% ] Validate jimple:  0
[ 06.772% ] Soot Packs:  475
[ 03.992% ] Soot Writing Output:  280
================================================
Abc started on Thu Jun 24 09:49:29 BST 2004
<<<< CloseConnectionsCflow.java >>>>
import java.util.Stack;

interface Connection {
    public abstract Connection open();
    
    public abstract void close();
}
aspect CloseConnectionsCflow {
    java.util.Stack openConnections;
    
    pointcut layerMethods() :
    execution (public * (com.example.businessFacade.*).*(..));
    
    pointcut layerEntryMethods() :
    layerMethods() &&
      !cflowbelow(layerMethods());
    
    pointcut openedConnection() : call(* (Connection).open(..));
    
    pointcut layerBoundary() : cflow(layerEntryMethods());
    
    after() returning(Connection conn):
    openedConnection() &&
      layerBoundary() {
        this/*null*/.openConnections.push(conn);
    }
    
    after():
    layerBoundary() {
        while (!this/*null*/.openConnections.empty()) {
            Connection conn =
              (Connection) this/*null*/.openConnections.pop();
            conn.close();
        }
    }
    
    public static CloseConnectionsCflow aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public CloseConnectionsCflow() { super(); }
}
retrieve <CloseConnectionsCflow: void afterReturning$0(Connection)> from CloseConnectionsCflow
retrieve <CloseConnectionsCflow: void after$1()> from CloseConnectionsCflow
retrieve <CloseConnectionsCflow: CloseConnectionsCflow aspectOf()> from CloseConnectionsCflow
retrieve <CloseConnectionsCflow: boolean hasAspect()> from CloseConnectionsCflow
retrieve <CloseConnectionsCflow: void <init>()> from CloseConnectionsCflow
Transforming Connection... 
Transforming CloseConnectionsCflow... 
Abc finished on Thu Jun 24 09:49:36 BST 2004. ( 0 min. 7 sec. )
PASS: percflow code hangs compiler()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 311 failed (check: 116), 398 passed (check: 96), 5 skipped.
Executing test 715 (bugs): assert and pertarget crashes compiler
Failed. Current status: 312 failed (check: 116), 398 passed (check: 96), 5 skipped.
Executing test 716 (bugs): Verification error tracing constructor that takes arguments
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 6689 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 78.547% ] Polyglot phases:  5254
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.688% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.538% ] Intertype Adjuster:  36
[ 07.101% ] Retrieving bodies:  475
[ 00.000% ] Weave Initializers:  0
[ 00.329% ] Load shadow types:  22
[ 01.734% ] Compute advice lists:  116
[ 00.045% ] Intertype weave:  3
[ 00.538% ] Add aspect code:  36
[ 01.256% ] Weaving advice:  84
[ 00.000% ] Validate jimple:  0
[ 04.859% ] Soot Packs:  325
[ 03.708% ] Soot Writing Output:  248
================================================
Abc started on Thu Jun 24 09:49:41 BST 2004
<<<< ConstructorArgTracing.java >>>>
public class ConstructorArgTracing {
    public ConstructorArgTracing(int arg) { super(); }
    
    public static void main(java.lang.String[] args) {
        ConstructorArgTracing account =
          new ConstructorArgTracing(12345);
    }
}
aspect TraceAspect {
    before():
    !within(TraceAspect) {
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
    }
    
    public static TraceAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public TraceAspect() { super(); }
}
retrieve <ConstructorArgTracing: void <init>(int)> from ConstructorArgTracing
retrieve <ConstructorArgTracing: void main(java.lang.String[])> from ConstructorArgTracing
retrieve <TraceAspect: void <init>()> from TraceAspect
retrieve <TraceAspect: void before$0(org.aspectj.lang.JoinPoint)> from TraceAspect
retrieve <TraceAspect: TraceAspect aspectOf()> from TraceAspect
retrieve <TraceAspect: boolean hasAspect()> from TraceAspect
Transforming ConstructorArgTracing... 
Transforming TraceAspect... 
Abc finished on Thu Jun 24 09:49:48 BST 2004. ( 0 min. 6 sec. )
staticinitialization(ConstructorArgTracing.<clinit>)
execution(void ConstructorArgTracing.main(String[]))
call(ConstructorArgTracing(int))
preinitialization(ConstructorArgTracing(int))
initialization(ConstructorArgTracing(int))
execution(ConstructorArgTracing(int))
PASS: Verification error tracing constructor that takes arguments()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 312 failed (check: 116), 399 passed (check: 96), 5 skipped.
Executing test 717 (bugs): declared exceptions in inter-type decls
================================================
Breakdown of abc phases  (total: 6445 millisec.)
------------------------------------------------
[ 00.590% ] Init. of Soot:  38
[ 00.047% ] Loading Jars:  3
[ 80.000% ] Polyglot phases:  5156
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.714% ] Recompute name pattern matches:  46
[ 00.016% ] Compute precedence relation:  1
[ 01.753% ] Intertype Adjuster:  113
[ 07.029% ] Retrieving bodies:  453
[ 00.000% ] Weave Initializers:  0
[ 00.357% ] Load shadow types:  23
[ 01.893% ] Compute advice lists:  122
[ 00.047% ] Intertype weave:  3
[ 00.559% ] Add aspect code:  36
[ 00.186% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.413% ] Soot Packs:  220
[ 03.336% ] Soot Writing Output:  215
================================================
BombException: KABOOM
Abc started on Thu Jun 24 09:49:50 BST 2004
<<<< ExceptionsOnInters.java >>>>
public class ExceptionsOnInters {
    public static void main(java.lang.String[] args) {
        try {
            ExceptionsOnInters.bomb();
        }
        catch (BombException e) {
            java.lang.System/*java.lang.System*/.err.println(e);
        }
    }
    
    public ExceptionsOnInters() { super(); }
}
aspect Bomb {
    public static intertype void ExceptionsOnInters.bomb()
                                                                throws BombException {
        throw new BombException("KABOOM");
    }
    
    public static Bomb aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Bomb() { super(); }
}
class BombException extends java.lang.Exception {
    public BombException(java.lang.String message) { super(message); }
}
retrieve <ExceptionsOnInters: void main(java.lang.String[])> from ExceptionsOnInters
retrieve <ExceptionsOnInters: void bomb()> from ExceptionsOnInters
retrieve <ExceptionsOnInters: void <init>()> from ExceptionsOnInters
retrieve <Bomb: void bomb()> from Bomb
retrieve <Bomb: Bomb aspectOf()> from Bomb
retrieve <Bomb: boolean hasAspect()> from Bomb
retrieve <Bomb: void <init>()> from Bomb
retrieve <BombException: void <init>(java.lang.String)> from BombException
Transforming BombException... 
Transforming Bomb... 
Transforming ExceptionsOnInters... 
Abc finished on Thu Jun 24 09:49:57 BST 2004. ( 0 min. 6 sec. )
PASS: declared exceptions in inter-type decls()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 312 failed (check: 116), 400 passed (check: 96), 5 skipped.
Executing test 718 (bugs): Verify error on non-Throwable in declare soft
Failed. Current status: 313 failed (check: 117), 400 passed (check: 96), 5 skipped.
Executing test 719 (bugs): inter-type fields with array types
Failed. Current status: 314 failed (check: 117), 400 passed (check: 96), 5 skipped.
Executing test 720 (new): unmatched type name in a declare parents should result in a warning in -Xlint mode
Failed. Current status: 315 failed (check: 118), 400 passed (check: 96), 5 skipped.
Executing test 721 (new): checking around join point for advice return type - numeric
================================================
Breakdown of abc phases  (total: 7956 millisec.)
------------------------------------------------
[ 00.452% ] Init. of Soot:  36
[ 00.050% ] Loading Jars:  4
[ 74.749% ] Polyglot phases:  5947
[ 00.025% ] Resolve class names:  2
[ 00.025% ] Declare Parents:  2
[ 00.427% ] Recompute name pattern matches:  34
[ 00.000% ] Compute precedence relation:  0
[ 00.754% ] Intertype Adjuster:  60
[ 06.523% ] Retrieving bodies:  519
[ 00.000% ] Weave Initializers:  0
[ 00.314% ] Load shadow types:  25
[ 01.936% ] Compute advice lists:  154
[ 00.038% ] Intertype weave:  3
[ 00.339% ] Add aspect code:  27
[ 01.131% ] Weaving advice:  90
[ 00.000% ] Validate jimple:  0
[ 03.859% ] Soot Packs:  307
[ 09.377% ] Soot Writing Output:  746
================================================
Failed. Current status: 316 failed (check: 119), 400 passed (check: 96), 5 skipped.
Executing test 722 (new): void around advice without proceed
Failed. Current status: 317 failed (check: 120), 400 passed (check: 96), 5 skipped.
Executing test 723 (new/PR852): declaring method on superclass and subclass
================================================
Breakdown of abc phases  (total: 6504 millisec.)
------------------------------------------------
[ 00.461% ] Init. of Soot:  30
[ 00.077% ] Loading Jars:  5
[ 79.966% ] Polyglot phases:  5201
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.738% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 01.922% ] Intertype Adjuster:  125
[ 05.935% ] Retrieving bodies:  386
[ 00.000% ] Weave Initializers:  0
[ 00.338% ] Load shadow types:  22
[ 02.276% ] Compute advice lists:  148
[ 00.046% ] Intertype weave:  3
[ 00.492% ] Add aspect code:  32
[ 00.200% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.213% ] Soot Packs:  274
[ 03.275% ] Soot Writing Output:  213
================================================
Abc started on Thu Jun 24 09:50:34 BST 2004
<<<< Aspect.java >>>>
package aspectPack;

import target.SuperClass;
import target.SubClass;

public aspect Aspect {
    intertype void target.SuperClass.test() {
        java.lang.System/*java.lang.System*/.out.println("SuperClass ok");
    }
    
    intertype void target.SubClass.test() {
        java.lang.System/*java.lang.System*/.out.println("SubClass ok");
    }
    
    public static void main(java.lang.String[] args) {
        new target.SuperClass().test();
        new target.SubClass().test();
    }
    
    public static aspectPack.Aspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect() { super(); }
}
<<<< SubClass.java >>>>
package target;

public class SubClass extends target.SuperClass {
    public SubClass() { super(); }
}
<<<< SuperClass.java >>>>
package target;

public class SuperClass {
    public SuperClass() { super(); }
}
retrieve <aspectPack.Aspect: void <init>()> from aspectPack.Aspect
retrieve <aspectPack.Aspect: void aspectPack$Aspect$test$2(target.SuperClass)> from aspectPack.Aspect
retrieve <aspectPack.Aspect: void aspectPack$Aspect$test$4(target.SubClass)> from aspectPack.Aspect
retrieve <aspectPack.Aspect: aspectPack.Aspect aspectOf()> from aspectPack.Aspect
retrieve <aspectPack.Aspect: boolean hasAspect()> from aspectPack.Aspect
retrieve <aspectPack.Aspect: void main(java.lang.String[])> from aspectPack.Aspect
retrieve <target.SubClass: void <init>()> from target.SubClass
retrieve <target.SubClass: void aspectPack$Aspect$test$4()> from target.SubClass
retrieve <target.SuperClass: void <init>()> from target.SuperClass
retrieve <target.SuperClass: void aspectPack$Aspect$test$2()> from target.SuperClass
Transforming target.SubClass... 
Transforming target.SuperClass... 
Transforming aspectPack.Aspect... 
Abc finished on Thu Jun 24 09:50:41 BST 2004. ( 0 min. 6 sec. )
SuperClass ok
SubClass ok
PASS: declaring method on superclass and subclass()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 317 failed (check: 120), 401 passed (check: 96), 5 skipped.
Executing test 724 (new/PR852): declaring method on superclass and subclass
Failed. Current status: 318 failed (check: 120), 401 passed (check: 96), 5 skipped.
Executing test 725 (bugs): privileged access to code outside the control of the compiler
Failed. Current status: 319 failed (check: 121), 401 passed (check: 96), 5 skipped.
Executing test 726 (new/PR862): import any inner from interface implementor
================================================
Breakdown of abc phases  (total: 6228 millisec.)
------------------------------------------------
[ 00.482% ] Init. of Soot:  30
[ 00.080% ] Loading Jars:  5
[ 79.640% ] Polyglot phases:  4960
[ 00.000% ] Resolve class names:  0
[ 00.032% ] Declare Parents:  2
[ 00.450% ] Recompute name pattern matches:  28
[ 00.000% ] Compute precedence relation:  0
[ 00.626% ] Intertype Adjuster:  39
[ 12.636% ] Retrieving bodies:  787
[ 00.000% ] Weave Initializers:  0
[ 00.466% ] Load shadow types:  29
[ 00.706% ] Compute advice lists:  44
[ 00.048% ] Intertype weave:  3
[ 00.128% ] Add aspect code:  8
[ 00.193% ] Weaving advice:  12
[ 00.016% ] Validate jimple:  1
[ 02.200% ] Soot Packs:  137
[ 02.296% ] Soot Writing Output:  143
================================================
Failed. Current status: 320 failed (check: 121), 401 passed (check: 96), 5 skipped.
Executing test 727 (new/finalfield): introducing final fields (simple)
================================================
Breakdown of abc phases  (total: 6924 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  36
[ 00.043% ] Loading Jars:  3
[ 74.841% ] Polyglot phases:  5182
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.650% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.520% ] Intertype Adjuster:  36
[ 13.923% ] Retrieving bodies:  964
[ 00.159% ] Weave Initializers:  11
[ 00.303% ] Load shadow types:  21
[ 01.213% ] Compute advice lists:  84
[ 00.043% ] Intertype weave:  3
[ 00.491% ] Add aspect code:  34
[ 00.188% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.856% ] Soot Packs:  267
[ 03.192% ] Soot Writing Output:  221
================================================
Abc started on Thu Jun 24 09:50:58 BST 2004
<<<< Introducer.java >>>>
aspect Introducer {
    final boolean Receiver.someField = true;
    
    public static final int Receiver.constant = 2;
    
    public static Introducer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Introducer() { super(); }
}
<<<< User1.java >>>>
import org.aspectj.testing.Tester;

public class User1 {
    public static void main(java.lang.String[] args) {
        Receiver r = new Receiver();
        org.aspectj.testing.Tester.check(r/*null*/.someField,
                                         "introduced field");
    }
    
    public User1() { super(); }
}
<<<< Receiver.java >>>>
class Receiver {
    public Receiver() { super(); }
}
retrieve <Introducer: Introducer aspectOf()> from Introducer
retrieve <Introducer: boolean hasAspect()> from Introducer
retrieve <Introducer: void <init>()> from Introducer
retrieve <Introducer: boolean init$someField$5(Receiver)> from Introducer
retrieve <Introducer: int init$constant$6()> from Introducer
retrieve <User1: void <init>()> from User1
retrieve <User1: void main(java.lang.String[])> from User1
retrieve <Receiver: void <init>()> from Receiver
Transforming Receiver... 
Transforming Introducer... 
Transforming User1... 
Abc finished on Thu Jun 24 09:51:05 BST 2004. ( 0 min. 7 sec. )
PASS: introducing final fields (simple)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 320 failed (check: 121), 402 passed (check: 96), 5 skipped.
Executing test 728 (new/finalfield): introducing final fields and using as constants
================================================
Breakdown of abc phases  (total: 6565 millisec.)
------------------------------------------------
[ 00.564% ] Init. of Soot:  37
[ 00.046% ] Loading Jars:  3
[ 80.716% ] Polyglot phases:  5299
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.487% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 00.914% ] Intertype Adjuster:  60
[ 07.022% ] Retrieving bodies:  461
[ 00.198% ] Weave Initializers:  13
[ 00.335% ] Load shadow types:  22
[ 01.340% ] Compute advice lists:  88
[ 00.046% ] Intertype weave:  3
[ 00.487% ] Add aspect code:  32
[ 00.198% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.082% ] Soot Packs:  268
[ 03.503% ] Soot Writing Output:  230
================================================
Abc started on Thu Jun 24 09:51:07 BST 2004
<<<< Introducer.java >>>>
aspect Introducer {
    final boolean Receiver.someField = true;
    
    public static final int Receiver.constant = 2;
    
    public static Introducer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Introducer() { super(); }
}
<<<< User2.java >>>>
import org.aspectj.testing.Tester;

public class User2 {
    public static void main(java.lang.String[] args) {
        switch (Receiver/*Receiver*/.constant) { case 2: return; }
        org.aspectj.testing.Tester.checkFailed("shouldn\'t get here");
    }
    
    public User2() { super(); }
}
<<<< Receiver.java >>>>
class Receiver {
    public Receiver() { super(); }
}
retrieve <Introducer: Introducer aspectOf()> from Introducer
retrieve <Introducer: boolean hasAspect()> from Introducer
retrieve <Introducer: void <init>()> from Introducer
retrieve <Introducer: boolean init$someField$5(Receiver)> from Introducer
retrieve <Introducer: int init$constant$6()> from Introducer
retrieve <User2: void <init>()> from User2
retrieve <User2: void main(java.lang.String[])> from User2
retrieve <Receiver: void <init>()> from Receiver
Transforming Receiver... 
Transforming Introducer... 
Transforming User2... 
Abc finished on Thu Jun 24 09:51:14 BST 2004. ( 0 min. 6 sec. )
PASS: introducing final fields and using as constants()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 320 failed (check: 121), 403 passed (check: 96), 5 skipped.
Executing test 729 (new/finalfield): introducing final fields and checking errors
Abc started on Thu Jun 24 09:51:16 BST 2004
<<<< Introducer.java >>>>
aspect Introducer {
    final boolean Receiver.someField = true;
    
    public static final int Receiver.constant = 2;
    
    public static Introducer aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Introducer() { super(); }
}
<<<< UserCf.java >>>>
import org.aspectj.testing.Tester;

public class UserCf {
    public static void main(java.lang.String[] args) {
        Receiver r = new Receiver();
        r/*null*/.someField = false;
    }
    
    public UserCf() { super(); }
}
<<<< Receiver.java >>>>
class Receiver {
    public Receiver() { super(); }
}
PASS: introducing final fields and checking errors()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 320 failed (check: 121), 404 passed (check: 97), 5 skipped.
Executing test 730 (bugs): Static inner aspects cannot reference user defined pointcuts
================================================
Breakdown of abc phases  (total: 6088 millisec.)
------------------------------------------------
[ 00.591% ] Init. of Soot:  36
[ 00.066% ] Loading Jars:  4
[ 81.012% ] Polyglot phases:  4932
[ 00.033% ] Resolve class names:  2
[ 00.033% ] Declare Parents:  2
[ 00.821% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 00.575% ] Intertype Adjuster:  35
[ 07.178% ] Retrieving bodies:  437
[ 00.000% ] Weave Initializers:  0
[ 00.361% ] Load shadow types:  22
[ 00.723% ] Compute advice lists:  44
[ 00.049% ] Intertype weave:  3
[ 00.838% ] Add aspect code:  51
[ 00.214% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.221% ] Soot Packs:  257
[ 03.285% ] Soot Writing Output:  200
================================================
Abc started on Thu Jun 24 09:51:20 BST 2004
<<<< PcdLookup.java >>>>
import org.aspectj.testing.Tester;

public class PcdLookup {
    public static void main(java.lang.String[] args) {  }
    
    public static aspect Referencer {
        pointcut mainCall() : call(void (*).main(..));
        
        pointcut myMainCall() : mainCall() && outer();
        
        public static PcdLookup.Referencer aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public Referencer() { super(); }
    }
    
    
    pointcut outer() : within(PcdLookup);
    
    public PcdLookup() { super(); }
}
retrieve <PcdLookup: void main(java.lang.String[])> from PcdLookup
retrieve <PcdLookup: void <init>()> from PcdLookup
retrieve <PcdLookup$Referencer: void <init>()> from PcdLookup$Referencer
retrieve <PcdLookup$Referencer: PcdLookup$Referencer aspectOf()> from PcdLookup$Referencer
retrieve <PcdLookup$Referencer: boolean hasAspect()> from PcdLookup$Referencer
Transforming PcdLookup... 
Transforming PcdLookup$Referencer... 
Abc finished on Thu Jun 24 09:51:27 BST 2004. ( 0 min. 6 sec. )
PASS: Static inner aspects cannot reference user defined pointcuts()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 320 failed (check: 121), 405 passed (check: 97), 5 skipped.
Executing test 731 (bugs): Static inner aspects cannot reference user defined pointcuts
================================================
Breakdown of abc phases  (total: 6650 millisec.)
------------------------------------------------
[ 00.541% ] Init. of Soot:  36
[ 00.060% ] Loading Jars:  4
[ 78.647% ] Polyglot phases:  5230
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.842% ] Recompute name pattern matches:  56
[ 00.000% ] Compute precedence relation:  0
[ 00.586% ] Intertype Adjuster:  39
[ 07.970% ] Retrieving bodies:  530
[ 00.000% ] Weave Initializers:  0
[ 00.361% ] Load shadow types:  24
[ 02.150% ] Compute advice lists:  143
[ 00.045% ] Intertype weave:  3
[ 00.316% ] Add aspect code:  21
[ 00.481% ] Weaving advice:  32
[ 00.015% ] Validate jimple:  1
[ 04.406% ] Soot Packs:  293
[ 03.519% ] Soot Writing Output:  234
================================================
Abc started on Thu Jun 24 09:51:29 BST 2004
<<<< SoftWithin.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.*;
import java.io.*;

public class SoftWithin {
    static void foo() throws java.io.IOException {
        throw new java.io.IOException();
    }
    
    public static void main(java.lang.String[] args)
          throws java.lang.Exception {
        try {
            foo();
        }
        catch (org.aspectj.lang.SoftException se) { return; }
        org.aspectj.testing.Tester.checkFailed("should have got SoftException");
    }
    
    public SoftWithin() { super(); }
}
aspect Soften {
    declare soft : java.io.IOException : within(SoftWithin);
    
    public static Soften aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Soften() { super(); }
}
retrieve <SoftWithin: void foo()> from SoftWithin
retrieve <SoftWithin: void main(java.lang.String[])> from SoftWithin
retrieve <SoftWithin: void <init>()> from SoftWithin
retrieve <Soften: void <init>()> from Soften
retrieve <Soften: Soften aspectOf()> from Soften
retrieve <Soften: boolean hasAspect()> from Soften
Transforming SoftWithin... 
Transforming Soften... 
Abc finished on Thu Jun 24 09:51:36 BST 2004. ( 0 min. 6 sec. )
PASS: Static inner aspects cannot reference user defined pointcuts()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 320 failed (check: 121), 406 passed (check: 97), 5 skipped.
Executing test 732 (bugs): Declare precedence should not allow multiple * patterns
================================================
Breakdown of abc phases  (total: 5386 millisec.)
------------------------------------------------
[ 00.724% ] Init. of Soot:  39
[ 00.056% ] Loading Jars:  3
[ 98.162% ] Polyglot phases:  5287
[ 00.037% ] Resolve class names:  2
[ 00.019% ] Declare Parents:  1
[ 01.003% ] Recompute name pattern matches:  54
================================================
Failed. Current status: 321 failed (check: 122), 406 passed (check: 97), 5 skipped.
Executing test 733 (bugs): VerifyError on accessing objects not accessible to the weaver
Failed. Current status: 322 failed (check: 122), 406 passed (check: 97), 5 skipped.
Executing test 734 (new): aspect static initializers should run before instance constructed
================================================
Breakdown of abc phases  (total: 6988 millisec.)
------------------------------------------------
[ 00.529% ] Init. of Soot:  37
[ 00.057% ] Loading Jars:  4
[ 75.301% ] Polyglot phases:  5262
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.458% ] Recompute name pattern matches:  32
[ 00.000% ] Compute precedence relation:  0
[ 06.096% ] Intertype Adjuster:  426
[ 06.869% ] Retrieving bodies:  480
[ 00.000% ] Weave Initializers:  0
[ 00.315% ] Load shadow types:  22
[ 02.962% ] Compute advice lists:  207
[ 00.043% ] Intertype weave:  3
[ 00.229% ] Add aspect code:  16
[ 00.286% ] Weaving advice:  20
[ 00.000% ] Validate jimple:  0
[ 03.663% ] Soot Packs:  256
[ 03.134% ] Soot Writing Output:  219
================================================
Abc started on Thu Jun 24 09:51:51 BST 2004
<<<< AspectStaticInit.java >>>>
import org.aspectj.testing.Tester;

public class AspectStaticInit {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.check(A/*A*/.i ==
                                         1,
                                         "1 != A.i=" +
                                         A/*A*/.i);
    }
    
    public AspectStaticInit() { super(); }
}
aspect A {
    static int i = 1;
    
    A() {
        super();
        org.aspectj.testing.Tester.check(A/*A*/.i ==
                                         1,
                                         "1 != i=" +
                                         A/*A*/.i);
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
}
retrieve <AspectStaticInit: void main(java.lang.String[])> from AspectStaticInit
retrieve <AspectStaticInit: void <init>()> from AspectStaticInit
retrieve <A: void <init>()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <clinit>()> from A
Transforming AspectStaticInit... 
Transforming A... 
Abc finished on Thu Jun 24 09:51:58 BST 2004. ( 0 min. 7 sec. )
PASS: aspect static initializers should run before instance constructed()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 322 failed (check: 122), 407 passed (check: 97), 5 skipped.
Executing test 735 (bugs): super call in intertype method declaration body causes VerifyError
Failed. Current status: 323 failed (check: 122), 407 passed (check: 97), 5 skipped.
Executing test 736 (bugs/crashes): Error with certain combination of advice
================================================
Breakdown of abc phases  (total: 7086 millisec.)
------------------------------------------------
[ 00.522% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 77.110% ] Polyglot phases:  5464
[ 00.028% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.720% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.522% ] Intertype Adjuster:  37
[ 07.014% ] Retrieving bodies:  497
[ 00.014% ] Weave Initializers:  1
[ 00.296% ] Load shadow types:  21
[ 04.220% ] Compute advice lists:  299
[ 00.042% ] Intertype weave:  3
[ 00.621% ] Add aspect code:  44
[ 00.790% ] Weaving advice:  56
[ 00.000% ] Validate jimple:  0
[ 04.530% ] Soot Packs:  321
[ 03.514% ] Soot Writing Output:  249
================================================
Abc started on Thu Jun 24 09:52:09 BST 2004
<<<< Test3.java >>>>
package test;

import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class Test3 {
    public static void main(java.lang.String[] args)
          throws java.lang.Exception {
        test.Test3 a = new test.Test3();
        a.foo(-3);
    }
    
    public void foo(int i) { this/*<unknown>*/.x = i; }
    
    int x;
    
    public Test3() { super(); }
}
aspect Log {
    pointcut assign(java.lang.Object newval, java.lang.Object targ) :
    set( * (test.).*) && args(newval) &&
      target(targ);
    
    before(Object newval, Object targ):
    assign(newval,
        targ) {
        org.aspectj.lang.Signature sign =
          thisJoinPoint.getSignature();
        java.lang.System/*java.lang.System*/.out.println(targ.toString() +
                                                         "." +
                                                         sign.getName() +
                                                         ":=" +
                                                         newval);
    }
    
    pointcut tracedCall() : call(* (test.).*(..)) && !within(Log);
    
    after() returning(Object o):
    tracedCall() {
        thisJoinPoint.getSignature();
        java.lang.System/*java.lang.System*/.out.println(thisJoinPoint);
    }
    
    public static test.Log aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Log() { super(); }
}
retrieve <test.Test3: void main(java.lang.String[])> from test.Test3
retrieve <test.Test3: void foo(int)> from test.Test3
retrieve <test.Test3: void <init>()> from test.Test3
retrieve <test.Log: void <init>()> from test.Log
retrieve <test.Log: void before$0(java.lang.Object,java.lang.Object,org.aspectj.lang.JoinPoint)> from test.Log
retrieve <test.Log: void afterReturning$1(java.lang.Object,org.aspectj.lang.JoinPoint)> from test.Log
retrieve <test.Log: test.Log aspectOf()> from test.Log
retrieve <test.Log: boolean hasAspect()> from test.Log
Transforming test.Test3... 
Transforming test.Log... 
Abc finished on Thu Jun 24 09:52:16 BST 2004. ( 0 min. 7 sec. )
test.Test3@6f403e.x:=-3
call(void test.Test3.foo(int))
PASS: Error with certain combination of advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 323 failed (check: 122), 408 passed (check: 97), 5 skipped.
Executing test 737 (bugs): Pointcut adviceexecution() does not work
================================================
Breakdown of abc phases  (total: 7400 millisec.)
------------------------------------------------
[ 00.486% ] Init. of Soot:  36
[ 00.054% ] Loading Jars:  4
[ 72.919% ] Polyglot phases:  5396
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.608% ] Recompute name pattern matches:  45
[ 00.000% ] Compute precedence relation:  0
[ 00.757% ] Intertype Adjuster:  56
[ 06.486% ] Retrieving bodies:  480
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  22
[ 07.473% ] Compute advice lists:  553
[ 00.041% ] Intertype weave:  3
[ 00.500% ] Add aspect code:  37
[ 01.014% ] Weaving advice:  75
[ 00.000% ] Validate jimple:  0
[ 05.851% ] Soot Packs:  433
[ 03.459% ] Soot Writing Output:  256
================================================
Abc started on Thu Jun 24 09:52:19 BST 2004
<<<< AdviceExec.java >>>>
import org.aspectj.testing.Tester;

public class AdviceExec {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(Aspect1/*Aspect1*/.ran,
                                              2,
                                              "Aspect1 ran");
        org.aspectj.testing.Tester.checkEqual(Aspect2/*Aspect2*/.ran,
                                              2,
                                              "Aspect2 ran");
    }
    
    public AdviceExec() { super(); }
}
aspect Aspect1 {
    static int ran = 0;
    
    before():
    execution (* (AdviceExec).*(..)) {
        Aspect1/*Aspect1*/.ran++;
    }
    
    void around ():
    execution (* (AdviceExec).*(..)) {
        Aspect1/*Aspect1*/.ran++;
        this.proceed();
    }
    
    public static Aspect1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect1() { super(); }
}
aspect Aspect2 {
    static int ran = 0;
    
    before():
    adviceexecution() &&
      !within(Aspect2) {
        Aspect2/*Aspect2*/.ran++;
    }
    
    public static Aspect2 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Aspect2() { super(); }
}
retrieve <AdviceExec: void main(java.lang.String[])> from AdviceExec
retrieve <AdviceExec: void <init>()> from AdviceExec
retrieve <Aspect1: void proceed$3()> from Aspect1
retrieve <Aspect1: boolean hasAspect()> from Aspect1
retrieve <Aspect1: void <init>()> from Aspect1
retrieve <Aspect1: void <clinit>()> from Aspect1
retrieve <Aspect1: void before$0()> from Aspect1
retrieve <Aspect1: void around$1()> from Aspect1
retrieve <Aspect1: Aspect1 aspectOf()> from Aspect1
retrieve <Aspect2: void before$2()> from Aspect2
retrieve <Aspect2: Aspect2 aspectOf()> from Aspect2
retrieve <Aspect2: boolean hasAspect()> from Aspect2
retrieve <Aspect2: void <init>()> from Aspect2
retrieve <Aspect2: void <clinit>()> from Aspect2
Transforming Aspect2... 
Transforming Aspect1... 
Transforming AdviceExec... 
Transforming abc$access$Aspect1$around$1... 
Abc finished on Thu Jun 24 09:52:26 BST 2004. ( 0 min. 7 sec. )
PASS: Pointcut adviceexecution() does not work()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 323 failed (check: 122), 409 passed (check: 97), 5 skipped.
Executing test 738 (bugs): problems with finalize call
Failed. Current status: 324 failed (check: 123), 409 passed (check: 97), 5 skipped.
Executing test 739 (bugs): Negation of if pointcut does not work
Failed. Current status: 325 failed (check: 123), 409 passed (check: 97), 5 skipped.
Executing test 740 (bugs): ajc reports error when encountering static declaration of nested classes
================================================
Breakdown of abc phases  (total: 6739 millisec.)
------------------------------------------------
[ 00.549% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 79.225% ] Polyglot phases:  5339
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.653% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.564% ] Intertype Adjuster:  38
[ 07.182% ] Retrieving bodies:  484
[ 00.000% ] Weave Initializers:  0
[ 00.415% ] Load shadow types:  28
[ 01.425% ] Compute advice lists:  96
[ 00.045% ] Intertype weave:  3
[ 00.668% ] Add aspect code:  45
[ 01.128% ] Weaving advice:  76
[ 00.000% ] Validate jimple:  0
[ 04.318% ] Soot Packs:  291
[ 03.725% ] Soot Writing Output:  251
================================================
Abc started on Thu Jun 24 09:52:42 BST 2004
<<<< WeaveLocal.java >>>>
import org.aspectj.testing.Tester;

public class WeaveLocal {
    static {
               class StaticNestedClass {
                   public StaticNestedClass() { super(); }
               }
               ;
           }
    
    public static void main(java.lang.String[] args) {
        java.lang.System/*java.lang.System*/.out.println(new WeaveLocal().handleOrder("test"));
    }
    
    private java.lang.String handleOrder(java.lang.String t) {
        return t;
    }
    
    public WeaveLocal() { super(); }
}
aspect A {
    pointcut withinTest() : within(WeaveLocal);
    
    pointcut callToHandleOrder() :
    withinTest() &&
      call(* (*).handleOrder(..));
    
    Object around ():
    callToHandleOrder() {
        return "DUMMY inserted by ASPECT";
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <WeaveLocal: void <clinit>()> from WeaveLocal
retrieve <WeaveLocal: void <init>()> from WeaveLocal
retrieve <WeaveLocal: void main(java.lang.String[])> from WeaveLocal
retrieve <WeaveLocal: java.lang.String handleOrder(java.lang.String)> from WeaveLocal
retrieve <WeaveLocal$1StaticNestedClass: void <init>()> from WeaveLocal$1StaticNestedClass
retrieve <A: java.lang.Object around$0()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: java.lang.Object proceed$1()> from A
retrieve <WeaveLocal$1StaticNestedClass: void <init>()> from WeaveLocal$1StaticNestedClass
Transforming A... 
Transforming WeaveLocal... 
Transforming WeaveLocal$1StaticNestedClass... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 09:52:49 BST 2004. ( 0 min. 6 sec. )
DUMMY inserted by ASPECT
PASS: ajc reports error when encountering static declaration of nested classes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 325 failed (check: 123), 410 passed (check: 97), 5 skipped.
Executing test 741 (bugs): can't use pointcuts defined in inner aspects 
================================================
Breakdown of abc phases  (total: 7156 millisec.)
------------------------------------------------
[ 00.517% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 74.483% ] Polyglot phases:  5330
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.755% ] Recompute name pattern matches:  54
[ 00.000% ] Compute precedence relation:  0
[ 00.545% ] Intertype Adjuster:  39
[ 12.409% ] Retrieving bodies:  888
[ 00.000% ] Weave Initializers:  0
[ 01.873% ] Load shadow types:  134
[ 01.369% ] Compute advice lists:  98
[ 00.042% ] Intertype weave:  3
[ 00.503% ] Add aspect code:  36
[ 00.335% ] Weaving advice:  24
[ 00.000% ] Validate jimple:  0
[ 03.983% ] Soot Packs:  285
[ 03.088% ] Soot Writing Output:  221
================================================
Abc started on Thu Jun 24 09:52:51 BST 2004
<<<< InnerPointcut.java >>>>
import org.aspectj.testing.Tester;

public class InnerPointcut {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.checkEqual(InnerPointcut.TrackTestCase/*InnerPointcut.TrackTestCase*/.note,
                                              "ran");
    }
    
    pointcut testcutOuter() : within(InnerPointcut);
    
    static aspect TrackTestCase {
        static java.lang.String note = "not run yet";
        
        pointcut testcut() : execution (public void (*).mai*(..));
        
        before():
        testcut() &&
          testcutOuter() {
            InnerPointcut.TrackTestCase/*InnerPointcut.TrackTestCase*/.note =
              "ran";
        }
        
        public static InnerPointcut.TrackTestCase aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public TrackTestCase() { super(); }
    }
    
    
    public InnerPointcut() { super(); }
}
retrieve <InnerPointcut: void main(java.lang.String[])> from InnerPointcut
retrieve <InnerPointcut: void <init>()> from InnerPointcut
retrieve <InnerPointcut$TrackTestCase: void before$0()> from InnerPointcut$TrackTestCase
retrieve <InnerPointcut$TrackTestCase: InnerPointcut$TrackTestCase aspectOf()> from InnerPointcut$TrackTestCase
retrieve <InnerPointcut$TrackTestCase: boolean hasAspect()> from InnerPointcut$TrackTestCase
retrieve <InnerPointcut$TrackTestCase: void <init>()> from InnerPointcut$TrackTestCase
retrieve <InnerPointcut$TrackTestCase: void <clinit>()> from InnerPointcut$TrackTestCase
Transforming InnerPointcut... 
Transforming InnerPointcut$TrackTestCase... 
Abc finished on Thu Jun 24 09:52:58 BST 2004. ( 0 min. 7 sec. )
PASS: can't use pointcuts defined in inner aspects ()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 325 failed (check: 123), 411 passed (check: 97), 5 skipped.
Executing test 742 (bugs/interfaceNames): can't resolve nested public interfaces (also PR#32399)
Failed. Current status: 326 failed (check: 123), 411 passed (check: 97), 5 skipped.
Executing test 743 (bugs): thisJoinPoint.getArgs() causes IncompatibleClassChangeError
================================================
Breakdown of abc phases  (total: 6776 millisec.)
------------------------------------------------
[ 00.531% ] Init. of Soot:  36
[ 00.044% ] Loading Jars:  3
[ 77.081% ] Polyglot phases:  5223
[ 00.030% ] Resolve class names:  2
[ 00.015% ] Declare Parents:  1
[ 00.679% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.531% ] Intertype Adjuster:  36
[ 07.246% ] Retrieving bodies:  491
[ 00.000% ] Weave Initializers:  0
[ 00.310% ] Load shadow types:  21
[ 04.221% ] Compute advice lists:  286
[ 00.044% ] Intertype weave:  3
[ 00.649% ] Add aspect code:  44
[ 00.945% ] Weaving advice:  64
[ 00.000% ] Validate jimple:  0
[ 04.265% ] Soot Packs:  289
[ 03.409% ] Soot Writing Output:  231
================================================
Abc started on Thu Jun 24 09:53:04 BST 2004
<<<< ThisJoinPointAndVerifier.java >>>>
public class ThisJoinPointAndVerifier {
    public void method() {
        java.lang.System/*java.lang.System*/.out.println("Executed method");
    }
    
    public static void main(java.lang.String[] args) {
        ThisJoinPointAndVerifier td = new ThisJoinPointAndVerifier();
        td.method();
    }
    
    public ThisJoinPointAndVerifier() { super(); }
}
aspect Log1 {
    pointcut logged_method() :
    call(* (ThisJoinPointAndVerifier).*(..));
    
    after():
    logged_method() {
        java.lang.Object[] args = thisJoinPoint.getArgs();
        java.lang.System/*java.lang.System*/.out.println("Log1a: leaving " +
                                                         thisJoinPoint.getSignature());
    }
    
    after():
    logged_method() {
        java.lang.System/*java.lang.System*/.out.println("Log1b: leaving " +
                                                         thisJoinPoint.getSignature());
    }
    
    public static Log1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Log1() { super(); }
}
retrieve <ThisJoinPointAndVerifier: void <init>()> from ThisJoinPointAndVerifier
retrieve <ThisJoinPointAndVerifier: void method()> from ThisJoinPointAndVerifier
retrieve <ThisJoinPointAndVerifier: void main(java.lang.String[])> from ThisJoinPointAndVerifier
retrieve <Log1: void after$0(org.aspectj.lang.JoinPoint)> from Log1
retrieve <Log1: void after$1(org.aspectj.lang.JoinPoint)> from Log1
retrieve <Log1: Log1 aspectOf()> from Log1
retrieve <Log1: boolean hasAspect()> from Log1
retrieve <Log1: void <init>()> from Log1
Transforming Log1... 
Transforming ThisJoinPointAndVerifier... 
Abc finished on Thu Jun 24 09:53:11 BST 2004. ( 0 min. 6 sec. )
Executed method
Log1a: leaving void ThisJoinPointAndVerifier.method()
Log1b: leaving void ThisJoinPointAndVerifier.method()
PASS: thisJoinPoint.getArgs() causes IncompatibleClassChangeError()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 326 failed (check: 123), 412 passed (check: 97), 5 skipped.
Executing test 744 (errors): inter-type declaration of void field
Abc started on Thu Jun 24 09:53:13 BST 2004
PASS: inter-type declaration of void field()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 326 failed (check: 123), 413 passed (check: 98), 5 skipped.
Executing test 745 (binding): no such constructor for proceed argument (error)
Abc started on Thu Jun 24 09:53:17 BST 2004
<<<< UnfoundConstructor.java >>>>
import org.aspectj.testing.Tester;

public class UnfoundConstructor {
    public static void main(java.lang.String[] args) {
        I i = new B();
        java.lang.String s = i.toString();
    }
    
    public UnfoundConstructor() { super(); }
}
interface I {}
class B implements I {
    public B() { super(); }
}
class Mock implements I {
    Mock(B toMock) { super(); }
}
aspect A {
    Object around (I targ):
    target(targ) && target(B) &&
      call(* (*).*(..)) {
        return this.proceed(new Mock(targ));
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: no such constructor for proceed argument (error)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 326 failed (check: 123), 414 passed (check: 99), 5 skipped.
Executing test 746 (new/declare): omnibus declare warning context with no initializer/constructor
================================================
Breakdown of abc phases  (total: 6514 millisec.)
------------------------------------------------
[ 00.553% ] Init. of Soot:  36
[ 00.046% ] Loading Jars:  3
[ 77.080% ] Polyglot phases:  5021
[ 00.046% ] Resolve class names:  3
[ 00.031% ] Declare Parents:  2
[ 00.660% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 00.568% ] Intertype Adjuster:  37
[ 12.189% ] Retrieving bodies:  794
[ 00.000% ] Weave Initializers:  0
[ 00.338% ] Load shadow types:  22
[ 00.614% ] Compute advice lists:  40
[ 00.046% ] Intertype weave:  3
[ 00.798% ] Add aspect code:  52
[ 00.200% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.807% ] Soot Packs:  248
[ 03.024% ] Soot Writing Output:  197
================================================
Failed. Current status: 327 failed (check: 124), 414 passed (check: 99), 5 skipped.
Executing test 747 (new/declare): omnibus declare warning context
================================================
Breakdown of abc phases  (total: 7757 millisec.)
------------------------------------------------
[ 00.400% ] Init. of Soot:  31
[ 00.039% ] Loading Jars:  3
[ 73.366% ] Polyglot phases:  5691
[ 00.026% ] Resolve class names:  2
[ 00.026% ] Declare Parents:  2
[ 00.670% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.464% ] Intertype Adjuster:  36
[ 08.031% ] Retrieving bodies:  623
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  24
[ 09.746% ] Compute advice lists:  756
[ 00.039% ] Intertype weave:  3
[ 00.129% ] Add aspect code:  10
[ 00.297% ] Weaving advice:  23
[ 00.013% ] Validate jimple:  1
[ 03.532% ] Soot Packs:  274
[ 02.913% ] Soot Writing Output:  226
================================================
Failed. Current status: 328 failed (check: 125), 414 passed (check: 99), 5 skipped.
Executing test 748 (new): can't apply around advice to the execution of around advice
Failed. Current status: 329 failed (check: 125), 414 passed (check: 99), 5 skipped.
Executing test 749 (new): incompatible advice throws clause are a compile-time error
Failed. Current status: 330 failed (check: 126), 414 passed (check: 99), 5 skipped.
Executing test 750 (bugs): cflow binding issues with ignoring state
Failed. Current status: 331 failed (check: 126), 414 passed (check: 99), 5 skipped.
Executing test 751 (bugs): cflow binding -- original weaver crash
Failed. Current status: 332 failed (check: 126), 414 passed (check: 99), 5 skipped.
Executing test 752 (errors): type not imported in around advice
Abc started on Thu Jun 24 09:54:11 BST 2004
PASS: type not imported in around advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 332 failed (check: 126), 415 passed (check: 100), 5 skipped.
Executing test 753 (errors): type not imported in aspect
Abc started on Thu Jun 24 09:54:15 BST 2004
PASS: type not imported in aspect()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 332 failed (check: 126), 416 passed (check: 101), 5 skipped.
Executing test 754 (errors): class extending abstract aspect
================================================
Breakdown of abc phases  (total: 6448 millisec.)
------------------------------------------------
[ 00.527% ] Init. of Soot:  34
[ 00.062% ] Loading Jars:  4
[ 80.955% ] Polyglot phases:  5220
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.806% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.558% ] Intertype Adjuster:  36
[ 07.165% ] Retrieving bodies:  462
[ 00.000% ] Weave Initializers:  0
[ 00.341% ] Load shadow types:  22
[ 01.954% ] Compute advice lists:  126
[ 00.047% ] Intertype weave:  3
[ 00.295% ] Add aspect code:  19
[ 00.202% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.846% ] Soot Packs:  248
[ 03.179% ] Soot Writing Output:  205
================================================
Failed. Current status: 333 failed (check: 127), 416 passed (check: 101), 5 skipped.
Executing test 755 (new): illegal name binding in around cflow
Failed. Current status: 334 failed (check: 128), 416 passed (check: 101), 5 skipped.
Executing test 756 (incremental/stringliteral): incrementally change string size and wire in injar classes
Failed. Current status: 335 failed (check: 128), 416 passed (check: 101), 5 skipped.
Executing test 757 (bugs): before():execution(new(..)) does not throw NoAspectBoundException
================================================
Breakdown of abc phases  (total: 6404 millisec.)
------------------------------------------------
[ 00.562% ] Init. of Soot:  36
[ 00.062% ] Loading Jars:  4
[ 79.638% ] Polyglot phases:  5100
[ 00.031% ] Resolve class names:  2
[ 00.016% ] Declare Parents:  1
[ 00.718% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.578% ] Intertype Adjuster:  37
[ 07.308% ] Retrieving bodies:  468
[ 00.000% ] Weave Initializers:  0
[ 00.344% ] Load shadow types:  22
[ 02.155% ] Compute advice lists:  138
[ 00.047% ] Intertype weave:  3
[ 00.562% ] Add aspect code:  36
[ 00.547% ] Weaving advice:  35
[ 00.000% ] Validate jimple:  0
[ 04.122% ] Soot Packs:  264
[ 03.310% ] Soot Writing Output:  212
================================================
Failed. Current status: 336 failed (check: 128), 416 passed (check: 101), 5 skipped.
Executing test 758 (bugs): declare soft and throw statements
Failed. Current status: 337 failed (check: 128), 416 passed (check: 101), 5 skipped.
Executing test 759 (bugs/interAbstract): inter-type declaration bug with abstract classes
Failed. Current status: 338 failed (check: 128), 416 passed (check: 101), 5 skipped.
Executing test 760 (bugs/interInherit): Inter type declaration to base class not seen by derived class
================================================
Breakdown of abc phases  (total: 6942 millisec.)
------------------------------------------------
[ 00.519% ] Init. of Soot:  36
[ 00.058% ] Loading Jars:  4
[ 75.900% ] Polyglot phases:  5269
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.432% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 07.289% ] Intertype Adjuster:  506
[ 05.258% ] Retrieving bodies:  365
[ 00.014% ] Weave Initializers:  1
[ 00.303% ] Load shadow types:  21
[ 02.175% ] Compute advice lists:  151
[ 00.043% ] Intertype weave:  3
[ 00.461% ] Add aspect code:  32
[ 00.187% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.077% ] Soot Packs:  283
[ 03.227% ] Soot Writing Output:  224
================================================
Abc started on Thu Jun 24 09:54:57 BST 2004
<<<< AImpl.java >>>>
package a_impl;

import a_intf.A;

public class AImpl implements a_intf.A {
    public AImpl() { super(); }
}
<<<< B.java >>>>
package b_intf;

import a_intf.A;

public interface B extends a_intf.A {
    public abstract b_intf.B g();
}
<<<< Af.java >>>>
package a_impl;

import a_intf.A;

aspect Af {
    public intertype a_intf.A a_impl.AImpl.f() {
        java.lang.System/*java.lang.System*/.out.println("f called");
        return null;
    }
    
    public static a_impl.Af aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Af() { super(); }
}
<<<< BImpl.java >>>>
package b_impl;

import a_impl.AImpl;
import b_intf.B;

public class BImpl extends a_impl.AImpl implements b_intf.B {
    public b_intf.B g() {
        java.lang.System/*java.lang.System*/.out.println("g called");
        return null;
    }
    
    public static void main(java.lang.String[] args) {
        new b_impl.BImpl().g();
        new b_impl.BImpl().f();
    }
    
    public BImpl() { super(); }
}
<<<< A.java >>>>
package a_intf;

public interface A {
    public abstract a_intf.A f();
}
retrieve <a_impl.AImpl: a_intf.A f()> from a_impl.AImpl
retrieve <a_impl.AImpl: void <init>()> from a_impl.AImpl
retrieve <a_impl.Af: a_intf.A f(a_impl.AImpl)> from a_impl.Af
retrieve <a_impl.Af: a_impl.Af aspectOf()> from a_impl.Af
retrieve <a_impl.Af: boolean hasAspect()> from a_impl.Af
retrieve <a_impl.Af: void <init>()> from a_impl.Af
retrieve <b_impl.BImpl: void main(java.lang.String[])> from b_impl.BImpl
retrieve <b_impl.BImpl: b_intf.B g()> from b_impl.BImpl
retrieve <b_impl.BImpl: void <init>()> from b_impl.BImpl
Transforming a_intf.A... 
Transforming b_impl.BImpl... 
Transforming b_intf.B... 
Transforming a_impl.AImpl... 
Transforming a_impl.Af... 
Abc finished on Thu Jun 24 09:55:04 BST 2004. ( 0 min. 7 sec. )
g called
f called
PASS: Inter type declaration to base class not seen by derived class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 338 failed (check: 128), 417 passed (check: 101), 5 skipped.
Executing test 761 (new/declareParents): Declare parents with intermediate ancestor
Failed. Current status: 339 failed (check: 128), 417 passed (check: 101), 5 skipped.
Executing test 762 (new/declareParents): Declare parents removing ancestor
Failed. Current status: 340 failed (check: 129), 417 passed (check: 101), 5 skipped.
Executing test 763 (options/injars/simple): options -injars checking declare parents interactions
Failed. Current status: 341 failed (check: 129), 417 passed (check: 101), 5 skipped.
Executing test 764 (bugs/interSpecials): IllegalAccessError while accessing introduced variable / 1.1rc1
================================================
Breakdown of abc phases  (total: 6795 millisec.)
------------------------------------------------
[ 00.545% ] Init. of Soot:  37
[ 00.044% ] Loading Jars:  3
[ 74.790% ] Polyglot phases:  5082
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.486% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 02.163% ] Intertype Adjuster:  147
[ 06.696% ] Retrieving bodies:  455
[ 00.000% ] Weave Initializers:  0
[ 00.383% ] Load shadow types:  26
[ 05.372% ] Compute advice lists:  365
[ 00.044% ] Intertype weave:  3
[ 00.177% ] Add aspect code:  12
[ 01.118% ] Weaving advice:  76
[ 00.000% ] Validate jimple:  0
[ 04.283% ] Soot Packs:  291
[ 03.841% ] Soot Writing Output:  261
================================================
Failed. Current status: 342 failed (check: 129), 417 passed (check: 101), 5 skipped.
Executing test 765 (bugs/interSpecials): testing that assert works like .class
Failed. Current status: 343 failed (check: 129), 417 passed (check: 101), 5 skipped.
Executing test 766 (new): implemented abstract pointcut
Abc started on Thu Jun 24 09:55:33 BST 2004
<<<< AbstractImplementedPointcut.java >>>>
public class AbstractImplementedPointcut {
    public static void main(java.lang.String[] args) { new C().go(); }
    
    public AbstractImplementedPointcut() { super(); }
}
class C {
    void go() {  }
    
    public C() { super(); }
}
abstract aspect A {
    abstract pointcut pc() : call(void (*).go());
    
    public A() { super(); }
}
aspect B extends A {
    pointcut pc() : call(void (*).go());
    
    before(): pc() { throw new java.lang.Error("do not run"); }
    
    public static B aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public B() { super(); }
}
PASS: implemented abstract pointcut()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 343 failed (check: 129), 418 passed (check: 102), 5 skipped.
Executing test 767 (new/verifyError): privileged aspect main verify error
Failed. Current status: 344 failed (check: 129), 418 passed (check: 102), 5 skipped.
Executing test 768 (bugs): Internal compiler error with thisJoinPoint.getStaticPart()
Failed. Current status: 345 failed (check: 129), 418 passed (check: 102), 5 skipped.
Executing test 769 (bugs): Inconsistant stack height with around
================================================
Breakdown of abc phases  (total: 7346 millisec.)
------------------------------------------------
[ 00.504% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 77.090% ] Polyglot phases:  5663
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.667% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.504% ] Intertype Adjuster:  37
[ 07.473% ] Retrieving bodies:  549
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 03.771% ] Compute advice lists:  277
[ 00.041% ] Intertype weave:  3
[ 00.558% ] Add aspect code:  41
[ 01.048% ] Weaving advice:  77
[ 00.000% ] Validate jimple:  0
[ 04.438% ] Soot Packs:  326
[ 03.512% ] Soot Writing Output:  258
================================================
Abc started on Thu Jun 24 09:55:45 BST 2004
<<<< StackError.java >>>>
import java.lang.reflect.Method;

public class StackError {
    public static void main(java.lang.String[] args) {
        new StackError().testEqualsNull();
    }
    
    void assertTrue(java.lang.String msg, boolean b) {  }
    
    public void testEqualsNull() {
        StackError one = new StackError();
        StackError two = new StackError();
        assertTrue("equal", one.equals(two));
    }
    
    public boolean equals(java.lang.Object other) { return true; }
    
    public StackError() { super(); }
}
aspect EqualsContract {
    pointcut equalsCall(java.lang.Object thisOne,
                        java.lang.Object otherOne) :
    target(java.lang.Object) && target(thisOne) &&
      call(public boolean (*).equals(Object+)) &&
      args(otherOne) &&
      !within(EqualsContract);
    
    boolean around (Object thisOne, Object otherOne):
    equalsCall(thisOne,
        otherOne) {
        boolean result = this.proceed(thisOne, otherOne);
        java.lang.Class cls = thisOne.getClass();
        java.lang.String name = cls.getName();
        boolean hasHashCode = false;
        try {
            java.lang.reflect.Method m =
              cls.getDeclaredMethod("hashCode", null);
            java.lang.String lookFor =
              "public int " + name +
            ".hashCode()";
            hasHashCode = lookFor.equals(m.toString());
        }
        catch (java.lang.NoSuchMethodException nsme) {  }
        return result;
    }
    
    public static EqualsContract aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public EqualsContract() { super(); }
}
retrieve <StackError: void main(java.lang.String[])> from StackError
retrieve <StackError: void assertTrue(java.lang.String,boolean)> from StackError
retrieve <StackError: void testEqualsNull()> from StackError
retrieve <StackError: boolean equals(java.lang.Object)> from StackError
retrieve <StackError: void <init>()> from StackError
retrieve <EqualsContract: boolean around$0(java.lang.Object,java.lang.Object)> from EqualsContract
retrieve <EqualsContract: EqualsContract aspectOf()> from EqualsContract
retrieve <EqualsContract: boolean hasAspect()> from EqualsContract
retrieve <EqualsContract: void <init>()> from EqualsContract
retrieve <EqualsContract: boolean proceed$1(java.lang.Object,java.lang.Object)> from EqualsContract
Transforming StackError... 
Transforming EqualsContract... 
Transforming abc$access$EqualsContract$around$0... 
Abc finished on Thu Jun 24 09:55:52 BST 2004. ( 0 min. 7 sec. )
PASS: Inconsistant stack height with around()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 345 failed (check: 129), 419 passed (check: 102), 5 skipped.
Executing test 770 (bugs/messyAround): Ajc 1.1 rc1 java.lang.VerifyError with messy arounds
Failed. Current status: 346 failed (check: 130), 419 passed (check: 102), 5 skipped.
Executing test 771 (new): try/finally in around advice (same as ...messy arounds?)
Failed. Current status: 347 failed (check: 130), 419 passed (check: 102), 5 skipped.
Executing test 772 (new): advise join points in subclass of empty interface
Failed. Current status: 348 failed (check: 130), 419 passed (check: 102), 5 skipped.
Executing test 773 (new): can't put around advice on interface static initializer
Failed. Current status: 349 failed (check: 131), 419 passed (check: 102), 5 skipped.
Executing test 774 (bugs): cflow concretization causing assertion failure
getting SJPInfo for a untagged source line return
================================================
Breakdown of abc phases  (total: 6954 millisec.)
------------------------------------------------
[ 00.561% ] Init. of Soot:  39
[ 00.043% ] Loading Jars:  3
[ 75.568% ] Polyglot phases:  5255
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.661% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.518% ] Intertype Adjuster:  36
[ 06.773% ] Retrieving bodies:  471
[ 00.014% ] Weave Initializers:  1
[ 00.302% ] Load shadow types:  21
[ 02.301% ] Compute advice lists:  160
[ 00.043% ] Intertype weave:  3
[ 00.748% ] Add aspect code:  52
[ 01.625% ] Weaving advice:  113
[ 00.000% ] Validate jimple:  0
[ 06.744% ] Soot Packs:  469
[ 04.041% ] Soot Writing Output:  281
================================================
Failed. Current status: 350 failed (check: 131), 419 passed (check: 102), 5 skipped.
Executing test 775 (new/options11): The compiler crashes when using aspect libraries created without using -noweave
Failed. Current status: 351 failed (check: 132), 419 passed (check: 102), 5 skipped.
Executing test 776 (bugs): lame error message: negation doesn't allow binding
Abc started on Thu Jun 24 09:56:35 BST 2004
<<<< BadBindingError.java >>>>
import org.aspectj.testing.Tester;

public aspect BadBindingError {
    pointcut p(int i) : call(void (*).f(i));
    
    public static BadBindingError aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public BadBindingError() { super(); }
}
PASS: lame error message: negation doesn't allow binding()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 351 failed (check: 132), 420 passed (check: 103), 5 skipped.
Executing test 777 (bugs/interSpecials): Error when introducing members of type Class
================================================
Breakdown of abc phases  (total: 6287 millisec.)
------------------------------------------------
[ 00.573% ] Init. of Soot:  36
[ 00.064% ] Loading Jars:  4
[ 79.163% ] Polyglot phases:  4977
[ 00.032% ] Resolve class names:  2
[ 00.032% ] Declare Parents:  2
[ 00.461% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 00.875% ] Intertype Adjuster:  55
[ 07.762% ] Retrieving bodies:  488
[ 00.207% ] Weave Initializers:  13
[ 00.334% ] Load shadow types:  21
[ 03.102% ] Compute advice lists:  195
[ 00.048% ] Intertype weave:  3
[ 00.191% ] Add aspect code:  12
[ 00.191% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.595% ] Soot Packs:  226
[ 03.372% ] Soot Writing Output:  212
================================================
Abc started on Thu Jun 24 09:56:39 BST 2004
<<<< Trg.java >>>>
public class Trg {
    public static void main(java.lang.String[] args) {
        new Trg();
        java.lang.System/*java.lang.System*/.out.println("All ok");
    }
    
    public Trg() { super(); }
}
<<<< Asp.java >>>>
public aspect Asp {
    public java.lang.Class Trg.member = java.lang.String.class;
    
    public static Asp aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Asp() { super(); }
}
retrieve <Trg: void <init>()> from Trg
retrieve <Trg: void main(java.lang.String[])> from Trg
retrieve <Asp: java.lang.Class class$(java.lang.String)> from Asp
retrieve <Asp: Asp aspectOf()> from Asp
retrieve <Asp: boolean hasAspect()> from Asp
retrieve <Asp: void <init>()> from Asp
retrieve <Asp: java.lang.Class init$member$2(Trg)> from Asp
Transforming Asp... 
Transforming Trg... 
Abc finished on Thu Jun 24 09:56:46 BST 2004. ( 0 min. 6 sec. )
All ok
PASS: Error when introducing members of type Class()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 351 failed (check: 132), 421 passed (check: 103), 5 skipped.
Executing test 778 (new): arrays via Class.forName()
getting SJPInfo for a untagged source line $r0 = <ClassForName: java.lang.Class class$java$lang$String[]>
================================================
Breakdown of abc phases  (total: 7159 millisec.)
------------------------------------------------
[ 00.503% ] Init. of Soot:  36
[ 00.056% ] Loading Jars:  4
[ 77.916% ] Polyglot phases:  5578
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.461% ] Recompute name pattern matches:  33
[ 00.000% ] Compute precedence relation:  0
[ 00.489% ] Intertype Adjuster:  35
[ 07.250% ] Retrieving bodies:  519
[ 00.000% ] Weave Initializers:  0
[ 00.307% ] Load shadow types:  22
[ 04.903% ] Compute advice lists:  351
[ 00.056% ] Intertype weave:  4
[ 00.196% ] Add aspect code:  14
[ 01.104% ] Weaving advice:  79
[ 00.000% ] Validate jimple:  0
[ 03.548% ] Soot Packs:  254
[ 03.157% ] Soot Writing Output:  226
================================================
Failed. Current status: 352 failed (check: 132), 421 passed (check: 103), 5 skipped.
Executing test 779 (new/binaryWarnings/src): declare warnings on main
================================================
Breakdown of abc phases  (total: 7515 millisec.)
------------------------------------------------
[ 00.399% ] Init. of Soot:  30
[ 00.133% ] Loading Jars:  10
[ 72.974% ] Polyglot phases:  5484
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.399% ] Recompute name pattern matches:  30
[ 00.000% ] Compute precedence relation:  0
[ 00.745% ] Intertype Adjuster:  56
[ 08.144% ] Retrieving bodies:  612
[ 00.000% ] Weave Initializers:  0
[ 00.333% ] Load shadow types:  25
[ 04.152% ] Compute advice lists:  312
[ 00.040% ] Intertype weave:  3
[ 00.173% ] Add aspect code:  13
[ 00.173% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.022% ] Soot Packs:  678
[ 03.260% ] Soot Writing Output:  245
================================================
Failed. Current status: 353 failed (check: 132), 421 passed (check: 103), 5 skipped.
Executing test 780 (new/binaryWarnings/src): declare warnings on binary javac 1.4 classes
Failed. Current status: 354 failed (check: 132), 421 passed (check: 103), 5 skipped.
Executing test 781 (new/binaryWarnings/src): declare warnings on binary ajc 1.1 classes
Failed. Current status: 355 failed (check: 132), 421 passed (check: 103), 5 skipped.
Executing test 782 (new/binaryWarnings/src): declare error on handler/method execution with no code on binary ajc 1.1 classes
Failed. Current status: 356 failed (check: 133), 421 passed (check: 103), 5 skipped.
Executing test 783 (new/binaryWarnings/src): declare error on handler/method execution with no code on binary javac 1.4 classes
Failed. Current status: 357 failed (check: 134), 421 passed (check: 103), 5 skipped.
Executing test 784 (incremental/initialTests/classAdded): expect class added in initial incremental tests
Failed. Current status: 358 failed (check: 134), 421 passed (check: 103), 5 skipped.
Executing test 785 (incremental/initialTests/classRemoved): expect class removed in initial incremental tests
Failed. Current status: 359 failed (check: 134), 421 passed (check: 103), 5 skipped.
Executing test 786 (incremental/initialTests/classUpdated): expect class updated in initial incremental tests
Failed. Current status: 360 failed (check: 134), 421 passed (check: 103), 5 skipped.
Executing test 787 (incremental/initialTests/sourceAdded): add file with class
Failed. Current status: 361 failed (check: 134), 421 passed (check: 103), 5 skipped.
Executing test 788 (incremental/initialTests/sourceDeleted): delete source file before incremental compile
Failed. Current status: 362 failed (check: 135), 421 passed (check: 103), 5 skipped.
Executing test 789 (incremental/initialTests/expClasses): expected class tree
================================================
Breakdown of abc phases  (total: 6264 millisec.)
------------------------------------------------
[ 00.479% ] Init. of Soot:  30
[ 00.080% ] Loading Jars:  5
[ 79.358% ] Polyglot phases:  4971
[ 00.016% ] Resolve class names:  1
[ 00.032% ] Declare Parents:  2
[ 00.702% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.607% ] Intertype Adjuster:  38
[ 12.516% ] Retrieving bodies:  784
[ 00.000% ] Weave Initializers:  0
[ 00.351% ] Load shadow types:  22
[ 00.718% ] Compute advice lists:  45
[ 00.048% ] Intertype weave:  3
[ 00.128% ] Add aspect code:  8
[ 00.192% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 02.267% ] Soot Packs:  142
[ 02.506% ] Soot Writing Output:  157
================================================
Failed. Current status: 363 failed (check: 135), 421 passed (check: 103), 5 skipped.
Executing test 790 (incremental/initialTests/defaultPackage): do everything in default package (sourceroots)
Failed. Current status: 364 failed (check: 136), 421 passed (check: 103), 5 skipped.
Executing test 791 (bugs/inlineAround): perthis and inline arounds
Failed. Current status: 365 failed (check: 136), 421 passed (check: 103), 5 skipped.
Executing test 792 (incremental/defaultPackage): change sources in default package
Failed. Current status: 366 failed (check: 136), 421 passed (check: 103), 5 skipped.
Executing test 793 (incremental/interPackage): change source
Failed. Current status: 367 failed (check: 136), 421 passed (check: 103), 5 skipped.
Executing test 794 (bugs): Weaver fails with NPE for very large source files 
================================================
Breakdown of abc phases  (total: 7221 millisec.)
------------------------------------------------
[ 00.512% ] Init. of Soot:  37
[ 00.042% ] Loading Jars:  3
[ 78.853% ] Polyglot phases:  5694
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.734% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.499% ] Intertype Adjuster:  36
[ 06.772% ] Retrieving bodies:  489
[ 00.000% ] Weave Initializers:  0
[ 00.305% ] Load shadow types:  22
[ 03.171% ] Compute advice lists:  229
[ 00.042% ] Intertype weave:  3
[ 00.499% ] Add aspect code:  36
[ 01.357% ] Weaving advice:  98
[ 00.000% ] Validate jimple:  0
[ 03.975% ] Soot Packs:  287
[ 03.185% ] Soot Writing Output:  230
================================================
done it
Abc started on Thu Jun 24 09:58:15 BST 2004
<<<< LongFile.java >>>>
import org.aspectj.testing.Tester;

public class LongFile {
    public static void main(java.lang.String[] args) { doit(); }
    
    static aspect A {
        before():
        execution (* (LongFile).doit()) {
            int line = thisJoinPoint.getSourceLocation().getLine();
            java.lang.System/*java.lang.System*/.out.println("line: " +
                                                             line);
            org.aspectj.testing.Tester.checkEqual(33000,
                                                  line,
                                                  "line number");
        }
        
        public static LongFile.A aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public A() { super(); }
    }
    
    
    public static void doit() {
        java.lang.System/*java.lang.System*/.err.println("done it");
    }
    
    public LongFile() { super(); }
}
retrieve <LongFile: void main(java.lang.String[])> from LongFile
retrieve <LongFile: void doit()> from LongFile
retrieve <LongFile: void <init>()> from LongFile
retrieve <LongFile$A: void before$0(org.aspectj.lang.JoinPoint)> from LongFile$A
retrieve <LongFile$A: LongFile$A aspectOf()> from LongFile$A
retrieve <LongFile$A: boolean hasAspect()> from LongFile$A
retrieve <LongFile$A: void <init>()> from LongFile$A
Transforming LongFile... 
Transforming LongFile$A... 
Abc finished on Thu Jun 24 09:58:22 BST 2004. ( 0 min. 7 sec. )
line: 33000
PASS: Weaver fails with NPE for very large source files ()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 367 failed (check: 136), 422 passed (check: 103), 5 skipped.
Executing test 795 (harness): CLE: -help usage
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(1 options 1 messages)" because missed values: [0: -help]
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 367 failed (check: 136), 422 passed (check: 103), 6 skipped.
Executing test 796 (harness): CLE: no sources
PASS: CLE: no sources()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 0 seconds
Passed. Current status: 367 failed (check: 136), 423 passed (check: 104), 6 skipped.
Executing test 797 (harness): CLE: bad filename
PASS: CLE: bad filename()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 0 seconds
Passed. Current status: 367 failed (check: 136), 424 passed (check: 105), 6 skipped.
Executing test 798 (harness): CLE: no dir specified for sourceroots
runMain(tmp.xml, [])
skip - MessageHolder:  (1 info) 
skip - [info   0]: info skipping "CompilerRun.Spec AbcCommand(1 options 1 paths 3 messages)" because missed values: [0: -sourceroots]
skip - MessageHolder:  (1 info) 
PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 skipped) 0 seconds
Skipped.
Current status: 367 failed (check: 136), 424 passed (check: 105), 7 skipped.
Executing test 799 (harness): CLE: no sourceroot specified for incremental
PASS: CLE: no sourceroot specified for incremental()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 0 seconds
Passed. Current status: 367 failed (check: 136), 425 passed (check: 106), 7 skipped.
Executing test 800 (harness): CLE: file specified with incremental
PASS: CLE: file specified with incremental()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 0 seconds
Passed. Current status: 367 failed (check: 136), 426 passed (check: 107), 7 skipped.
Executing test 801 (bugs): Unexpected Xlint:unresolvableMember warning with withincode
Failed. Current status: 368 failed (check: 136), 426 passed (check: 107), 7 skipped.
Executing test 802 (bugs): public static fields being ignored
================================================
Breakdown of abc phases  (total: 6757 millisec.)
------------------------------------------------
[ 00.533% ] Init. of Soot:  36
[ 00.059% ] Loading Jars:  4
[ 78.674% ] Polyglot phases:  5316
[ 00.015% ] Resolve class names:  1
[ 00.030% ] Declare Parents:  2
[ 00.725% ] Recompute name pattern matches:  49
[ 00.000% ] Compute precedence relation:  0
[ 00.548% ] Intertype Adjuster:  37
[ 07.814% ] Retrieving bodies:  528
[ 00.000% ] Weave Initializers:  0
[ 00.326% ] Load shadow types:  22
[ 04.543% ] Compute advice lists:  307
[ 00.044% ] Intertype weave:  3
[ 00.133% ] Add aspect code:  9
[ 00.178% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.226% ] Soot Packs:  218
[ 03.152% ] Soot Writing Output:  213
================================================
Abc started on Thu Jun 24 09:58:42 BST 2004
<<<< FinalFields.java >>>>
import java.io.Serializable;
import java.lang.reflect.*;

public class FinalFields implements java.io.Serializable {
    public static final java.lang.Integer SUCCESS =
      new java.lang.Integer(0);
    
    public static void main(java.lang.String[] args)
          throws java.lang.Exception {
        java.lang.Class c = FinalFields.class;
        java.lang.reflect.Field f = c.getDeclaredField("SUCCESS");
        int mods = f.getModifiers();
        java.lang.System/*java.lang.System*/.out.println("modifers are: " +
                                                         java.lang.reflect.Modifier.toString(mods));
        if (!java.lang.reflect.Modifier.isFinal(mods))
            throw new java.lang.RuntimeException("modifier should be final");
        if (!java.lang.reflect.Modifier.isPublic(mods))
            throw new java.lang.RuntimeException("modifier should be public");
        if (!java.lang.reflect.Modifier.isStatic(mods))
            throw new java.lang.RuntimeException("modifier should be static");
    }
    
    public FinalFields() { super(); }
}
retrieve <FinalFields: java.lang.Class class$(java.lang.String)> from FinalFields
retrieve <FinalFields: void main(java.lang.String[])> from FinalFields
retrieve <FinalFields: void <init>()> from FinalFields
retrieve <FinalFields: void <clinit>()> from FinalFields
Transforming FinalFields... 
Abc finished on Thu Jun 24 09:58:49 BST 2004. ( 0 min. 6 sec. )
modifers are: public static final
PASS: public static fields being ignored()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 368 failed (check: 136), 427 passed (check: 107), 7 skipped.
Executing test 803 (bugs/lines): Weaving rt.jar results in stack overflow
Failed. Current status: 369 failed (check: 136), 427 passed (check: 107), 7 skipped.
Executing test 804 (harness): setting -warn:constructorName works
Failed. Current status: 370 failed (check: 137), 427 passed (check: 107), 7 skipped.
Executing test 805 (harness): valid XLintWarningTest file, default level of warning
================================================
Breakdown of abc phases  (total: 6206 millisec.)
------------------------------------------------
[ 00.564% ] Init. of Soot:  35
[ 00.064% ] Loading Jars:  4
[ 80.841% ] Polyglot phases:  5017
[ 00.048% ] Resolve class names:  3
[ 00.016% ] Declare Parents:  1
[ 00.854% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.596% ] Intertype Adjuster:  37
[ 07.283% ] Retrieving bodies:  452
[ 00.000% ] Weave Initializers:  0
[ 00.354% ] Load shadow types:  22
[ 01.370% ] Compute advice lists:  85
[ 00.048% ] Intertype weave:  3
[ 00.773% ] Add aspect code:  48
[ 00.193% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.948% ] Soot Packs:  245
[ 03.045% ] Soot Writing Output:  189
================================================
Failed. Current status: 371 failed (check: 138), 427 passed (check: 107), 7 skipped.
Executing test 806 (harness): XLint:ignore suppresses XLint warnings
Illegal arguments: Unknown option -Xlint:ignore
PASS: XLint:ignore suppresses XLint warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 371 failed (check: 138), 428 passed (check: 107), 7 skipped.
Executing test 807 (harness): XLint:error promotes XLint warnings to error
Failed. Current status: 372 failed (check: 139), 428 passed (check: 107), 7 skipped.
Executing test 808 (new/binaryWarnings/src): declare warnings on main - constructor execution
================================================
Breakdown of abc phases  (total: 6958 millisec.)
------------------------------------------------
[ 00.431% ] Init. of Soot:  30
[ 00.072% ] Loading Jars:  5
[ 76.717% ] Polyglot phases:  5338
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.604% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.517% ] Intertype Adjuster:  36
[ 08.867% ] Retrieving bodies:  617
[ 00.000% ] Weave Initializers:  0
[ 00.302% ] Load shadow types:  21
[ 04.556% ] Compute advice lists:  317
[ 00.043% ] Intertype weave:  3
[ 00.201% ] Add aspect code:  14
[ 00.216% ] Weaving advice:  15
[ 00.000% ] Validate jimple:  0
[ 03.924% ] Soot Packs:  273
[ 03.492% ] Soot Writing Output:  243
================================================
Failed. Current status: 373 failed (check: 140), 428 passed (check: 107), 7 skipped.
Executing test 809 (new/binaryWarnings/src): declare warnings on binary javac 1.4 main - constructor execution
Failed. Current status: 374 failed (check: 141), 428 passed (check: 107), 7 skipped.
Executing test 810 (new/binaryWarnings/src): declare warnings on binary ajc 1.1 main - constructor execution
Failed. Current status: 375 failed (check: 142), 428 passed (check: 107), 7 skipped.
Executing test 811 (bugs/handlers): advice on handler join points should not throw unpermitted checked exceptions
================================================
Breakdown of abc phases  (total: 6424 millisec.)
------------------------------------------------
[ 00.545% ] Init. of Soot:  35
[ 00.047% ] Loading Jars:  3
[ 80.962% ] Polyglot phases:  5201
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.716% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.560% ] Intertype Adjuster:  36
[ 08.422% ] Retrieving bodies:  541
[ 00.000% ] Weave Initializers:  0
[ 00.327% ] Load shadow types:  21
[ 00.950% ] Compute advice lists:  61
[ 00.047% ] Intertype weave:  3
[ 00.233% ] Add aspect code:  15
[ 00.451% ] Weaving advice:  29
[ 00.000% ] Validate jimple:  0
[ 03.425% ] Soot Packs:  220
[ 03.253% ] Soot Writing Output:  209
================================================
Failed. Current status: 376 failed (check: 143), 428 passed (check: 107), 7 skipped.
Executing test 812 (incremental/stringliteral): incrementally change only string literal, still expect advice
Failed. Current status: 377 failed (check: 143), 428 passed (check: 107), 7 skipped.
Executing test 813 (harness): -nowarn suppresses XLint warnings
Illegal arguments: Unknown option -nowarn
PASS: -nowarn suppresses XLint warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 377 failed (check: 143), 429 passed (check: 107), 7 skipped.
Executing test 814 (harness): warn:none suppresses XLint warnings
Illegal arguments: Unknown option -warn:none
PASS: warn:none suppresses XLint warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 377 failed (check: 143), 430 passed (check: 107), 7 skipped.
Executing test 815 (harness): -nowarn suppresses declare warnings
Illegal arguments: Unknown option -nowarn
PASS: -nowarn suppresses declare warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 377 failed (check: 143), 431 passed (check: 107), 7 skipped.
Executing test 816 (harness): -warn:none suppresses declare warnings
Illegal arguments: Unknown option -warn:none
PASS: -warn:none suppresses declare warnings()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 377 failed (check: 143), 432 passed (check: 107), 7 skipped.
Executing test 817 (bugs): insertion of lots of advice code can make branch offset for if too large
Failed. Current status: 378 failed (check: 143), 432 passed (check: 107), 7 skipped.
Executing test 818 (bugs/accessMethods): can not resolve this member warning
================================================
Breakdown of abc phases  (total: 6672 millisec.)
------------------------------------------------
[ 00.540% ] Init. of Soot:  36
[ 00.060% ] Loading Jars:  4
[ 76.769% ] Polyglot phases:  5122
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.659% ] Recompute name pattern matches:  44
[ 00.015% ] Compute precedence relation:  1
[ 00.525% ] Intertype Adjuster:  35
[ 07.389% ] Retrieving bodies:  493
[ 00.000% ] Weave Initializers:  0
[ 00.330% ] Load shadow types:  22
[ 04.257% ] Compute advice lists:  284
[ 00.045% ] Intertype weave:  3
[ 00.615% ] Add aspect code:  41
[ 00.375% ] Weaving advice:  25
[ 00.000% ] Validate jimple:  0
[ 04.706% ] Soot Packs:  314
[ 03.657% ] Soot Writing Output:  244
================================================
Failed. Current status: 379 failed (check: 143), 432 passed (check: 107), 7 skipped.
Executing test 819 (bugs): try switch VerifyError, InconsistentStackHeight
================================================
Breakdown of abc phases  (total: 6246 millisec.)
------------------------------------------------
[ 00.576% ] Init. of Soot:  36
[ 00.064% ] Loading Jars:  4
[ 79.331% ] Polyglot phases:  4955
[ 00.016% ] Resolve class names:  1
[ 00.016% ] Declare Parents:  1
[ 00.688% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 00.608% ] Intertype Adjuster:  38
[ 08.950% ] Retrieving bodies:  559
[ 00.000% ] Weave Initializers:  0
[ 00.352% ] Load shadow types:  22
[ 02.626% ] Compute advice lists:  164
[ 00.048% ] Intertype weave:  3
[ 00.144% ] Add aspect code:  9
[ 00.192% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.202% ] Soot Packs:  200
[ 03.186% ] Soot Writing Output:  199
================================================
caught: java.lang.RuntimeException
Abc started on Thu Jun 24 10:02:17 BST 2004
<<<< TrySwitch.java >>>>
public class TrySwitch {
    public static void main(java.lang.String[] args)
          throws java.lang.Throwable {
        m(10);
    }
    
    static boolean done = true;
    
    static int m(int i) {
        try {
            switch (i) {
                default:
                    return 10;
                case 10:
                    if (false) {
                        break;
                    } else {
                        throw new java.lang.RuntimeException();
                    }
                case 11:
                    break;
            }
        }
        catch (java.lang.Throwable e) {
            java.lang.System/*java.lang.System*/.err.println("caught: " +
                                                             e);
        }
        return 33;
    }
    
    public TrySwitch() { super(); }
}
retrieve <TrySwitch: void main(java.lang.String[])> from TrySwitch
retrieve <TrySwitch: int m(int)> from TrySwitch
retrieve <TrySwitch: void <init>()> from TrySwitch
retrieve <TrySwitch: void <clinit>()> from TrySwitch
Transforming TrySwitch... 
Abc finished on Thu Jun 24 10:02:23 BST 2004. ( 0 min. 6 sec. )
PASS: try switch VerifyError, InconsistentStackHeight()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 379 failed (check: 143), 433 passed (check: 107), 7 skipped.
Executing test 820 (bugs): Compiler crash in ajc 1.1 - terrible error for inaccessible constructor
Failed. Current status: 380 failed (check: 144), 433 passed (check: 107), 7 skipped.
Executing test 821 (bugs): Missing import crashes compiler
Abc started on Thu Jun 24 10:02:30 BST 2004
PASS: Missing import crashes compiler()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 380 failed (check: 144), 434 passed (check: 108), 7 skipped.
Executing test 822 (bugs): NPE in bcel.LazyMethodGen when delegating from one ctor to a second that includes a switch
Failed. Current status: 381 failed (check: 144), 434 passed (check: 108), 7 skipped.
Executing test 823 (bugs): switch statement in aspects crashes weaving
================================================
Breakdown of abc phases  (total: 7239 millisec.)
------------------------------------------------
[ 00.511% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 73.145% ] Polyglot phases:  5295
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.718% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.497% ] Intertype Adjuster:  36
[ 06.769% ] Retrieving bodies:  490
[ 00.000% ] Weave Initializers:  0
[ 00.304% ] Load shadow types:  22
[ 02.666% ] Compute advice lists:  193
[ 00.041% ] Intertype weave:  3
[ 00.428% ] Add aspect code:  31
[ 01.312% ] Weaving advice:  95
[ 00.000% ] Validate jimple:  0
[ 04.172% ] Soot Packs:  302
[ 09.338% ] Soot Writing Output:  676
================================================
Abc started on Thu Jun 24 10:02:43 BST 2004
<<<< SwitchInAround.java >>>>
import org.aspectj.testing.Tester;

public class SwitchInAround {
    public static void main(java.lang.String[] args) {
        SwitchInAround o = new SwitchInAround();
        org.aspectj.testing.Tester.checkEqual(o.doit(1), "1");
        org.aspectj.testing.Tester.checkEqual(o.doit(2), "2");
        org.aspectj.testing.Tester.checkEqual(o.doit(3), "default");
    }
    
    public java.lang.String doit(int i) { return "doit"; }
    
    public SwitchInAround() { super(); }
}
privilegedaspect aspect A {
    String around (int index):
    args(index) &&
      call(String (*).doit(int)) {
        switch (index) {
            case 1:
                return "1";
            case 2:
                return "2";
            default:
                return "default";
        }
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <SwitchInAround: void main(java.lang.String[])> from SwitchInAround
retrieve <SwitchInAround: java.lang.String doit(int)> from SwitchInAround
retrieve <SwitchInAround: void <init>()> from SwitchInAround
retrieve <A: java.lang.String around$0(int)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: java.lang.String proceed$1(int)> from A
Transforming A... 
Transforming SwitchInAround... 
Transforming abc$access$A$around$0... 
Abc finished on Thu Jun 24 10:02:51 BST 2004. ( 0 min. 7 sec. )
PASS: switch statement in aspects crashes weaving()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 381 failed (check: 144), 435 passed (check: 108), 7 skipped.
Executing test 824 (bugs): ajc stack trace on declaring hashcode() method in aspect
Failed. Current status: 382 failed (check: 144), 435 passed (check: 108), 7 skipped.
Executing test 825 (bugs): using super in method introduced on interface with multiple supertypes
Abc started on Thu Jun 24 10:02:57 BST 2004
<<<< MultipleSuperCf.java >>>>
import org.aspectj.testing.Tester;

interface B1 {}
interface B2 {}
interface D extends B1, B2 {}
aspect A {
    public intertype int B1.m() { return 2; }
    
    public intertype int D.m() { return hostDsuper.m(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
PASS: using super in method introduced on interface with multiple supertypes()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 382 failed (check: 144), 436 passed (check: 109), 7 skipped.
Executing test 826 (bugs/cflowAndJar): Compiler crashes in jar and cflow (with no .jar)
Failed. Current status: 383 failed (check: 145), 436 passed (check: 109), 7 skipped.
Executing test 827 (bugs/cflowAndJar): Compiler crashes in jar and cflow (with .jar)
Failed. Current status: 384 failed (check: 146), 436 passed (check: 109), 7 skipped.
Executing test 828 (bugs): Default method impl for interface causes internal exception.
Failed. Current status: 385 failed (check: 146), 436 passed (check: 109), 7 skipped.
Executing test 829 (bugs): Class Literals as non final fields (also assert, and this$0)
Failed. Current status: 386 failed (check: 146), 436 passed (check: 109), 7 skipped.
Executing test 830 (errors): compile error expected for abstract pointcut outside abstract aspect
Failed. Current status: 387 failed (check: 147), 436 passed (check: 109), 7 skipped.
Executing test 831 (bugs): subtype-qualified pointcut reference
================================================
Breakdown of abc phases  (total: 7320 millisec.)
------------------------------------------------
[ 00.505% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 72.281% ] Polyglot phases:  5291
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.642% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 00.492% ] Intertype Adjuster:  36
[ 06.708% ] Retrieving bodies:  491
[ 00.000% ] Weave Initializers:  0
[ 00.301% ] Load shadow types:  22
[ 03.716% ] Compute advice lists:  272
[ 00.041% ] Intertype weave:  3
[ 00.533% ] Add aspect code:  39
[ 01.407% ] Weaving advice:  103
[ 00.000% ] Validate jimple:  0
[ 07.923% ] Soot Packs:  580
[ 05.355% ] Soot Writing Output:  392
================================================
Abc started on Thu Jun 24 10:03:17 BST 2004
<<<< PointcutLibraryTest.java >>>>
public class PointcutLibraryTest {
    public static void main(java.lang.String[] a) {
        new Test().run();
    }
    
    public PointcutLibraryTest() { super(); }
}
class Test {
    public void run() { prun(); }
    
    private void prun() {
        java.lang.System/*java.lang.System*/.out.println("Test.prun()");
    }
    
    public Test() { super(); }
}
class PrivatePointcutLibrary {
    pointcut adviceCflow() : !cflow(adviceexecution());
    
    pointcut publicCalls() :
    call(public * (*).*(..)) &&
      !adviceCflow();
    
    public PrivatePointcutLibrary() { super(); }
}
class PointcutLibrary extends PrivatePointcutLibrary {
    public PointcutLibrary() { super(); }
}
class CPL extends PointcutLibrary {
    static aspect A {
        before():
        publicCalls() {
            java.lang.System/*java.lang.System*/.out.println("CPL: " +
                                                             thisJoinPointStaticPart);
        }
        
        public static CPL.A aspectOf()
              throws org.aspectj.lang.NoAspectBoundException {
            return null;
        }
        
        public static boolean hasAspect() { return true; }
        
        public A() { super(); }
    }
    
    
    public CPL() { super(); }
}
aspect ExternalClientOfCPL {
    before():
    publicCalls() {
        java.lang.System/*java.lang.System*/.out.println("XDP: " +
                                                         thisJoinPointStaticPart);
    }
    
    public static ExternalClientOfCPL aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public ExternalClientOfCPL() { super(); }
}
retrieve <PointcutLibraryTest: void main(java.lang.String[])> from PointcutLibraryTest
retrieve <PointcutLibraryTest: void <init>()> from PointcutLibraryTest
retrieve <Test: void run()> from Test
retrieve <Test: void prun()> from Test
retrieve <Test: void <init>()> from Test
retrieve <PrivatePointcutLibrary: void <init>()> from PrivatePointcutLibrary
retrieve <PointcutLibrary: void <init>()> from PointcutLibrary
retrieve <CPL: void <init>()> from CPL
retrieve <CPL$A: boolean hasAspect()> from CPL$A
retrieve <CPL$A: void <init>()> from CPL$A
retrieve <CPL$A: void before$0(org.aspectj.lang.JoinPoint$StaticPart)> from CPL$A
retrieve <CPL$A: CPL$A aspectOf()> from CPL$A
retrieve <ExternalClientOfCPL: void <init>()> from ExternalClientOfCPL
retrieve <ExternalClientOfCPL: void before$1(org.aspectj.lang.JoinPoint$StaticPart)> from ExternalClientOfCPL
retrieve <ExternalClientOfCPL: ExternalClientOfCPL aspectOf()> from ExternalClientOfCPL
retrieve <ExternalClientOfCPL: boolean hasAspect()> from ExternalClientOfCPL
Transforming PointcutLibraryTest... 
Transforming CPL... 
Transforming ExternalClientOfCPL... 
Transforming CPL$A... 
Transforming PointcutLibrary... 
Transforming PrivatePointcutLibrary... 
Transforming Test... 
Abc finished on Thu Jun 24 10:03:24 BST 2004. ( 0 min. 7 sec. )
Test.prun()
PASS: subtype-qualified pointcut reference()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 387 failed (check: 147), 437 passed (check: 109), 7 skipped.
Executing test 832 (bugs): weaver trace on mis-qualified pointcut reference
Failed. Current status: 388 failed (check: 148), 437 passed (check: 109), 7 skipped.
Executing test 833 (bugs): compile error expected for interface pointcuts
Failed. Current status: 389 failed (check: 149), 437 passed (check: 109), 7 skipped.
Executing test 834 (bugs): interface call signatures when declaring method in aspect
================================================
Breakdown of abc phases  (total: 7131 millisec.)
------------------------------------------------
[ 00.421% ] Init. of Soot:  30
[ 00.042% ] Loading Jars:  3
[ 73.356% ] Polyglot phases:  5231
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.589% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 00.561% ] Intertype Adjuster:  40
[ 07.516% ] Retrieving bodies:  536
[ 00.000% ] Weave Initializers:  0
[ 00.309% ] Load shadow types:  22
[ 07.979% ] Compute advice lists:  569
[ 00.056% ] Intertype weave:  4
[ 00.309% ] Add aspect code:  22
[ 00.182% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 05.217% ] Soot Packs:  372
[ 03.408% ] Soot Writing Output:  243
================================================
Failed. Current status: 390 failed (check: 150), 437 passed (check: 109), 7 skipped.
Executing test 835 (new/interfaceLibrary): aspect-declared interface members in libraries - baseline
================================================
Breakdown of abc phases  (total: 6335 millisec.)
------------------------------------------------
[ 00.584% ] Init. of Soot:  37
[ 00.047% ] Loading Jars:  3
[ 79.148% ] Polyglot phases:  5014
[ 00.032% ] Resolve class names:  2
[ 00.032% ] Declare Parents:  2
[ 00.458% ] Recompute name pattern matches:  29
[ 00.000% ] Compute precedence relation:  0
[ 02.273% ] Intertype Adjuster:  144
[ 05.967% ] Retrieving bodies:  378
[ 00.000% ] Weave Initializers:  0
[ 00.347% ] Load shadow types:  22
[ 02.526% ] Compute advice lists:  160
[ 00.047% ] Intertype weave:  3
[ 00.505% ] Add aspect code:  32
[ 00.363% ] Weaving advice:  23
[ 00.000% ] Validate jimple:  0
[ 04.120% ] Soot Packs:  261
[ 03.552% ] Soot Writing Output:  225
================================================
LibraryAspect-defined run() for C@14d0e66
Abc started on Thu Jun 24 10:03:44 BST 2004
<<<< LibraryInterface.java >>>>
package lib;

public interface LibraryInterface {}
<<<< LibraryAspect.java >>>>
aspect LibraryAspect {
    public intertype void lib.LibraryInterface.run() {
        java.lang.System/*java.lang.System*/.err.println("LibraryAspect-defined run() for " +
                                                         hostlib.LibraryInterfacethis);
    }
    
    public static LibraryAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public LibraryAspect() { super(); }
}
<<<< Client.java >>>>
public class Client {
    public static void main(java.lang.String[] a) { new C().run(); }
    
    public Client() { super(); }
}
class C implements lib.LibraryInterface {
    public C() { super(); }
}
retrieve <LibraryAspect: void run(lib.LibraryInterface)> from LibraryAspect
retrieve <LibraryAspect: LibraryAspect aspectOf()> from LibraryAspect
retrieve <LibraryAspect: boolean hasAspect()> from LibraryAspect
retrieve <LibraryAspect: void <init>()> from LibraryAspect
retrieve <Client: void main(java.lang.String[])> from Client
retrieve <Client: void <init>()> from Client
retrieve <C: void <init>()> from C
retrieve <C: void run()> from C
Transforming Client... 
Transforming C... 
Transforming lib.LibraryInterface... 
Transforming LibraryAspect... 
Abc finished on Thu Jun 24 10:03:50 BST 2004. ( 0 min. 6 sec. )
PASS: aspect-declared interface members in libraries - baseline()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 390 failed (check: 150), 438 passed (check: 109), 7 skipped.
Executing test 836 (new/interfaceLibrary): aspect-declared interface members in libraries - interfaceOnly.jar
Failed. Current status: 391 failed (check: 151), 438 passed (check: 109), 7 skipped.
Executing test 837 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectOnly.jar
Failed. Current status: 392 failed (check: 151), 438 passed (check: 109), 7 skipped.
Executing test 838 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectedInterfaceOnly.jar
Failed. Current status: 393 failed (check: 152), 438 passed (check: 109), 7 skipped.
Executing test 839 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectedInterfaceOnly.jar,aspectOnly.jar
Abc started on Thu Jun 24 10:04:02 BST 2004
<<<< Client.java >>>>
public class Client {
    public static void main(java.lang.String[] a) { new C().run(); }
    
    public Client() { super(); }
}
class C implements lib.LibraryInterface {
    public C() { super(); }
}
PASS: aspect-declared interface members in libraries - aspectedInterfaceOnly.j...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 393 failed (check: 152), 439 passed (check: 110), 7 skipped.
Executing test 840 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectedInterfaceOnlyBinary.jar,aspectOnly.jar
Abc started on Thu Jun 24 10:04:05 BST 2004
<<<< Client.java >>>>
public class Client {
    public static void main(java.lang.String[] a) { new C().run(); }
    
    public Client() { super(); }
}
class C implements lib.LibraryInterface {
    public C() { super(); }
}
PASS: aspect-declared interface members in libraries - aspectedInterfaceOnlyBi...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 393 failed (check: 152), 440 passed (check: 111), 7 skipped.
Executing test 841 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectedInterfaceOnly.jar,aspectpath=aspectOnly.jar
Failed. Current status: 394 failed (check: 152), 440 passed (check: 111), 7 skipped.
Executing test 842 (new/interfaceLibrary): aspect-declared interface members in libraries - aspectedInterfaceOnly.jar,aspectpath=aspectOnly.jar
Failed. Current status: 395 failed (check: 152), 440 passed (check: 111), 7 skipped.
Executing test 843 (bugs/interfaceLibrary): exception clause for aspect-declared interface methods - positive
================================================
Breakdown of abc phases  (total: 6740 millisec.)
------------------------------------------------
[ 00.534% ] Init. of Soot:  36
[ 00.059% ] Loading Jars:  4
[ 74.421% ] Polyglot phases:  5016
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.623% ] Recompute name pattern matches:  42
[ 00.000% ] Compute precedence relation:  0
[ 02.107% ] Intertype Adjuster:  142
[ 06.454% ] Retrieving bodies:  435
[ 00.000% ] Weave Initializers:  0
[ 00.326% ] Load shadow types:  22
[ 02.300% ] Compute advice lists:  155
[ 00.045% ] Intertype weave:  3
[ 00.371% ] Add aspect code:  25
[ 00.178% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 09.258% ] Soot Packs:  624
[ 03.264% ] Soot Writing Output:  220
================================================
Abc started on Thu Jun 24 10:04:16 BST 2004
<<<< Client.java >>>>
import java.io.IOException;

public class Client {
    public static void main(java.lang.String[] a) {
        try {
            new C().run();
            throw new java.lang.Error("test failed to throw IOException");
        }
        catch (java.io.IOException e) {  }
    }
    
    public Client() { super(); }
}
class C implements lib.LibraryInterface {
    public C() { super(); }
}
<<<< LibraryInterface.java >>>>
package lib;

public interface LibraryInterface {}
<<<< LibraryAspect.java >>>>
import java.io.IOException;

aspect LibraryAspect {
    public intertype void lib.LibraryInterface.run()
                                                          throws java.io.IOException {
        throw new java.io.IOException("LibraryAspect-defined run() for " +
                                      hostlib.LibraryInterfacethis);
    }
    
    public static LibraryAspect aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public LibraryAspect() { super(); }
}
retrieve <Client: void main(java.lang.String[])> from Client
retrieve <Client: void <init>()> from Client
retrieve <C: void <init>()> from C
retrieve <C: void run()> from C
retrieve <LibraryAspect: void run(lib.LibraryInterface)> from LibraryAspect
retrieve <LibraryAspect: LibraryAspect aspectOf()> from LibraryAspect
retrieve <LibraryAspect: boolean hasAspect()> from LibraryAspect
retrieve <LibraryAspect: void <init>()> from LibraryAspect
Transforming Client... 
Transforming lib.LibraryInterface... 
Transforming C... 
Transforming LibraryAspect... 
Abc finished on Thu Jun 24 10:04:22 BST 2004. ( 0 min. 6 sec. )
PASS: exception clause for aspect-declared interface methods - positive()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 395 failed (check: 152), 441 passed (check: 111), 7 skipped.
Executing test 844 (bugs/interfaceLibrary): exception clause for aspect-declared interface methods - negative
Abc started on Thu Jun 24 10:04:25 BST 2004
<<<< ClientCE.java >>>>
public class ClientCE {
    public static void main(java.lang.String[] a) { new C().run(); }
    
    public ClientCE() { super(); }
}
class C implements lib.LibraryInterface {
    public C() { super(); }
}
<<<< LibraryInterface.java >>>>
package lib;

public interface LibraryInterface {}
PASS: exception clause for aspect-declared interface methods - negative()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 395 failed (check: 152), 442 passed (check: 112), 7 skipped.
Executing test 845 (bugs/interfaceLibrary): exception clause for aspect-declared class methods - positive
================================================
Breakdown of abc phases  (total: 6428 millisec.)
------------------------------------------------
[ 00.560% ] Init. of Soot:  36
[ 00.062% ] Loading Jars:  4
[ 79.294% ] Polyglot phases:  5097
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.731% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 01.929% ] Intertype Adjuster:  124
[ 06.845% ] Retrieving bodies:  440
[ 00.000% ] Weave Initializers:  0
[ 00.451% ] Load shadow types:  29
[ 02.302% ] Compute advice lists:  148
[ 00.047% ] Intertype weave:  3
[ 00.389% ] Add aspect code:  25
[ 00.202% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.640% ] Soot Packs:  234
[ 03.485% ] Soot Writing Output:  224
================================================
Failed. Current status: 396 failed (check: 152), 442 passed (check: 112), 7 skipped.
Executing test 846 (bugs/interfaceLibrary): exception clause for aspect-declared class methods - negative
Abc started on Thu Jun 24 10:04:38 BST 2004
<<<< ClassClientCE.java >>>>
public class ClassClientCE {
    public static void main(java.lang.String[] a) { new C().run(); }
    
    public ClassClientCE() { super(); }
}
class C extends lib.LibraryClass {
    public C() { super(); }
}
<<<< LibraryClass.java >>>>
package lib;

public class LibraryClass {
    public LibraryClass() { super(); }
}
PASS: exception clause for aspect-declared class methods - negative()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 396 failed (check: 152), 443 passed (check: 113), 7 skipped.
Executing test 847 (bugs): reflective check of declared exceptions from aspect-declared methods
================================================
Breakdown of abc phases  (total: 7307 millisec.)
------------------------------------------------
[ 00.493% ] Init. of Soot:  36
[ 00.055% ] Loading Jars:  4
[ 78.240% ] Polyglot phases:  5717
[ 00.027% ] Resolve class names:  2
[ 00.014% ] Declare Parents:  1
[ 00.643% ] Recompute name pattern matches:  47
[ 00.000% ] Compute precedence relation:  0
[ 01.943% ] Intertype Adjuster:  142
[ 05.926% ] Retrieving bodies:  433
[ 00.000% ] Weave Initializers:  0
[ 00.301% ] Load shadow types:  22
[ 05.036% ] Compute advice lists:  368
[ 00.041% ] Intertype weave:  3
[ 00.164% ] Add aspect code:  12
[ 00.178% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.750% ] Soot Packs:  274
[ 03.189% ] Soot Writing Output:  233
================================================
Failed. Current status: 397 failed (check: 152), 443 passed (check: 113), 7 skipped.
Executing test 848 (bugs/interfaceLibrary): exception clause for aspect-declared interface methods - positive binary
Failed. Current status: 398 failed (check: 152), 443 passed (check: 113), 7 skipped.
Executing test 849 (bugs/interfaceLibrary): exception clause for aspect-declared interface methods - negative binary
Failed. Current status: 399 failed (check: 153), 443 passed (check: 113), 7 skipped.
Executing test 850 (bugs/interfaceLibrary): exception clause for aspect-declared class methods - positive binary
Failed. Current status: 400 failed (check: 153), 443 passed (check: 113), 7 skipped.
Executing test 851 (bugs/interfaceLibrary): exception clause for aspect-declared class methods - negative binary
Failed. Current status: 401 failed (check: 154), 443 passed (check: 113), 7 skipped.
Executing test 852 (bugs/moreInterfaceLibrary): Weaving failure when using injars (no jars)
Abc started on Thu Jun 24 10:05:02 BST 2004
PASS: Weaving failure when using injars (no jars)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 401 failed (check: 154), 444 passed (check: 113), 7 skipped.
Executing test 853 (bugs/moreInterfaceLibrary): Weaving failure when using injars (on aspectpath)
Illegal arguments: Unknown option -aspectpath
PASS: Weaving failure when using injars (on aspectpath)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 401 failed (check: 154), 445 passed (check: 113), 7 skipped.
Executing test 854 (bugs/moreInterfaceLibrary): Weaving failure when using injars (on classpath)
Abc started on Thu Jun 24 10:05:08 BST 2004
<<<< BusObj.java >>>>
package model;

public class BusObj {
    public BusObj() { super(); }
}
PASS: Weaving failure when using injars (on classpath)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 401 failed (check: 154), 446 passed (check: 114), 7 skipped.
Executing test 855 (bugs/moreInterfaceLibrary): Weaving failure when using injars (actual injars)
Failed. Current status: 402 failed (check: 155), 446 passed (check: 114), 7 skipped.
Executing test 856 (bugs/perCflowAndJar): percflow aspects compiled from jars share one instance for all entry points
Failed. Current status: 403 failed (check: 155), 446 passed (check: 114), 7 skipped.
Executing test 857 (bugs/perCflowAndJar): (using aspectpath) percflow aspects compiled from jars share one instance for all entry points
Failed. Current status: 404 failed (check: 155), 446 passed (check: 114), 7 skipped.
Executing test 858 (bugs/throwsSignature): throw derivative pointcuts not advised
================================================
Breakdown of abc phases  (total: 7098 millisec.)
------------------------------------------------
[ 00.507% ] Init. of Soot:  36
[ 00.042% ] Loading Jars:  3
[ 73.316% ] Polyglot phases:  5204
[ 00.028% ] Resolve class names:  2
[ 00.028% ] Declare Parents:  2
[ 00.817% ] Recompute name pattern matches:  58
[ 00.000% ] Compute precedence relation:  0
[ 00.507% ] Intertype Adjuster:  36
[ 16.103% ] Retrieving bodies:  1143
[ 00.000% ] Weave Initializers:  0
[ 00.310% ] Load shadow types:  22
[ 00.747% ] Compute advice lists:  53
[ 00.042% ] Intertype weave:  3
[ 00.578% ] Add aspect code:  41
[ 00.169% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.790% ] Soot Packs:  269
[ 03.015% ] Soot Writing Output:  214
================================================
Failed. Current status: 405 failed (check: 155), 446 passed (check: 114), 7 skipped.
Executing test 859 (bugs): perthis and signature bad interaction
================================================
Breakdown of abc phases  (total: 6493 millisec.)
------------------------------------------------
[ 00.554% ] Init. of Soot:  36
[ 00.046% ] Loading Jars:  3
[ 78.608% ] Polyglot phases:  5104
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.801% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 00.554% ] Intertype Adjuster:  36
[ 07.269% ] Retrieving bodies:  472
[ 00.000% ] Weave Initializers:  0
[ 00.339% ] Load shadow types:  22
[ 02.187% ] Compute advice lists:  142
[ 00.046% ] Intertype weave:  3
[ 00.785% ] Add aspect code:  51
[ 00.400% ] Weaving advice:  26
[ 00.000% ] Validate jimple:  0
[ 04.451% ] Soot Packs:  289
[ 03.897% ] Soot Writing Output:  253
================================================
Abc started on Thu Jun 24 10:05:40 BST 2004
<<<< InterPerCall.java >>>>
public class InterPerCall {
    public static void main(java.lang.String[] args) { new D().m(); }
    
    public InterPerCall() { super(); }
}
class C {
    public C() { super(); }
}
class D extends C {
    public void m() {  }
    
    public D() { super(); }
}
aspect A {
    pointcut p1() : execution (void (D).m());
    
    pointcut p2() : execution (void (C).m());
    
    before():
    p2() {
        java.lang.System/*java.lang.System*/.out.println("hello");
    }
    
    public static A aspectOf(java.lang.Object thisparam)
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect(java.lang.Object thisparam) {
        return true;
    }
    
    public A() { super(); }
}
retrieve <InterPerCall: void <init>()> from InterPerCall
retrieve <InterPerCall: void main(java.lang.String[])> from InterPerCall
retrieve <C: void <init>()> from C
retrieve <D: void m()> from D
retrieve <D: void <init>()> from D
retrieve <A: void <init>()> from A
retrieve <A: void before$0()> from A
retrieve <A: A aspectOf(java.lang.Object)> from A
retrieve <A: boolean hasAspect(java.lang.Object)> from A
Transforming D... 
Transforming C... 
Transforming A... 
Transforming InterPerCall... 
Transforming A$abc$PerThis... 
Abc finished on Thu Jun 24 10:05:47 BST 2004. ( 0 min. 6 sec. )
PASS: perthis and signature bad interaction()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 7 seconds
Passed. Current status: 405 failed (check: 155), 447 passed (check: 114), 7 skipped.
Executing test 860 (bugs/declareBinding): declare error fails on pointcuts composed from multiple classes
================================================
Breakdown of abc phases  (total: 6496 millisec.)
------------------------------------------------
[ 00.539% ] Init. of Soot:  35
[ 00.046% ] Loading Jars:  3
[ 75.431% ] Polyglot phases:  4900
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.708% ] Recompute name pattern matches:  46
[ 00.000% ] Compute precedence relation:  0
[ 00.570% ] Intertype Adjuster:  37
[ 06.881% ] Retrieving bodies:  447
[ 00.000% ] Weave Initializers:  0
[ 00.339% ] Load shadow types:  22
[ 00.662% ] Compute advice lists:  43
[ 00.046% ] Intertype weave:  3
[ 00.908% ] Add aspect code:  59
[ 00.185% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 04.110% ] Soot Packs:  267
[ 09.514% ] Soot Writing Output:  618
================================================
Failed. Current status: 406 failed (check: 155), 447 passed (check: 114), 7 skipped.
Executing test 861 (bugs/declareSoftWithin): declare error fails on pointcuts composed from multiple classes
Failed. Current status: 407 failed (check: 155), 447 passed (check: 114), 7 skipped.
Executing test 862 (bugs): Interaction between pointcut binding and declare parents
Failed. Current status: 408 failed (check: 155), 447 passed (check: 114), 7 skipped.
Executing test 863 (bugs): Non-functional concretezation of ReferencePointcut
================================================
Breakdown of abc phases  (total: 6792 millisec.)
------------------------------------------------
[ 00.530% ] Init. of Soot:  36
[ 00.044% ] Loading Jars:  3
[ 73.057% ] Polyglot phases:  4962
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.559% ] Recompute name pattern matches:  38
[ 00.015% ] Compute precedence relation:  1
[ 00.810% ] Intertype Adjuster:  55
[ 06.861% ] Retrieving bodies:  466
[ 00.015% ] Weave Initializers:  1
[ 00.309% ] Load shadow types:  21
[ 07.627% ] Compute advice lists:  518
[ 00.044% ] Intertype weave:  3
[ 00.604% ] Add aspect code:  41
[ 00.398% ] Weaving advice:  27
[ 00.000% ] Validate jimple:  0
[ 05.654% ] Soot Packs:  384
[ 03.416% ] Soot Writing Output:  232
================================================
Abc started on Thu Jun 24 10:06:10 BST 2004
<<<< AdviceInteraction.java >>>>
public class AdviceInteraction {
    public static void main(java.lang.String[] args) { new C().m1(); }
    
    public AdviceInteraction() { super(); }
}
class C {
    public void m1() {  }
    
    public void m2() {  }
    
    public C() { super(); }
}
aspect A {
    pointcut exec1(C c) : this(c) && execution (void (*).m1());
    
    pointcut execs(C c) : exec1(c);
    
    before(): execs() {  }
    
    before(C c): execs(c) {  }
    
    pointcut exec2(C c) : this(c) && execution (void (*).m2());
    
    pointcut execs2(C c) : exec2(c);
    
    before(C c): execs2(c) {  }
    
    before(): execs2() {  }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
retrieve <AdviceInteraction: void main(java.lang.String[])> from AdviceInteraction
retrieve <AdviceInteraction: void <init>()> from AdviceInteraction
retrieve <C: void m1()> from C
retrieve <C: void m2()> from C
retrieve <C: void <init>()> from C
retrieve <A: void before$0()> from A
retrieve <A: void before$1(C)> from A
retrieve <A: void before$2(C)> from A
retrieve <A: void before$3()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming AdviceInteraction... 
Transforming C... 
Abc finished on Thu Jun 24 10:06:16 BST 2004. ( 0 min. 6 sec. )
PASS: Non-functional concretezation of ReferencePointcut()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 408 failed (check: 155), 448 passed (check: 114), 7 skipped.
Executing test 864 (bugs/concretizeNpe): NPE in concretization error path
Failed. Current status: 409 failed (check: 155), 448 passed (check: 114), 7 skipped.
Executing test 865 (bugs/jpOptimization): JoinPoint Optimization when targetting 1.4
Failed. Current status: 410 failed (check: 155), 448 passed (check: 114), 7 skipped.
Executing test 866 (bugs/extdirs): zip and jar suffixes for extdirs entries
Illegal arguments: Unknown option -extdirs
PASS: zip and jar suffixes for extdirs entries()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 410 failed (check: 155), 449 passed (check: 114), 7 skipped.
Executing test 867 (bugs/privilege/packageProtected): priviledged aspects calling methods from advice
Failed. Current status: 411 failed (check: 155), 449 passed (check: 114), 7 skipped.
Executing test 868 (bugs): No error on overloaded pointcuts in class
Failed. Current status: 412 failed (check: 156), 449 passed (check: 114), 7 skipped.
Executing test 869 (bugs): No error on overloaded pointcuts unless binding variables
Failed. Current status: 413 failed (check: 157), 449 passed (check: 114), 7 skipped.
Executing test 870 (bugs): alias getCause for getWrappedThrowable in SoftException
Failed. Current status: 414 failed (check: 157), 449 passed (check: 114), 7 skipped.
Executing test 871 (bugs): Declare soft softening other exception types
Failed. Current status: 415 failed (check: 158), 449 passed (check: 114), 7 skipped.
Executing test 872 (bugs): static method introduction on interfaces, should not be allowed
================================================
Breakdown of abc phases  (total: 6502 millisec.)
------------------------------------------------
[ 00.538% ] Init. of Soot:  35
[ 00.046% ] Loading Jars:  3
[ 77.084% ] Polyglot phases:  5012
[ 00.031% ] Resolve class names:  2
[ 00.031% ] Declare Parents:  2
[ 00.677% ] Recompute name pattern matches:  44
[ 00.000% ] Compute precedence relation:  0
[ 00.600% ] Intertype Adjuster:  39
[ 12.119% ] Retrieving bodies:  788
[ 00.000% ] Weave Initializers:  0
[ 00.338% ] Load shadow types:  22
[ 00.631% ] Compute advice lists:  41
[ 00.046% ] Intertype weave:  3
[ 00.784% ] Add aspect code:  51
[ 00.185% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.799% ] Soot Packs:  247
[ 03.091% ] Soot Writing Output:  201
================================================
Failed. Current status: 416 failed (check: 159), 449 passed (check: 114), 7 skipped.
Executing test 873 (bugs): External pointcut refs not resolved if named pointcut used by declare
================================================
Breakdown of abc phases  (total: 6675 millisec.)
------------------------------------------------
[ 00.524% ] Init. of Soot:  35
[ 00.045% ] Loading Jars:  3
[ 73.438% ] Polyglot phases:  4902
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.599% ] Recompute name pattern matches:  40
[ 00.000% ] Compute precedence relation:  0
[ 00.569% ] Intertype Adjuster:  38
[ 07.251% ] Retrieving bodies:  484
[ 00.000% ] Weave Initializers:  0
[ 00.404% ] Load shadow types:  27
[ 01.273% ] Compute advice lists:  85
[ 00.045% ] Intertype weave:  3
[ 00.734% ] Add aspect code:  49
[ 00.195% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 09.978% ] Soot Packs:  666
[ 04.884% ] Soot Writing Output:  326
================================================
Failed. Current status: 417 failed (check: 160), 449 passed (check: 114), 7 skipped.
Executing test 874 (bugs): XLint warning for call PCD's using subtype of defining type
Failed. Current status: 418 failed (check: 161), 449 passed (check: 114), 7 skipped.
Executing test 875 (bugs): XLint warning for call PCD's using subtype of defining type (-1.3 -Xlint:ignore)
Illegal arguments: Unknown option -Xlint:ignore
PASS: XLint warning for call PCD's using subtype of defining type (-1.3 -Xlint...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 1 seconds
Passed. Current status: 418 failed (check: 161), 450 passed (check: 114), 7 skipped.
Executing test 876 (bugs): XLint warning for call PCD's using subtype of defining type (-1.4 -Xlint:ignore)
Failed. Current status: 419 failed (check: 162), 450 passed (check: 114), 7 skipped.
Executing test 877 (bugs): XLint warning for call PCD's using subtype of defining type (-1.4)
Failed. Current status: 420 failed (check: 163), 450 passed (check: 114), 7 skipped.
Executing test 878 (bugs): Appropriate message for 'after() thowing(Throwable th)' syntax error
Failed. Current status: 421 failed (check: 164), 450 passed (check: 114), 7 skipped.
Executing test 879 (bugs/faultingInSource): Ensure we don't look for source on the classpath when binary not found
Failed. Current status: 422 failed (check: 165), 450 passed (check: 114), 7 skipped.
Executing test 880 (bugs): inner aspect containing declare soft
Failed. Current status: 423 failed (check: 165), 450 passed (check: 114), 7 skipped.
Executing test 881 (bugs): Bad parser error recovery in advice
Abc started on Thu Jun 24 10:07:25 BST 2004
PASS: Bad parser error recovery in advice()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 423 failed (check: 165), 451 passed (check: 115), 7 skipped.
Executing test 882 (bugs): Bad parser error recovery in java source
Failed. Current status: 424 failed (check: 166), 451 passed (check: 115), 7 skipped.
Executing test 883 (bugs): compiler issues error on inner aspects when privilieged
Failed. Current status: 425 failed (check: 166), 451 passed (check: 115), 7 skipped.
Executing test 884 (bugs): After throwing advice on ctors doesn't execute for inter-type decl field inits
================================================
Breakdown of abc phases  (total: 6924 millisec.)
------------------------------------------------
[ 00.520% ] Init. of Soot:  36
[ 00.058% ] Loading Jars:  4
[ 79.116% ] Polyglot phases:  5478
[ 00.029% ] Resolve class names:  2
[ 00.029% ] Declare Parents:  2
[ 00.520% ] Recompute name pattern matches:  36
[ 00.000% ] Compute precedence relation:  0
[ 00.823% ] Intertype Adjuster:  57
[ 07.813% ] Retrieving bodies:  541
[ 00.130% ] Weave Initializers:  9
[ 00.318% ] Load shadow types:  22
[ 02.282% ] Compute advice lists:  158
[ 00.043% ] Intertype weave:  3
[ 00.376% ] Add aspect code:  26
[ 00.419% ] Weaving advice:  29
[ 00.000% ] Validate jimple:  0
[ 04.145% ] Soot Packs:  287
[ 03.380% ] Soot Writing Output:  234
================================================
Failed. Current status: 426 failed (check: 166), 451 passed (check: 115), 7 skipped.
Executing test 885 (bugs/abstractMethods): Introduced abstract method on abstract class not implemented by subtype
Failed. Current status: 427 failed (check: 167), 451 passed (check: 115), 7 skipped.
Executing test 886 (bugs/abstractMethods): Introduced abstract method on interface not implemented by subtype (weave altogether)
================================================
Breakdown of abc phases  (total: 6774 millisec.)
------------------------------------------------
[ 00.531% ] Init. of Soot:  36
[ 00.059% ] Loading Jars:  4
[ 76.085% ] Polyglot phases:  5154
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.738% ] Recompute name pattern matches:  50
[ 00.000% ] Compute precedence relation:  0
[ 07.130% ] Intertype Adjuster:  483
[ 05.433% ] Retrieving bodies:  368
[ 00.000% ] Weave Initializers:  0
[ 00.325% ] Load shadow types:  22
[ 01.771% ] Compute advice lists:  120
[ 00.044% ] Intertype weave:  3
[ 00.531% ] Add aspect code:  36
[ 00.192% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 03.897% ] Soot Packs:  264
[ 03.203% ] Soot Writing Output:  217
================================================
Abc started on Thu Jun 24 10:07:48 BST 2004
<<<< C.java >>>>
public class C implements B {
    public static void main(java.lang.String[] args) {
        A.doit(new C());
    }
    
    public C() { super(); }
}
<<<< A.java >>>>
aspect A {
    intertype void B.m() {  }
    
    public static void doit(B b) { b.m(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
<<<< B.java >>>>
interface B {}
retrieve <C: void A$m$1()> from C
retrieve <C: void main(java.lang.String[])> from C
retrieve <C: void <init>()> from C
retrieve <A: void A$m$1(B)> from A
retrieve <A: void doit(B)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
Transforming A... 
Transforming B... 
Transforming C... 
Abc finished on Thu Jun 24 10:07:55 BST 2004. ( 0 min. 6 sec. )
PASS: Introduced abstract method on interface not implemented by subtype (weav...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 427 failed (check: 167), 452 passed (check: 115), 7 skipped.
Executing test 887 (bugs/abstractMethods): Introduced abstract method on interface not implemented by subtype (injars)
Failed. Current status: 428 failed (check: 168), 452 passed (check: 115), 7 skipped.
Executing test 888 (bugs/abstractMethods): Introduced abstract method on interface not implemented by subtype (aspectpath)
Failed. Current status: 429 failed (check: 168), 452 passed (check: 115), 7 skipped.
Executing test 889 (bugs/abstractMethods): Introduced abstract method on abstract class not implemented by subtype (single source file)
Abc started on Thu Jun 24 10:08:07 BST 2004
<<<< C.java >>>>
abstract class B {
    public B() { super(); }
}
aspect A {
    abstract intertype void B.m();
    
    public static void doit(B b) { b.m(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
public class C extends B {
    public static void main(java.lang.String[] args) {
        A.doit(new C());
    }
    
    public C() { super(); }
}
PASS: Introduced abstract method on abstract class not implemented by subtype ...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 2 seconds
Passed. Current status: 429 failed (check: 168), 453 passed (check: 116), 7 skipped.
Executing test 890 (bugs/abstractMethods): Introduced abstract method on abstract class with introduced concrete method (single source file)
================================================
Breakdown of abc phases  (total: 6760 millisec.)
------------------------------------------------
[ 00.547% ] Init. of Soot:  37
[ 00.059% ] Loading Jars:  4
[ 75.163% ] Polyglot phases:  5081
[ 00.030% ] Resolve class names:  2
[ 00.015% ] Declare Parents:  1
[ 00.710% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 07.263% ] Intertype Adjuster:  491
[ 05.577% ] Retrieving bodies:  377
[ 00.000% ] Weave Initializers:  0
[ 00.414% ] Load shadow types:  28
[ 01.834% ] Compute advice lists:  124
[ 00.044% ] Intertype weave:  3
[ 00.547% ] Add aspect code:  37
[ 00.192% ] Weaving advice:  13
[ 00.000% ] Validate jimple:  0
[ 04.127% ] Soot Packs:  279
[ 03.476% ] Soot Writing Output:  235
================================================
Abc started on Thu Jun 24 10:08:11 BST 2004
<<<< C1.java >>>>
abstract class B {
    public B() { super(); }
}
aspect A {
    abstract intertype void B.m();
    
    public static void doit(B b) { b.m(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
public class C1 extends B {
    public static void main(java.lang.String[] args) {
        A.doit(new C1());
    }
    
    public C1() { super(); }
}
aspect A1 {
    intertype void C1.m() {  }
    
    public static A1 aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A1() { super(); }
}
retrieve <B: void <init>()> from B
retrieve <A: void doit(B)> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <C1: void <init>()> from C1
retrieve <C1: void main(java.lang.String[])> from C1
retrieve <C1: void A$m$2()> from C1
retrieve <A1: void A$m$2(C1)> from A1
retrieve <A1: A1 aspectOf()> from A1
retrieve <A1: boolean hasAspect()> from A1
retrieve <A1: void <init>()> from A1
Transforming A... 
Transforming C1... 
Transforming B... 
Transforming A1... 
Abc finished on Thu Jun 24 10:08:18 BST 2004. ( 0 min. 6 sec. )
PASS: Introduced abstract method on abstract class with introduced concrete me...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 429 failed (check: 168), 454 passed (check: 116), 7 skipped.
Executing test 891 (bugs/abstractMethods): Introduced abstract method on abstract class with existing concrete method (single source file)
================================================
Breakdown of abc phases  (total: 6679 millisec.)
------------------------------------------------
[ 00.554% ] Init. of Soot:  37
[ 00.060% ] Loading Jars:  4
[ 75.595% ] Polyglot phases:  5049
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.599% ] Recompute name pattern matches:  40
[ 00.000% ] Compute precedence relation:  0
[ 06.094% ] Intertype Adjuster:  407
[ 06.902% ] Retrieving bodies:  461
[ 00.000% ] Weave Initializers:  0
[ 00.329% ] Load shadow types:  22
[ 01.842% ] Compute advice lists:  123
[ 00.045% ] Intertype weave:  3
[ 00.554% ] Add aspect code:  37
[ 00.180% ] Weaving advice:  12
[ 00.000% ] Validate jimple:  0
[ 03.938% ] Soot Packs:  263
[ 03.249% ] Soot Writing Output:  217
================================================
Abc started on Thu Jun 24 10:08:20 BST 2004
<<<< C2.java >>>>
abstract class B {
    public B() { super(); }
}
aspect A {
    public abstract intertype void B.m();
    
    public static void doit(B b) { b.m(); }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
public class C2 extends B {
    public static void main(java.lang.String[] args) {
        A.doit(new C2());
    }
    
    public void m() {  }
    
    public C2() { super(); }
}
retrieve <B: void <init>()> from B
retrieve <A: boolean hasAspect()> from A
retrieve <A: void <init>()> from A
retrieve <A: void doit(B)> from A
retrieve <A: A aspectOf()> from A
retrieve <C2: void main(java.lang.String[])> from C2
retrieve <C2: void m()> from C2
retrieve <C2: void <init>()> from C2
Transforming C2... 
Transforming B... 
Transforming A... 
Abc finished on Thu Jun 24 10:08:27 BST 2004. ( 0 min. 6 sec. )
PASS: Introduced abstract method on abstract class with existing concrete meth...


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 429 failed (check: 168), 455 passed (check: 116), 7 skipped.
Executing test 892 (bugs/interAbstract): aspect declares interface method (no modifiers)
Failed. Current status: 430 failed (check: 169), 455 passed (check: 116), 7 skipped.
Executing test 893 (bugs/interAbstract): aspect declares interface method (abstract)
================================================
Breakdown of abc phases  (total: 7434 millisec.)
------------------------------------------------
[ 00.484% ] Init. of Soot:  36
[ 00.040% ] Loading Jars:  3
[ 73.823% ] Polyglot phases:  5488
[ 00.027% ] Resolve class names:  2
[ 00.013% ] Declare Parents:  1
[ 00.713% ] Recompute name pattern matches:  53
[ 00.000% ] Compute precedence relation:  0
[ 00.538% ] Intertype Adjuster:  40
[ 06.632% ] Retrieving bodies:  493
[ 00.000% ] Weave Initializers:  0
[ 00.296% ] Load shadow types:  22
[ 09.712% ] Compute advice lists:  722
[ 00.054% ] Intertype weave:  4
[ 00.242% ] Add aspect code:  18
[ 00.592% ] Weaving advice:  44
[ 00.000% ] Validate jimple:  0
[ 03.820% ] Soot Packs:  284
[ 03.013% ] Soot Writing Output:  224
================================================
Failed. Current status: 431 failed (check: 170), 455 passed (check: 116), 7 skipped.
Executing test 894 (bugs/interAbstract): aspect declares interface method (public abstract)
================================================
Breakdown of abc phases  (total: 7352 millisec.)
------------------------------------------------
[ 00.490% ] Init. of Soot:  36
[ 00.054% ] Loading Jars:  4
[ 74.361% ] Polyglot phases:  5467
[ 00.027% ] Resolve class names:  2
[ 00.027% ] Declare Parents:  2
[ 00.653% ] Recompute name pattern matches:  48
[ 00.000% ] Compute precedence relation:  0
[ 00.544% ] Intertype Adjuster:  40
[ 06.787% ] Retrieving bodies:  499
[ 00.000% ] Weave Initializers:  0
[ 00.299% ] Load shadow types:  22
[ 02.884% ] Compute advice lists:  212
[ 00.082% ] Intertype weave:  6
[ 00.231% ] Add aspect code:  17
[ 00.422% ] Weaving advice:  31
[ 00.000% ] Validate jimple:  0
[ 03.972% ] Soot Packs:  292
[ 09.168% ] Soot Writing Output:  674
================================================
Abc started on Thu Jun 24 10:08:44 BST 2004
<<<< InterfaceMethodDeclarationFull.java >>>>
import org.aspectj.testing.Tester;

public class InterfaceMethodDeclarationFull {
    public static void main(java.lang.String[] args) {
        org.aspectj.testing.Tester.expectEvent("before-execution");
        org.aspectj.testing.Tester.expectEvent("before-call");
        I i = new C();
        org.aspectj.testing.Tester.check(1 ==
                                         i.getInt(),
                                         "1 == i.getInt()");
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public InterfaceMethodDeclarationFull() { super(); }
}
interface I {}
aspect A {
    public abstract intertype int I.getInt();
    
    before():
    execution (int (*).getInt()) &&
      target(I) {
        org.aspectj.testing.Tester.event("before-execution");
    }
    
    before():
    call(int (*).getInt()) &&
      target(I) {
        org.aspectj.testing.Tester.event("before-call");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public A() { super(); }
}
class C implements I {
    public int getInt() { return 1; }
    
    public C() { super(); }
}
retrieve <InterfaceMethodDeclarationFull: void <init>()> from InterfaceMethodDeclarationFull
retrieve <InterfaceMethodDeclarationFull: void main(java.lang.String[])> from InterfaceMethodDeclarationFull
retrieve <A: void <init>()> from A
retrieve <A: void before$1()> from A
retrieve <A: void before$2()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <C: int getInt()> from C
retrieve <C: void <init>()> from C
Transforming I... 
Transforming C... 
Transforming A... 
Transforming InterfaceMethodDeclarationFull... 
Abc finished on Thu Jun 24 10:08:51 BST 2004. ( 0 min. 7 sec. )
PASS: aspect declares interface method (public abstract)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 9 seconds
Passed. Current status: 431 failed (check: 170), 456 passed (check: 116), 7 skipped.
Executing test 895 (bugs/interfaceDefinition): Use class implementing interface via aspect (not woven together)
================================================
Breakdown of abc phases  (total: 7065 millisec.)
------------------------------------------------
[ 00.425% ] Init. of Soot:  30
[ 00.071% ] Loading Jars:  5
[ 79.873% ] Polyglot phases:  5643
[ 00.028% ] Resolve class names:  2
[ 00.198% ] Declare Parents:  14
[ 00.524% ] Recompute name pattern matches:  37
[ 00.000% ] Compute precedence relation:  0
[ 02.151% ] Intertype Adjuster:  152
[ 05.435% ] Retrieving bodies:  384
[ 00.000% ] Weave Initializers:  0
[ 00.297% ] Load shadow types:  21
[ 02.562% ] Compute advice lists:  181
[ 00.042% ] Intertype weave:  3
[ 00.609% ] Add aspect code:  43
[ 00.495% ] Weaving advice:  35
[ 00.000% ] Validate jimple:  0
[ 04.020% ] Soot Packs:  284
[ 03.270% ] Soot Writing Output:  231
================================================
Failed. Current status: 432 failed (check: 171), 456 passed (check: 116), 7 skipped.
Executing test 896 (bugs/interfaceDefinition): Use class implementing interface via aspect (weave all together)
================================================
Breakdown of abc phases  (total: 7306 millisec.)
------------------------------------------------
[ 00.506% ] Init. of Soot:  37
[ 00.041% ] Loading Jars:  3
[ 78.908% ] Polyglot phases:  5765
[ 00.027% ] Resolve class names:  2
[ 00.041% ] Declare Parents:  3
[ 00.821% ] Recompute name pattern matches:  60
[ 00.000% ] Compute precedence relation:  0
[ 01.889% ] Intertype Adjuster:  138
[ 05.379% ] Retrieving bodies:  393
[ 00.000% ] Weave Initializers:  0
[ 00.301% ] Load shadow types:  22
[ 03.080% ] Compute advice lists:  225
[ 00.041% ] Intertype weave:  3
[ 00.602% ] Add aspect code:  44
[ 00.452% ] Weaving advice:  33
[ 00.000% ] Validate jimple:  0
[ 04.380% ] Soot Packs:  320
[ 03.531% ] Soot Writing Output:  258
================================================
Abc started on Thu Jun 24 10:09:04 BST 2004
<<<< DefineInterface.java >>>>
package pack;

import org.aspectj.testing.Tester;

public aspect DefineInterface {
    declare parents : InterfaceDefinition.C implements pack.MyInterface;
    
    static { org.aspectj.testing.Tester.expectEvent("m()"); }
    
    public intertype void pack.MyInterface.m() {
        org.aspectj.testing.Tester.event("m()");
    }
    
    before(MyInterface targ):
    target(targ) &&
      call(void (*).run()) {
        targ.m();
    }
    
    after() returning:
    execution (void (*).main(String[])) {
        org.aspectj.testing.Tester.checkAllEvents();
    }
    
    public static pack.DefineInterface aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public DefineInterface() { super(); }
}
<<<< Main.java >>>>
public class Main implements pack.MyInterface {
    public static void main(java.lang.String[] args) {
        new Main().m();
        new pack.InterfaceDefinition.C().m();
    }
    
    public void m() {
        java.lang.System/*java.lang.System*/.out.println("hello");
    }
    
    public Main() { super(); }
}
<<<< MyInterface.java >>>>
package pack;

public interface MyInterface {
    public abstract void m();
}
<<<< InterfaceDefinition.java >>>>
package pack;

public class InterfaceDefinition {
    public static void main(java.lang.String[] args) {
        new pack.InterfaceDefinition.C().run();
    }
    
    public static class C {
        void run() {  }
        
        public C() { super(); }
    }
    
    
    public InterfaceDefinition() { super(); }
}
retrieve <pack.DefineInterface: void <init>()> from pack.DefineInterface
retrieve <pack.DefineInterface: void <clinit>()> from pack.DefineInterface
retrieve <pack.DefineInterface: void m(pack.MyInterface)> from pack.DefineInterface
retrieve <pack.DefineInterface: void before$1(pack.MyInterface)> from pack.DefineInterface
retrieve <pack.DefineInterface: void afterReturning$2()> from pack.DefineInterface
retrieve <pack.DefineInterface: pack.DefineInterface aspectOf()> from pack.DefineInterface
retrieve <pack.DefineInterface: boolean hasAspect()> from pack.DefineInterface
retrieve <Main: void m()> from Main
retrieve <Main: void main(java.lang.String[])> from Main
retrieve <Main: void <init>()> from Main
retrieve <pack.InterfaceDefinition: void main(java.lang.String[])> from pack.InterfaceDefinition
retrieve <pack.InterfaceDefinition: void <init>()> from pack.InterfaceDefinition
retrieve <pack.InterfaceDefinition$C: void m()> from pack.InterfaceDefinition$C
retrieve <pack.InterfaceDefinition$C: void <init>()> from pack.InterfaceDefinition$C
retrieve <pack.InterfaceDefinition$C: void run()> from pack.InterfaceDefinition$C
Transforming pack.InterfaceDefinition... 
Transforming pack.InterfaceDefinition$C... 
Transforming pack.MyInterface... 
Transforming Main... 
Transforming pack.DefineInterface... 
Abc finished on Thu Jun 24 10:09:12 BST 2004. ( 0 min. 7 sec. )
hello
PASS: Use class implementing interface via aspect (weave all together)()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 432 failed (check: 171), 457 passed (check: 116), 7 skipped.
Executing test 897 (bugs/interfaceDefinition): Use class implementing interface via aspect (only one implementer)
================================================
Breakdown of abc phases  (total: 7621 millisec.)
------------------------------------------------
[ 00.538% ] Init. of Soot:  41
[ 00.039% ] Loading Jars:  3
[ 75.305% ] Polyglot phases:  5739
[ 00.026% ] Resolve class names:  2
[ 00.039% ] Declare Parents:  3
[ 00.682% ] Recompute name pattern matches:  52
[ 00.000% ] Compute precedence relation:  0
[ 01.994% ] Intertype Adjuster:  152
[ 04.986% ] Retrieving bodies:  380
[ 00.000% ] Weave Initializers:  0
[ 00.289% ] Load shadow types:  22
[ 02.611% ] Compute advice lists:  199
[ 00.039% ] Intertype weave:  3
[ 00.446% ] Add aspect code:  34
[ 00.472% ] Weaving advice:  36
[ 00.000% ] Validate jimple:  0
[ 09.343% ] Soot Packs:  712
[ 03.189% ] Soot Writing Output:  243
================================================
Failed. Current status: 433 failed (check: 171), 457 passed (check: 116), 7 skipped.
Executing test 898 (bugs): Erroneous exception conversion
================================================
Breakdown of abc phases  (total: 7479 millisec.)
------------------------------------------------
[ 00.508% ] Init. of Soot:  38
[ 00.040% ] Loading Jars:  3
[ 78.807% ] Polyglot phases:  5894
[ 00.040% ] Resolve class names:  3
[ 00.027% ] Declare Parents:  2
[ 00.682% ] Recompute name pattern matches:  51
[ 00.000% ] Compute precedence relation:  0
[ 00.495% ] Intertype Adjuster:  37
[ 08.183% ] Retrieving bodies:  612
[ 00.174% ] Weave Initializers:  13
[ 00.308% ] Load shadow types:  23
[ 03.356% ] Compute advice lists:  251
[ 00.040% ] Intertype weave:  3
[ 00.147% ] Add aspect code:  11
[ 00.308% ] Weaving advice:  23
[ 00.000% ] Validate jimple:  0
[ 03.771% ] Soot Packs:  282
[ 03.115% ] Soot Writing Output:  233
================================================
boom in 5...
Abc started on Thu Jun 24 10:09:25 BST 2004
<<<< ErroneousExceptionConversion.java >>>>
import org.aspectj.testing.Tester;
import org.aspectj.lang.NoAspectBoundException;

public class ErroneousExceptionConversion {
    public static void main(java.lang.String[] args) {
        try {
            new ErroneousExceptionConversion();
            org.aspectj.testing.Tester.checkFailed("Wanted an exception in initializer error");
        }
        catch (org.aspectj.lang.NoAspectBoundException nabEx) {
            java.lang.Throwable cause = nabEx.getCause();
            if (!(cause instanceof java.lang.RuntimeException)) {
                org.aspectj.testing.Tester.checkFailed("Should have a RuntimeException as cause");
            }
        }
        catch (java.lang.Throwable t) {
            org.aspectj.testing.Tester.checkFailed("Wanted an ExceptionInInitializerError but got " +
                                                   t);
        }
    }
    
    public ErroneousExceptionConversion() { super(); }
}
aspect A {
    int ErroneousExceptionConversion.someField = throwIt();
    
    public static int throwIt() {
        throw new java.lang.RuntimeException("Exception during aspect initialization");
    }
    
    public A() {
        super();
        java.lang.System/*java.lang.System*/.err.println("boom in 5...");
        throw new java.lang.RuntimeException("boom");
    }
    
    after() throwing:
    initialization((ErroneousExceptionConversion).new(..)) {
        java.lang.System/*java.lang.System*/.out.println("After throwing");
    }
    
    public static A aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
}
retrieve <ErroneousExceptionConversion: void <init>()> from ErroneousExceptionConversion
retrieve <ErroneousExceptionConversion: void main(java.lang.String[])> from ErroneousExceptionConversion
retrieve <A: int throwIt()> from A
retrieve <A: void <init>()> from A
retrieve <A: void afterThrowing$1()> from A
retrieve <A: A aspectOf()> from A
retrieve <A: boolean hasAspect()> from A
retrieve <A: int init$someField$4(ErroneousExceptionConversion)> from A
Transforming A... 
Transforming ErroneousExceptionConversion... 
Abc finished on Thu Jun 24 10:09:32 BST 2004. ( 0 min. 7 sec. )
PASS: Erroneous exception conversion()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 433 failed (check: 171), 458 passed (check: 116), 7 skipped.
Executing test 899 (bugs): before():execution(new(..)) does not throw NoAspectBoundException
================================================
Breakdown of abc phases  (total: 6723 millisec.)
------------------------------------------------
[ 00.550% ] Init. of Soot:  37
[ 00.045% ] Loading Jars:  3
[ 79.845% ] Polyglot phases:  5368
[ 00.030% ] Resolve class names:  2
[ 00.030% ] Declare Parents:  2
[ 00.640% ] Recompute name pattern matches:  43
[ 00.000% ] Compute precedence relation:  0
[ 00.535% ] Intertype Adjuster:  36
[ 08.166% ] Retrieving bodies:  549
[ 00.000% ] Weave Initializers:  0
[ 00.327% ] Load shadow types:  22
[ 02.291% ] Compute advice lists:  154
[ 00.045% ] Intertype weave:  3
[ 00.521% ] Add aspect code:  35
[ 00.416% ] Weaving advice:  28
[ 00.000% ] Validate jimple:  0
[ 03.272% ] Soot Packs:  220
[ 03.287% ] Soot Writing Output:  221
================================================
Abc started on Thu Jun 24 10:09:35 BST 2004
<<<< ErroneousExceptionConversion1.java >>>>
import org.aspectj.lang.*;
import org.aspectj.testing.Tester;

aspect Watchcall {
    pointcut myConstructor() : execution ((*).new(..));
    
    before():
    myConstructor() {
        java.lang.System/*java.lang.System*/.err.println("Entering Constructor");
    }
    
    after():
    myConstructor() {
        java.lang.System/*java.lang.System*/.err.println("Leaving Constructor");
    }
    
    public static Watchcall aspectOf()
          throws org.aspectj.lang.NoAspectBoundException {
        return null;
    }
    
    public static boolean hasAspect() { return true; }
    
    public Watchcall() { super(); }
}
public class ErroneousExceptionConversion1 {
    public static void main(java.lang.String[] args) {
        try {
            ErroneousExceptionConversion1 c =
              new ErroneousExceptionConversion1();
            org.aspectj.testing.Tester.checkFailed("shouldn\'t get here");
        }
        catch (org.aspectj.lang.NoAspectBoundException nab) {  }
    }
    
    public ErroneousExceptionConversion1() { super(); }
}
retrieve <Watchcall: void after$1()> from Watchcall
retrieve <Watchcall: Watchcall aspectOf()> from Watchcall
retrieve <Watchcall: boolean hasAspect()> from Watchcall
retrieve <Watchcall: void <init>()> from Watchcall
retrieve <Watchcall: void before$0()> from Watchcall
retrieve <ErroneousExceptionConversion1: void main(java.lang.String[])> from ErroneousExceptionConversion1
retrieve <ErroneousExceptionConversion1: void <init>()> from ErroneousExceptionConversion1
Transforming ErroneousExceptionConversion1... 
Transforming Watchcall... 
Abc finished on Thu Jun 24 10:09:42 BST 2004. ( 0 min. 6 sec. )
PASS: before():execution(new(..)) does not throw NoAspectBoundException()


PASS Suite.Spec(/usr/local/src/abc-dev/ajc-harness/tests) 1 tests (1 passed) 8 seconds
Passed. Current status: 433 failed (check: 171), 459 passed (check: 116), 7 skipped.
Executing test 900 (bugs): Anomalous handling of inter-type declarations to abstract base classes in aspectj 1.1
Failed. Current status: 434 failed (check: 171), 459 passed (check: 116), 7 skipped.
Executing test 901 (bugs/caseSensitivity): NPE When compiling intertype declaration
Failed. Current status: 435 failed (check: 172), 459 passed (check: 116), 7 skipped.
Executing test 902 (bugs): declare warning on subtype constructor
Failed. Current status: 436 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 903 (bugs): CatchClauseSignature has broken operation
getting SJPInfo for a untagged source line $r2 := @caughtexception
================================================
Breakdown of abc phases  (total: 7273 millisec.)
------------------------------------------------
[ 00.495% ] Init. of Soot:  36
[ 00.041% ] Loading Jars:  3
[ 78.180% ] Polyglot phases:  5686
[ 00.014% ] Resolve class names:  1
[ 00.027% ] Declare Parents:  2
[ 00.756% ] Recompute name pattern matches:  55
[ 00.000% ] Compute precedence relation:  0
[ 00.481% ] Intertype Adjuster:  35
[ 07.878% ] Retrieving bodies:  573
[ 00.000% ] Weave Initializers:  0
[ 00.302% ] Load shadow types:  22
[ 03.616% ] Compute advice lists:  263
[ 00.069% ] Intertype weave:  5
[ 00.137% ] Add aspect code:  10
[ 01.100% ] Weaving advice:  80
[ 00.000% ] Validate jimple:  0
[ 03.671% ] Soot Packs:  267
[ 03.231% ] Soot Writing Output:  235
================================================
Failed. Current status: 437 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 904 (new): after returning with parameter: matching rules
Failed. Current status: 438 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 905 (bugs/binaryCompat): binary compatibility of advice method names - expect no error
Failed. Current status: 439 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 906 (bugs/binaryCompat): binary compatibility of advice method names - expect error
Failed. Current status: 440 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 907 (bugs/binaryCompat): binary compatibility of advice method names - expect no error
Failed. Current status: 441 failed (check: 173), 459 passed (check: 116), 7 skipped.
Executing test 908 (bugs/protectedvf): mail list VerifyError with protected access
Failed. Current status: 442 failed (check: 173), 459 passed (check: 116), 7 skipped.
Tests: 908

package abc.impact.utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import soot.ArrayType;
import soot.Body;
import soot.ByteType;
import soot.CharType;
import soot.DoubleType;
import soot.FloatType;
import soot.Hierarchy;
import soot.IntType;
import soot.LongType;
import soot.Modifier;
import soot.PrimType;
import soot.RefType;
import soot.Scene;
import soot.ShortType;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.Type;
import soot.Unit;
import soot.jimple.Stmt;
import soot.tagkit.SourceLnPosTag;
import abc.impact.analysis.ITDNoiseAnalysis;
import abc.impact.impact.MethodSignature;
import abc.impact.impact.ReferredPlace;
import abc.weaving.aspectinfo.AbcType;
import abc.weaving.aspectinfo.FieldSig;
import abc.weaving.aspectinfo.Formal;
import abc.weaving.aspectinfo.GlobalAspectInfo;
import abc.weaving.aspectinfo.InAspect;
import abc.weaving.aspectinfo.IntertypeConstructorDecl;
import abc.weaving.aspectinfo.IntertypeFieldDecl;
import abc.weaving.aspectinfo.IntertypeMethodDecl;
import abc.weaving.aspectinfo.MethodSig;

public class ImpactUtil {

	//prevent instantiation 
	private ImpactUtil() {}
	
	//check if the method is proceed method
	public static boolean isProceed(SootMethod method) {
		String name = method.getName();
		return name.startsWith("abc$static$proceed$") ||
				name.startsWith("proceed$") /*TODO if the advice is not applied, 
				prefix with this, furthur verify*/;
	}
	
	//check if the formal is the "org.aspectj.lang.JoinPoint thisJoinPoint" formal,
	//which is generated by abc when dealing with around advice accessing "thisJoinPoint"
	public static boolean isThisJoinPointFormal(Formal formal) {
		if (formal.getName().equals("thisJoinPoint") && 
				formal.getType().toString().equals("org.aspectj.lang.JoinPoint")) { 
			return true; 
		}
		if (formal.getName().equals("thisJoinPointStaticPart") &&
				formal.getType().toString().equals("org.aspectj.lang.JoinPoint$StaticPart")) {
			return true;
		}
		return false;
	}
	
	//check if the stmt is generated by abc
	//if can not get source line information, consider it as abc genrated
	// TODO need to further verify
	public static boolean isAbcGeneratedStmt(Stmt stmt) {
		SourceLnPosTag slpTag = (SourceLnPosTag) stmt.getTag("SourceLnPosTag");
		return slpTag == null;
	}
	
	//check if b contains u
	public static boolean isContainUnit(Body b, Unit u)
	{
		boolean found = false;
		for (Iterator uIt = b.getUnits().iterator(); uIt.hasNext();) {
			if (u.equals(uIt.next())) {
				found = true;
				break;
			}
		}
		return found;
	}

	/**
	 * check if itd field is visible to injected class
	 * @param itdFieldDecl
	 * @return
	 */
	public static boolean isInvisibleITDField(IntertypeFieldDecl itdFieldDecl) {
		
		FieldSig itdFieldSig = itdFieldDecl.getTarget();
		SootClass itdFieldClass = itdFieldSig.getDeclaringClass().getSootClass();
		int realMod = getRealModifiers(itdFieldSig);
		// System.out.println(realMod);
		boolean isPrivate = Modifier.isPrivate(realMod);
		boolean isDefault = ImpactUtil.isDefaultModifer(realMod);
		String aspectPackage = itdFieldDecl.getAspect().getInstanceClass().getSootClass().getPackageName();
		return isPrivate || (isDefault && !itdFieldClass.getPackageName().equals(aspectPackage));
	}
	
//	/**
//	 * check if an inter-type declaration method is private
//	 */
//	public static boolean isPrivateITDMethod(MethodSig methodSig)
//	{
////		GlobalAspectInfo globalAspectInfo = 
////			 abc.main.Main.v().getAbcExtension().getGlobalAspectInfo();
////		int realModifier = globalAspectInfo.getRealModifiers(methodSig, -1);
////		if (realModifier == -1) {
////			//if see many exceptions, try: 
////			// if (methodSig.getName().startsWith(itdMethodDecl.getAspect().getName() + "$")) continue;
////			throw new RuntimeException("Unable to acquire real modifiers of " + methodSig);
////		} else {
////			return Modifier.isPrivate(realModifier);
////		}
//		return Modifier.isPrivate(getRealModifiers(methodSig));
//	}
//	
//	public static boolean isDefaultITDMethod(MethodSig methodSig)
//	{
//		return ImpactUtil.isDefaultModifer(getRealModifiers(methodSig));
//	}
//
//	public static boolean isPublicITDMethod(MethodSig methodSig)
//	{
//		return Modifier.isPublic(getRealModifiers(methodSig));
//	}

	/**
	 * Check if itd method is visible to injected class
	 * @param itdMethodDecl
	 * @return
	 */
	public static boolean isInvisibleITDMethod(IntertypeMethodDecl itdMethodDecl) {
		
		MethodSig itdMethodSig = itdMethodDecl.getTarget();
		SootClass itdMethodClass = itdMethodSig.getDeclaringClass().getSootClass();
		boolean isPrivate = Modifier.isPrivate(getRealModifiers(itdMethodSig));
		boolean isDefault = ImpactUtil.isDefaultModifer(getRealModifiers(itdMethodSig));
		String aspectPackage = itdMethodDecl.getAspect().getInstanceClass().getSootClass().getPackageName();
		return isPrivate || (isDefault && !itdMethodClass.getPackageName().equals(aspectPackage));
	}
	
//	public static boolean isPrivateITDConstructor(IntertypeConstructorDecl itdConstructorDecl)
//	{
//		return Modifier.isPrivate(itdConstructorDecl.getOriginalModifiers());
//	}
//	
//	public static boolean isDefaultITDConstructor(IntertypeConstructorDecl itdConstructorDecl)
//	{
//		return ImpactUtil.isDefaultModifer(itdConstructorDecl.getOriginalModifiers());
//	}
//
//	public static boolean isPublicITDConstructor(IntertypeConstructorDecl itdConstructorDecl)
//	{
//		return Modifier.isPublic(itdConstructorDecl.getOriginalModifiers());
//	}

	/**
	 * Check if itd method is visible to injected class
	 * @param itdMethodDecl
	 * @return
	 */
	public static boolean isInvisibleITDConstructor(IntertypeConstructorDecl itdConstructorDecl) {
		
		SootClass itdConstructorClass = itdConstructorDecl.getTarget().getSootClass();
		boolean isPrivate = Modifier.isPrivate(getRealModifiers(itdConstructorDecl));
		boolean isDefault = ImpactUtil.isDefaultModifer(getRealModifiers(itdConstructorDecl));
		String aspectPackage = itdConstructorDecl.getAspect().getInstanceClass().getSootClass().getPackageName();
		return isPrivate || (isDefault && !itdConstructorClass.getPackageName().equals(aspectPackage));
	}
	
	/**
	 * Test if a modifier is default
	 * @param m
	 * @return
	 */
	public static boolean isDefaultModifer(int m) {
		return (!Modifier.isPrivate(m) && !Modifier.isProtected(m) && !Modifier.isPublic(m));
	}
	
//	/**
//	 * check if the method name is injected, return true if the name
//	 * 1. has the pattern string1$string2$number
//	 * 2. string1 is the name of an aspect
//	 * 3. string2 is in one of realnames of itdmethodinject
//	 * 4. number is consisted of digits
//	 * @param name the suspected name
//	 * @return ture if condition 1 & 2 & 3 & 4 are satisfied
//	 */
//	public static boolean isInjectedMethodName(String name)
//	{
//		int firstDollar = name.indexOf('$');
//		if (firstDollar == -1) return false;
//		
//		int lastDollar = name.lastIndexOf('$');
//		if (firstDollar == lastDollar) return false;
//		
//		String string1 = name.substring(0, firstDollar);
//		GlobalAspectInfo globalAspectInfo = 
//			 abc.main.Main.v().getAbcExtension().getGlobalAspectInfo();
//		boolean cond2 = false;
//		for (Iterator aspectIt = globalAspectInfo.getAspects().iterator(); aspectIt.hasNext(); ) {
//			if ( ((Aspect)aspectIt.next()).getName().equals(string1) ) cond2 = true;
//		}
//		if (!cond2) return false;
//		
//		String string2 = name.substring(firstDollar+1, lastDollar);
//		boolean cond3 = false;
//		for (Iterator itdMethodDeclIt = globalAspectInfo.getIntertypeMethodDecls().iterator(); itdMethodDeclIt.hasNext(); ) {
//			IntertypeMethodDecl itdMethodDecl = (IntertypeMethodDecl)itdMethodDeclIt.next();
//			if ( itdMethodDecl.getOrigName().equals(string2) ) cond3 = true;
//		}
//		if (!cond3) return false;
//		
//		String number = name.substring(lastDollar+1);
//		boolean cond4 = true;
//		for (int i = 0; i < number.length(); i++) {
//			char ic = number.charAt(i);
//			if (ic < '0' || ic > '9' ) cond4 = false;
//		}
//		if (!cond4) return false;
//		
//		return true;
//	}
//
//	/**
//	 * get real name (string2 in the pattern string1$string2$number)
//	 * caller is supposed to call isInjectedMethodName(injectedName) first
//	 * @param injectedName
//	 * @return
//	 */
//	public static String getRealName(String injectedName)
//	{
//		return injectedName.substring(injectedName.indexOf('$')+1, injectedName.lastIndexOf('$'));
//	}
	
	/**
	 * Get real modifiers of sf, take itd injection into account
	 * @param sf
	 * @return
	 */
	public static int getRealModifiers(SootField sf) {
		
		Map<SootField, InAspect> targets = ITDNoiseAnalysis.v().getTargetFields();
		if (targets.containsKey(sf)) {
			IntertypeFieldDecl fd = (IntertypeFieldDecl) targets.get(sf);
			return getRealModifiers(fd);
		} else {
			return sf.getModifiers();
		}
	}
	
	/**
	 * Get real modifiers of sm, take itd injection into account
	 * @param sm
	 * @return
	 */
	public static int getRealModifiers(SootMethod sm) {
		Map<SootMethod, InAspect> targets = ITDNoiseAnalysis.v().getTargetMethods();
		
		if (targets.containsKey(sm)) {
			InAspect ia = targets.get(sm);
			if (ia instanceof IntertypeMethodDecl) {
				IntertypeMethodDecl md = (IntertypeMethodDecl) targets.get(sm);
				return getRealModifiers(md);
			} else if (ia instanceof IntertypeConstructorDecl) {
				IntertypeConstructorDecl cd = (IntertypeConstructorDecl) targets.get(sm);
				return getRealModifiers(cd);
			} else 
				throw new RuntimeException("Unknown " + targets.get(sm));
		} else 
			return sm.getModifiers();
	}
	
	public static int getRealModifiers(FieldSig fieldSig) {
		GlobalAspectInfo globalAspectInfo = 
			 abc.main.Main.v().getAbcExtension().getGlobalAspectInfo();
		int realModifier = globalAspectInfo.getRealModifiers(fieldSig, -1);
		if (realModifier == -1) {
			throw new RuntimeException("Unable to acquire real modifiers of " + fieldSig);
		} else {
			return realModifier;
		}
	}
	
	public static int getRealModifiers(MethodSig methodSig) {
		return methodSig.getModifiers();
	}
	
	public static int getRealModifiers(IntertypeMethodDecl methodDecl) {
		return methodDecl.getTarget().getModifiers();
	}
	
	public static int getRealModifiers(IntertypeConstructorDecl conDecl) {
		return conDecl.getOriginalModifiers();
	}
	
	public static int getRealModifiers(IntertypeFieldDecl fieldDecl) {
		return getRealModifiers(fieldDecl.getTarget());
	}
	
	/**
	 * Get the SootField target of inter type field injection.
	 * This method is listed here for being consistent with 
	 *  getITDMethodTarget and getITDConstructorTarget, and 
	 *  it just calls itdFieldSig.getSootField()
	 * @param itdMethodSig
	 * @return
	 */
	public static SootField getITDFieldTarget(FieldSig itdFieldSig) {
		return itdFieldSig.getSootField();
	}

	/**
	 * Get the SootMethod target of inter type method injection.
	 * This is a patch for abc's MethodSig.getSootMethod, which is failed to
	 * deal with itd method. Basically, if the MethodSig is not static, try 
	 * to get the SootMethod after removing the first parameter.
	 * @param itdMethodSig
	 * @return
	 */
	public static SootMethod getITDMethodTarget(MethodSig itdMethodSig) {
		SootMethod target = null;
		if (Modifier.isStatic(itdMethodSig.getModifiers())) return itdMethodSig.getSootMethod();
		
		List<Type> spt = new ArrayList<Type>();
		Iterator fi = itdMethodSig.getFormals().iterator();
		while (fi.hasNext()) {
			Formal f = (Formal)fi.next();
			spt.add(f.getType().getSootType());
		}
		spt.remove(0);
		try {
			target = itdMethodSig.getDeclaringClass().getSootClass().getMethod(itdMethodSig.getName(), spt);
		} catch (RuntimeException e) {System.out.println("fix here");}
		
		return target;
	}

	/**
	 * Get the SootMethod of inter type consturctor injection
	 * @param itdConstructorDecl
	 * @return
	 */
	public static SootMethod getITDConstructorTarget(IntertypeConstructorDecl itdConstructorDecl) {
		SootMethod target = null;
		
		List<Type> spt = new ArrayList<Type>();
		Iterator fi = itdConstructorDecl.getFormalTypes().iterator();
		while (fi.hasNext()) {
			AbcType f = (AbcType)fi.next();
			spt.add(f.getSootType());
		}
		try {
			target = itdConstructorDecl.getTarget().getSootClass().getMethod(SootMethod.constructorName, spt);
		} catch (RuntimeException e) {System.out.println("fix here");}
		
		return target;
	}

	/**
	 * check if Type s can be converted to Type t, JLS v2 5.1.1
	 */
	public static boolean isIdentityConversion(Type s, Type t)
	{
			return s.equals(t);
	}
	
	/**
	 * check if Type s can be converted to Type t, JLS v2 5.1.2
	 */
	public static boolean isWideningPrimConversion(Type s, Type t)
	{
		if (! (s instanceof PrimType && t instanceof PrimType) )
			return false;
		
		if (s instanceof ByteType) {
			if (t instanceof ShortType ||
				t instanceof IntType ||
				t instanceof LongType ||
				t instanceof FloatType ||
				t instanceof DoubleType)
			return true;
		}
		
		if (s instanceof ShortType) {
			if (t instanceof IntType ||
				t instanceof LongType ||
				t instanceof FloatType ||
				t instanceof DoubleType)
			return true;
		}
		
		if (s instanceof CharType) {
			if (t instanceof IntType ||
				t instanceof LongType ||
				t instanceof FloatType ||
				t instanceof DoubleType)
			return true;
		}
		
		if (s instanceof IntType) {
			if (t instanceof LongType ||
				t instanceof FloatType ||
				t instanceof DoubleType)
			return true;
		}
		
		if (s instanceof LongType) {
			if (t instanceof FloatType ||
				t instanceof DoubleType)
			return true;
		}

		if (s instanceof FloatType) {
			if (t instanceof DoubleType)
			return true;
		}

		return false;
	}
	
	/**
	 * check if Type s can be converted to Type t, JLS v2 5.1.4
	 */
	public static boolean isWideningRefConversion(Type s, Type t)
	{
		Hierarchy hierarchy = Scene.v().getActiveHierarchy();

		if (s instanceof RefType && t instanceof RefType) {
			RefType rs = (RefType) s;
			RefType rt = (RefType) t;
			SootClass sClass = rs.getSootClass();
			SootClass tClass = rt.getSootClass();

			// # From any class type S to any class type T, provided that S is a subclass of T. (An important special case is that there is a widening conversion to the class type Object from any other class type.)
			if (!sClass.isInterface() && !tClass.isInterface()) {
				return hierarchy.isClassSubclassOf(sClass, tClass);
			}

			// # From any class type S to any interface type K(T), provided that S implements K.
			if (!sClass.isInterface() && tClass.isInterface()) {
				sClass.checkLevel(SootClass.HIERARCHY);
				tClass.checkLevel(SootClass.HIERARCHY);
				return hierarchy.getImplementersOf(tClass).contains(sClass);
			}

			// # From the null type to any class type, interface type, or array type. **not implemented**
			// # From any interface type J(S) to any interface type K(T), provided that J is a subinterface of K.
			if (sClass.isInterface() && tClass.isInterface()) {
				return hierarchy.isInterfaceSubinterfaceOf(sClass, tClass);
			}
			
			//# From any interface type to type Object.
			if (sClass.isInterface() && tClass.getName().equals("java.lang.Object")) {
				return true;
			}
		}
		
		// # From any array type SC[] to any array type TC[], provided that SC and TC are reference types and there is a widening conversion from SC to TC.
		if (s instanceof ArrayType && t instanceof ArrayType) {
			ArrayType as = (ArrayType) s;
			ArrayType at = (ArrayType) t;
			Type sc = as.getElementType();
			Type tc = at.getElementType();
			return isWideningRefConversion(sc, tc);
		}
		
		/*
		# From any array type to type Object.
		# From any array type to type Cloneable.
		# From any array type to type java.io.Serializable
		 */
		if (s instanceof ArrayType && t instanceof RefType) {
			SootClass tClass = ((RefType)t).getSootClass();
			String tName = tClass.getName();
			if (tName.equals("java.lang.Object") ||
				tName.equals("java.lang.Cloneable") ||
				tName.equals("java.io.Serializable")) {
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * check if soot.Type s can be converted to soot.Type t, JLS v2 5.3
	 */
	public static boolean isMethodInvocationConversion(Type s, Type t) {
		return isIdentityConversion(s, t) || isWideningPrimConversion(s, t) || isWideningRefConversion(s, t);
	}
	
	/**
	 * Get direct super types (super class/interface and implemented interfaces) of a SootClass
	 * @param currentClass
	 * @return empty list if currentClass is "java.lang.Object"
	 */
	public static List<SootClass> getDirectSuperTypesOf(SootClass currentClass) {
		LinkedList<SootClass> ret = new LinkedList<SootClass>();
		// if the currentClass is not Object, try get its super types
		if (!currentClass.getName().equals("java.lang.Object")) {
			ret.add(currentClass.getSuperclass());
			if (currentClass.getInterfaceCount() > 0) ret.addAll(currentClass.getInterfaces());
		}
		return Collections.unmodifiableList(ret);
	}
	
	/**
	 * Get direct sub types (sub class/interface and interface implementers) of a SootClass
	 * @param currentClass
	 * @return
	 */
	public static List<SootClass> getDirectSubTypesOf(SootClass currentClass) {
		LinkedList<SootClass> ret = new LinkedList<SootClass>();
		Hierarchy hierarchy = Scene.v().getActiveHierarchy();
		if (currentClass.isInterface()) {
			ret.addAll(hierarchy.getDirectSubinterfacesOf(currentClass));
			ret.addAll(hierarchy.getDirectImplementersOf(currentClass));
		} else {
			ret.addAll(hierarchy.getDirectSubclassesOf(currentClass));
		}
		
		return Collections.unmodifiableList(ret);
	}
	
	
	/**
	 * Check if sf is inherited by sc
	 * @param sf should be have default visibility
	 * @param sc should be subclass of sf's declaring class
	 */
	public static boolean isDefaultFieldInheritedBy(SootField sf, SootClass sc) {

		SootClass fClass = sf.getDeclaringClass();
		String scPackage = sc.getPackageName();
		boolean samePackage = true;
		SootClass temp = sc;
		while (temp != fClass) {
			if (temp.getName().equals("java.lang.Object"))
				throw new RuntimeException("sc is not subclass of sf's declaring class");
			temp = temp.getSuperclass();
			if (samePackage) samePackage = scPackage.equals(temp.getPackageName());
		}
		
		return samePackage;
	}
	
//	/**
//	 * Get a list of concrete SootMethod inheritable to childern (direct sub classes) of sc
//	 * excluding constructors and abstract, interface methods
//	 * excluding those are not visible from referredPlace (relative to childern of sc)
//	 * excluding methods being overrided
//	 * @param sc
//	 * @param isChildInSamePackage
//	 * @param referredPlace
//	 * @return
//	 */
//	public static List<SootMethod> getInheritableMethods(SootClass sc, boolean isChildInSamePackage, ReferredPlace referredPlace) {
//		return getInheritableMethodsImpl(sc, isChildInSamePackage, referredPlace, false, "java.lang.Object");
//	}
	
	/**
	 * Get a list of concrete SootMethod inheritable to childern (direct sub classes) of sc
	 * excluding constructors and abstract, interface methods
	 * including methods being overriden
	 * Note: NO noise filter
	 * @param sc
	 * @param isChildInSamePackage
	 * @return
	 */
	public static List<SootMethod> getInheritableMethodsWithOverriden(SootClass sc, boolean isChildInSamePackage) {
		return getInheritableMethodsImpl(sc, isChildInSamePackage, true, "java.lang.Object", null, null);
	}
	
	/**
	 * Get a list of concrete SootMethod inheritable to childern (direct sub classes) of sc
	 * excluding constructors and abstract, interface methods
	 * including methods being overriden
	 * skip methods defined in classes between skipBottom(skipped) and skipTop(not skipped)
	 * Note: NO noise filter
	 * @param sc
	 * @param isChildInSamePackage
	 * @param skipBottom
	 * @param skipTop
	 * @return
	 */
	public static List<SootMethod> getInheritableMethodsWithOverriden(SootClass sc, boolean isChildInSamePackage, SootClass skipBottom, SootClass skipTop) {
		return getInheritableMethodsImpl(sc, isChildInSamePackage, true, "java.lang.Object", skipBottom, skipTop);
	}
	
//	/**
//	 * Get a list of concrete SootMethod inherited from ancestors (super classes) of sc
//	 * excluding constructors and abstract, interface methods
//	 * excluding those are not visible from referredPlace (relative to sc)
//	 * excluding methods being overrided
//	 * @param sc
//	 * @param referredPlace
//	 * @return
//	 */
//	public static List<SootMethod> getInheritedMethods(SootClass sc, ReferredPlace referredPlace) {
//
//		List<SootMethod> methods = new LinkedList<SootMethod>();
//		String scPackage = sc.getPackageName();
//		
//		if (!sc.getName().equals("java.lang.Object")) {
//			SootClass superc = sc.getSuperclass();
//			return Tool.getInheritableMethods(superc, scPackage.equals(superc.getPackageName()), referredPlace);
//		}
//
//		return Collections.unmodifiableList(methods);
//	}
	
	/**
	 * Get a list of concrete SootMethod inherited from ancestors (super classes) of sc
	 * excluding constructors and abstract, interface methods
	 * including methods being overriden
	 * Note: NO noise filter
	 * @param sc
	 * @return
	 */
	public static List<SootMethod> getInheritedMethodsWithOverriden(SootClass sc) {

		List<SootMethod> methods = new LinkedList<SootMethod>();
		
		if (!sc.getName().equals("java.lang.Object")) {
			SootClass superc = sc.getSuperclass();
			return ImpactUtil.getInheritableMethodsWithOverriden(superc, sc.getPackageName().equals(superc.getPackageName()));
		}

		return Collections.unmodifiableList(methods);
	}
	
	/**
	 * Get a list of concrete SootMethod inherited from ancestors (super classes) of sc
	 * excluding constructors and abstract, interface methods
	 * including methods being overriden
	 * skip methods defined in classes between skipBottom(skipped) and skipTop(not skipped)
	 * Note: NO noise filter
	 * @param sc
	 * @param skipBottom
	 * @param skipTop
	 * @return
	 */
	public static List<SootMethod> getInheritedMethodsWithOverriden(final SootClass sc, final SootClass skipBottom, final SootClass skipTop) {

		List<SootMethod> methods = new LinkedList<SootMethod>();
		
		if (!sc.getName().equals("java.lang.Object")) {
			SootClass superc = sc.getSuperclass();
			return ImpactUtil.getInheritableMethodsWithOverriden(superc, sc.getPackageName().equals(superc.getPackageName()), skipBottom, skipTop);
		}

		return Collections.unmodifiableList(methods);
	}
	
//	/**
//	 * 
//	 * @param oldSuper
//	 * @param newSuper
//	 * @param isChildInSamePackage is child in the same package with new super
//	 * @param referredPlace
//	 * @return
//	 */
//	public static List<SootMethod> getNewInheritedMethods(SootClass oldSuper, SootClass newSuper, boolean isChildInSamePackage, ReferredPlace referredPlace) {
//		
//		if (oldSuper == newSuper) return new LinkedList<SootMethod>();
//		
//		SootClass topNewSuper = null;
//		while (oldSuper != newSuper) {
//			topNewSuper = newSuper;
//			newSuper = newSuper.getSuperclass();
//		}
//		
//		return getInheritableMethodsImpl(newSuper, isChildInSamePackage, referredPlace, false, topNewSuper.getName());
//	}
	
	/**
	 * Get memeber methods added by declaring new parent
	 * excluding methods being overriden
	 * Note: NO noise filter
	 * @param oldSuper
	 * @param newSuper
	 * @param isChildInSamePackageWithNewSuper is child in the same package with new super
	 * @return
	 */
	public static List<SootMethod> getNewInheritedMethodsNoOverriden(final SootClass oldSuper, final SootClass newSuper, final boolean isChildInSamePackageWithNewSuper) {
		
		if (oldSuper == newSuper) return Collections.unmodifiableList(new LinkedList<SootMethod>());
		
		SootClass topNewSuper = null, temp = newSuper;
		while (oldSuper != temp) {
			topNewSuper = temp;
			temp = temp.getSuperclass();
		}
		
		return getInheritableMethodsImpl(newSuper, isChildInSamePackageWithNewSuper, false, topNewSuper.getName(), null, null);
	}
	
//	/**
//	 * Select methods could be inherited from methodsOfSuperIncludingInherited
//	 * @param isSuperInSamePackage
//	 * @param methodsOfSuperIncludingInherited should include methods of super and methods which are inherited by super from its ancestor
//	 * @return a new List
//	 */
//	public static List<SootMethod> getInheritableMethods(boolean isSuperInSamePackage, final List<SootMethod> methodsOfSuperIncludingInherited) {
//		
//		LinkedList<SootMethod> l = new LinkedList<SootMethod>();
//		for (Iterator<SootMethod> mIt = methodsOfSuperIncludingInherited.iterator(); mIt.hasNext(); ) {
//			SootMethod m = mIt.next();
//			if (m.isPrivate()) continue;
//			boolean isDefault = (!m.isPrivate() && !m.isProtected() && !m.isPublic());
//			if (!isSuperInSamePackage && isDefault) continue;
//			l.add(m);
//		}
//		return Collections.unmodifiableList(l);
//	}
	
//	/**
//	 * Methods from topClass is included
//	 * @param sc
//	 * @param isChildInSamePackage
//	 * @param referredPlace
//	 * @param isKeepOverrided
//	 * @param topClass
//	 * @return
//	 */
//	private static List<SootMethod> getInheritableMethodsImpl(SootClass sc, boolean isChildInSamePackage, ReferredPlace referredPlace, boolean isKeepOverrided, String topClass) {
//		LinkedList<SootClass> worklist = new LinkedList<SootClass>();
//		List<SootMethod> methods = new LinkedList<SootMethod>();
//		boolean samePackage = isChildInSamePackage;
//		LinkedList<MethodSignature> msl = new LinkedList<MethodSignature>();
//		MethodSignature tempms = null;
//		
//		worklist.add(sc);
//		
//		while (!worklist.isEmpty()) {
//			// System.out.println(worklist);
//			SootClass currentSootClass = (SootClass)worklist.getFirst();
//			//System.out.println("--current class: " + currentSootClass.getName());
//			worklist.removeFirst();
//			
//			for (Iterator methodIt = currentSootClass.getMethods().iterator(); methodIt.hasNext();) {
//				SootMethod sm = (SootMethod) methodIt.next();
//				if (sm.getName().equals(SootMethod.constructorName)) continue;
//				if (sm.getName().equals(SootMethod.staticInitializerName)) continue;
//				if (sm.isAbstract()) continue;
//				// private is not inherited
//				if (sm.isPrivate()) continue;
//				// default and not same package, not inherited
//				boolean isDefault = !sm.isPrivate() && !sm.isProtected() && !sm.isPublic();
//				if (!samePackage && isDefault)
//					continue;
//				
//				if (referredPlace == ReferredPlace.CHILDERN) {
//					if (isDefault) continue;
//				}
//				
//				if (referredPlace == ReferredPlace.ALL) {
//					if (!sm.isPublic()) continue;
//				}
//				
//				if (!isKeepOverrided) {
//					tempms = new MethodSignature(sm);
//					if (msl.contains(tempms)) continue;
//				}
//				
//				methods.add(sm);
//				
//				if (!isKeepOverrided) {
//					msl.add(tempms);
//				}
//			}
//
//			if (!currentSootClass.getName().equals(topClass)) {
//				SootClass superc = currentSootClass.getSuperclass();
//				// once not same package in the inheritence chain, default methods in ancestors are not visible any more
//				// Notice: we are traversing the hierarchy down to up
//				if (samePackage) samePackage = currentSootClass.getPackageName().equals(superc.getPackageName());
//				worklist.add(superc);
//			}
//		}
//		
//		return Collections.unmodifiableList(methods);
//	}
	
	/**
	 * Methods from topClass is included
	 * skip methods defined in classes between skipBottom(skipped) and skipTop(not skipped)
	 * @param sc
	 * @param isChildInSamePackage
	 * @param isKeepOverrided
	 * @param topClass
	 * @param skipBottom
	 * @param skipTop
	 * @return
	 */
	private static List<SootMethod> getInheritableMethodsImpl(final SootClass sc, final boolean isChildInSamePackage, final boolean isKeepOverrided, final String topClass, final SootClass skipBottom, final SootClass skipTop) {
		LinkedList<SootClass> worklist = new LinkedList<SootClass>();
		List<SootMethod> methods = new LinkedList<SootMethod>();
		boolean samePackage = isChildInSamePackage;
		LinkedList<MethodSignature> msl = new LinkedList<MethodSignature>();
		MethodSignature tempms = null;
		SootClass start;

		if (sc == skipBottom) start = skipTop;
		else start = sc;
		worklist.add(start);
		
		while (!worklist.isEmpty()) {
			// System.out.println(worklist);
			SootClass currentSootClass = (SootClass)worklist.getFirst();
			//System.out.println("--current class: " + currentSootClass.getName());
			worklist.removeFirst();
			
			for (Iterator methodIt = currentSootClass.getMethods().iterator(); methodIt.hasNext();) {
				SootMethod sm = (SootMethod) methodIt.next();
				if (sm.getName().equals(SootMethod.constructorName)) continue;
				if (sm.getName().equals(SootMethod.staticInitializerName)) continue;
				if (sm.isAbstract()) continue;
				int modifiers = ImpactUtil.getRealModifiers(sm);
				// private is not inherited
				if (Modifier.isPrivate(modifiers)) continue;
				// default and not same package, not inherited
				if (!samePackage && ImpactUtil.isDefaultModifer(modifiers))
					continue;
				
				if (!isKeepOverrided) {
					tempms = new MethodSignature(sm);
					if (msl.contains(tempms)) continue;
				}
				
				methods.add(sm);
				
				if (!isKeepOverrided) {
					msl.add(tempms);
				}
			}

			if (!currentSootClass.getName().equals(topClass)) {
				SootClass superc = currentSootClass.getSuperclass();
				// skip
				if (superc.equals(skipBottom)) superc = skipTop;
				// once not same package in the inheritence chain, default methods in ancestors are not visible any more
				// Notice: we are traversing the hierarchy down to up
				if (samePackage) samePackage = currentSootClass.getPackageName().equals(superc.getPackageName());
				worklist.add(superc);
			}
		}
		
		return Collections.unmodifiableList(methods);
	}
	
//	/**
//	 * Get a list of concrete SootMethod of sc, only SootMethods is
//	 *  visible to referredPlace are selected
//	 * excluding constructors and abstract, interface methods
//	 * @param sc
//	 * @param referredPlace
//	 * @return
//	 */
//	public static List<SootMethod> getSootMethodsOf(SootClass sc, ReferredPlace referredPlace) {
//		List<SootMethod> methods = new LinkedList<SootMethod>();
//		
//		if (sc.isInterface()) throw new RuntimeException("Class is needed, not inerface.");
//		
//		for (Iterator methodIt = sc.getMethods().iterator(); methodIt.hasNext();) {
//			SootMethod sm = (SootMethod) methodIt.next();
//			if (sm.getName().equals(SootMethod.constructorName)) continue;
//			if (sm.getName().equals(SootMethod.staticInitializerName)) continue;
//			if (sm.isAbstract()) continue;
//			
//			if (referredPlace == ReferredPlace.PACKAGE) {
//				// private is excluded
//				if (sm.isPrivate()) continue;
//			}
//			
//			if (referredPlace == ReferredPlace.CHILDERN) {
//				// private is excluded
//				if (sm.isPrivate()) continue;
//				// default is excluded
//				if (!sm.isPrivate() && !sm.isProtected() && !sm.isPublic())
//					continue;
//			}
//			
//			if (referredPlace == ReferredPlace.ALL) {
//				// non-public is excluded
//				if (!sm.isPublic()) continue;
//			}
//			
//			methods.add(sm);
//		}
//		
//		return Collections.unmodifiableList(methods);
//	}
	
	/**
	 * Get a list of concrete SootMethod defined in sc
	 * excluding constructors and abstract, interface methods
	 * Note: NO noise filter
	 * @param sc
	 * @return
	 */
	public static List<SootMethod> getSootMethodsOf(SootClass sc) {
		List<SootMethod> methods = new LinkedList<SootMethod>();
		
		if (sc.isInterface()) throw new RuntimeException("Class is needed, not inerface.");
		
		for (Iterator methodIt = sc.getMethods().iterator(); methodIt.hasNext();) {
			SootMethod sm = (SootMethod) methodIt.next();
			if (sm.getName().equals(SootMethod.constructorName)) continue;
			if (sm.getName().equals(SootMethod.staticInitializerName)) continue;
			if (sm.isAbstract()) continue;
			
			methods.add(sm);
		}
		
		return Collections.unmodifiableList(methods);
	}
	
	/**
	 * Get a list of constructors defined in sc
	 * Note: NO noise filter
	 * @param sc
	 * @return
	 */
	public static List<SootMethod> getConstructorsOf(SootClass sc) {
		List<SootMethod> methods = new LinkedList<SootMethod>();
		
		if (sc.isInterface()) throw new RuntimeException("Class is needed, not inerface.");
		
		for (Iterator methodIt = sc.getMethods().iterator(); methodIt.hasNext();) {
			SootMethod sm = (SootMethod) methodIt.next();
			if (sm.isAbstract()) continue;

			if (sm.getName().equals(SootMethod.constructorName))
				methods.add(sm);
		}
		
		return Collections.unmodifiableList(methods);
	}
	
	/**
	 * Given a list of methods defined or inherited by a class, select visible methods
	 * depending on referredPlace
	 * @param candidates
	 * @param referredPlace
	 * @param receiver receiver's type
	 * @return a new List
	 */
	public static List<SootMethod> getVisibleMethods(final List<SootMethod> candidates, final ReferredPlace referredPlace, final SootClass receiver) {
		
		if (referredPlace == ReferredPlace.CLASS) return Collections.unmodifiableList(candidates);
		
		List<SootMethod> methods = new LinkedList<SootMethod>();
		
		for (Iterator methodIt = candidates.iterator(); methodIt.hasNext();) {
			SootMethod sm = (SootMethod) methodIt.next();
			int modifiers = ImpactUtil.getRealModifiers(sm);
			
			if (referredPlace == ReferredPlace.PACKAGE) {
				// private is excluded
				if (Modifier.isPrivate(modifiers)) continue;
				// protected not in the same package is excluded
				if (Modifier.isProtected(modifiers) &&
						receiver.getPackageName().equals(sm.getDeclaringClass().getPackageName())) continue;
			}
			
			if (referredPlace == ReferredPlace.PROTECTED) {
				// private is excluded
				if (Modifier.isPrivate(modifiers)) continue;
				// default is excluded
				if (ImpactUtil.isDefaultModifer(modifiers)) continue;
				// protected is INCLUDED
			}
			
			if (referredPlace == ReferredPlace.OTHER) {
				// non-public is excluded
				if (!Modifier.isPublic(modifiers)) continue;
			}
			
			methods.add(sm);
		}
		
		return Collections.unmodifiableList(methods);
	}
}

package abc.tm.weaving.weaver;

import java.util.*;

import com.sun.rsasign.i;

import soot.*;
import soot.util.*;
import soot.jimple.*;
import abc.soot.util.LocalGeneratorEx;
import abc.tm.weaving.aspectinfo.*;
import abc.tm.weaving.matching.TMStateMachine;
import abc.weaving.aspectinfo.Formal;

/**
 * Fills in method stubs for tracematch classes.
 * @author Pavel Avgustinov
 */
public class TraceMatchCodeGen {
    // TODO: Perhaps have a dedicated flag for tracematch codegen
    private static void debug(String message)
    { if (abc.main.Debug.v().aspectCodeGen)
        System.err.println("ACG*** " + message);
    }

    protected String getConstraintClassName(TraceMatch tm) {
        return "Constraint$" + tm.getName();
    }
    
    protected String getDisjunctClassName(TraceMatch tm) {
        return "Disjunct$" + tm.getName();
    }
    
    /**
     * Create the classes needed to keep constraints for a given tracematch. Classes are
     * the Constraint set of disjuncts and the disjunct class, plus any helper classes.
     * Could, at some point, specialise the constraints to each FSA state.
     * @param tm The relevant tracematch
     */
    protected void createConstraintClasses(TraceMatch tm) {
        // the SootClasses for the constraint and the main disjunct class for the tracematch 
        SootClass constraint = new SootClass(getConstraintClassName(tm));
        SootClass disjunct = new SootClass(getDisjunctClassName(tm));
        createMainConstraintClass(constraint, disjunct);
        
    }
    
    /**
     * Fills in the constraint class for a given tracematch.
     * @param constraint the SootClass to add methods and fields to
     * @param disjunct the SootClass for the disjuncts -- to call methods on
     */
    protected void createMainConstraintClass(SootClass constraint, SootClass disjunct) {
    }
    
    /**
     * Fills in the method stubs that have been generated for this tracematch.
     * @param tm the tracematch in question
     */
    protected void fillInAdviceBodies(TraceMatch tm) {
        
    }
    
    /**
     * Fills in the method stubs generated by the frontend for a given tracematch.
     * @param tm the tracecmatch to deal with.
     */
    public void fillInTraceMatch(TraceMatch tm) {
        TMStateMachine tmsm = (TMStateMachine)tm.getState_machine();
        
        List formals = new LinkedList();
        for (Iterator formalIter = tm.getFormals().iterator(); formalIter.hasNext(); ) {
        	Formal f = (Formal) formalIter.next();
        	formals.add(f.getName());
        }
        // FIXME: need to compute the set of formals that are not used in the body
        tmsm.prepareForMatching(tm.getSymbols(),formals, tm.getSym_to_vars(),new LinkedList());
        
        // Create the constraint class(es). A constraint is represented in DNF as a set of
        // disjuncts, which are conjuncts of positive or negative bindings. For now, we 
        // only create one kind of disjunct class for each tracematch, specialised to have
        // fields for the tracecmatch variables. A potential optimisation is to specialise
        // the disjunct class to each state, as negative bindings needn't be kept for all
        // states in general -- this may/will be done in time.
        createConstraintClasses(tm);
        
        // Fill in the advice bodies. The method stubs have been created by the frontend and
        // can be obtained from the TraceMatch object; code to keep track of changing 
        // constraints and to run the tracematch advice when appropriate, with the necessary
        // bindings, should be added.
        fillInAdviceBodies(tm);
    }
}

import java.io.*;
import org.aspectj.lang.*;

public class Aspect
{   /* ----------------- generated by abc ------------------------ */
    static int aspectlevel = 0;
    public static  Aspect ajc$perSingletonInstance;

    static
    {
        aspectlevel = 0;
        Aspect.ajc$postClinit();
    }

    private static void ajc$postClinit()
    {
        Aspect r0;

        r0 = new Aspect();
        ajc$perSingletonInstance = r0;
        return;
    }

    public static Aspect aspectOf()
    {
        Aspect r0;
        org.aspectj.lang.NoAspectBoundException r1;

        r0 = ajc$perSingletonInstance;

        if (r0 == null)
        {
            r1 = new NoAspectBoundException();
            throw r1;
        }
        else
        {
            return r0;
        }
    }

    public static boolean hasAspect()
    {
        Aspect r0;

        r0 = ajc$perSingletonInstance;

        if (r0 == null)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

  static void message(String s) 
    { for (int i=0; i < aspectlevel; i++) System.out.print("===+");
      System.out.println(" " + s);
    }

    /* ---------------------- before advice ------------------------ */

    void before$0()
    {
        Aspect.message("beginning of method");
        return;
    }

    void before$2()
    {
        Aspect.message("Here is some before advice");
        return;
    }


    /* --------------------  GENERATED BY HAND by LAURIE ----------- */

  // specialized to go until first call to proceed
  int around$1$beforepart(int x, Around1$State state)
    { message("1: at beginning of around, value of first param is " + x); 
      int mylocalx = x + 1;
      aspectlevel++; 
      int result = 0;
      for (int i=0; i< 10; i++)
        { if (i%2 == 0)
	    { message("if inside for");
	      int anotherlivevar = i * 2;
	      // { i, localx, anotherlivevar } are live after call
	      // so save them in the state
              state.i = i;
              state.mylocalx = mylocalx;
              state.anotherlivevar = anotherlivevar;	      
	      // save the return point of 1
	      state.continuepoint = 1;
	      // result = proceed(mylocalx + i);
	      state.arg1 = mylocalx + i; // this is the value that call must use
	      return 0;  // replace call of proceed with a return
	    }
	  else
	    { message("else inside for");
	      // { i, localx } are live after the call 
	      // so save them in the state
	      state.i = i;
	      state.mylocalx = mylocalx;
	      // save the return point of 2
	      state.continuepoint = 2;
	      // result = proceed(i);
	      state.arg1 = i;
	      return 0;   // replace call of proceed with a return 
	    }
	}

      // a smart analysis could determine these are unreachable stmts
      message("1: at end of around, return value is " + result); 
      message("1: at end of around, mylocalx is " + mylocalx); 
      aspectlevel --;

      // signal finished 
      state.finished = true;
      return(result);
    }

  // specialized for a call back 
  int around$1$continuepart(Around1$State state, int result)
    { int i;
      int anotherlivevar;
      int mylocalx;
      
      boolean gotoL1, gotoL2;  // in Jimple we can do real gotos 
      switch (state.continuepoint)
        { case 1: 
	    // restore state for point 1
	    i = state.i;
	    anotherlivevar = state.anotherlivevar;
            mylocalx = state.mylocalx;
	    gotoL1 = true; gotoL2 = false;  // in Jimple, goto L1:
	    break;

          case 2: 
	    // restore state for point 2
	    i = state.i;
	    mylocalx = state.mylocalx;
	    anotherlivevar = 0; // to make verifier happy
	    gotoL1 = false; gotoL2 = true;  // in Jimple, goto L2;
	    break;	 

          // to make verifier shut up, will never execute	
          default: i= 0; anotherlivevar = 0; mylocalx = 0;
		   gotoL1 =false; gotoL2 = false; 
        } 
      
      while (gotoL2 || gotoL1 || i < 10) // in Jimple don't need goto vars
        { if (gotoL1 || i%2 == 0)
	    { if (!gotoL1) 
                { message("if inside for");
	          anotherlivevar = i * 2;
	          // result = proceed(mylocalx + i);
                  state.i = i;
                  state.mylocalx = mylocalx;
                  state.anotherlivevar = anotherlivevar;	      
	          // save the continue point of 1
	          state.continuepoint = 1;
	          // result = proceed(mylocalx + i);
	          state.arg1 = mylocalx + i; // value that call must use
	          return 0;  
	         }

              L1: gotoL1 = false;
	      result = result + anotherlivevar;
	    }
	  else
	    { if (!gotoL2)
	        { message("else inside for");
         	  state.i = i;
	          state.mylocalx = mylocalx;
	          // save the return point of 2
	          state.continuepoint = 2;
	          // result = proceed(i);
	          state.arg1 = i;
	          return 0;   // replace call of proceed with a return 
		}
	      // result = proceed(i);
              L2: gotoL2 = false;	
	    }
	  message("in loop " + i + " result is " + result);
	  i++;
	}
      message("1: at end of around, return value is " + result); 
      message("1: at end of around, mylocalx is " + mylocalx); 
      aspectlevel --;
      state.finished = true;
      return(result);
    }

}

class Around1$State {
   // field to signal return from advice, ( when no proceeds happen )
   boolean finished;  
   // all vars that are live after some call to proceed
   int i;
   int mylocalx;
   int anotherlivevar;
   // where to continue 
   int continuepoint;
   // what to call method with (arg1)
   int arg1;
}

aspect IntertypeMethodNameAnalysis {

  eq IntertypeMethodDecl.getTargetType().nameType() = NameType.TYPE_NAME;
  
  // hostAspect is the aspect the declares the intertype method decl
  syn TypeDecl IntertypeMethodDecl.hostAspect() = (TypeDecl)getParent().getParent();
  // introducedType is the type into which the intertype method decl is statically introduced
  syn TypeDecl IntertypeMethodDecl.introducedType() = getTargetType().type();


  // isNestedType() need not be changed since all types within a bodydecl are nested types
  // isLocalClass() need not be changed
  eq IntertypeMethodDecl.getBlock().enclosingType() = introducedType();
  eq IntertypeMethodDecl.getBlock().isMemberType() = introducedType().isMemberType();
  eq IntertypeMethodDecl.getBlock().enclosingInstance() = introducedType();

  eq IntroducedMethodDecl.getBlock().enclosingType() = introducedType();
  eq IntroducedMethodDecl.getBlock().enclosingInstance() = introducedType();

  // override ag-inherited attribute, this will cause calls bound to an
  // IntertypeMethodDecl to invoke a method in the introducedType instead of the hostAspect
  syn TypeDecl IntertypeMethodDecl.hostType() = introducedType();
  eq IntertypeMethodDecl.getBlock().hostType() = hostType();
  eq IntertypeMethodDecl.getParameter(int index).hostType() = hostType();
  eq IntertypeMethodDecl.getBlock().lookupMethod(String name) {
    Collection c = introducedType().memberMethods(name);
    if(!c.isEmpty())
      return c;
    return lookupMethod(name);
  }

  // override behavior to allow multiple methods with the same signature (but in different types)
  syn SimpleSet AspectDecl.localLookupMethod(MethodDecl signature) {
    return SimpleSet.emptySet.add(signature);
  }
  
  refine LookupMethod eq TypeDecl.localMethodsSignatureMap() {
    // Locally declared methods
    HashMap map = LookupMethod.TypeDecl.localMethodsSignatureMap();
    // Add intertype methods if there is no local declaration
    for(Iterator iter = introducedMethods().iterator(); iter.hasNext(); ) {
      MethodDecl decl = (MethodDecl)iter.next();
      if(!map.containsKey(decl.signature()))
        map.put(decl.signature(), decl);
    }
    return map;
  }
  eq ClassDecl.localMethodsSignatureMap() {
    // Locally declared methods + intertype methods with exact type
    HashMap map = super.localMethodsSignatureMap();
    // Add intertype methods introduced through an interface
    for(Iterator iter = interfacesMethodsIterator(); iter.hasNext(); ) {
      MethodDecl decl = (MethodDecl)iter.next();
      if(decl instanceof IntertypeMethodDecl && !decl.isAbstract() && !map.containsKey(decl.signature()))
        map.put(decl.signature(), decl);
    }
    return map;
  }

  syn lazy Collection AspectDecl.localIntroductionMethods() {
    Collection c = new ArrayList(1);
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i) instanceof IntertypeMethodDecl) {
      	c.add(getBodyDecl(i));
      }
    }
    return c;
  }

  protected void IntertypeMethodDecl.collectIntertypeDecls(HashMap map) {
    super.collectIntertypeDecls(map);
    TypeDecl typeDecl = introducedType();
    if(!map.containsKey(typeDecl))
      map.put(typeDecl, new ArrayList());
    Collection c = (Collection)map.get(typeDecl);
    c.add(this);
  }

  syn lazy Collection TypeDecl.introducedMethods() {
    Collection c = new ArrayList();
    for(Iterator iter = intertypeDecls().iterator(); iter.hasNext(); ) {
      ASTNode node = (ASTNode)iter.next();
      if(node instanceof IntertypeMethodDecl)
        c.add(node);
    }
    return c;
  }

}

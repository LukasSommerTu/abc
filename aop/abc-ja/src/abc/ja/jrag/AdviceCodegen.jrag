import polyglot.util.InternalCompilerError;

aspect AdviceCodegen {
  inh Aspect BodyDecl.aspectClass();
  eq AspectDecl.getBodyDecl().aspectClass() = globalAspectInfo().getAspect(abcClass());
  eq Program.getCompilationUnit().aspectClass() { throw new Error("Missing equation for aspectClass()"); }

  public int TypeDecl.adviceCounter = 0;
  syn lazy String AdviceDecl.name() = "advice$" + hostType().adviceCounter++;

  public void AdviceDecl.jimplify1phase2() {
    hostType().getSootClassDecl().addMethod(sootMethod());
    createAspectInfo();
  }

  syn lazy java.util.List AdviceSpec.paramList() {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).type().getSootType());
    return list;
  }

  syn lazy java.util.List AfterReturningSpec.paramList() {
    java.util.List list = super.paramList();
    if(hasReturnParameter())
      list.add(getReturnParameter().type().getSootType());
    return list;
  }

  syn lazy java.util.List AfterThrowingSpec.paramList() {
    java.util.List list = super.paramList();
    if(hasExceptionParameter())
      list.add(getExceptionParameter().type().getSootType());
    return list;
  }

  syn lazy SootMethod AdviceDecl.sootMethod() {
    return new SootMethod(name(), getAdviceSpec().paramList(),
                    soot.VoidType.v(), sootTypeModifiers(), new ArrayList());
  }

  protected void AdviceDecl.createAspectInfo() {
    
    Pointcut pc = getPointcutExpr().pointcut();

    globalAspectInfo().addAdviceDecl(new abc.weaving.aspectinfo.AdviceDecl(
      getAdviceSpec().adviceSpec(),
      pc,
      methodSig(),
      aspectClass(),
      -1 /*jp*/,
      -1 /*jpsp*/,
      -1 /*ejp*/,
      new ArrayList(),
      pos()
    ));
  }

  protected java.util.List AdviceSpec.methodFormals() {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).formal());
    return list;
  }

  protected java.util.List AfterReturningSpec.methodFormals() {
    java.util.List list = super.methodFormals();
    if (hasReturnParameter())
      list.add(getReturnParameter().formal());
    return list;
  }

  protected java.util.List AfterThrowingSpec.methodFormals() {
    java.util.List list = super.methodFormals();
    if(hasExceptionParameter())
      list.add(getExceptionParameter().formal());
    return list;
  }

  protected MethodSig AdviceDecl.methodSig() {
    return new MethodSig(
      sootTypeModifiers(),
      AbcFactory.AbcClass(hostType().getSootClassDecl()),
      AbcFactory.AbcType(soot.VoidType.v()),
      name(),
      getAdviceSpec().methodFormals(),
      new ArrayList(),
      pos()
    );
  }

  /*abstract*/ public abc.weaving.aspectinfo.AdviceSpec AdviceSpec.adviceSpec() {
    throw new Error("adviceSpec() not implemented for " + getClass().getName());
  }

  public abc.weaving.aspectinfo.AdviceSpec BeforeSpec.adviceSpec() {
    return new BeforeAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterSpec.adviceSpec() {
    return new AfterAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterReturningSpec.adviceSpec() {
    if(hasReturnParameter())
      return new AfterReturningArgAdvice(
                    getReturnParameter().formal(), pos());
    else
      return new AfterReturningAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterThrowingSpec.adviceSpec() {
    if(hasExceptionParameter())
      return new AfterThrowingArgAdvice(
                    getExceptionParameter().formal(), pos());
    else
      return new AfterThrowingAdvice(pos());
  }

  MemberPattern implements abc.weaving.aspectinfo.MethodPattern;
  public boolean MemberPattern.matchesCall(SootMethodRef smr) { return false; }
  public boolean MemberPattern.matchesExecution(SootMethod sm) { return false; }
  public boolean MemberPattern.equivalent(abc.weaving.aspectinfo.MethodPattern p) { return false; }
  public abc.aspectj.ast.MethodPattern MemberPattern.getPattern() { return null; }

  public boolean MethodPattern.matchesCall(SootMethodRef smr) {
    // check modifiers, return type, name, formals, exceptions
    SootMethod m = smr.resolve();
    if(!getReturnTypePattern().matchesType(m.getReturnType()))
      return false;
    if(!getMemberNamePattern().matchesTypeAndName(m))
      return false;
    return true;
  }
  public boolean MethodPattern.matchesExecution(SootMethod sm) { return false; }
  public boolean MethodPattern.equivalent(abc.weaving.aspectinfo.MethodPattern p) { return false; }
  public abc.aspectj.ast.MethodPattern MethodPattern.getPattern() {
    throw new InternalCompilerError("Can not get polyglot frontend pattern from JastAdd");
  }

  syn lazy java.util.regex.Pattern SimpleNamePattern.regex() {
    String p = getPattern();
    p = p.replaceAll("\\*", ".*");
    p = p.replaceAll("\\$","\\\\\\$");
    p = "^" + p + "$";
    return java.util.regex.Pattern.compile(p);
  }


  syn boolean Pattern.matchesTypeAndName(SootMethod m) = false;
  syn boolean Pattern.matchesName(String name) = false;

  eq SimpleNamePattern.matchesTypeAndName(SootMethod m) =
    matchesName(m.getName());

  eq SimpleNamePattern.matchesName(String name) =
    regex().matcher(name).matches();

  eq TypeDotNamePattern.matchesTypeAndName(SootMethod m) {
    throw new InternalCompilerError("matches not implemented for " + getClass().getName());
  }
  eq DotNamePattern.matchesTypeAndName(SootMethod m) {
    // TODO: match type on left hand side
    // and name on right hand side

    if(m.isStatic()) {
      return getLhs().matchesType(m.getDeclaringClass()) && getRhs().matchesName(m.getName());
    }
    return false;
  }

  syn boolean Pattern.matchesType(SootClass c) = false;
  eq SimpleNamePattern.matchesType(SootClass c) = matchesName(c.getShortName());
  eq ExplicitTypeNamePattern.matchesType(SootClass c) =
    getAccess().type().fullName().equals(c.getName())
    && getAccess().isTypeAccess();

  syn boolean Pattern.matchesType(Type t) = false;
  eq SimpleNamePattern.matchesType(Type t) {
    if(! (t instanceof RefType)) {
      return matchesName(t.toString());
    }
    SootClass c = ((RefType) t).getSootClass();
    return matchesType(c);
  }
  eq ExplicitTypeNamePattern.matchesType(Type t) = 
    getAccess().type().name().equals(t.toString())
    && getAccess().isTypeAccess();

  syn int AdviceDecl.sootTypeModifiers() {
    int result = 0;
    result |= soot.Modifier.PUBLIC;
    if(getModifiers().isSynchronized()) result |= soot.Modifier.SYNCHRONIZED;
    if(getModifiers().isStrictfp()) result |= soot.Modifier.STRICTFP;
    return result;
  }

  public void AdviceSpec.jimplify2(Body b) {
    for(int i = 0; i < getNumParameter(); i++)
      getParameter(i).jimplify2(b);
  }

  public void AfterReturningSpec.jimplify2(Body b) {
    super.jimplify2(b);
    if (hasReturnParameter())
      getReturnParameter().jimplify2(b);
  }

  public void AfterThrowingSpec.jimplify2(Body b) {
    super.jimplify2(b);
    if (hasExceptionParameter())
      getExceptionParameter().jimplify2(b);
  }

  public void AdviceDecl.jimplify2() {
    JimpleBody body = Jimple.v().newBody(sootMethod());
    sootMethod().setActiveBody(body);
    Body b = new Body(body);
    b.addThis(hostType());
    getAdviceSpec().jimplify2(b);
    getBlock().jimplify2(b);
    b.add(Jimple.v().newReturnVoidStmt());
  }
  eq AdviceSpec.getParameter(int index).localNum() = index;

}

import polyglot.util.InternalCompilerError;

aspect AdviceCodegen {
  inh Aspect BodyDecl.aspectClass();
  eq TypeDecl.getBodyDecl().aspectClass() = globalAspectInfo().getAspect(abcClass());
  eq Program.getCompilationUnit().aspectClass() { throw new Error("Missing equation for aspectClass()"); }

  public int TypeDecl.adviceCounter = 0;
  syn lazy String AdviceDecl.name() = "advice$" + hostType().adviceCounter++;

  public void AdviceDecl.jimplify1phase2() {
    hostType().getSootClassDecl().addMethod(sootMethod());
    createAspectInfo();
    getAdviceSpec().jimplify1phase2();
  }

  syn lazy java.util.List AdviceSpec.paramList() {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).type().getSootType());
    return list;
  }

  syn lazy java.util.List AfterReturningSpec.paramList() {
    java.util.List list = super.paramList();
    if(hasReturnParameter())
      list.add(getReturnParameter().type().getSootType());
    return list;
  }

  syn lazy java.util.List AfterThrowingSpec.paramList() {
    java.util.List list = super.paramList();
    if(hasExceptionParameter())
      list.add(getExceptionParameter().type().getSootType());
    return list;
  }

  syn lazy SootMethod AdviceDecl.sootMethod() {
    return new SootMethod(name(), getAdviceSpec().paramList(),
                          returnType().getSootType(),
                          sootTypeModifiers(), new ArrayList());
  }

  protected void AdviceDecl.createAspectInfo() {
    int[] jp_params = implicitParameters();
    Pointcut pc = getPointcutExpr().pointcut();

    globalAspectInfo().addAdviceDecl(new abc.weaving.aspectinfo.AdviceDecl(
      getAdviceSpec().adviceSpec(),
      pc,
      methodSig(),
      aspectClass(),
      jp_params[0] /*jp*/,
      jp_params[1] /*jpsp*/,
      jp_params[2] /*ejp*/,
      new ArrayList(),
      pos()
    ));
  }

  protected java.util.List AdviceSpec.methodFormals() {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumParameter(); i++)
      list.add(getParameter(i).formal());
    return list;
  }

  protected java.util.List AfterReturningSpec.methodFormals() {
    java.util.List list = super.methodFormals();
    if (hasReturnParameter())
      list.add(getReturnParameter().formal());
    return list;
  }

  protected java.util.List AfterThrowingSpec.methodFormals() {
    java.util.List list = super.methodFormals();
    if(hasExceptionParameter())
      list.add(getExceptionParameter().formal());
    return list;
  }

  protected MethodSig AdviceDecl.methodSig() {
    return new MethodSig(
      sootTypeModifiers(),
      AbcFactory.AbcClass(hostType().getSootClassDecl()),
      AbcFactory.AbcType(returnType().getSootType()),
      name(),
      getAdviceSpec().methodFormals(),
      new ArrayList(),
      pos()
    );
  }

  abstract public abc.weaving.aspectinfo.AdviceSpec AdviceSpec.adviceSpec();

  public abc.weaving.aspectinfo.AdviceSpec BeforeSpec.adviceSpec() {
    return new BeforeAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterSpec.adviceSpec() {
    return new AfterAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterReturningSpec.adviceSpec() {
    if(hasReturnParameter())
      return new AfterReturningArgAdvice(
                    getReturnParameter().formal(), pos());
    else
      return new AfterReturningAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AfterThrowingSpec.adviceSpec() {
    if(hasExceptionParameter())
      return new AfterThrowingArgAdvice(
                    getExceptionParameter().formal(), pos());
    else
      return new AfterThrowingAdvice(pos());
  }
  public abc.weaving.aspectinfo.AdviceSpec AroundSpec.adviceSpec() {
    MethodCategory.register(proceedSig(), MethodCategory.PROCEED);
    AbcType return_type = AbcFactory.AbcType(returnType().getSootType());
    return new AroundAdvice(return_type, proceedSig(), pos());
  }

  syn int AdviceDecl.sootTypeModifiers() {
    int result = 0;
    result |= soot.Modifier.PUBLIC;
    if(getModifiers().isSynchronized()) result |= soot.Modifier.SYNCHRONIZED;
    if(getModifiers().isStrictfp()) result |= soot.Modifier.STRICTFP;
    return result;
  }

  public void AdviceSpec.jimplify2(Body b) {
    for(int i = 0; i < getNumParameter(); i++)
      getParameter(i).jimplify2(b);
  }

  public void AfterReturningSpec.jimplify2(Body b) {
    super.jimplify2(b);
    if (hasReturnParameter())
      getReturnParameter().jimplify2(b);
  }

  public void AfterThrowingSpec.jimplify2(Body b) {
    super.jimplify2(b);
    if (hasExceptionParameter())
      getExceptionParameter().jimplify2(b);
  }

  public void AdviceDecl.jimplify2() {
    JimpleBody body = Jimple.v().newBody(sootMethod());
    sootMethod().setActiveBody(body);
    Body b = new Body(hostType(), body);
    getAdviceSpec().jimplify2(b);
    getBlock().jimplify2(b);
    b.add(Jimple.v().newReturnVoidStmt());
    getAdviceSpec().jimplify2();
  }
  eq AdviceSpec.getParameter(int index).localNum() = index;



  //
  // proceed calls
  //

  syn AroundSpec AdviceSpec.aroundSpec() = null;
  eq AroundSpec.aroundSpec() = this;

  inh AroundSpec Proceed.aroundSpec();
  eq Program.getCompilationUnit().aroundSpec() = null;
  eq AdviceDecl.getBlock().aroundSpec() = getAdviceSpec().aroundSpec();

  protected java.util.List AroundSpec.proceedFormals()
  {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumExplicitParameter(); i++)
      list.add(getExplicitParameter(i).formal());
    return list;
  }

  protected java.util.List AroundSpec.proceedParamList()
  {
    ArrayList list = new ArrayList();
    for(int i = 0; i < getNumExplicitParameter(); i++)
        list.add(getExplicitParameter(i).type().getSootType());
    return list;
  }

  inh lazy MethodSig AroundSpec.proceedSig();
  eq AdviceDecl.getAdviceSpec().proceedSig() {
    return new MethodSig(
      soot.Modifier.PUBLIC | soot.Modifier.FINAL | soot.Modifier.STATIC,
      AbcFactory.AbcClass(hostType().getSootClassDecl()),
      AbcFactory.AbcType(returnType().getSootType()),
      "proceed$" + name(),
      getAdviceSpec().aroundSpec().proceedFormals(),
      new ArrayList(),
      pos());
  }

  private ArrayList Proceed.buildProceedArgs(Body b)
  {
    ArrayList list = new ArrayList();
    AroundSpec spec = aroundSpec();
    int arg = 0;

    for(int i = 0; i < spec.getNumExplicitParameter(); i++)
    {
      TypeDecl type = spec.getExplicitParameter(i).type();
      list.add(
        asImmediate(b, getArg(arg).type().emitCastTo(b, getArg(arg), type))
      );
      arg++;
    }
    return list;
  }

  inh Aspect AdviceSpec.aspectClass();
  inh TypeDecl AdviceSpec.hostType();

  public soot.Value Proceed.eval(Body b)
  {
    AroundSpec spec = aroundSpec();
    soot.SootMethodRef ref = spec.proceedSig().getSootMethodRef();
    ArrayList args = buildProceedArgs(b);

    soot.Value result = Jimple.v().newStaticInvokeExpr(ref, args);

    return spec.returnType().isVoid() ? result : asLocal(b, result);
  }

  syn lazy SootMethod AroundSpec.proceedMethod()
  {
    MethodSig ms = aroundSpec().proceedSig();
    SootMethod m = new SootMethod(ms.getName(), proceedParamList(),
                        ms.getReturnType().getSootType(), ms.getModifiers(),
                        new ArrayList());
    return m;
  }

  public void AdviceSpec.jimplify1phase2() { }

  public void AroundSpec.jimplify1phase2()
  {
    hostType().getSootClassDecl().addMethod(proceedMethod());
  }

  public void AroundSpec.jimplify2()
  {
    JimpleBody body = Jimple.v().newBody(proceedMethod());
    proceedMethod().setActiveBody(body);
    Body b = new Body(hostType(), body);
    jimplify2(b);
    b.add(Jimple.v().newReturnVoidStmt());
  }
}

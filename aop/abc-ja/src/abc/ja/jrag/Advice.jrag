aspect Advice
{
  eq AdviceDecl.getBlock().hostBodyDecl() = this;
  eq AdviceDecl.getBlock().returnType() = returnType();
  syn TypeDecl AdviceDecl.returnType() = getAdviceSpec().returnType();

  inh TypeDecl AdviceSpec.typeVoid();
  syn TypeDecl AdviceSpec.returnType() = typeVoid();
  eq AroundSpec.returnType() = getTypeAccess().type();


  eq AdviceDecl.getAdviceSpec().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  eq AdviceDecl.getBlock().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  eq AdviceDecl.getPointcutExpr().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  syn SimpleSet AdviceSpec.localLookupVariable(String name) {
    if (name.equals("thisJoinPoint")
        || name.equals("thisJoinPointStaticPart")
        || name.equals("thisEnclosingJoinPointStaticPart"))
    {
      return SimpleSet.emptySet.add(implicitVarDecl(name));
    }
    for(int i = 0; i < getNumParameter(); i++)
      if(getParameter(i).name().equals(name))
        return SimpleSet.emptySet.add(getParameter(i));
    return SimpleSet.emptySet;
  }
  syn SimpleSet AfterReturningSpec.localLookupVariable(String name) {
    if(hasReturnParameter() &&
       getReturnParameter().name().equals(name))
      return SimpleSet.emptySet.add(getReturnParameter());
    return super.localLookupVariable(name);
  }
  syn SimpleSet AfterThrowingSpec.localLookupVariable(String name) {
    if(hasExceptionParameter() &&
       getExceptionParameter().name().equals(name))
      return SimpleSet.emptySet.add(getExceptionParameter());
    return super.localLookupVariable(name);
  }
  inh SimpleSet AdviceDecl.lookupVariable(String name);

  // UnreachableStatements.jrag
  eq AdviceDecl.getBlock().reachable() = true;

  eq AdviceDecl.getModifiers().mayBeSynchronized() = true;
  eq AdviceDecl.getModifiers().mayBeStrictfp() = true;

  
  eq AdviceSpec.getParameter(int index).isMethodParameter() = true;
  eq AdviceSpec.getParameter(int index).isConstructorParameter() = false;
  eq AdviceSpec.getParameter(int index).isExceptionHandlerParameter() = false;
  eq AdviceSpec.getParameter(int index).isPointcutVariable() = true;
  eq AdviceSpec.getParameter(int index).nameType() = NameType.TYPE_NAME;

  eq AfterReturningSpec.getReturnParameter().isMethodParameter() = true;
  eq AfterReturningSpec.getReturnParameter().isConstructorParameter() = false;
  eq AfterReturningSpec.getReturnParameter().isExceptionHandlerParameter() = false;
  eq AfterReturningSpec.getReturnParameter().nameType() = NameType.TYPE_NAME;

  eq AfterThrowingSpec.getExceptionParameter().isMethodParameter() = true;
  eq AfterThrowingSpec.getExceptionParameter().isConstructorParameter() = false;
  eq AfterThrowingSpec.getExceptionParameter().isExceptionHandlerParameter() = false;
  eq AfterThrowingSpec.getExceptionParameter().nameType() = NameType.TYPE_NAME;

  eq AroundSpec.getTypeAccess().nameType() = NameType.TYPE_NAME;


  //
  // semantic checks for proceed-calls
  //

  public void Proceed.typeCheck() {
    AroundSpec spec = aroundSpec();
    if (spec == null)
      error("Can only use proceed within around advice");
    else if (spec.getNumExplicitParameter() != getNumArg()) {
      error("Proceed called with the wrong number of arguments");
    } else {
      for (int i = 0; i < getNumArg(); i++) {
        TypeDecl exprType = getArg(i).type();
        TypeDecl parmType = spec.getExplicitParameter(i).type();

        if (!exprType.methodInvocationConversionTo(parmType)
            && !exprType.isUnknown() && !parmType.isUnknown())
        {
            error("Expression " + getArg(i) + " of type " + exprType.typeName()
            + " is not compatible with the proceed parameter type " +
            parmType.typeName());
        }
      }
    }
  }
}

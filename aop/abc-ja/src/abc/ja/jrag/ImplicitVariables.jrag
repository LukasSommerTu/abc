aspect ImplicitVariables
{
    //
    // Pieces of advice in AspectJ have three implicitly defined variables,
    // which are encoded in this source-file using the following numbering:
    //
    //  (0) thisJointPoint
    //  (1) thisJoinPointStaticPart
    //  (2) thisEnclosingJoinPointStaticPart

    inh TypeDecl AdviceSpec.lookupType(String packageName, String typeName);
    eq AdviceDecl.getAdviceSpec().lookupType(String packageName, String typeName)
    {
        return lookupType(packageName, typeName);
    }

    syn lazy Variable AdviceSpec.implicitVarDecl(String name)
    {
        // compute a declaration for this implicit variable
        Modifiers final_mod =
            new Modifiers(new List().add(new Modifier("final")));

        TypeDecl var_type = lookupType("org.aspectj.lang", "JoinPoint");
        if (!name.equals("thisJoinPoint")) {
            SimpleSet results = var_type.memberTypes("StaticPart");
            var_type = (TypeDecl) results.iterator().next();
        }

        Access type_access = var_type.createQualifiedAccess();
        ParameterDeclaration decl =
            new ImplicitParameterDeclaration(final_mod, type_access,
                                             name, new List());

        // add decl to tree (as parameter to the advice method)
        // and force possible rewrites to this decl (by reading it)
        addParameter(decl);
        getParameter(getNumParameter() - 1);

        // return the new declaration
        return decl;
    }
 
    syn boolean ParameterDeclaration.isImplicit() = false;
    eq ImplicitParameterDeclaration.isImplicit() = true;

    syn int AdviceSpec.getNumExplicitParameter()
    {
        return getExplicitParameterList().size();
    }

    syn lazy ArrayList AdviceSpec.getExplicitParameterList()
    {
        ArrayList list = new ArrayList();
        for (int i = 0; i < getNumParameter(); i++) {
            ParameterDeclaration decl = getParameter(i);
            if (!decl.isImplicit())
                list.add(decl);
        }
        return list;
    }

    syn ParameterDeclaration AdviceSpec.getExplicitParameter(int i)
    {
        return (ParameterDeclaration)getExplicitParameterList().get(i);
    }


    // this is run before the implicit parameters are added
    public void AdviceSpec.nameCheck()
    {
        super.nameCheck();

        for (int i = 0; i < getNumParameter(); i++) {
            String name = getParameter(i).name();

            if (name.equals("thisJoinPoint") ||
                name.equals("thisJoinPointStaticPart") ||
                name.equals("thisEnclosingJoinPointStaticPart"))
            {
                getParameter(i).error(
                    "The variable \"" + name +
                    "\" is implicitly defined in advice bodies");
            }
        }
    }



    // some of this may eventually be split off into
    // ImplicitVariablesCodegen.jrag

    public static String AdviceDecl.implicitVarName(int i)
    {
        switch(i) {
            case 0:
                return "thisJoinPoint";
            case 1:
                return "thisJoinPointStaticPart";
            case 2:
                return "thisEnclosingJoinPointStaticPart";
        }
        throw new
            InternalCompilerError("No such implicit advice variable: " + i);
    }

    syn lazy int[] AdviceDecl.implicitParameters()
    {
        int[] params = new int[3];
        AdviceSpec spec = getAdviceSpec();
        
        for (int i = 0; i < 3; i++) {
            params[i] = -1;

            for (int j = 0; j < spec.getNumParameter(); j++)
                if (spec.getParameter(j).name().equals(implicitVarName(i)))
                    params[i] = j;
        }
        return params;
    }
}

aspect ImplicitVariables
{
    //
    // Pieces of advice in AspectJ have three implicitly defined variables,
    // which are encoded in this source-file using the following numbering:
    //
    //  (0) thisJointPoint
    //  (1) thisJoinPointStaticPart
    //  (2) thisEnclosingJoinPointStaticPart

    inh TypeDecl AdviceSpec.lookupType(String packageName, String typeName);
    eq AdviceDecl.getAdviceSpec().lookupType(String packageName, String typeName)
    {
        return lookupType(packageName, typeName);
    }

    syn lazy Variable AdviceSpec.implicitVarDecl(String name)
    {
        // compute a declaration for this implicit variable
        Modifiers final_mod =
            new Modifiers(new List().add(new Modifier("final")));
        String classname =
            name.equals("thisJoinPoint") ? "JoinPoint" : "JoinPointStaticPart";
        Access type_access =
            lookupType("org.aspectj.lang", classname).createQualifiedAccess();

        ParameterDeclaration decl =
            new ParameterDeclaration(final_mod, type_access, name);

        // add decl to tree (as parameter to the advice method)
        // and force possible rewrites to this decl (by reading it)
        addParameter(decl);
        getParameter(getNumParameter() - 1);

        // return the new declaration
        return decl;
    }
 
    public void AdviceSpec.nameCheck()
    {
        super.nameCheck();

        for (int i = 0; i < getNumParameter(); i++) {
            String name = getParameter(i).name();

            if (name.equals("thisJoinPoint") ||
                name.equals("thisJoinPointStaticPart") ||
                name.equals("thisEnclosingJoinPointStaticPart"))
            {
                getParameter(i).error(
                    "The variable \"" + name +
                    "\" is implicitly defined in advice bodies");
            }
        }
    }



    // some of this may eventually be split off into
    // ImplicitVariablesCodegen.jrag

    public static String AdviceDecl.implicitVarName(int i)
    {
        switch(i) {
            case 0:
                return "thisJoinPoint";
            case 1:
                return "thisJoinPointStaticPart";
            case 2:
                return "thisEnclosingJoinPointStaticPart";
        }
        throw new
            InternalCompilerError("No such implicit advice variable: " + i);
    }

    syn lazy int[] AdviceDecl.implicitParameters()
    {
        int[] params = new int[3];
        AdviceSpec spec = getAdviceSpec();
        
        for (int i = 0; i < 3; i++) {
            params[i] = -1;

            for (int j = 0; j < spec.getNumParameter(); j++)
                if (spec.getParameter(j).name().equals(implicitVarName(i)))
                    params[i] = j;
        }
        return params;
    }
}

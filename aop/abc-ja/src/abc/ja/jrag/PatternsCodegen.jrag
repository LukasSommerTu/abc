aspect PatternsCodegen
{
    //
    // The abc weaver must be able to check whether or not a
    // pattern matches a particular method or constructor or
    // field or type.
    //
    // Each kind of pattern in the frontend implements an
    // interface to allow these checks to take place.
    //

    FieldPattern implements abc.weaving.aspectinfo.FieldPattern;
    MethodPattern implements abc.weaving.aspectinfo.MethodPattern;
    ConstructorPattern implements abc.weaving.aspectinfo.ConstructorPattern;

    // methods are needed to get these in a type-safe way...

    eq FieldPattern.fieldPattern() = this;
    eq MethodPattern.methodPattern() = this;
    eq ConstructorPattern.constructorPattern() = this;
    public abc.weaving.aspectinfo.TypePattern Pattern.typePattern() {
      return new abc.weaving.aspectinfo.TypePattern() {
        public boolean matchesType(Type cl) {
          return Pattern.this.matchesType(cl);
        }
        public abc.aspectj.ast.TypePatternExpr getPattern() {
          throw new InternalCompilerError(
                    "Can not get polyglot frontend pattern from JastAdd");
        }
        public boolean equivalent(abc.weaving.aspectinfo.TypePattern p) {
          return false;
        }
      };
    }

    // ...which throw an exception when called on the wrong node

    syn FieldPattern MemberPattern.fieldPattern()
    {
        throw new RuntimeException("Tried get a FieldPattern from a "
                                    + getClass().getName());
    }
    syn MethodPattern MemberPattern.methodPattern()
    {
        throw new RuntimeException("Tried get a MethodPattern from a "
                                    + getClass().getName());
    }
    syn ConstructorPattern MemberPattern.constructorPattern()
    {
        throw new RuntimeException("Tried get a ConstructorPattern from a "
                                    + getClass().getName());
    }

    

    //
    // Matching method patterns
    //
    public boolean MethodPattern.matchesCall(SootMethodRef smr)
    {
        // check modifiers
        for(int i  = 0; i < getNumModifierPattern(); i++)
          if(!getModifierPattern(i).matches(smr.resolve().getModifiers()))
            return false;

        // check return type
        if(!getReturnTypePattern().matchesType(smr.returnType()))
            return false;

        // check type and name
        if(!getMemberNamePattern().matchesTypeAndName(smr))
            return false;

        // check formals
        LinkedList/*<soot.Type>*/ ftypes = new LinkedList(smr.parameterTypes());
        LinkedList/*<FormalPattern>*/ fpats = new LinkedList();
        for(int i = 0; i < getNumFormalPattern(); i++)
          fpats.add(getFormalPattern(i));
        if(!matchesFormals(fpats, 0, ftypes, 0))
          return false;

        // check exceptions
        for(int i = 0; i < getNumThrowsPattern(); i++) {
          boolean found = false;
          for(Iterator iter = smr.resolve().getExceptions().iterator(); iter.hasNext() && !found; ) {
            soot.SootClass c = (soot.SootClass)iter.next();
            if(getThrowsPattern(i).matchesType(c))
              found = true;
          }
          if(!found)
            return false;
        }
        return true;
    }

    protected static boolean MemberPattern.matchesFormals(java.util.List/*<FormalPattern>*/ fpats, int fpi, java.util.List/*<soot.Type>*/ ftypes, int fti) {
      // FIXME: BRUTE FORCE MATCHING. DO SOMETHING MORE CLEVER!
      while (fpi < fpats.size()) {
        FormalPattern fp = (FormalPattern)fpats.get(fpi);
        if (fp instanceof ConcreteFormalPattern) {
          if (fti >= ftypes.size()) return false;
          Pattern pat = ((ConcreteFormalPattern)fp).getPattern();
          soot.Type ft = (soot.Type)ftypes.get(fti);
          if (!pat.matchesType(ft)) return false;
        } else {
          // DOTDOT
          while (fti <= ftypes.size()) {
            if (matchesFormals(fpats, fpi+1, ftypes, fti)) return true;
            fti++;
          }
          return false;
        }
        fpi++;
        fti++;
      }
      return fti == ftypes.size();
    }


    public boolean MethodPattern.matchesExecution(SootMethod sm)
    {
        return matchesCall(sm.makeRef());
    }

    public boolean
    MethodPattern.equivalent(abc.weaving.aspectinfo.MethodPattern p)
    {
        return false;
    }

    public abc.aspectj.ast.MethodPattern MethodPattern.getPattern()
    {
        throw new InternalCompilerError(
                    "Can not get polyglot frontend pattern from JastAdd");
    }


    //
    // Matching field patterns
    //
    // abc-2006-2, section 4.1.2:
    // 
    public boolean FieldPattern.matchesFieldRef(SootFieldRef sfr)
    {
    	// Check these in roughly increasing order of complexity...
    	
    	// Check name and type of field
    	if(!getMemberNamePattern().matchesTypeAndName(sfr))
    		return false;
    	
    	// Check modifier list
    	SootField sf;
    	try {
    		sf = sfr.resolve();
    	} catch(Exception e) {
    		warning("Failed to resolve SootFieldRef " + sfr + " while matching... assuming no match, but this shouldn't happen. Please report a bug.");
    		return false;
    	}
    	for(int i = 0; i < getNumModifierPattern(); i++)
    		if(!getModifierPattern(i).matches(sf.getModifiers()))
    			return false;
    	
        return true;
    }

    // Sometimes we need to introduce accessor methods for fields, e.g. when they're private.
    // These methods should still match field patterns.
    // Although, this seems to be dead code -- it's never called!
    public boolean FieldPattern.matchesMethod(SootMethod sm)
    {
    	System.out.println("MATCHING METHOD TO FIELD!");
    	int cat = abc.weaving.aspectinfo.MethodCategory.getCategory(sm);
    	if(cat != MethodCategory.ACCESSOR_GET && cat != MethodCategory.ACCESSOR_SET)
    		return false;
    		
    	String name = MethodCategory.getName(sm);
    	SootClass realcl = MethodCategory.getClass(sm);
    	// FIXME: This (apparently) will not work for inner classes, according to
    	// comment in abc.aspectj.visit.PatternMatcher.AIFieldPattern.matchesMethod()
    	SootField sf = realcl.getField(name);
        return matchesFieldRef(sf.makeRef());
    }

    public boolean
    FieldPattern.equivalent(abc.weaving.aspectinfo.FieldPattern p)
    {
        return false;
    }

    public abc.aspectj.ast.FieldPattern FieldPattern.getPattern()
    {
        throw new InternalCompilerError(
                    "Can not get polyglot frontend pattern from JastAdd");
    }


    //
    // Matching constructor patterns
    //
    public boolean ConstructorPattern.matchesConstructor(SootMethod sc)
    {
        // check modifiers
        for(int i  = 0; i < getNumModifierPattern(); i++)
          if(!getModifierPattern(i).matches(sc.getModifiers()))
            return false;

        // check type and name
        if(!getMemberNamePattern().matchesTypeAndName(sc.makeRef()))
            return false;

        // check formals
        LinkedList/*<soot.Type>*/ ftypes = new LinkedList(sc.getParameterTypes());
        LinkedList/*<FormalPattern>*/ fpats = new LinkedList();
        for(int i = 0; i < getNumFormalPattern(); i++)
          fpats.add(getFormalPattern(i));
        if(!matchesFormals(fpats, 0, ftypes, 0))
          return false;

        // check exceptions
        for(int i = 0; i < getNumThrowsPattern(); i++) {
          boolean found = false;
          for(Iterator iter = sc.getExceptions().iterator(); iter.hasNext() && !found; ) {
            soot.SootClass c = (soot.SootClass)iter.next();
            if(getThrowsPattern(i).matchesType(c))
              found = true;
          }
          if(!found)
            return false;
        }
        return true;
    }

    public boolean ConstructorPattern.equivalent(
                                abc.weaving.aspectinfo.ConstructorPattern p)
    {
        return false;
    }

    public abc.aspectj.ast.ConstructorPattern ConstructorPattern.getPattern()
    {
        throw new InternalCompilerError(
            "Can not get polyglot frontend pattern from JastAdd");
    }


    //
    // Matching name patterns
    //
    syn ClassnamePattern Pattern.classnamePattern() =
        new ClassnamePattern() {
            public boolean matchesClass(SootClass cl)
            {
            	if(abc.main.Debug.v().patternMatches) {
            		System.err.println("Matching classname pattern " + Pattern.this + " against "
            				+ cl + ": " + matchesType(cl.getType()));
            	}
                return matchesType(cl);
            }

            public boolean equivalent(ClassnamePattern p)
            {
                return false;
            }

            public abc.aspectj.ast.ClassnamePatternExpr getPattern()
            {
                throw new InternalCompilerError(
                        "Can not get polyglot frontend pattern from JastAdd");
            }
        };


    //
    // Type-pattern matching
    //

    // Simple name patterns can be matched using the regular-expression
    // matcher in the Java standard library. The AspectJ patterns must be
    // pre-processed to:
    //   - replace each * with .*
    //   - escape any dollar-signs which appear in the pattern
    //   - add ^ at the beginning of the regular expression and $ at the
    //     end because the pattern must match the whole class name
    syn lazy java.util.regex.Pattern SimpleNamePattern.regex()
    {
        String p = getPattern();
        p = p.replaceAll("\\*", ".*");
        p = p.replaceAll("\\$","\\\\\\$");
        p = "^" + p + "$";
        return java.util.regex.Pattern.compile(p);
    }

    // Field patterns require different matching (to some extent), as the
    // 'static' modifier is not taken into account (cf. abc-2006-2, section
    // 4.1.2).
    syn boolean Pattern.matchesTypeAndName(SootFieldRef sfr) = false;
    
    eq SimpleNamePattern.matchesTypeAndName(SootFieldRef sfr) =
    	matchesName(sfr.name());
    
    eq TypeDotNamePattern.matchesTypeAndName(SootFieldRef sfr) {
    	throw new InternalCompilerError("matches not implemented for "
    										+ getClass().getName());	
    }
    
    eq DotNamePattern.matchesTypeAndName(SootFieldRef sfr) {
    	// abc-2006-2, section 4.1.2
        // -------------------------
    	// member part
    	if(!getRhs().matchesName(sfr.name()))
    		return false;
        // type part
        return getLhs().matchesType(sfr.resolve().getDeclaringClass());
    }

    syn boolean Pattern.matchesTypeAndName(SootMethodRef smr) = false;
    syn boolean Pattern.matchesName(String name) = false;

    eq SimpleNamePattern.matchesTypeAndName(SootMethodRef smr) =
        matchesName(smr.name());

    eq SimpleNamePattern.matchesName(String name) =
        regex().matcher(name).matches();

    eq TypeDotNamePattern.matchesTypeAndName(SootMethodRef smr) {
        throw new InternalCompilerError("matches not implemented for "
                                            + getClass().getName());
    }

    eq DotNamePattern.matchesTypeAndName(SootMethodRef smr)
    {
        // abc-2006-2, section 4.1.1
        // -------------------------
        // C (the context) is implicit
        // R is the static type for method called X in the shadow
        // X is any method that smr overrides
        // Z is a (reflexive transitive) supertype of R and matches the pattern
        // P is the class that contains X

        // match member part
        if (!getRhs().matchesName(smr.name()))
            return false;

        // match type part
        SootClass classR = smr.declaringClass();

        // constructors matching is simpler
        if (smr.name().equals(SootMethod.constructorName))
            return getLhs().matchesType(classR);

        // find supertypes of R that matches the type pattern
        Set supertypes = superTypes(classR);

        Iterator i = supertypes.iterator();
        while (i.hasNext()) {
            SootClass classZ = (SootClass) i.next();
            if (!getLhs().matchesType(classZ))
                continue;

            // in the static case it must be the case that P = Z
            if(smr.isStatic() && declaresMethod(classZ, smr))
                return true;

            // otherwise it must be the case that hasSubtypeStar(P,Z)
            if (!smr.isStatic() && containsOverriddenMethod(classZ, smr))
                return true;
        }
        return false;
    }

    protected boolean
    DotNamePattern.declaresMethod(SootClass sc, SootMethodRef smr)
    {
        return sc.declaresMethod(smr.getSubSignature());
    }
    
    protected boolean DotNamePattern.declaresField(SootClass sc, SootFieldRef sfr) {
    	return sc.declaresField(sfr.name(), sfr.type());
    }

    protected boolean
    DotNamePattern.containsOverriddenMethod(SootClass sc, SootMethodRef smr)
    {
        SootMethodRef overridden =
            Scene.v().makeMethodRef(sc, smr.name(), smr.parameterTypes(),
                                    smr.returnType(), smr.isStatic());

        try {
            overridden.resolve();
            return true;
        } catch(RuntimeException e) {
            return false;
        }
    }

    protected static Set ASTNode.superTypes(SootClass sc)
    {
        Set supertypes = new HashSet();
        addSuperTypes(sc, supertypes);
        return supertypes;
    }

    protected static void ASTNode.addSuperTypes(SootClass sc, Set supertypes)
    {
        supertypes.add(sc);

        // recurse over the interfaces of this class
        Iterator i = sc.getInterfaces().iterator();
        while(i.hasNext()) {
            SootClass iface = (SootClass) i.next();
            if (!supertypes.contains(iface))
                addSuperTypes(iface, supertypes);
        }

        // recurse over the superclass of this class
        if (sc.hasSuperclass()) {
            SootClass superclass = sc.getSuperclass();
            if (!supertypes.contains(superclass))
                addSuperTypes(superclass, supertypes);
        }
    }

    // detect if the subtypes of the type are to be matched
    inh boolean Pattern.matchSubtype();
    // notation for match on subtype
    eq SubtypeNamePattern.getPattern().matchSubtype() = true;
    // default is to not match on subtype
    eq TypeDecl.getBodyDecl().matchSubtype() = false;
    eq AspectDecl.getPerClause().matchSubtype() = false;

    syn boolean Pattern.matchesType(SootClass c) = false;
    eq SimpleNamePattern.matchesType(SootClass c) {
        Set set = matchSubtype() ? superTypes(c) : new HashSet();
        set.add(c);
        for(Iterator iter = set.iterator(); iter.hasNext(); ) {
          c = (SootClass)iter.next();
          String name = c.getShortName();
          int index = name.lastIndexOf('$');
          if (index != -1)
            name = name.substring(index + 1, name.length());
          if(matchesName(name))
            return true;
        }
        return false;
    }
    eq ExplicitTypeNamePattern.matchesType(SootClass c) {
        Set set = matchSubtype() ? superTypes(c) : new HashSet();
        set.add(c);
        for(Iterator iter = set.iterator(); iter.hasNext(); ) {
          c = (SootClass)iter.next();

          if(getAccess().type().jvmName().equals(c.getName())
             && getAccess().isTypeAccess())
            return true;
        }
        return false;
    }
    // the subtyping part is handled by the matchSubtype() inherited
    // attribute - all we have to do here is recurse
    eq SubtypeNamePattern.matchesType(SootClass c) =
        getPattern().matchesType(c);
    eq ArraytypeNamePattern.matchesType(SootClass c) = false;

    syn boolean Pattern.matchesType(Type t) = false;
    eq SimpleNamePattern.matchesType(Type t) {
        if(! (t instanceof RefType)) {
            return matchesName(t.toString());
        }
        SootClass c = ((RefType) t).getSootClass();
        return matchesType(c);
    }
    eq ExplicitTypeNamePattern.matchesType(Type t) {
        boolean builtin_pat = getAccess().type().isPrimitive()
                                || getAccess().type().isVoid();
        boolean builtin_type = ! (t instanceof RefType);

        if (builtin_pat && builtin_type) {
            return getAccess().type().name().equals(t.toString())
                    && getAccess().isTypeAccess();
        }
        if (builtin_pat || builtin_type) {
            return false;
        }
        SootClass c = ((RefType) t).getSootClass();
        return matchesType(c);
    }
    // the subtyping part is handled by the matchSubtype() inherited
    // attribute - all we have to do here is recurse
    eq SubtypeNamePattern.matchesType(Type t) =
        getPattern().matchesType(t);
    eq ArraytypeNamePattern.matchesType(Type t) {
        if (! (t instanceof ArrayType))
            return false;
        ArrayType arraytype = (ArrayType) t;
        return arraytype.numDimensions == getNumDims()
               && getPattern().matchesType(arraytype.baseType);
    }
        

    syn boolean Pattern.matchesType(TypeDecl t) = false;
    eq SimpleNamePattern.matchesType(TypeDecl t) {
      Set set = matchSubtype() ? t.superTypes() : new HashSet();
      set.add(t);
      for(Iterator iter = set.iterator(); iter.hasNext(); ) {
        t = (TypeDecl)iter.next();
        String name = t.name();
        if(matchesName(name))
          return true;
      }
      return false;
    }
    eq ExplicitTypeNamePattern.matchesType(TypeDecl t) {
      return getAccess().type() == t;
    }
    // the subtyping part is handled by the matchSubtype() inherited
    // attribute - all we have to do here is recurse
    eq SubtypeNamePattern.matchesType(TypeDecl t) =
        getPattern().matchesType(t);
    eq ArraytypeNamePattern.matchesType(TypeDecl t) =
        getNumDims() == t.dimension()
        && getPattern().matchesType(t.elementType());



    // find super types
    syn lazy Set TypeDecl.superTypes()
    {
        Set set = new HashSet();
        addSuperTypes(set);
        return set;
    }
    public void TypeDecl.addSuperTypes(Set set) { }
    public void ClassDecl.addSuperTypes(Set set)
    {
        if (hasSuperclass() && !set.contains(superclass())) {
            set.add(superclass());
            superclass().addSuperTypes(set);
        }
        Iterator i = interfacesIterator();
        while (i.hasNext()) {
            TypeDecl iface = (TypeDecl) i.next();
            if (!set.contains(iface)) {
                set.add(iface);
                iface.addSuperTypes(set);
            }
        }
    }
    public void InterfaceDecl.addSuperTypes(Set set)
    {
        Iterator i = superinterfacesIterator();
        while (i.hasNext()) {
            TypeDecl iface = (TypeDecl) i.next();
            if (!set.contains(iface)) {
                set.add(iface);
                iface.addSuperTypes(set);
            }
        }
    }
    
    syn boolean ModifierPattern.matches(int m) = (modifierMask() & m) != 0;
    eq NegModifierPattern.matches(int m) = !super.matches(m);
    syn lazy int ModifierPattern.modifierMask() {
      String s = getModifier().getID();
      if(s.equals("public")) return soot.Modifier.PUBLIC;
      if(s.equals("private")) return soot.Modifier.PRIVATE;
      if(s.equals("protected")) return soot.Modifier.PROTECTED;
      if(s.equals("static")) return soot.Modifier.STATIC;
      if(s.equals("abstract")) return soot.Modifier.ABSTRACT;
      if(s.equals("final")) return soot.Modifier.FINAL;
      if(s.equals("native")) return soot.Modifier.NATIVE;
      if(s.equals("synchronized")) return soot.Modifier.SYNCHRONIZED;
      if(s.equals("transient")) return soot.Modifier.TRANSIENT;
      if(s.equals("volatile")) return soot.Modifier.VOLATILE;
      if(s.equals("strictfp")) return soot.Modifier.STRICTFP;
      throw new Error("Trying to match unsupported modifier: " + s);
    }
}

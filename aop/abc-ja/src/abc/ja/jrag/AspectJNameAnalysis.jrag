aspect AspectJNameAnalysis {

  // transitive "implements" test
  syn boolean TypeDecl.implement(TypeDecl typeDecl) = false;
  eq ClassDecl.implement(TypeDecl typeDecl) {
    for(int i = 0; i < getNumImplements(); i++)
      if(getImplements(i).type().instanceOf(typeDecl))
        return true;
    return false;
  }

  refine IntertypeMethodErrorCheck eq AspectDecl.localMethodsSignatureMap() {
    addImplicitMethods();
    return IntertypeMethodErrorCheck.AspectDecl.localMethodsSignatureMap();
  }

  private boolean AspectDecl.addImplicitMethods = true;
  private void AspectDecl.addImplicitMethods() {
    if(!addImplicitMethods || isAbstract())
      return;
    addImplicitMethods = false;
    List parameters = new List();
    if(getPerClause().isPerObject())
      parameters.add(new ParameterDeclaration(new Modifiers(new List()), typeObject().createQualifiedAccess(), "obj"));
    MethodDecl aspectOf = 
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public")).add(new Modifier("static")).add(new Modifier("synthetic"))),
        createQualifiedAccess(),
        "aspectOf",
        parameters,
        new List(),
        new List(),
        new Opt(new Block(new List().add(new ReturnStmt(new Opt(new NullLiteral())))))
      );
    parameters = new List();
    if(getPerClause().isPerObject())
      parameters.add(new ParameterDeclaration(new Modifiers(new List()), typeObject().createQualifiedAccess(), "obj"));
    MethodDecl hasAspect =
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public")).add(new Modifier("static")).add(new Modifier("synthetic"))),
        typeBoolean().createQualifiedAccess(),
        "hasAspect",
        parameters,
        new List(),
        new List(),
        new Opt(new Block(new List().add(new ReturnStmt(new Opt(new BooleanLiteral("true"))))))
      );
    aspectOf.category = MethodCategory.ASPECT_INSTANCE;
    hasAspect.category = MethodCategory.ASPECT_INSTANCE;
    addBodyDecl(aspectOf);
    addBodyDecl(hasAspect);
  }
  inh TypeDecl AspectDecl.typeBoolean();

  syn boolean PerClause.isPerObject() = false;
  eq PerTarget.isPerObject() = true;
  eq PerThis.isPerObject() = true;

  eq AspectDecl.getPerClause().hostType() = this;


  // TODO: move
  public void PointcutDecl.nameCheck()
  {
    super.nameCheck();
    implicitNameCheck();
    circularNameCheck();
  }


  // Check for cycles in named pointcuts
  public void PointcutDecl.circularNameCheck()
  {
    if(isCircular())
      error("The pointcut " + getID() + " has a circular dependency.");
  }

  // do a fixpoint computation over the boolean domain
  syn lazy boolean PointcutDecl.isCircular() circular [true] =
    hasPointcutExpr() ? getPointcutExpr().isCircular() : false;

  syn lazy boolean PointcutExpr.isCircular() circular [true] = false;
  eq NamedPointcutExpr.isCircular() = decl().isCircular();
  eq BinaryPointcutExpr.isCircular() = getLhs().isCircular()
                                       || getRhs().isCircular();
  eq NegPointcutExpr.isCircular() = getPointcutExpr().isCircular();
  eq CflowPointcutExpr.isCircular() = getPointcut().isCircular();
  eq CflowBelowPointcutExpr.isCircular() = getPointcut().isCircular();

  syn PointcutDecl NamedPointcutExpr.decl() =
    ((PointcutAccess) getName().lastAccess()).decl();
}

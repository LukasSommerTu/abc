aspect AspectJNameAnalysis {
  // compute the set of intertype declarations
  // this is an attribute at the very root of the
  // program - we'll collect the intertype decls from
  // all sources that are being compiled
  syn lazy Collection Program.intertypeDeclarations() {
    Collection c = new ArrayList();
    for(int i = 0; i < getNumCompilationUnit(); i++) {
      c.addAll(getCompilationUnit(i).intertypeDeclarations());
    }
    return c;
  }
  syn lazy Collection CompilationUnit.intertypeDeclarations() {
    Collection c = new ArrayList();
    if(fromSource())
      collectIntertypeDeclarations(c);
    return c;
  }

  // generic traversal code
  protected void ASTNode.collectIntertypeDeclarations(Collection c) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectIntertypeDeclarations(c);
  }
  // override generic traversal..
  protected void BodyDecl.collectIntertypeDeclarations(Collection c) {
  }
  // ..to only process membertypes and not other body declarations
  protected void MemberTypeDecl.collectIntertypeDeclarations(Collection c) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectIntertypeDeclarations(c);
  }
  // ..and to add intertype declarations
  protected void IntertypeMethodDecl.collectIntertypeDeclarations(Collection c) {
    c.add(this);
  }

  // transitive "implements" test
  syn boolean TypeDecl.implement(TypeDecl typeDecl) = false;
  eq ClassDecl.implement(TypeDecl typeDecl) {
    for(int i = 0; i < getNumImplements(); i++)
      if(getImplements(i).type().instanceOf(typeDecl))
        return true;
    return false;
  }

  // mark normal methods as local, and intertype methods as nonlocal
  syn boolean BodyDecl.isLocalMethod(/*String name*/) = false;
  eq MethodDecl.isLocalMethod(/*String name*/) = true; //name().equals(name);
  eq IntertypeMethodDecl.isLocalMethod(/*String name*/) = false;
  
  eq AspectDecl.localMethodsSignatureMap() {
    addImplicitMethods();
    HashMap map = new HashMap(getNumBodyDecl());
    for(int i = 0; i < getNumBodyDecl(); i++) {
      if(getBodyDecl(i).isLocalMethod()) {
        MethodDecl decl = (MethodDecl)getBodyDecl(i);
        map.put(decl.signature(), decl);
      }
    }
    return map;
  }

  private boolean AspectDecl.addImplicitMethods = true;
  private void AspectDecl.addImplicitMethods() {
    if(!addImplicitMethods || isAbstract())
      return;
    addImplicitMethods = false;
    List parameters = new List();
    if(getPerClause().isPerObject())
      parameters.add(new ParameterDeclaration(new Modifiers(new List()), typeObject().createQualifiedAccess(), "obj"));
    addBodyDecl(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public")).add(new Modifier("static"))),
        createQualifiedAccess(),
        "aspectOf",
        parameters,
        new List(),
        new List(),
        new Opt(new Block(new List().add(new ReturnStmt(new Opt(new NullLiteral())))))
      )
    );
    parameters = new List();
    if(getPerClause().isPerObject())
      parameters.add(new ParameterDeclaration(new Modifiers(new List()), typeObject().createQualifiedAccess(), "obj"));
    addBodyDecl(
      new MethodDecl(
        new Modifiers(new List().add(new Modifier("public")).add(new Modifier("static"))),
        typeBoolean().createQualifiedAccess(),
        "hasAspect",
        parameters,
        new List(),
        new List(),
        new Opt(new Block(new List().add(new ReturnStmt(new Opt(new BooleanLiteral("true"))))))
      )
    );
  }
  inh TypeDecl AspectDecl.typeBoolean();

  syn boolean PerClause.isPerObject() = false;
  eq PerTarget.isPerObject() = true;
  eq PerThis.isPerObject() = true;

  /* ------------------------------------------------------------------------------------------------------ */
  // named pointcut (sketch)
  // the main difficulty here is to check that there are no cycles
  // in pointcut declarations. In JastAdd, that can be done via
  // circular attributes.
  
  /*
  // quick hack: we only find pcs in the declaring aspect
  inh PCDecl PCName.lookupPC(String name);
  inh PCDecl PCDecl.lookupPC(String name);
  eq Program.getCompilationUnit(int i).lookupPC(String name) = null;
  eq AspectDecl.getBodyDecl(int index).lookupPC(String name) {
    for(int i = 0; i < getNumBodyDecl(); i++)
      if(getBodyDecl(i).isPC(name))
        return (PCDecl)getBodyDecl(i);
    return null;
  }
  syn boolean BodyDecl.isPC(String name) = false;
  eq PCDecl.isPC(String name) = getID().equals(name);
  syn PCDecl PCName.decl() = lookupPC(getID());
  
  // checking the name for circular use
  public void PCDecl.nameCheck() {
    super.nameCheck();
    if(isCircular())
      error("Semantic Error: pointcut " + getID() + " in " + hostType().fullName() + " is circular");
  }

  // do a fixpoint computation over the boolean domain
  syn lazy boolean PCDecl.isCircular() circular [true] = getPC().isCircular();
  syn lazy boolean PC.isCircular() circular [true];
  eq PCAnd.isCircular() = getLeft().isCircular() || getRight().isCircular();
  eq PCCall.isCircular() = false;
  eq PCName.isCircular() = decl().isCircular();
  */

}

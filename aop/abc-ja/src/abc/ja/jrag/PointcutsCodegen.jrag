aspect PointcutCodegen
{
    //
    // The abc backend works on a representation of AspectJ constructs
    // known as the "aspectinfo". Each pointcut expression in the frontend
    // is converted to an aspectinfo representation.
    //

    abstract public Pointcut PointcutExpr.pointcut();


    // boolean pointcut expressions

    public Pointcut AndPointcutExpr.pointcut() {
        return AndPointcut.construct(getLhs().pointcut(),
                                     getRhs().pointcut(), pos());
    }

    public Pointcut OrPointcutExpr.pointcut() {
        return OrPointcut.construct(getLhs().pointcut(),
                                    getRhs().pointcut(), pos());
    }

    public Pointcut NegPointcutExpr.pointcut() {
        return NotPointcut.construct(getPointcutExpr().pointcut(), pos());
    }


    // primitive pointcuts (in alphabetical order)

    public Pointcut AdviceExecutionPointcutExpr.pointcut() {
        return AndPointcut.construct(
                    new WithinAdvice(pos()),
                    new Execution(pos()),
                    pos());
    }

    public Pointcut ArgsPointcutExpr.pointcut() {
        java.util.List arg_patterns = new ArrayList();

        for(int i = 0; i < getNumPattern(); i++)
            arg_patterns.add(getPattern(i).argPattern());

        return new Args(arg_patterns, pos());
    }

    public Pointcut CallPointcutExpr.pointcut() {
        if (getPattern().isMethodPattern())
            return new MethodCall(getPattern().methodPattern(), pos());
        else
            return new
                ConstructorCall(getPattern().constructorPattern(), pos());
    }

    public Pointcut CflowPointcutExpr.pointcut() {
        return new Cflow(getPointcut().pointcut(), pos());
    }

    public Pointcut CflowBelowPointcutExpr.pointcut() {
        return new CflowBelow(getPointcut().pointcut(), pos());
    }

    public Pointcut ExecutionPointcutExpr.pointcut() {
        Pointcut withincode;
        if (getPattern().isMethodPattern())
            withincode = new WithinMethod(getPattern().methodPattern(), pos());
        else
            withincode = new
                WithinConstructor(getPattern().constructorPattern(), pos());

        return AndPointcut.construct(withincode, new Execution(pos()), pos());
    }

    public Pointcut GetPointcutExpr.pointcut() {
        return new GetField(getPattern().fieldPattern(), pos());
    }

    public Pointcut HandlerPointcutExpr.pointcut() {
        return new Handler(getPattern().classnamePattern(), pos());
    }

    // FIXME
    public Pointcut IfPointcutExpr.pointcut() {
        // get jp/jpsp/ejpsp info
        return new If(methodFormals(), methodSig(), -1, -1, -1, pos());
    }

    public Pointcut InitializationPointcutExpr.pointcut() {
        Pointcut within_constructor =
            new WithinConstructor(getPattern().constructorPattern(), pos());

        Pointcut class_init = new ClassInitialization(pos());

        if (!getPattern().matchesEmptyArgList())
            return class_init;

        Pointcut interface_init =
            new InterfaceInitialization(
                getPattern().getMemberNamePattern().base().classnamePattern(),
                pos());

        return OrPointcut.construct(
                AndPointcut.construct(within_constructor, class_init, pos()),
                interface_init,
                pos());
    }

    public Pointcut NamedPointcutExpr.pointcut() {
        java.util.List arg_patterns = new ArrayList();

        for(int i = 0; i < getNumPattern(); i++)
            arg_patterns.add(getPattern(i).argPattern());

        PointcutAccess access = (PointcutAccess) getName().lastAccess();
        Object key = new Object();
        Map decl_map = new HashMap();
        decl_map.put(key, access.decl().pointcutDecl());

        return new PointcutRef(key, decl_map, arg_patterns,
                                pos(), access.isQualified());
    }

    public Pointcut PreInitializationPointcutExpr.pointcut() {
        return AndPointcut.construct(
            new WithinConstructor(getPattern().constructorPattern(), pos()),
            new Preinitialization(pos()),
            pos());
    }

    public Pointcut SetPointcutExpr.pointcut() {
        return new SetField(getPattern().fieldPattern(), pos());
    }

    public Pointcut StaticInitializationPointcutExpr.pointcut() {
        Pointcut directly_within =
            new DirectlyWithin(getPattern().classnamePattern(), pos());
        Pointcut within_static_init =
            new WithinStaticInitializer(pos());
        Pointcut execution = new Execution(pos());

        return AndPointcut.construct(
                directly_within,
                AndPointcut.construct(within_static_init, execution, pos()),
                pos());
    }

    public Pointcut TargetPointcutExpr.pointcut() {
        return getPattern().targetPointcut();
    }

    public Pointcut ThisPointcutExpr.pointcut() {
        return getPattern().thisPointcut();
    }

    public Pointcut WithinPointcutExpr.pointcut() {
        return new Within(getPattern().classnamePattern(), pos());
    }

    public Pointcut WithinCodePointcutExpr.pointcut() {
        if (getPattern().isMethodPattern())
            return new WithinMethod(getPattern().methodPattern(), pos());

        return new WithinConstructor(getPattern().constructorPattern(), pos());
    }



    //
    // Arguments to args/target/this also need to be converted
    // into aspectinfo format
    //

    // find an ArgPattern from a BindingPattern
    syn ArgPattern BindingPattern.argPattern();
    eq StarBindingPattern.argPattern() = new ArgAny(pos());
    eq DotDotBindingPattern.argPattern() = new ArgFill(pos());
    eq NameBindingPattern.argPattern()
    {
        Pattern pat = getPattern();
        if (pat.isVariable())
            return new ArgVar(new Var(pat.variableName(), pos()), pos());
        else
            return new ArgType(AbcFactory.AbcType(pat.type().getSootType()),
                               pos());
    }

    // find a target pointcut from a BindingPattern
    syn Pointcut BindingPattern.targetPointcut();
    eq StarBindingPattern.targetPointcut() = new TargetAny(pos());
    eq DotDotBindingPattern.targetPointcut()
    {
        throw new InternalCompilerError(
            "trying to create an aspectinfo pointcut for 'target(..)'");
    }
    eq NameBindingPattern.targetPointcut()
    {
        Pattern pat = getPattern();
        if (pat.isVariable())
            return new TargetVar(new Var(pat.variableName(), pos()), pos());
        return new TargetType(AbcFactory.AbcType(pat.type().getSootType()),
                              pos());
    }

    // find a this pointcut from a BindingPattern
    syn Pointcut BindingPattern.thisPointcut();
    eq StarBindingPattern.thisPointcut() = new ThisAny(pos());
    eq DotDotBindingPattern.thisPointcut()
    {
        throw new InternalCompilerError(
            "trying to create an aspectinfo pointcut for 'this(..)'");
    }
    eq NameBindingPattern.thisPointcut()
    {
        Pattern pat = getPattern();
        if (pat.isVariable())
            return new ThisVar(new Var(pat.variableName(), pos()), pos());
        return new ThisType(AbcFactory.AbcType(pat.type().getSootType()),
                            pos());
    }

    syn boolean Pattern.isVariable() = false;
    eq ExplicitTypeNamePattern.isVariable() = getAccess().isVariable();

    syn String Pattern.variableName() {
        throw new InternalCompilerError(
            "variableName() not defined for " + getClass().getName() + ")");
    }
    eq ExplicitTypeNamePattern.variableName() = getAccess().variableName();

    syn String Access.variableName() {
        throw new InternalCompilerError(
            "variableName() not defined for " + getClass().getName() + ")");
    }
    eq VarAccess.variableName() = name();

    syn TypeDecl Pattern.type() {
        throw new InternalCompilerError(
            "type() not defined for " + getClass().getName() + ")");
    }
    eq ExplicitTypeNamePattern.type() = getAccess().type();



    //
    // Code generation for pointcut declarations
    //
    syn lazy abc.weaving.aspectinfo.PointcutDecl PointcutDecl.pointcutDecl()
    {
        return new abc.weaving.aspectinfo.PointcutDecl(
                    name(),
                    formals(),
                    hasPointcutExpr() ? getPointcutExpr().pointcut() : null,
                    aspectClass(),
                    pos());
    }

    protected java.util.List PointcutDecl.formals()
    {
        ArrayList list = new ArrayList();
        for (int i = 0; i < getNumParameter(); i++)
            list.add(getParameter(i).formal());
        return list;
    }

    public void PointcutDecl.jimplify2()
    {
        globalAspectInfo().addPointcutDecl(pointcutDecl());
    }



    //
    // Code generation for if-pointcuts
    //
    public void IfPointcutExpr.jimplify2()
    {

    }

    syn lazy java.util.List IfPointcutExpr.methodFormals()
    {
        return null;
    }

    syn lazy SootMethod IfPointcutExpr.sootMethod()
    {
        return null;
    }

    syn lazy MethodSig IfPointcutExpr.methodSig()
    {
        return null;
    }
}

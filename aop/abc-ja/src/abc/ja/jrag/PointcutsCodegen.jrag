aspect PointcutCodegen
{
    //
    // The abc backend works on a representation of AspectJ constructs
    // known as the "aspectinfo". Each pointcut expression in the frontend
    // is converted to an aspectinfo representation.
    //

    abstract public Pointcut PointcutExpr.pointcut();


    // boolean pointcut expressions

    public Pointcut AndPointcutExpr.pointcut() {
        return AndPointcut.construct(getLhs().pointcut(),
                                     getRhs().pointcut(), pos());
    }

    public Pointcut OrPointcutExpr.pointcut() {
        return OrPointcut.construct(getLhs().pointcut(),
                                    getRhs().pointcut(), pos());
    }

    public Pointcut NegPointcutExpr.pointcut() {
        return NotPointcut.construct(getPointcutExpr().pointcut(), pos());
    }


    // primitive pointcuts (in alphabetical order)

    public Pointcut AdviceExecutionPointcutExpr.pointcut() {
        return AndPointcut.construct(
                    new WithinAdvice(pos()),
                    new Execution(pos()),
                    pos());
    }

    public Pointcut ArgsPointcutExpr.pointcut() {
        java.util.List arg_patterns = new ArrayList();

        for(int i = 0; i < getNumPattern(); i++)
            arg_patterns.add(getPattern(i).argPattern());

        return new Args(arg_patterns, pos());
    }

    public Pointcut CallPointcutExpr.pointcut() {
        if (getPattern().isMethodPattern())
            return new MethodCall(getPattern().methodPattern(), pos());
        else
            return new
                ConstructorCall(getPattern().constructorPattern(), pos());
    }

    public Pointcut CflowPointcutExpr.pointcut() {
        return new Cflow(getPointcut().pointcut(), pos());
    }

    public Pointcut CflowBelowPointcutExpr.pointcut() {
        return new CflowBelow(getPointcut().pointcut(), pos());
    }

    public Pointcut ExecutionPointcutExpr.pointcut() {
        Pointcut withincode;
        if (getPattern().isMethodPattern())
            withincode = new WithinMethod(getPattern().methodPattern(), pos());
        else
            withincode = new
                WithinConstructor(getPattern().constructorPattern(), pos());

        return AndPointcut.construct(withincode, new Execution(pos()), pos());
    }

    public Pointcut GetPointcutExpr.pointcut() {
        return new GetField(getPattern().fieldPattern(), pos());
    }

    public Pointcut HandlerPointcutExpr.pointcut() {
        return new Handler(getPattern().classnamePattern(), pos());
    }

    // FIXME
    public Pointcut IfPointcutExpr.pointcut() {
        // get vars
        // get methodsig
        // get jp/jpsp/ejpsp info
        return new If(null, null, -1, -1, -1, pos());
    }

    // FIXME - interface init conditional on the pattern
    //         matching the empty argument list
    //       - supposed to get base() for interface-initialization
    public Pointcut InitializationPointcutExpr.pointcut() {
        Pointcut within_constructor =
            new WithinConstructor(getPattern().constructorPattern(), pos());

        Pointcut class_init = new ClassInitialization(pos());

        Pointcut interface_init =
            new InterfaceInitialization(
                    getPattern().getMemberNamePattern().classnamePattern(),
                    pos());

        return OrPointcut.construct(
                AndPointcut.construct(within_constructor, class_init, pos()),
                interface_init,
                pos());
    }

    // FIXME
    public Pointcut NamedPointcutExpr.pointcut() {
        java.util.List arg_patterns = new ArrayList();

        for(int i = 0; i < getNumPattern(); i++)
            arg_patterns.add(getPattern(i).argPattern());

        PointcutAccess access = (PointcutAccess) getName().lastAccess();
        Object key = new Object();
        Map decl_map = new HashMap();
        decl_map.put(key, access.decl().pointcutDecl());

        return new PointcutRef(key, decl_map, arg_patterns,
                                pos(), access.isQualified());
    }

    public Pointcut PreInitializationPointcutExpr.pointcut() {
        return AndPointcut.construct(
            new WithinConstructor(getPattern().constructorPattern(), pos()),
            new Preinitialization(pos()),
            pos());
    }

    public Pointcut SetPointcutExpr.pointcut() {
        return new SetField(getPattern().fieldPattern(), pos());
    }

    public Pointcut StaticInitializationPointcutExpr.pointcut() {
        Pointcut directly_within =
            new DirectlyWithin(getPattern().classnamePattern(), pos());
        Pointcut within_static_init =
            new WithinStaticInitializer(pos());
        Pointcut execution = new Execution(pos());

        return AndPointcut.construct(
                directly_within,
                AndPointcut.construct(within_static_init, execution, pos()),
                pos());
    }

    public Pointcut TargetPointcutExpr.pointcut() {
        return getPattern().targetPointcut();
    }

    public Pointcut ThisPointcutExpr.pointcut() {
        return getPattern().thisPointcut();
    }

    public Pointcut WithinPointcutExpr.pointcut() {
        return new Within(getPattern().classnamePattern(), pos());
    }

    public Pointcut WithinCodePointcutExpr.pointcut() {
        if (getPattern().isMethodPattern())
            return new WithinMethod(getPattern().methodPattern(), pos());

        return new WithinConstructor(getPattern().constructorPattern(), pos());
    }



    //
    // Arguments to args/target/this also need to be converted
    // into aspectinfo format
    //

    // find an ArgPattern from a BindingPattern
    syn ArgPattern BindingPattern.argPattern();
    eq StarBindingPattern.argPattern() = new ArgAny(pos());
    eq DotDotBindingPattern.argPattern() = new ArgFill(pos());
    eq NameBindingPattern.argPattern() = getPattern().argPattern();

    // find an ArgPattern from a Pattern
    syn ArgPattern Pattern.argPattern() {
        throw new RuntimeException("argPattern() not defined for " +
                                    getClass().getName());
    }
    eq ExplicitTypeNamePattern.argPattern() = getAccess().argPattern();

    // find an ArgPattern from an Access
    syn ArgPattern Access.argPattern() {
        throw new RuntimeException("argPattern() not defined for " +
                                    getClass().getName());
    }
    eq VarAccess.argPattern() = new ArgVar(new Var(name(), pos()), pos());
    eq TypeAccess.argPattern() =
        new ArgType(AbcFactory.AbcType(type().getSootType()), pos());

    // find a target pointcut from a BindingPattern
    syn Pointcut BindingPattern.targetPointcut();
    eq StarBindingPattern.targetPointcut() = new TargetAny(pos());
    eq NameBindingPattern.targetPointcut() = getPattern().targetPointcut();
    eq DotDotBindingPattern.targetPointcut() {
        throw new InternalCompilerError(
            "trying to create an aspectinfo pointcut for 'target(..)'");
    }

    // find a target pointcut from a Pattern
    syn Pointcut Pattern.targetPointcut()
    {
        throw new InternalCompilerError(
            "targetPointcut() not defined for " + getClass().getName());
    }
    eq ExplicitTypeNamePattern.targetPointcut() = getAccess().targetPointcut();

    // find a target pointcut from an Access
    syn Pointcut Access.targetPointcut() {
        throw new RuntimeException("targetPointcut() not defined for " +
                                    getClass().getName());
    }
    eq VarAccess.targetPointcut() =
        new TargetVar(new Var(name(), pos()), pos());
    eq TypeAccess.targetPointcut() =
        new TargetType(AbcFactory.AbcType(type().getSootType()), pos());

    // find a this pointcut from a BindingPattern
    syn Pointcut BindingPattern.thisPointcut();
    eq StarBindingPattern.thisPointcut() = new ThisAny(pos());
    eq NameBindingPattern.thisPointcut() = getPattern().thisPointcut();
    eq DotDotBindingPattern.thisPointcut() {
        throw new InternalCompilerError(
            "trying to create an aspectinfo pointcut for 'this(..)'");
    }

    // find a this pointcut from a Pattern
    syn Pointcut Pattern.thisPointcut()
    {
        throw new InternalCompilerError(
            "thisPointcut() not defined for " + getClass().getName());
    }
    eq ExplicitTypeNamePattern.thisPointcut() = getAccess().thisPointcut();

    // find a this pointcut from an Access
    syn Pointcut Access.thisPointcut() {
        throw new RuntimeException("thisPointcut() not defined for " +
                                    getClass().getName());
    }
    eq VarAccess.thisPointcut() =
        new ThisVar(new Var(name(), pos()), pos());
    eq TypeAccess.thisPointcut() =
        new ThisType(AbcFactory.AbcType(type().getSootType()), pos());



    //
    // Code generation for pointcut declarations
    //
    syn lazy abc.weaving.aspectinfo.PointcutDecl PointcutDecl.pointcutDecl()
    {
        return new abc.weaving.aspectinfo.PointcutDecl(
                    name(),
                    formals(),
                    hasPointcutExpr() ? getPointcutExpr().pointcut() : null,
                    aspectClass(),
                    pos());
    }

    protected java.util.List PointcutDecl.formals()
    {
        ArrayList list = new ArrayList();
        for (int i = 0; i < getNumParameter(); i++)
            list.add(getParameter(i).formal());
        return list;
    }

    public void PointcutDecl.jimplify2()
    {
        globalAspectInfo().addPointcutDecl(pointcutDecl());
    }
}

aspect PointcutCodegen
{
    //
    // The abc backend works on a representation of AspectJ constructs
    // known as the "aspectinfo". Each pointcut expression in the frontend
    // is converted to an aspectinfo representation.
    //

    abstract public Pointcut PointcutExpr.pointcut();


    // boolean pointcut expressions

    public Pointcut AndPointcutExpr.pointcut() {
        return AndPointcut.construct(getLhs().pointcut(),
                                     getRhs().pointcut(), pos());
    }

    public Pointcut OrPointcutExpr.pointcut() {
        return OrPointcut.construct(getLhs().pointcut(),
                                    getRhs().pointcut(), pos());
    }

    public Pointcut NegPointcutExpr.pointcut() {
        return NotPointcut.construct(getPointcutExpr().pointcut(), pos());
    }


    // primitive pointcuts (in alphabetical order)

    public Pointcut AdviceExecutionPointcutExpr.pointcut() {
        return AndPointcut.construct(
                    new WithinAdvice(pos()),
                    new Execution(pos()),
                    pos());
    }

    public Pointcut ArgsPointcutExpr.pointcut() {
        java.util.List arg_patterns = new ArrayList();

        for(int i = 0; i < getNumPattern(); i++)
            arg_patterns.add(getPattern(i).argPattern());

        return new Args(arg_patterns, pos());
    }

    public Pointcut CallPointcutExpr.pointcut() {
        if(getPattern().isMethodPattern())
            return new MethodCall(getPattern(), pos());
        else
            // FIXME: return new ConstructorCall(getPattern(), pos());
            throw new RuntimeException("constructor matching: broken");
    }

    public Pointcut CflowPointcutExpr.pointcut() {
        return new Cflow(getPointcut().pointcut(), pos());
    }

    public Pointcut CflowBelowPointcutExpr.pointcut() {
        return new CflowBelow(getPointcut().pointcut(), pos());
    }

    // FIXME below this point
    public Pointcut ExecutionPointcutExpr.pointcut() {
        Pointcut withincode;
        if(getPattern().isMethodPattern())
            withincode = new WithinMethod(getPattern(), pos());
        else
            // withincode = new WithinConstructor(getPattern(), pos());
            throw new RuntimeException("constructor matching: broken");

        return AndPointcut.construct(withincode, new Execution(pos()), pos());
    }

    public Pointcut GetPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut HandlerPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut IfPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut InitializationPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut NamedPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut PreInitializationPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut SetPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut StaticInitializationPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut TargetPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut ThisPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut WithinPointcutExpr.pointcut() {
        return null;
    }

    public Pointcut WithinCodePointcutExpr.pointcut() {
        return null;
    }



    //
    // Arguments to args/target/this also need to be converted
    // into aspectinfo format
    //
    
    abstract public ArgPattern BindingPattern.argPattern();

    public ArgPattern StarBindingPattern.argPattern() {
        return new ArgAny(pos());
    }

    public ArgPattern DotDotBindingPattern.argPattern() {
        return new ArgFill(pos());
    }

    public ArgPattern NameBindingPattern.argPattern() {
        return getPattern().argPattern();
    }

    public ArgPattern Pattern.argPattern() {
        throw new RuntimeException("argPattern() not defined for " +
                                    getClass().getName());
    }

    public ArgPattern ExplicitTypeNamePattern.argPattern() {
        return getAccess().argPattern();
    }

    public ArgPattern Access.argPattern() {
        throw new RuntimeException("argPattern() not defined for " +
                                    getClass().getName());
    }

    public ArgPattern VarAccess.argPattern() {
        return new ArgVar(new Var(name(), pos()), pos());
    }

    public ArgPattern TypeAccess.argPattern() {
        return new ArgType(AbcFactory.AbcType(type().getSootType()), pos());
    }
}

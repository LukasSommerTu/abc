import abc.weaving.aspectinfo.*;
import abc.weaving.aspectinfo.MethodCategory;

aspect AspectJCodegen {

  public static GlobalAspectInfo ASTNode.globalAspectInfo() {
    return abc.main.Main.v().getAbcExtension().getGlobalAspectInfo();
  }

  syn lazy AbcClass TypeDecl.abcClass() = AbcFactory.AbcClass(sootClass());

  public int MethodDecl.category = MethodCategory.NORMAL;
  refine EmitJimple public void MethodDecl.jimplify2() {
    EmitJimple.MethodDecl.jimplify2();
    MethodCategory.register(sootMethod, category);
  }
  refine IntertypeMethodCodegeneration eq IntertypeMethodDecl.createAspectMethod() {
    MethodDecl m = IntertypeMethodCodegeneration.IntertypeMethodDecl.createAspectMethod();
    m.category = MethodCategory.INTERTYPE_METHOD_SOURCE;
    return m;
  }
  refine IntertypeMethodCodegeneration public MethodDecl IntertypeMethodDecl.createDelegateMethod(MethodDecl aspectMethod) {
    MethodDecl m = IntertypeMethodCodegeneration.IntertypeMethodDecl.createDelegateMethod(aspectMethod);
    m.category = MethodCategory.INTERTYPE_METHOD_DELEGATOR;
    return m;
  }

  refine EmitJimple public void Program.jimplify1() {
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit u = (CompilationUnit)iter.next();
      if(u.weavable())
        u.jimplify1phase1();
    }
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit u = (CompilationUnit)iter.next();
      if(u.weavable())
        u.jimplify1phase2();
    }
  }

  refine EmitJimple public void Program.jimplify2() {
    for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
      CompilationUnit u = (CompilationUnit)iter.next();
      if(u.weavable())
        u.jimplify2();
    }
  }

  refine EmitJimple eq TypeDecl.getSootClassDecl() {
    if(compilationUnit().weavable()) {
      return sootClass();
    }
    else {
      if(Program.verbose())
        System.out.println("Loading .class file " + jvmName());
      SootClass sc = Scene.v().loadClass(jvmName(), SootClass.SIGNATURES);
      sc.setLibraryClass();
      return sc;
    }
  }


  public void ClassDecl.jimplify1phase1() {
    super.jimplify1phase1();
    AbcClass abc = abcClass();
    globalAspectInfo().addWeavableClass(abc);
  }
  
  public void InterfaceDecl.jimplify1phase1() {
    super.jimplify1phase1();
    AbcClass abc = abcClass();
    globalAspectInfo().addWeavableClass(abc);
  }

  public void AspectDecl.jimplify1phase1() {
    super.jimplify1phase1();
    globalAspectInfo().addAspect(
      new Aspect(abcClass(), getPerClause().aspectInfo(), pos())
    );
  }

  public abstract Per PerClause.aspectInfo();
  public Per PerTarget.aspectInfo() {
    return new abc.weaving.aspectinfo.PerTarget(
      getPointcutExpr().pointcut(), pos()
    );
  }
  public Per PerThis.aspectInfo() {
    return new abc.weaving.aspectinfo.PerThis(
      getPointcutExpr().pointcut(), pos()
    );
  }
  public Per PerCflow.aspectInfo() {
    return new abc.weaving.aspectinfo.PerCflow(
      getPointcutExpr().pointcut(), pos()
    );
  }
  public Per PerCflowBelow.aspectInfo() {
    return new abc.weaving.aspectinfo.PerCflowBelow(
      getPointcutExpr().pointcut(), pos()
    );
  }
  public Per IsSingleton.aspectInfo() {
    return new Singleton(pos());
  }

  
  eq IntertypeMethodDecl.sootRef() {
    ArrayList parameters = new ArrayList();
    for(int i = 0; i < getNumParameter(); i++)
      parameters.add(getParameter(i).type().getSootType());
    SootMethodRef ref = Scene.v().makeMethodRef(
      introducedType().getSootClassDecl(),
      name(),
      parameters,
      type().getSootType(),
      isStatic()
    );
    return ref;
  }

  public void IntertypeMethodDecl.jimplify2() {
    // do not generate any code for an IntertypeMethodDecl
    // weaving is done in the front-end
  }


  public Formal ParameterDeclaration.formal() {
    return new Formal(
        AbcFactory.AbcType(type().getSootType()),
        name(),
        pos()
    );
  }

  public void IntertypeMethodDecl.jimplify1phase2() {
    // do not generate any code for an IntertypeMethodDecl
    // weaving is done in the front-end
  }
  
  // Build a polyglot Position that corresponds to the current position
  public polyglot.util.Position ASTNode.pos() {
    return new polyglot.util.Position(sourceFile(), lineNumber());
  }


}

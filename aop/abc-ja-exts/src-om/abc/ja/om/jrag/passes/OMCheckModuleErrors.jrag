import abc.ja.om.aspectinfo.*;
import abc.ja.om.*;
import abc.om.visit.ModuleNode;
import java.util.*;

aspect OMCheckModuleErrors {
	
	//dependent on ErrorCheck.CompilationUnit.errors/warnings
  	public void Program.initErrHandling(Collection err, Collection warn) {
  		err.clear();
  		warn.clear();
  		
  		for (CompilationUnit cu : getCompilationUnitList()) {
  			if(cu.fromSource()) {
  				cu.initErrHandling();
  			}
  		}
  	}
  	
  	public void CompilationUnit.initErrHandling() {
  		errors.clear();
  		warnings.clear();
  	}
  
  	public void Program.collectModuleErrors(Collection err, Collection warn) {
  		for (Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
  			CompilationUnit cu = (CompilationUnit)iter.next();
  			if(cu.fromSource()) {
  				cu.collectModuleErrors(err, warn);
  			}
  		}
  	}
  	
  	public void CompilationUnit.collectModuleErrors(Collection err, Collection warn) {
  		err.addAll(errors);
  		warn.addAll(warnings);
  	}	
	
	//methods called from here must do their own traversal. This is run before the single checks
	public void Program.barrierCheckModuleErrors1() {
	}
	
	//methods called from here must not traverse, the traversal is done
	//by singleCheckModuleErrors 
	public void ASTNode.singleCheckModuleErrors() {
		//add error checks here
		checkModuleCycles();
		checkDuplicateClassInclude();
		checkDuplicateFriendInclude();
		markFriendMemberExistence();
		
		for (int i = 0 ; i < getNumChild(); i++) {
			getChild(i).singleCheckModuleErrors();
		}
	}
	
	//methods called from here must do their own traversal. This is run after the single checks
	public void Program.barrierCheckModuleErrors2() {
		collectNonexistentFriendAspects();
	}
	
	//throws an exception if any errors are queued up. Add more things later if needed
	public void ASTNode.checkUnrecoverableErrors() {
		for (int i = 0 ; i < getNumChild(); i++) {
			getChild(i).checkUnrecoverableErrors();
		}
	}
	public void CompilationUnit.checkUnrecoverableErrors() {
		if (this.errors.size() > 0) {
			throw new OMUnrecoverableSemanticError("Unrecoverable errors found");
		}
	}
	
	//check module cycles
	public void ASTNode.checkModuleCycles() {}
	public void OMModuleDecl.checkModuleCycles() {
		JAModuleNodeModule moduleNode = 
			(JAModuleNodeModule)getOMAbcExtension().moduleStruct.getNode(getModuleName(), ModuleNode.TYPE_MODULE);
		assert moduleNode != null : "null JAModuleNodeModule in OMModuleDecl.checkModuleCycles()";
		
		HashSet parents = new HashSet();
		while (moduleNode.getParent() != null) {
			moduleNode = (JAModuleNodeModule)moduleNode.getParent();
			if (parents.contains(moduleNode)) {
				error("module " + getModuleName() + " involved in circular inclusion.");
				break;
			}
			parents.add(moduleNode);
		}
	}
	
	//duplicate class include
	public void ASTNode.checkDuplicateClassInclude() {}
	public void TypeDecl.checkDuplicateClassInclude() {
		JAModuleStructure moduleStruct = getOMAbcExtension().moduleStruct;
		if (moduleStruct.hasMultipleOwners(this)) {
			error("class " + this.getID() + " included in more than one module.");
		}
	}
	
	//duplicate aspect friend (aspect is a friend in more than one module
	public void ASTNode.checkDuplicateFriendInclude() {}
	public void AspectDecl.checkDuplicateFriendInclude() {
		JAModuleStructure moduleStruct = getOMAbcExtension().moduleStruct;
		if (moduleStruct.hasMultipleFriendOwners(this)) {
			error("aspect " + this.getID() + " included in more than one module.");
		}
	}
	//check for wildcards in friend member patterns
	public void ASTNode.checkFriendAspectWildcard() {}
	public void NamePattern.checkFriendAspectWildcard() {
		if (getHostModule() == null) { //if not in module, continue to next
			return;
		}
		if (containsWildcard()) {
			error("Wildcards are not allowed in friend aspects.");
		}
	}
	
	//Check for non-existent aspect (traverse AspectDecls, marking off 
	//OMFriendMembers as they match. Then do another pass to check if the friend aspects
	//were found)
	public void ASTNode.markFriendMemberExistence() {}
	public void AspectDecl.markFriendMemberExistence() {
		Collection aspectNodes = getOMAbcExtension().moduleStruct.getAspectNodes();
		for (Iterator i = aspectNodes.iterator(); i.hasNext();) {
			JAModuleNodeAspect aspectNode = (JAModuleNodeAspect)i.next();
			if (aspectNode.getCPEPattern().matchesType(this)) {
				aspectNode.setFound(true);
			}
		}
	}

	//pass to collect all the friend members that don't match an aspect	
	public void ASTNode.collectNonexistentFriendAspects() {
		for (int i = 0 ; i < getNumChild(); i++) {
			getChild(i).collectNonexistentFriendAspects();
		}
	}
	public void CompilationUnit.collectNonexistentFriendAspects() {
	}
	public void OMCompilationUnit.collectNonexistentFriendAspects() {
		for (int i = 0 ; i < getNumChild(); i++) {
			getChild(i).collectNonexistentFriendAspects();
		}
	}
	public void NamePattern.collectNonexistentFriendAspects() {
		//if not in a module member or not a friend aspect
		if (getHostOMModuleMember() == null ||
			!(getHostOMModuleMember().isFriendMember())) {
			return;
		}
		//if not the root name pattern
		if (namePatternRoot() != this) {
			return;
		}
		JAModuleNodeAspect aspectNode = (JAModuleNodeAspect)getOMAbcExtension().moduleStruct.getNode(
					this.toString(), 
					ModuleNode.TYPE_ASPECT);
		if (!aspectNode.isFound()) {
			error("Friend aspect " + this.toString() + " does not exist.");
		}
		
		//arguable if this is needed at all
		super.collectNonexistentFriendAspects();
	}
	
	
}
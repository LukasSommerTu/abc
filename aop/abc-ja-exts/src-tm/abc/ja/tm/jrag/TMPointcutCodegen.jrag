/* abc - The AspectBench Compiler
 * Copyright (C) 2008 Pavel Avgustinov
 * Copyright (C) 2008 Torbjorn Ekman
 * Copyright (C) 2008 Julian Tibble
 *
 * This compiler is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This compiler is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this compiler, in the file LESSER-GPL;
 * if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

aspect TMPointcutCodegen
{
    syn Regex PointcutExpr.regex()
    {
        throw new InternalCompilerError("called regex() on regular pointcut");
    }
    eq Regex.regex() = this;

    public Pointcut Regex.pointcut()
    {
        throw new InternalCompilerError("called pointcut() on regex()");
    }

    // Record which symbols match before a joinpoint, rather than after it.
    syn boolean SymbolKind.matchesBefore() = false;
    eq BeforeSymbol.matchesBefore() = true;
    eq AroundSymbol.matchesBefore() = true;

    // returns a pointcut that matches whenever one of the before
    // or around symbol-pointcuts matches (if matchbefore == true)
    // or whenever one of the after, after-returning, or after-throwing
    // symbol-pointcuts matches (if matchbefore == false)
    syn Pointcut TraceMatchDecl.symbolsPointcut(boolean matchbefore)
    {
        Pointcut result = null;
        for (int i = 0; i < getNumSymbolDecl(); i++)
            if (getSymbolDecl(i).getSymbolKind().matchesBefore() == matchbefore)
                result = pcOr(result, getSymbolDecl(i).closedPointcut());
        return result;
    }

    syn Pointcut TraceMatchDecl.beforeSymbolsPointcut() = symbolsPointcut(true);

    syn Pointcut TraceMatchDecl.afterSymbolsPointcut() = symbolsPointcut(false);

    syn Pointcut TraceMatchDecl.aroundSymbolPointcut()
    {
        for (int i = 0; i < getNumSymbolDecl(); i++)
            if (getSymbolDecl(i).getSymbolKind().aroundSymbol() != null)
                return getSymbolDecl(i).getPointcutExpr().pointcut();
        return null;
    }

    protected Pointcut TraceMatchDecl.pcOr(Pointcut current, Pointcut next)
    {
        if (current == null)
            return next;
        return OrPointcut.construct(current, next, pos());
    }
    
    // returns an aspectinfo-representation of the pointcut for this
    // symbol, with the variables it binds existentially quantified.
    syn Pointcut SymbolDecl.closedPointcut() {
        return new LocalPointcutVars(getPointcutExpr().pointcut(), 
        		perSymbolAdviceFormals(), pos());
    }
    
    // When a tracematch has DistinctGroups, we rewrite symbol pointcuts to take
    // these into account
    public boolean SymbolDecl.distinctGroupsReflected = false;
    rewrite SymbolDecl {
    	when(!distinctGroupsReflected && enclosingTracematch().getNumDistinctGroup() > 0)
    	to SymbolDecl {
    		this.distinctGroupsReflected = true;
        	Expr ifExpr = new BooleanLiteral("true");
        	for(DistinctGroup g : enclosingTracematch().getDistinctGroups()) {
        		// Determine which of the distinct group's variables are bound by this symbol
            	Set<VarAccess> distinctAndBound = new HashSet<VarAccess>();
            	for(VarAccess v : g.getVarAccessList())
            		if(this.binds(v.name()))
            			distinctAndBound.add(v);
            			
            	// Add the right inequalities
            	for(int left = 0; left < distinctAndBound.size(); left++)
        			for(int right = left + 1; right < distinctAndBound.size(); right++)
        				ifExpr = new AndLogicalExpr(ifExpr, new NEExpr(g.getVarAccess(left), g.getVarAccess(right)));
        	}

        	// Check if we actually have something to put in an if() pointcut
        	if(!(ifExpr instanceof BooleanLiteral)) {
        		PointcutExpr ifPc = new IfPointcutExpr(ifExpr);
        		this.setPointcutExpr(new AndPointcutExpr(this.getPointcutExpr(), ifPc));
        	}
    		return this;
    	}
    }
}

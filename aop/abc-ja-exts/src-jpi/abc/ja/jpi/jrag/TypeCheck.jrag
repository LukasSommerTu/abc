aspect TypeCheck{

	/**
	 * synthesized attribute isJPITypeDecl() indicates
	 * if the TypeDecl is a JPITypeDecl or not.
	 */
	syn lazy boolean TypeDecl.isJPITypeDecl() = false;
	eq JPITypeDecl.isJPITypeDecl() = true;
	
	syn lazy boolean JPITypeDecl.hasException(String name){
  		for(int i = 0; i < getNumException(); i++){
  			if(((TypeAccess)getException(i)).name().equals(name)){
  				return true;
  			}
	    }
	    return false;	
	}

	public void JPITypeDecl.typeCheck(){
		TypeAccess jpiSuperAccess = (TypeAccess)getSuperTypeName();
		JPITypeDecl jpiSuperDecl;
		
		/***
		 * 1) check if SuperAcces is $RootJPI$
		 * 2) check that the type of SuperAccess is JPITypeDecl.
		 * 3) check the return types.
		 * 4) check the exception accesses.
		 * 5) check the arguments types.
		 */
		if (jpiSuperAccess.getID().equals("$RootJPI$")){
			return;
		}
		
		if (!jpiSuperAccess.type().isJPITypeDecl()){
			error("TypeCheck: "+jpiSuperAccess.getID()+" must be a JPI not a "+jpiSuperAccess.type().typeName());
			return;
		}

		jpiSuperDecl = (JPITypeDecl)jpiSuperAccess.type();
		
		if(!getTypeAccess().type().equals(jpiSuperDecl.getTypeAccess().type())){
			error("TypeCheck: Return type must be equals");
		}
		
		if(jpiSuperDecl.getNumException() > getNumException()){
			error("TypeCheck: " +typeName()+" must at least defines the same exceptions of its parent.");
		}
		for(Access exceptionAccess: jpiSuperDecl.getExceptionList()){
			if (!hasException(((TypeAccess)exceptionAccess).name())){
				error("TypeCheck: "+((TypeAccess)exceptionAccess).name() +" must be declared in "+typeName());
			}
		}
				
		if(getNumSuperArgumentName() != jpiSuperDecl.getNumParameter()){
			error("TypeCheck: Arguments quantity must match in the extends clause.");
		}
		else {
			for(int i=0; i<getNumSuperArgumentName(); i++){
				SimpleSet childParameter = lookupVariable(getSuperArgumentName(i).variableName());
				ParameterDeclaration parentParameter = jpiSuperDecl.getParameter(i);
				if (childParameter.isEmpty()){
					error("TypeCheck: "+getSuperArgumentName(i).variableName()+" doesn't exist as formal parameter of "+typeName()+" JPI.");
					continue;
				}
				if (!((ParameterDeclaration)childParameter).getTypeAccess().type().equals(parentParameter.getTypeAccess().type())){
					error("TypeCheck: Argument types must be equals.");
				}
				
			}
		}	
	}
	
	refine TypeCheckCJP public void CJPAdviceDecl.typeCheck() {
		TypeAccess jpiAccess = (TypeAccess)getName();
		JPITypeDecl jpiDecl;
		AdviceSpec currentAdviceSpec = getAdviceSpec();

		/***
		 * 1) check that the type of SuperAccess is JPITypeDecl.
		 * 2) check the arguments types.
		 * 3) check the return types.
		 * 4) check the exceptions.
		 */		
		
		if (!jpiAccess.type().isJPITypeDecl()){
			error("TypeCheck: "+jpiAccess.getID()+" must be a JPI not a "+jpiAccess.type().typeName());
			return;
		}
		jpiDecl = (JPITypeDecl)jpiAccess.type();
				
		int paramNum = 0;
		for(int i=0; i<currentAdviceSpec.getNumParameter(); i++){
			ParameterDeclaration adviceParameter = currentAdviceSpec.getParameter(i);
			if(!adviceParameter.isImplicit()) paramNum++;			
		}		
		
		if (jpiDecl.getNumParameter() != paramNum){
			error("TypeCheck: Advice declaration must have the same number of parameter as "+jpiDecl.getID());
		} else {
			ParameterDeclaration adviceParameter;
			ParameterDeclaration jpiParameter;
			for(int i=0; i<jpiDecl.getNumParameter(); i++){
				adviceParameter = currentAdviceSpec.getParameter(i);
				jpiParameter = jpiDecl.getParameter(i);
				if(!adviceParameter.type().equals(jpiParameter.type())){
					error("TypeCheck: Parameter "+adviceParameter.getID()+" must be the type of "+jpiParameter.type().name()+" instead "+adviceParameter.type().name());
				}
			}
		}
		
		if(jpiDecl.getNumException() == 0 && getNumException() > 0){
			error("TypeCheck: Advice can not throws exceptions.");
			return;
		}
		else{
			if(jpiDecl.getNumException() > 0 && getNumException() == 0){
				error("TypeCheck: Advice must throws at least one exception.");
				return;
			}			
		}
		
		if (currentAdviceSpec.isAround()){
			if (!jpiDecl.getTypeAccess().type().equals(returnType())){
				error("TypeCheck: Advice return type: "+returnType().name()+" instead "+jpiDecl.getTypeAccess().type().name());
			}			
		}
		
		if (currentAdviceSpec.isAfterReturning()){
			AfterReturningSpec r = (AfterReturningSpec) currentAdviceSpec;
			if(r.hasReturnParameter()) {
				TypeDecl jpiReturnType = jpiDecl.getTypeAccess().type();
				TypeDecl adviceReturnType = r.getReturnParameter().getTypeAccess().type();
				if(!jpiReturnType.castingConversionTo(adviceReturnType)) {
					error("TypeCheck: jpi "+ jpiDecl.getID() + " returns type "+jpiReturnType.name()+
					      " which is incompatible with advice return type "+adviceReturnType.name());
				}
			}
			
		}
		
		if(currentAdviceSpec.isAfterThrowing()) {
			AfterThrowingSpec r = (AfterThrowingSpec) currentAdviceSpec;
			if(r.hasExceptionParameter()) {
				TypeDecl adviceSpecException = r.getExceptionParameter().getTypeAccess().type();
	 	    	//note: the notion of checked and unchecked exceptions is apparently incorrectly reversed in JastAdd!!! 
				if(!adviceSpecException.isCheckedException()) {
					boolean found = false;
			        for(Access ex: jpiDecl.getExceptions()) {
			        	TypeDecl declared = ex.type();
			    		if(declared.castingConversionTo(adviceSpecException)) {
			    			found = true;
		    				break;
	    				}
		    			if(!found)
		    				error("TypeCheck: jpi "+ jpiDecl.getID() + " cannot throw checked exceptions of type "+adviceSpecException.name()); 
			        }
		        }
			}
		}		
		
		boolean found;
		for(Access exceptionAccess: getExceptionList()){
			found = false;
			for(Access parentExceptionAccess: jpiDecl.getExceptionList()){
				if(exceptionAccess.type().instanceOf(parentExceptionAccess.type())){
					found = true;
					break;
				}
			}
			if (!found){
				error("TypeCheck: Advice can not throw exception of type "+exceptionAccess.type().name());
			}
		}
	}
	
	public void ExhibitBodyDecl.typeCheck(){
	  	TypeAccess jpiAccess = (TypeAccess)getJPIName();
	  	JPITypeDecl jpiDecl;
	  
		if (!jpiAccess.type().isJPITypeDecl()){
			error("TypeCheck: "+jpiAccess.getID()+" must be a JPI not a "+jpiAccess.type().typeName());
			return;
		}
		jpiDecl = (JPITypeDecl)jpiAccess.type();
		
		if(!getReturnType().type().equals(jpiDecl.getTypeAccess().type())){
			error("TypeCheck: Exhibit return type: "+getReturnType().type().name()+" instead "+jpiDecl.getTypeAccess().type().name());
		}
		
		if(getNumParameter() != jpiDecl.getNumParameter()){
			error("TypeCheck: Exhibit clause must declare the same quantity of arguments that its JPI");
		}
		else{
			ParameterDeclaration exhibitParameter;
			ParameterDeclaration jpiParameter;
			for(int i=0; i<jpiDecl.getNumParameter(); i++){
				exhibitParameter = getParameter(i);
				jpiParameter = jpiDecl.getParameter(i);
				if(!exhibitParameter.type().equals(jpiParameter.type())){
					error("TypeCheck: Exhibit parameter "+exhibitParameter.getID()+" must be the type of "+jpiParameter.type().name()+" instead "+exhibitParameter.type().name());
				}
			}
		}

		for(ParameterDeclaration parameter: getParameterList()){
			int bindings = getPointcut().binds(parameter.name());
			if(bindings == 0){
				error("TypeCheck: Exhibit must bind its formal argument "+parameter.name());
			}
			else if(bindings > 1){
				error("TypeCheck: Exhibit binds formal argument "+parameter.name() + " multiple times.");
			}
		}
	}
	
	refine AspectErrorCheck public void AspectDecl.typeCheck() {
		AspectErrorCheck.AspectDecl.typeCheck();
		CJPAdviceDecl cjpAdvice;
  		HashSet<abc.ja.jpi.utils.CJPAdviceDeclElement> set = new HashSet<abc.ja.jpi.utils.CJPAdviceDeclElement>();
  		int CJPAdviceCounter=0, FinalCJPAdviceCounter=0;
  		for(BodyDecl bd : getBodyDeclList()){
	  		if(bd.isCJPAdviceDecl()){
			  	cjpAdvice = (CJPAdviceDecl)bd;
			  	if (!set.add(new abc.ja.jpi.utils.CJPAdviceDeclElement(cjpAdvice.getAdviceSpec().kind(),cjpAdvice.getName()))){
					error("TypeCheck: advice " +cjpAdvice.getAdviceSpec().kind()+" " + cjpAdvice.getName().typeName() +" has multiple definitions");
		  		}
			  	if (cjpAdvice.isFinal()){
			  		if (CJPAdviceCounter != FinalCJPAdviceCounter){
			  			error("TypeCheck: final advice "+cjpAdvice.getAdviceSpec().kind()+" " + cjpAdvice.getName().typeName() +" has to be defined before of no final pieces of advice");
			  		}
			  		FinalCJPAdviceCounter++;
			  	}
			  	CJPAdviceCounter++;
	  		}
  		}
	}
}
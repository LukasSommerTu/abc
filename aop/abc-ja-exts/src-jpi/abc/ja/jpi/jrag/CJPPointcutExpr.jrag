aspect CJPPointcutExpr{

	inh lazy AdviceSpec CJPPointcutExpr.getAdviceSpec();
	
	eq AdviceDecl.getPointcutExpr().getAdviceSpec() = getAdviceSpec();
	eq CJPAdviceDecl.getPointcutExpr().getAdviceSpec() = getAdviceSpec();
	eq PointcutDecl.getPointcutExpr().getAdviceSpec() = null;
	eq PerTarget.getPointcutExpr().getAdviceSpec() = null;
	eq PerThis.getPointcutExpr().getAdviceSpec() = null;
	eq PerCflow.getPointcutExpr().getAdviceSpec() = null;
	eq PerCflowBelow.getPointcutExpr().getAdviceSpec() = null;
	eq DeclareSoft.getPointcutExpr().getAdviceSpec() = null;
	eq DeclareWarning.getPointcutExpr().getAdviceSpec() = null;
	eq DeclareError.getPointcutExpr().getAdviceSpec() = null;
	eq ExhibitBodyDecl.getPointcut().getAdviceSpec() = null;
	
	inh lazy Collection<CJPAdviceDecl> CJPPointcutExpr.getAdviceDecls();
	eq Program.getCompilationUnit().getAdviceDecls() = null;
	eq AspectDecl.getBodyDecl().getAdviceDecls(){
		HashSet<CJPAdviceDecl> set = new HashSet<CJPAdviceDecl>();
		for(BodyDecl bodyDecl : getBodyDeclList()){
			if (!bodyDecl.isCJPAdviceDecl()){
				continue;
			}
			set.add((CJPAdviceDecl)bodyDecl);
		}
		return set;
	}
	
	
	inh lazy Access CJPPointcutExpr.getJPIAccess();
	eq CJPAdviceDecl.getPointcutExpr().getJPIAccess() = getName();
	
   private Pointcut CJPPointcutExpr.runExtractPointcuts(Iterator<ExhibitBodyDecl> exhibitIterator, int size, Position pos, boolean hierarchy){
	  if (size == 1){
		  return makeExhibitBodyDeclPointcut(exhibitIterator, pos, hierarchy);
	  }
	  if (size == 2){
		  Pointcut left = makeExhibitBodyDeclPointcut(exhibitIterator, pos, hierarchy);
		  Pointcut right = makeExhibitBodyDeclPointcut(exhibitIterator, pos, hierarchy);
		  return OrPointcut.construct(left,right,pos);
	  }
	  Pointcut parent = makeExhibitBodyDeclPointcut(exhibitIterator, pos, hierarchy);
	  size = size - 1;
	  return OrPointcut.construct(parent, runExtractPointcuts(exhibitIterator,size,pos,hierarchy), pos);
  }
  
  private ClassnamePattern CJPPointcutExpr.getPattern(TypeDecl hostType, ASTNode parentNode) {
	  ExplicitTypeNamePattern pattern;
	  String name = hostType.getID();
	  String packageName = "";
	  String[] path = hostType.fullName().split("\\.");
	  for(int i=0;i<path.length-1;i++){
		  if (packageName==""){
			  packageName = path[i];
		  }
		  else{
			  packageName = packageName + "." + path[i];
		  }
	  }
	  TypeAccess hostAccess = new TypeAccess(packageName,name);
	  pattern = new ExplicitTypeNamePattern(hostAccess);
	  hostAccess.setParent(pattern);
	  pattern.setParent(parentNode);	  	  
	  return pattern.classnamePattern();
  }
  
  private Pointcut CJPPointcutExpr.extractPointcuts(Collection<ExhibitBodyDecl> exhibitBodyDeclarations, Position pos, boolean hierarchy) {
	  Iterator<ExhibitBodyDecl> exhibitIterator = exhibitBodyDeclarations.iterator();
	  return runExtractPointcuts(exhibitIterator,exhibitBodyDeclarations.size(),pos,hierarchy);
	  
  }
  
  private Pointcut CJPPointcutExpr.makeOrPointcuts(Iterator<Pointcut> iterator, int size, Position pos) {
	  if (size == 1){
		  return iterator.next();
	  }
	  if (size == 2){
		  Pointcut left = iterator.next();
		  Pointcut right = iterator.next();
		  return OrPointcut.construct(left,right,pos);
	  }
	  Pointcut parent = iterator.next();
	  size = size - 1;
	  return OrPointcut.construct(parent, makeOrPointcuts(iterator,size,pos), pos);
	  
  }

  
  private boolean CJPPointcutExpr.containsKey(HashMap<JPITypeDecl, Object> jpiHierarchy, JPITypeDecl currentJPITypeDecl) {
	  HashMap<JPITypeDecl, Object> local;
	  if (jpiHierarchy.containsKey(currentJPITypeDecl)){
		  return true;
	  }
	  for(Object value : jpiHierarchy.values()){
		if(value == null){ continue; }
		local = (HashMap<JPITypeDecl, Object>)value;
		if (containsKey(local,currentJPITypeDecl)){
			return true;
		}
	  }
	  return false;
  }


  private Pointcut CJPPointcutExpr.makeExhibitBodyDeclPointcut(Iterator<ExhibitBodyDecl> exhibitIterator, Position pos, boolean hierarchy) {
	  Pointcut currentPointcut;
	  ExhibitBodyDecl tempExhibitBodyDecl = exhibitIterator.next();
	  
	  if (hierarchy){
		  java.util.LinkedList formals = new LinkedList();
		  for(ParameterDeclaration p : tempExhibitBodyDecl.getParameterList()){
			  formals.add((Formal)p.formal());
		  }
		  currentPointcut = new LocalPointcutVars(tempExhibitBodyDecl.getPointcut().pointcut(),formals,pos);
	  }
	  else{
		  
		  Hashtable/*<String,Var>*/ renameEnv=new Hashtable();
		  Hashtable/*<String,Abctype>*/ typeEnv=new Hashtable();
		  
		  for(int i=0; i<getAdviceSpec().getNumParameter(); i++){
			  Formal oldVar = tempExhibitBodyDecl.getParameter(i).formal();
			  renameEnv.put(oldVar.getName(),new Var(getAdviceSpec().getParameter(i).name(), oldVar.getPosition()));
			  typeEnv.put(oldVar.getName(), oldVar.getType());
		  }
		  currentPointcut = tempExhibitBodyDecl.getPointcut().pointcut();
		  currentPointcut = currentPointcut.inline(renameEnv, typeEnv, null, 0);
	  }
		
	  return AndPointcut.construct(currentPointcut, 
			  					   new Within(getPattern(tempExhibitBodyDecl.getHostType(), tempExhibitBodyDecl.getParent()), pos), pos);
  }
	
	
}
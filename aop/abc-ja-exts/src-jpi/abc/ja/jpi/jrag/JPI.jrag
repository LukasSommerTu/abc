aspect JPI{
	
	syn boolean JPITypeDecl.hasChildren(){
		return hasJPIChildren(this);
	}
	
	inh lazy boolean JPITypeDecl.hasJPIChildren(JPITypeDecl jpiTypeDecl);
	eq Program.getCompilationUnit().hasJPIChildren(JPITypeDecl jpiTypeDecl) = false;
	eq CompilationUnit.getTypeDecl().hasJPIChildren(JPITypeDecl jpiTypeDecl){
		TypeAccess jpiSuperAccess;
		for(TypeDecl typeDecl : getTypeDeclList()){
			if(!typeDecl.isJPITypeDecl()){
				continue;
			}
			jpiSuperAccess = (TypeAccess)((JPITypeDecl)typeDecl).getSuperTypeName();
			if (jpiSuperAccess.type().equals(jpiTypeDecl)){
				return true;
			}
		}
		return false;
	}
	
	syn HashMap<JPITypeDecl,Object> JPITypeDecl.getHierarchy(){
		return getJPIHierarchy(this);
	}

	inh lazy HashMap<JPITypeDecl,Object> JPITypeDecl.getJPIHierarchy(JPITypeDecl jpiTypeDecl);
	eq Program.getCompilationUnit().getJPIHierarchy(JPITypeDecl jpiTypeDecl) = null;
	eq CompilationUnit.getTypeDecl().getJPIHierarchy(JPITypeDecl jpiTypeDecl){
		TypeAccess jpiSuperAccess;
		HashMap<JPITypeDecl, Object> root = new HashMap<JPITypeDecl, Object>();		
		HashMap<JPITypeDecl, Object> children;
		for(TypeDecl typeDecl : getTypeDeclList()){
			if(!typeDecl.isJPITypeDecl()){
				continue;
			}
			children = new HashMap<JPITypeDecl, Object>();
			jpiSuperAccess = (TypeAccess)((JPITypeDecl)typeDecl).getSuperTypeName();
			if (jpiSuperAccess.type().equals(jpiTypeDecl)){
				children = ((JPITypeDecl)typeDecl).getJPIHierarchy((JPITypeDecl)typeDecl);
				root.put((JPITypeDecl)typeDecl, children);
			}
		}
		return root;
	}

	syn lazy boolean BodyDecl.isCJPAdviceDecl() = false;
	eq CJPAdviceDecl.isCJPAdviceDecl() = true;

	inh lazy Collection<CJPAdviceDecl> CJPPointcutExpr.getAdviceDecls();
	eq Program.getCompilationUnit().getAdviceDecls() = null;
	eq AspectDecl.getBodyDecl().getAdviceDecls(){
		HashSet<CJPAdviceDecl> set = new HashSet<CJPAdviceDecl>();
		for(BodyDecl bodyDecl : getBodyDeclList()){
			if (!bodyDecl.isCJPAdviceDecl()){
				continue;
			}
			set.add((CJPAdviceDecl)bodyDecl);
		}
		return set;
	}
	
	
	inh lazy Access CJPPointcutExpr.getJPIAccess();
	eq CJPAdviceDecl.getPointcutExpr().getJPIAccess() = getName();
	
   private Pointcut CJPPointcutExpr.runExtractPointcuts(Iterator<ExhibitBodyDecl> exhibitIterator, int size, Position pos){
	  ExhibitBodyDecl tempExhibitBodyDecl;
	  if (size == 1){
		  tempExhibitBodyDecl = exhibitIterator.next();		  		  		  
		  return AndPointcut.construct(tempExhibitBodyDecl.getPointcut().pointcut(), new Within(getPattern(tempExhibitBodyDecl.getHostType(), tempExhibitBodyDecl.getParent()), pos), pos);
	  }
	  if (size == 2){
		  tempExhibitBodyDecl = exhibitIterator.next(); 
		  Pointcut left = AndPointcut.construct(tempExhibitBodyDecl.getPointcut().pointcut(), new Within(getPattern(tempExhibitBodyDecl.getHostType(), tempExhibitBodyDecl.getParent()),pos),pos);
		  tempExhibitBodyDecl = exhibitIterator.next(); 		  
		  Pointcut right = AndPointcut.construct(tempExhibitBodyDecl.getPointcut().pointcut(), new Within(getPattern(tempExhibitBodyDecl.getHostType(), tempExhibitBodyDecl.getParent()),pos),pos);
		  return OrPointcut.construct(left,right,pos);
	  }
	  tempExhibitBodyDecl = exhibitIterator.next();		    
	  Pointcut parent = AndPointcut.construct(tempExhibitBodyDecl.getPointcut().pointcut(), new Within(getPattern(tempExhibitBodyDecl.getHostType(), tempExhibitBodyDecl.getParent()), pos), pos);
	  size = size - 1;
	  return OrPointcut.construct(parent, runExtractPointcuts(exhibitIterator,size,pos), pos);
  }
  
  private ClassnamePattern CJPPointcutExpr.getPattern(TypeDecl hostType, ASTNode parentNode) {
	  SimpleNamePattern pattern;
	  pattern = new SimpleNamePattern(hostType.fullName());
	  pattern.setParent(parentNode);
	  return pattern.classnamePattern();  
  }
  
  private Pointcut CJPPointcutExpr.extractPointcuts(Collection<ExhibitBodyDecl> exhibitBodyDeclarations, Position pos) {
	  Iterator<ExhibitBodyDecl> exhibitIterator = exhibitBodyDeclarations.iterator();
	  return runExtractPointcuts(exhibitIterator,exhibitBodyDeclarations.size(),pos);
	  
  }
  
  private Pointcut CJPPointcutExpr.makeOrPointcuts(Iterator<Pointcut> iterator, int size, Position pos) {
	  if (size == 1){
		  return iterator.next();
	  }
	  if (size == 2){
		  Pointcut left = iterator.next();
		  Pointcut right = iterator.next();
		  return OrPointcut.construct(left,right,pos);
	  }
	  Pointcut parent = iterator.next();
	  size = size - 1;
	  return OrPointcut.construct(parent, makeOrPointcuts(iterator,size,pos), pos);
	  
  }

  
  private boolean CJPPointcutExpr.containsKey(HashMap<JPITypeDecl, Object> jpiHierarchy, JPITypeDecl currentJPITypeDecl) {
	  HashMap<JPITypeDecl, Object> local;
	  if (jpiHierarchy.containsKey(currentJPITypeDecl)){
		  return true;
	  }
	  for(Object value : jpiHierarchy.values()){
		if(value == null){ continue; }
		local = (HashMap<JPITypeDecl, Object>)value;
		if (containsKey(local,currentJPITypeDecl)){
			return true;
		}
	  }
	  return false;
  }

  
	
	
}
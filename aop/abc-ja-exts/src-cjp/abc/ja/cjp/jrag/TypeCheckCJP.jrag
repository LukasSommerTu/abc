aspect TypeCheckCJP {

	public boolean ClosureJoinpointAccess.passedTypeCheck = false;

	public void ClosureJoinpointAccess.typeCheck() {
		super.typeCheck();
		//setting this flag will enable the rewrite that
		//extracts the closure into a proper method
		this.passedTypeCheck=true;
	}
	
	syn boolean ASTNode.allCjpHavePassedTypeCheck() {
		for(int i = 0; i < getNumChild(); i++)
			if(!getChild(i).allCjpHavePassedTypeCheck())
				return false;
		return true;
	}

	eq ClosureJoinpointAccess.allCjpHavePassedTypeCheck() = passedTypeCheck;


	refine NameCheck public void TypeDecl.nameCheck() {
		correctTheReturnType();	
		NameCheck.TypeDecl.nameCheck();
	}
	
	public void ASTNode.correctTheReturnType() {
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).correctTheReturnType();
	}
	
	public void ClosureJoinpointAccess.correctTheReturnType() {
		TypeDecl t = getName().type();
		if(t instanceof JoinpointTypeDecl) {
			JoinpointTypeDecl joinpointTypeDecl = (JoinpointTypeDecl) t;
			setReturnType(joinpointTypeDecl.getSignature().getTypeAccess());
		}
	}

 	eq AnonymousMethod.getParameter().outerScope() = this;
 	inh VariableScope AnonymousMethod.outerScope();
 	 	
 	AnonymousMethod implements VariableScope;
 	
 	eq AnonymousMethod.getBlock().returnType() = type();
 	
	refine NameCheck public void ParameterDeclaration.nameCheck() {
		//do nothing
	}
 	
	inh boolean MethodDecl.isWithinJoinpointTypeDecl();
	eq JoinpointTypeDecl.getSignature().isWithinJoinpointTypeDecl() = true;
	eq Program.getChild().isWithinJoinpointTypeDecl() = false;
	

	refine IntertypeMethodErrorCheck public void MethodDecl.nameCheck() {
		if(isWithinJoinpointTypeDecl()) {
		    if(!hostType().methodsSignature(signature()).contains(this)) {
		      boolean allZap = true;
		      for(Iterator iter = hostType().methodsSignature(signature()).iterator(); allZap && iter.hasNext(); ) {
		        MethodDecl m = (MethodDecl)iter.next();
		        if(!m.zaps(this))
		          allZap = false;
		      }
		      if(!allZap)
		        error("method with signature " + signature() + " is multiply declared in type " + hostType().typeName());
		    }
		} else {
			IntertypeMethodErrorCheck.MethodDecl.nameCheck();
		}
	}

	syn lazy JoinpointTypeDecl CJPAdviceDecl.cjpTypeDecl() = cjpTypeDecl(getAdviceSpec().getGivenName()); 

	inh JoinpointTypeDecl CJPAdviceDecl.cjpTypeDecl(String name);
	
	eq TypeDecl.getBodyDecl().cjpTypeDecl(String name) {
		for(BodyDecl b: getBodyDecls()) {
			if(b instanceof MemberCJPTypeDecl) {
				MemberCJPTypeDecl mj = (MemberCJPTypeDecl)b;
				JoinpointTypeDecl j = (JoinpointTypeDecl)mj.typeDecl();
				if(j.getID().equals(name)) {
					return j;
				}
			}						
		}
		return null;
	}

	eq Program.getChild().cjpTypeDecl(String name) { throw new InternalError("attribute not supported here"); }

  //copied from Advice.jrag
  eq CJPAdviceDecl.getAdviceSpec().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  eq CJPAdviceDecl.getBlock().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  inh SimpleSet CJPAdviceDecl.lookupVariable(String name);
  
  eq CJPAdviceDecl.getBlock().returnType() = returnType();
  
  //copied from AdviceCodegen.jrag
  eq CJPAdviceDecl.getBlock().aroundSpec() = getAdviceSpec().aroundSpec();
  
}




aspect TypeCheckCJP {

	public boolean ClosureJoinpointAccess.passedTypeCheck = false;

	public void ClosureJoinpointAccess.typeCheck() {
		super.typeCheck();
		
  		TypeDecl decl = getName().type();
  		if(decl.isJoinpointTypeDecl()) {
  			JoinpointTypeDecl d = (JoinpointTypeDecl)decl;
  			int i=0;
  			for(ParameterDeclaration p: getParameters()) {
				if(p.type()!=d.getParameter(i).type()) {
					error(p.getID()+" must be of type "+d.getParameter(i).type().name()+" but is of type "+p.type().name()+" instead.");
				}
				i++;
  			}
		}

		//setting this flag will enable the rewrite that
		//extracts the closure into a proper method
		this.passedTypeCheck=true;
	}

	syn lazy boolean AdviceSpec.isAround() = false;
	eq AroundSpec.isAround() = true;

	syn lazy boolean AdviceSpec.isAfterReturning() = false;
	eq AfterReturningSpec.isAfterReturning() = true;
	
	syn lazy boolean AdviceSpec.isAfterThrowing() = false;
	eq AfterThrowingSpec.isAfterThrowing() = true;
	
	syn lazy boolean TypeDecl.isCJPTypeDecl() = false;
	eq JoinpointTypeDecl.isCJPTypeDecl() = true;

	public void CJPAdviceDecl.typeCheck() {
		super.typeCheck();
		TypeAccess joinpointAccess = (TypeAccess) getName();
		
		if (joinpointAccess.decls().isEmpty()){
			error("TypeChecking: "+joinpointAccess.getID()+" is not a valid type for JoinpointTypeDeclaration");
			return;
		} 
		else {
			if (!joinpointAccess.decl().isCJPTypeDecl()){
				error("TypeChecking: "+joinpointAccess.getID()+" is not a valid type for JoinpointTypeDeclaration");
				return;				
			}
		}
	
		if(cjpTypeDecl()==null) {
			error("no visible joinpoint type named "+getName());
		}
		
		AdviceSpec spec = getAdviceSpec();
		if(spec.isAround()) {
			if(spec.returnType()!=cjpTypeDecl().getTypeAccess().type()) {
				error("return type must be "+cjpTypeDecl().getTypeAccess().type().name()+" but is "+spec.returnType().name()+" instead.");
			}
		}	
		
		if(spec.isAfterReturning()) {
			AfterReturningSpec r = (AfterReturningSpec) spec;
			if(r.hasReturnParameter()) {
				TypeDecl declared = cjpTypeDecl().getTypeAccess().type();
				TypeDecl here = r.getReturnParameter().getTypeAccess().type();
				if(!declared.castingConversionTo(here)) {
					error("joinpoint type "+ cjpTypeDecl().getID() + " returns type "+declared.name()+
					      " which is incompatible with advice return type "+here.name());
				}
			}
		}

		if(spec.isAfterThrowing()) {
			AfterThrowingSpec r = (AfterThrowingSpec) spec;
			if(r.hasExceptionParameter()) {
				TypeDecl here = r.getExceptionParameter().getTypeAccess().type();
	 	    	//note: the notion of checked and unchecked exceptions is apparently incorrectly reversed in JastAdd!!! 
				if(!here.isCheckedException()) {
					boolean found = false;
			        for(Access ex: cjpTypeDecl().getExceptions()) {
			        	TypeDecl declared = ex.type();
			    		if(declared.castingConversionTo(here)) {
			    			found = true;
		    				break;
	    				}
		    			if(!found)
		    				error("joinpoints of type "+ cjpTypeDecl().getID() + " cannot throw checked exceptions of type "+here.name()); 
			        }
		        }
			}
		}
		
 	    for(Access e: getExceptions()) {
 	    	//note: the notion of checked and unchecked exceptions is apparently incorrectly reversed in JastAdd!!! 
 	    	if(e.type().isCheckedException()) continue;
	        boolean found = false;
	        for(Access e2: cjpTypeDecl().getExceptions()) {
	          	if(e.type().instanceOf(e2.type())) {
	          		found = true;
	           		break;
           		}
	        }
	        if(!found)
	          error("Advice may not throw checked exception of type "+e.type().name()+" because its the joinpoint declaration does not declare such exceptions to be thrown.");
       }	
	}
	
	syn boolean ASTNode.allCjpHavePassedTypeCheck() {
		for(int i = 0; i < getNumChild(); i++)
			if(!getChild(i).allCjpHavePassedTypeCheck())
				return false;
		return true;
	}

	eq ClosureJoinpointAccess.allCjpHavePassedTypeCheck() = passedTypeCheck;


	refine NameCheck public void TypeDecl.nameCheck() {
		correctTheReturnTypeAndThrowsList();	
		NameCheck.TypeDecl.nameCheck();
	}
	
	public void ASTNode.correctTheReturnTypeAndThrowsList() {
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).correctTheReturnTypeAndThrowsList();
	}
	
	public void ClosureJoinpointAccess.correctTheReturnTypeAndThrowsList() {
		TypeDecl t = getName().type();
		if(t instanceof JoinpointTypeDecl) {
			JoinpointTypeDecl joinpointTypeDecl = (JoinpointTypeDecl) t;
			try{
				setReturnType(joinpointTypeDecl.getTypeAccess().clone());
				setExceptionList(joinpointTypeDecl.getExceptionList().clone());
			} catch(CloneNotSupportedException e) {
				throw new RuntimeException(e); //cannot occur
			}
		}
	}
	
	public void ClosureJoinpointAccess.nameCheck() {
		TypeDecl t = getName().type();
		if(!t.isUnknown() && !t.isJoinpointTypeDecl()) {
			error("type "+getName()+" is not a joinpoint type");	
		} 
	}

 	eq AnonymousMethod.getParameter().outerScope() = this;
 	inh VariableScope AnonymousMethod.outerScope();
 	 	
 	AnonymousMethod implements VariableScope;
 	
 	eq AnonymousMethod.getBlock().returnType() = type();
 	
	refine NameCheck public void ParameterDeclaration.nameCheck() {
		//do nothing
	}

	syn lazy JoinpointTypeDecl CJPAdviceDecl.cjpTypeDecl() {
		TypeAccess name = (TypeAccess) getName();	
		return (JoinpointTypeDecl) name.decl();
	}

  //copied from Advice.jrag
  eq CJPAdviceDecl.getAdviceSpec().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  eq CJPAdviceDecl.getBlock().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  inh SimpleSet CJPAdviceDecl.lookupVariable(String name);
  
  eq CJPAdviceDecl.getBlock().returnType() = returnType();
  
  //copied from AdviceCodegen.jrag
  eq CJPAdviceDecl.getBlock().aroundSpec() = getAdviceSpec().aroundSpec();
  
}




aspect TypeCheckCJP {

	public boolean ClosureJoinpointAccess.passedTypeCheck = false;


	refine NameCheck public void TypeDecl.nameCheck() {
		correctTheReturnType();	
		NameCheck.TypeDecl.nameCheck();
	}
	
	public void ASTNode.correctTheReturnType() {
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).correctTheReturnType();
	}
	
	public void ClosureJoinpointAccess.correctTheReturnType() {
		TypeDecl t = getName().type();
		if(t instanceof JoinpointTypeDecl) {
			JoinpointTypeDecl joinpointTypeDecl = (JoinpointTypeDecl) t;
			setReturnType(joinpointTypeDecl.getSignature().getTypeAccess());
		}
	}

 	eq AnonymousMethod.getParameter().outerScope() = this;
 	inh VariableScope AnonymousMethod.outerScope();
 	 	
 	AnonymousMethod implements VariableScope;
 	
 	eq AnonymousMethod.getBlock().returnType() = type();
 	
	refine NameCheck public void ParameterDeclaration.nameCheck() {
		//do nothing
	}
 	
	public void ClosureJoinpointAccess.typeCheck() {
		super.typeCheck();
		//setting this flag will enable the rewrite that
		//extracts the closure into a proper method
		this.passedTypeCheck=true;
	}
	
	syn lazy boolean ASTNode.allCjpHavePassedTypeCheck() {
		for(int i = 0; i < getNumChild(); i++)
			if(!getChild(i).allCjpHavePassedTypeCheck())
				return false;
		return true;
	}

	eq ClosureJoinpointAccess.allCjpHavePassedTypeCheck() = passedTypeCheck;

	inh boolean MethodDecl.isWithinJoinpointTypeDecl();
	eq JoinpointTypeDecl.getSignature().isWithinJoinpointTypeDecl() = true;
	eq Program.getChild().isWithinJoinpointTypeDecl() = false;

	refine IntertypeMethodErrorCheck public void MethodDecl.nameCheck() {
		if(isWithinJoinpointTypeDecl()) {
		    if(!hostType().methodsSignature(signature()).contains(this)) {
		      boolean allZap = true;
		      for(Iterator iter = hostType().methodsSignature(signature()).iterator(); allZap && iter.hasNext(); ) {
		        MethodDecl m = (MethodDecl)iter.next();
		        if(!m.zaps(this))
		          allZap = false;
		      }
		      if(!allZap)
		        error("method with signature " + signature() + " is multiply declared in type " + hostType().typeName());
		    }
		} else {
			IntertypeMethodErrorCheck.MethodDecl.nameCheck();
		}
	}

}




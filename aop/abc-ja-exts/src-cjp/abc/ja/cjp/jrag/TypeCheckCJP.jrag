aspect TypeCheckCJP {

	public boolean ClosureJoinpointAccess.passedTypeCheck = false;

	public void ClosureJoinpointAccess.typeCheck() {
		super.typeCheck();
		
  		TypeDecl decl = getName().type();
  		if(decl.isJoinpointTypeDecl()) {
  			JoinpointTypeDecl d = (JoinpointTypeDecl)decl;
  			MethodDecl m = d.getSignature();
  			int i=0;
  			for(ParameterDeclaration p: getParameters()) {
				if(p.type()!=m.getParameter(i).type()) {
					error(p.getID()+" must be of type "+m.getParameter(i).type().name()+" but is of type "+p.type().name()+" instead.");
				}
				i++;
  			}
		}

		//setting this flag will enable the rewrite that
		//extracts the closure into a proper method
		this.passedTypeCheck=true;
	}

	syn lazy boolean AdviceSpec.isAround() = false;
	eq AroundSpec.isAround() = true;
	
	public void CJPAdviceDecl.typeCheck() {
		super.typeCheck();
	
		AdviceSpec spec = getAdviceSpec();
		if(spec.isAround()) {
			if(spec.returnType()!=cjpTypeDecl().getSignature().getTypeAccess().type()) {
				error("return type must be "+cjpTypeDecl().getSignature().getTypeAccess().type().name()+" but is "+spec.returnType().name()+" instead.");
			}
		}	
		
 	    for(Access e: getExceptions()) {
 	    	//note: the notion of checked and unchecked exceptions is apparently incorrectly reversed in JastAdd!!! 
 	    	if(e.type().isCheckedException()) continue;
	        boolean found = false;
	        for(Access e2: cjpTypeDecl().getSignature().getExceptions()) {
	          	if(e.type().instanceOf(e2.type())) {
	          		found = true;
	           		break;
           		}
	        }
	        if(!found)
	          error("Advice may not throw checked exception of type "+e.type().name()+" because its the joinpoint declaration does not declare such exceptions to be thrown.");
       }	
	}
	
	syn boolean ASTNode.allCjpHavePassedTypeCheck() {
		for(int i = 0; i < getNumChild(); i++)
			if(!getChild(i).allCjpHavePassedTypeCheck())
				return false;
		return true;
	}

	eq ClosureJoinpointAccess.allCjpHavePassedTypeCheck() = passedTypeCheck;


	refine NameCheck public void TypeDecl.nameCheck() {
		correctTheReturnTypeAndThrowsList();	
		NameCheck.TypeDecl.nameCheck();
	}
	
	public void ASTNode.correctTheReturnTypeAndThrowsList() {
		for(int i = 0; i < getNumChild(); i++)
			getChild(i).correctTheReturnTypeAndThrowsList();
	}
	
	public void ClosureJoinpointAccess.correctTheReturnTypeAndThrowsList() {
		TypeDecl t = getName().type();
		if(t instanceof JoinpointTypeDecl) {
			JoinpointTypeDecl joinpointTypeDecl = (JoinpointTypeDecl) t;
			try{
				setReturnType(joinpointTypeDecl.getSignature().getTypeAccess().clone());
				setExceptionList(joinpointTypeDecl.getSignature().getExceptionList().clone());
			} catch(CloneNotSupportedException e) {
				throw new RuntimeException(e); //cannot occur
			}
		}
	}
	
	public void ClosureJoinpointAccess.nameCheck() {
		TypeDecl t = getName().type();
		if(!t.isUnknown() && !t.isJoinpointTypeDecl()) {
			error("type "+getName()+" is not a joinpoint type");	
		} 
	}

 	eq AnonymousMethod.getParameter().outerScope() = this;
 	inh VariableScope AnonymousMethod.outerScope();
 	 	
 	AnonymousMethod implements VariableScope;
 	
 	eq AnonymousMethod.getBlock().returnType() = type();
 	
	refine NameCheck public void ParameterDeclaration.nameCheck() {
		//do nothing
	}
 	
	inh boolean MethodDecl.isWithinJoinpointTypeDecl();
	eq JoinpointTypeDecl.getSignature().isWithinJoinpointTypeDecl() = true;
	eq Program.getChild().isWithinJoinpointTypeDecl() = false;
	

	refine IntertypeMethodErrorCheck public void MethodDecl.nameCheck() {
		if(isWithinJoinpointTypeDecl()) {
		    if(!hostType().methodsSignature(signature()).contains(this)) {
		      boolean allZap = true;
		      for(Iterator iter = hostType().methodsSignature(signature()).iterator(); allZap && iter.hasNext(); ) {
		        MethodDecl m = (MethodDecl)iter.next();
		        if(!m.zaps(this))
		          allZap = false;
		      }
		      if(!allZap)
		        error("method with signature " + signature() + " is multiply declared in type " + hostType().typeName());
		    }
		} else {
			IntertypeMethodErrorCheck.MethodDecl.nameCheck();
		}
	}

	syn lazy JoinpointTypeDecl CJPAdviceDecl.cjpTypeDecl() = cjpTypeDecl(getAdviceSpec().getGivenName()); 

	inh JoinpointTypeDecl CJPAdviceDecl.cjpTypeDecl(String name);
	
	eq TypeDecl.getBodyDecl().cjpTypeDecl(String name) {
		for(BodyDecl b: getBodyDecls()) {
			if(b instanceof MemberCJPTypeDecl) {
				MemberCJPTypeDecl mj = (MemberCJPTypeDecl)b;
				JoinpointTypeDecl j = (JoinpointTypeDecl)mj.typeDecl();
				if(j.getID().equals(name)) {
					return j;
				}
			}						
		}
		return null;
	}

	eq Program.getChild().cjpTypeDecl(String name) { throw new InternalError("attribute not supported here"); }

  //copied from Advice.jrag
  eq CJPAdviceDecl.getAdviceSpec().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  eq CJPAdviceDecl.getBlock().lookupVariable(String name) {
    SimpleSet v = getAdviceSpec().localLookupVariable(name);
    if(!v.isEmpty()) return v;
    v = getAdviceSpec().lookupAfterVariable(name);
    if(!v.isEmpty()) return v;
    return lookupVariable(name);
  }
  inh SimpleSet CJPAdviceDecl.lookupVariable(String name);
  
  eq CJPAdviceDecl.getBlock().returnType() = returnType();
  
  //copied from AdviceCodegen.jrag
  eq CJPAdviceDecl.getBlock().aroundSpec() = getAdviceSpec().aroundSpec();
  
}



